<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小鹿的博客</title>
  
  <subtitle>Ordinary life , Unwilling to be ordinary code farmers</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-21T13:50:41.149Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小鹿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络原理之【TCP三次和四次握手】</title>
    <link href="http://yoursite.com/2019/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E3%80%90TCP%E4%B8%89%E6%AC%A1%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/07/20/计算机网络原理之【TCP三次和四次握手】/</id>
    <published>2019-07-20T12:19:17.889Z</published>
    <updated>2019-07-21T13:50:41.149Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于 TCP 的三次握手和四次挥手！</p><a id="more"></a><h3 id="一、TCP-的三次握手"><a href="#一、TCP-的三次握手" class="headerlink" title="一、TCP 的三次握手"></a>一、TCP 的三次握手</h3><h4 id="1-1-握手作用"><a href="#1-1-握手作用" class="headerlink" title="1.1 握手作用"></a>1.1 握手作用</h4><blockquote><p>1、为了确认双方的接收与发送能力是否正常。</p><p>2、指定自己的初始化序列号，为后面的可靠传送做准备。</p><p>3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p></blockquote><h4 id="1-2-握手过程"><a href="#1-2-握手过程" class="headerlink" title="1.2 握手过程"></a>1.2 握手过程</h4><p><strong>1、初始状态：</strong>客户端处于 <code>closed</code> 状态，服务器处于 <code>listen</code> 状态。</p><p><strong>2、第一次握手：</strong>客户端给服务端发送一个 <code>SYN</code> 报文，并指明客户端的初始化序列号 <code>ISN(c)</code>。此时客户端处于 <code>SYN_Send</code> 状态。</p><p><strong>3、第二次握手：</strong>服务端收到客户端的 <code>SYN</code> 报文之后，会以自己的 <code>SYN</code> 报文作为答应，并且也指定了自己的初始化序列号 <code>ISN(s)</code>,同时会把客户端的 <code>ISN + 1</code> 作为 <code>ACK</code> 的值，表示自己已经收到客户端的 <code>SYN</code>，此时服务器处于 <code>SYN_REVD</code> 的状态。</p><p><strong>4、第三次握手：</strong>客户端收到 <code>SYN</code> 报文之后，会发送一个 <code>ACK</code> 报文，当然，也是一样把服务器的 <code>ISN + 1</code> 作为 <code>ACK</code> 的值，表示已经收到了服务端的 <code>SYN</code> 报文，此时客户端处于 <code>establised</code> 状态。</p><p><strong>5、</strong>服务器收到 ACK 报文之后，也处于 <strong>establised 状态</strong>，此时，双方以建立起了链接。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMBrXTMI7LNzs7drC044ibDkxSVNr37IgFeyGLstNGLp7k9Lpia5tp79lZqNYicbOJbELC4f6iaMvZ4LHw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h4 id="1-3-初始化序列号-ISN-是固定的吗？"><a href="#1-3-初始化序列号-ISN-是固定的吗？" class="headerlink" title="1.3 初始化序列号(ISN) 是固定的吗？"></a>1.3 初始化序列号(ISN) 是固定的吗？</h4><blockquote><p>1、三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>2、如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p></blockquote><h4 id="1-4-什么是半连接队列"><a href="#1-4-什么是半连接队列" class="headerlink" title="1.4 什么是半连接队列"></a>1.4 什么是半连接队列</h4><blockquote><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p></blockquote><h4 id="1-5-三次握手过程中可以携带数据吗？"><a href="#1-5-三次握手过程中可以携带数据吗？" class="headerlink" title="1.5 三次握手过程中可以携带数据吗？"></a>1.5 三次握手过程中可以携带数据吗？</h4><blockquote><p>第一次、第二次不可以携带数据的，第三次握手是可以携带数据的。</p></blockquote><p>原因：</p><blockquote><p>1、因为第一次握手可以携带数据的话，攻击者就会在 SYN 的报文中放入大量的数据，攻击者不会理会服务器的接受、发送能力，所以疯狂的发送 SYN 报文，导致服务器花很长时间、内存空间来接受这些报文，如果第一次握手可以放数据的话，第一个原因就是让服务器更加容易受到攻击。</p><p>2、对于第三次握手，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了。</p></blockquote><h4 id="1-6-HTTPS-的认证过程"><a href="#1-6-HTTPS-的认证过程" class="headerlink" title="1.6 HTTPS 的认证过程"></a>1.6 HTTPS 的认证过程</h4><blockquote></blockquote><h3 id="二、TCP-的四次挥手"><a href="#二、TCP-的四次挥手" class="headerlink" title="二、TCP 的四次挥手"></a>二、TCP 的四次挥手</h3><h4 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h4><p><strong>1、初始化状态：</strong>刚开始双方都处于 establised 状态，客户端发起关闭请求。</p><p><strong>2、第一次挥手：</strong>客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于<strong>CLOSED_WAIT1</strong>状态。</p><p><strong>3、第二次挥手：</strong>服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <strong>CLOSE_WAIT2</strong>状态。</p><p><strong>4、第三次挥手：</strong>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <strong>LAST_ACK</strong> 的状态。</p><p><strong>5、第四次挥手：</strong>号值，此时客户端处于 <strong>TIME_WAIT</strong> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。</p><p><strong>6、</strong>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/b95QHPkcOMBrXTMI7LNzs7drC044ibDkx4dVUR45eKUWFj6daic3kxbFa5UiaeUM9V3Aaia6PHZ8VRWVQMj5rj1z0g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><h4 id="TIME-WAIT-状态"><a href="#TIME-WAIT-状态" class="headerlink" title="TIME_WAIT 状态"></a>TIME_WAIT 状态</h4><blockquote><p>1、为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p><p>2、至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 TCP 的三次握手和四次挥手！&lt;/p&gt;
    
    </summary>
    
      <category term="网络原理" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="网络原理" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【this上下文】</title>
    <link href="http://yoursite.com/2019/07/19/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90this%20%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%91/"/>
    <id>http://yoursite.com/2019/07/19/前端进阶深入系列之【this 上下文】/</id>
    <published>2019-07-19T09:36:25.202Z</published>
    <updated>2019-07-20T04:06:53.730Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>函数的调用 arguments 和 this、函数的调用方式、函数上下文方式！</p><a id="more"></a><h3 id="一、this-和-arguments"><a href="#一、this-和-arguments" class="headerlink" title="一、this 和 arguments"></a>一、this 和 arguments</h3><h4 id="1、this-执行上下文"><a href="#1、this-执行上下文" class="headerlink" title="1、this 执行上下文"></a>1、this 执行上下文</h4><blockquote><p>this 表示被调用函数上下文对象。</p></blockquote><h4 id="2、argumments-参数"><a href="#2、argumments-参数" class="headerlink" title="2、argumments 参数"></a>2、argumments 参数</h4><blockquote><p>表示函数调用过程中传递的所有参数。arguments 是个类数组结构，并不能当数组使用 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arguments[2]</span><br></pre></td></tr></table></figure><h3 id="二、函数调用"><a href="#二、函数调用" class="headerlink" title="二、函数调用"></a>二、函数调用</h3><blockquote><p><strong>函数的上下文 this 取决于函数的调用方式！</strong>，函数的调用一共四种：</p></blockquote><ul><li><strong>直接调用；</strong></li><li><strong>对象调用；</strong></li><li><strong>构造函数调用（new）；</strong></li><li><strong>apply、call 调用；</strong></li></ul><h4 id="1、直接调用"><a href="#1、直接调用" class="headerlink" title="1、直接调用"></a>1、直接调用</h4><blockquote><p>直接调用的三种方式：this 的指向，在非严格模式下，this 指向 <code>window</code>，在严格模式下，this 指向 <code>undefined</code>。</p></blockquote><ul><li>函数定义调用；</li><li>函数表达式调用；</li><li>立即执行函数调用；</li></ul><h4 id="2、对象调用"><a href="#2、对象调用" class="headerlink" title="2、对象调用"></a>2、对象调用</h4><blockquote><p>某个对象调用函数，this 将会执行调用的对象，并且可以在函数内部访问到。</p></blockquote><h4 id="3、-构造函数调用"><a href="#3、-构造函数调用" class="headerlink" title="3、 构造函数调用"></a>3、 构造函数调用</h4><blockquote><p>通过 new 操作符调用函数，生成一个实例化对象。</p><p><strong>注意：</strong></p><p>1）如果构造函数返回一个对象，则该对象作为整个表达式的值返回，而传入构造函数的 this 将被丢弃。</p><p>2）如果构造函数返回的是非对象类型，则忽略返回值，返回新创建的对象。</p></blockquote><p>1）创建一个空对象；</p><p>2）将该对象作为 this 参数传递给构造函数，称为构造函数的上下文；</p><p>3）构造函数将新对象返回。</p><h4 id="4、-Call-调用"><a href="#4、-Call-调用" class="headerlink" title="4、 Call 调用"></a>4、 Call 调用</h4><h6 id="▉-Call-的内部实现"><a href="#▉-Call-的内部实现" class="headerlink" title="▉ Call 的内部实现"></a>▉ Call 的内部实现</h6><ul><li>首先 <code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code>；</li><li>接下来给 <code>context</code> 创建一个 <code>fn</code> 属性，并将值设置为需要调用的函数；</li><li>因为 <code>call</code> 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来；</li><li>然后调用函数并将对象上的函数删除。</li></ul><p><strong>▉ ※ 手写一个 call 方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this 为调用的函数</span></span><br><span class="line"><span class="comment">// context 是参数对象</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断调用者是否为函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不传参默认为 window</span></span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">// 新增 fn 属性,将值设置为需要调用的函数</span></span><br><span class="line">    context.fn = <span class="keyword">this</span> </span><br><span class="line">    <span class="comment">// 将 arguments 转化为数组将 call 的传参提取出来  [...arguments]</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 传参调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">    <span class="comment">// 删除函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">" "</span>+age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'小鹿'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数的 call 方法</span></span><br><span class="line">print.myCall(obj,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="5、apply-调用"><a href="#5、apply-调用" class="headerlink" title="5、apply 调用"></a>5、apply 调用</h4><h6 id="▉-apply-的内部实现"><a href="#▉-apply-的内部实现" class="headerlink" title="▉ apply 的内部实现"></a>▉ apply 的内部实现</h6><ul><li>首先 <code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></li><li>接下来给 <code>context</code> 创建一个 <code>fn</code> 属性，并将值设置为需要调用的函数</li><li>因为 <code>apply</code> 传参是数组传参，所以取得数组，将其剥离为顺序参数进行函数调用</li><li>然后调用函数并将对象上的函数删除</li></ul><p><strong>▉ ※ 手写一个 apply 方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写一个 apply 方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断调用者是否为函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不传参默认为 window</span></span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">// 新增 fn 属性,将值设置为需要调用的函数</span></span><br><span class="line">    context.fn = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="comment">// 判断是否有参数传入</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">        result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = context.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">age,age2,age3</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">" "</span>+ age + <span class="string">" "</span>+ age2+<span class="string">" "</span>+age3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'小鹿'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数的 call 方法</span></span><br><span class="line">print.myApply(obj,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h4 id="4、补充"><a href="#4、补充" class="headerlink" title="4、补充"></a>4、补充</h4><blockquote><p>三者可以方便理解为：第一个参数调用了该方法，并将第二个参数作为该方法的参数传入。</p></blockquote><p><strong>共同点：</strong></p><p>① apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的；</p><p>② apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；</p><p>③ apply 、 call 、bind 三者都可以利用后续参数传参；</p><p><strong>不同点：</strong></p><p>①  call 顺序传参，而 apply 是数组传参。</p><p>② bind 的 <code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</p><p>③ bind 是返回对应函数（<strong>需要加一对花括号进行调用</strong>），便于稍后调用；apply 、call 则是立即调用 。</p><h3 id="三、-箭头函数"><a href="#三、-箭头函数" class="headerlink" title="三、 箭头函数"></a>三、 箭头函数</h3><blockquote><p>之前的 this 的上下问问题会与预期不否(如：事件处理器)，但是可以通过 apply 、call 绕过。还有另外两种解决办法：</p></blockquote><ul><li><strong>箭头函数</strong></li><li><strong>bind 函数</strong></li></ul><h4 id="1、箭头函数"><a href="#1、箭头函数" class="headerlink" title="1、箭头函数"></a>1、箭头函数</h4><blockquote><p>箭头函数可以规避上下文问题。箭头函数没有单独的 this 值。箭头函数的 this 与声明所在的上下文的 this 相同（调用箭头函数，不会隐士的传入 this 参数，而是从定义时的函数继承上下文）。</p></blockquote><h6 id="▉-箭头函数和对象字面量"><a href="#▉-箭头函数和对象字面量" class="headerlink" title="▉ 箭头函数和对象字面量"></a>▉ 箭头函数和对象字面量</h6><blockquote><p>1）箭头函数在创建的时候就已经确定了 this 的指向。</p><p>2）字面量中的箭头函数指向全局的 window 对象。</p></blockquote><h4 id="2、bind-函数"><a href="#2、bind-函数" class="headerlink" title="2、bind 函数"></a>2、bind 函数</h4><h6 id="▉-bind-的内部实现"><a href="#▉-bind-的内部实现" class="headerlink" title="▉ bind 的内部实现"></a>▉ bind 的内部实现</h6><ul><li>判断调用者是否为函数。</li><li>截取参数，注意：这里有两种形式传参。</li><li>返回一个函数，判断外部哪种方式调用了该函数（new | 直接调用）</li></ul><h6 id="▉-※-手写一个-bind方法："><a href="#▉-※-手写一个-bind方法：" class="headerlink" title="▉ ※ 手写一个 bind方法："></a>▉ ※ 手写一个 bind方法：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 手写一个 bind 函数</span><br><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line">    // 判断调用者是否为函数</span><br><span class="line">    if(typeof this !== &apos;function&apos;)&#123;</span><br><span class="line">        throw new TypeError(&apos;Error&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 截取传递的参数</span><br><span class="line">    const args = Array.from(arguments).slice(1)</span><br><span class="line">    // _this 指向调用的函数</span><br><span class="line">    const _this = this;</span><br><span class="line"></span><br><span class="line">    // 返回一个函数</span><br><span class="line">    return function F()&#123;</span><br><span class="line">        // 因为返回了一个函数，我们可以 new F()，所以需要判断</span><br><span class="line">        // 对于 new 的情况来说，不会被任何方式改变 this</span><br><span class="line">        if(this instanceof F)&#123;</span><br><span class="line">            return new _this(...args,...arguments)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return _this.apply(context,args.concat(...arguments))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 普通函数</span><br><span class="line">function print()&#123;</span><br><span class="line">    // new 的方式调用 bind 参数输出换做 [...arguments]</span><br><span class="line">    console.log(this.name);  </span><br><span class="line">&#125;</span><br><span class="line">// 自定义对象</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name:&apos;小鹿&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 调用函数的 call 方法</span><br><span class="line">let F = print.myBind(obj,1,2,3);</span><br><span class="line">// 返回对象</span><br><span class="line">let obj1 = new F();</span><br><span class="line">console.log(obj1);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数的调用 arguments 和 this、函数的调用方式、函数上下文方式！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端框架之Vue【生命周期】</title>
    <link href="http://yoursite.com/2019/07/10/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BVue%E3%80%90%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%91/"/>
    <id>http://yoursite.com/2019/07/10/前端框架之Vue【生命周期】/</id>
    <published>2019-07-10T11:45:19.279Z</published>
    <updated>2019-07-10T11:48:49.288Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vue 的生命周期！</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 的生命周期！&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之【生命周期】</title>
    <link href="http://yoursite.com/2019/07/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E3%80%90%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%91/"/>
    <id>http://yoursite.com/2019/07/05/微信小程序之【生命周期】/</id>
    <published>2019-07-05T00:33:31.101Z</published>
    <updated>2019-07-05T01:27:55.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>微信小程序的生命周期！</p><a id="more"></a><h4 id="一、小程序的生命周期"><a href="#一、小程序的生命周期" class="headerlink" title="一、小程序的生命周期"></a>一、小程序的生命周期</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="comment">//功能：注册小程序（小程序的生命周期）</span></span><br><span class="line">App(&#123;</span><br><span class="line">  <span class="comment">// 小程序的启动，全局只调用一次</span></span><br><span class="line"> onLaunch:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e+<span class="string">"初始化成功"</span>)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">// 监听小程序页面显示——从后台进入前台</span></span><br><span class="line"> onShow:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"显示"</span>)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">// 监听小程序隐藏——从前台进入后台</span></span><br><span class="line"> onHide:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"隐藏"</span>)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">// 当小程序发生脚本错误时调用</span></span><br><span class="line"> onError: <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(“报错”);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>#### </p><h4 id="二、页面的生命周期"><a href="#二、页面的生命周期" class="headerlink" title="二、页面的生命周期"></a>二、页面的生命周期</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  <span class="comment">// 生命周期函数--监听页面加载</span></span><br><span class="line">  onLoad: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"page ---onLoad---"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生命周期函数--监听页面初次渲染完成</span></span><br><span class="line">  onReady: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"page ---onReady---"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生命周期函数--监听页面显示——后台进入前台</span></span><br><span class="line">  onShow: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"page ---onShow---"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生命周期函数--监听页面隐藏——前台进入后台</span></span><br><span class="line">  onHide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"page ---onHide---"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生命周期函数--监听页面卸载——页面销毁</span></span><br><span class="line">  onUnload: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"page ---onUnload---"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序的生命周期！&lt;/p&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【设计模式】</title>
    <link href="http://yoursite.com/2019/07/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/07/03/前端面试之道【设计模式】/</id>
    <published>2019-07-03T00:07:52.610Z</published>
    <updated>2019-07-03T00:41:11.154Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端所用到的设计模式！</p><a id="more"></a><h2 id="发布-订阅者模式"><a href="#发布-订阅者模式" class="headerlink" title="发布-订阅者模式"></a>发布-订阅者模式</h2><blockquote><p>发布-订阅者模式也叫做<strong>观察者模式</strong>。这是一种<strong>一对一或一对多</strong>的依赖关系，对象相当于发布方，当对象发生改变时，订阅方都会受到通知。</p></blockquote><h4 id="1、应用"><a href="#1、应用" class="headerlink" title="1、应用"></a>1、应用</h4><blockquote><ul><li>MVC 模型中的 Model 与 View 之间的关系就是观察者模式。</li><li>Vue 中的响应式也是用到了该模式。</li><li>按钮的点击事件也属于该模式。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"ul"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>)</span><br><span class="line">    ul.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(event.target);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>定义一系列的算法，把它们封装起来，并且可以相互替换。</p></blockquote><h4 id="1、由来"><a href="#1、由来" class="headerlink" title="1、由来"></a>1、由来</h4><blockquote><p>在多种算法相似的情况下，使用 if-else 所带来的的复杂和难以维护。</p></blockquote><h4 id="2、适用条件"><a href="#2、适用条件" class="headerlink" title="2、适用条件"></a>2、适用条件</h4><blockquote><p>一个系统有多了类，区分它们的只是直接的行为。</p></blockquote><h4 id="3、优缺点"><a href="#3、优缺点" class="headerlink" title="3、优缺点"></a>3、优缺点</h4><ul><li><strong>优点：</strong>算法自由切换、避免重复使用判断条件、扩展性好</li><li><strong>缺点：</strong>策略类会增多、所有的类都会暴露接口</li></ul><h4 id="4、应用"><a href="#4、应用" class="headerlink" title="4、应用"></a>4、应用</h4><ul><li>MVC 中 View 与 Controller 之间的关系就是策略模式。</li></ul><h4 id="5、实例"><a href="#5、实例" class="headerlink" title="5、实例"></a>5、实例</h4><blockquote><p>计算器的加减乘除运算。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端所用到的设计模式！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道之框架【MVC/MVP/MVVM】</title>
    <link href="http://yoursite.com/2019/07/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E4%B9%8B%E6%A1%86%E6%9E%B6%E3%80%90MVVM%E3%80%91/"/>
    <id>http://yoursite.com/2019/07/02/前端面试之道之框架【MVVM】/</id>
    <published>2019-07-01T23:19:14.038Z</published>
    <updated>2019-07-03T00:40:49.909Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>什么是MVC/MVP/MVVM？</p><a id="more"></a><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><blockquote><p>使用了两种模式，观察者模式和策略模式。</p></blockquote><ul><li><code>Model</code> 和 <code>View</code> 之间使用的是<strong>观察者模式</strong>;</li><li><code>View</code> 和 <code>Controller</code> 之间采用的是<strong>策略模式</strong>;</li><li><code>Controller</code>  是 <code>View</code> 和 <code>Model</code> 之间的连接的枢纽。</li></ul><h4 id="一、Model-模型层"><a href="#一、Model-模型层" class="headerlink" title="一、Model 模型层"></a>一、Model 模型层</h4><blockquote><p>模型层主要封装了<strong>应用程序以及业务逻辑</strong>所使用到数据和处理数据的方法。Model 和 View 之间使用的是<strong>观察者模式</strong>，View 事先在 Model 上进行注册，一旦 Model 的数据发生改变，就会做出相应的改变。</p></blockquote><h4 id="二、View-视图层"><a href="#二、View-视图层" class="headerlink" title="二、View 视图层"></a>二、View 视图层</h4><blockquote><p>视图层主要是负责数据的展示。View 和 Controller 之间采用的是<strong>策略模式</strong>，不同的 View 引用不同的 Controller 的实例来实现了特定的<strong>响应策略</strong>（比如点击事件）。</p></blockquote><h4 id="三、Controller-控制层"><a href="#三、Controller-控制层" class="headerlink" title="三、Controller 控制层"></a>三、Controller 控制层</h4><blockquote><p>控制层主要用来连接 Model 和 View 。<strong>使用控制层来对用户界面的用户输入响应</strong>，连接模型层，用于控制对数据的改变，所有的业务逻辑主要集中在控制层。</p></blockquote><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><blockquote><p>MVP 主要加大了 Model 和 View 解耦， View 不能直接获取 Model 层的数据，而是通过 Presenter 提供给 View 接口，负责将 View 和 Model  的数据进行手动同步。</p></blockquote><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><blockquote><p>MVVM 主要用框架封装了 MVP 中的 Presenter 的手动操作，主要实现了自动化的数据绑定，只要告诉 View 显示的数据是 Model 的哪一部分就可以了。</p></blockquote><h3 id="一、MVVM-出现的原因？"><a href="#一、MVVM-出现的原因？" class="headerlink" title="一、MVVM 出现的原因？"></a>一、MVVM 出现的原因？</h3><blockquote><p>1、由于前端开发混合了 HTML 、CSS、Javacript 众多页面，所以代码的组织和维护变的更加复杂，所以就出现了 MVVM 模式的原因。</p><p>2、MVVM 最早是微软提出来的，其实借鉴了桌面应用程序的 MVC 设计思想。</p></blockquote><h4 id="二、什么是-MVVM-？"><a href="#二、什么是-MVVM-？" class="headerlink" title="二、什么是 MVVM ？"></a>二、什么是 MVVM ？</h4><blockquote><p>MVVM 就是 Model-View-ViewMoudel 的缩写。</p></blockquote><p>Model 就用纯 JavaScript 对象表示，View 负责显示，两者做到了极大限度的分离。把 Model 和 View 关联起来就是 ViewModel。ViewModel 主要负责把 Model 的数据同步到 View 显示，还负责把 View 修改的数据同步回 Model。</p><h4 id="1、Model"><a href="#1、Model" class="headerlink" title="1、Model"></a>1、Model</h4><blockquote><p>Model 视图层，只关注视图本身，可以理解成 json 对象。</p></blockquote><h4 id="2、View"><a href="#2、View" class="headerlink" title="2、View"></a>2、View</h4><blockquote><p>MVVM 中的 View 通过使用模板语法声明式的渲染 DOM，当 ViewModel 对 Model 进行更新的时候，通过数据绑定更新到 View。</p></blockquote><h4 id="3、ViewModel"><a href="#3、ViewModel" class="headerlink" title="3、ViewModel"></a>3、ViewModel</h4><blockquote><p>与 MVP 不同的是，没有了 View 为 Presente 提供的接口，之前由 Presenter 负责的 View 和 Model之间的数据同步交给了 ViewModel 中的<strong>数据绑定</strong>进行处理，当 Model 发生变化，ViewModel 就会自动更新；ViewModel 变化，Model 也会更新。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是MVC/MVP/MVVM？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端 JS 基础篇之【浏览器中的高度】</title>
    <link href="http://yoursite.com/2019/06/30/%E5%89%8D%E7%AB%AF%20HTML%20%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%AB%98%E5%BA%A6%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/30/前端 HTML 基础篇之【浏览器中的高度】/</id>
    <published>2019-06-30T02:59:47.099Z</published>
    <updated>2019-06-30T03:46:20.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浏览器中的高度由内而外分为页面、窗口、屏幕！</p><a id="more"></a><h2 id="浏览器相关高度"><a href="#浏览器相关高度" class="headerlink" title="浏览器相关高度"></a>浏览器相关高度</h2><h3 id="一、页面尺寸"><a href="#一、页面尺寸" class="headerlink" title="一、页面尺寸"></a>一、页面尺寸</h3><p><img src="https://img-blog.csdn.net/20161228000813185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3M2NTEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="é¡µé¢å°ºå¯¸"></p><h4 id="1、Body-的总高度-总宽度"><a href="#1、Body-的总高度-总宽度" class="headerlink" title="1、Body 的总高度/总宽度"></a>1、Body 的总高度/总宽度</h4><blockquote><p>页面的可滚动的高度也算。</p></blockquote><ul><li><code>body.offsetHeight</code></li><li><code>body.offsetWidth</code></li></ul><h4 id="2、Body-的可见区域高度-宽度"><a href="#2、Body-的可见区域高度-宽度" class="headerlink" title="2、Body 的可见区域高度/宽度"></a>2、Body 的可见区域高度/宽度</h4><blockquote><p>只展现出的可视化页面高度/宽度。</p></blockquote><ul><li><code>body.clientHeight</code></li><li><code>body.clientWidth</code></li></ul><h4 id="3、滚动条的高度"><a href="#3、滚动条的高度" class="headerlink" title="3、滚动条的高度"></a>3、滚动条的高度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.Height - body.clientHeight = 滚动条的高度</span><br></pre></td></tr></table></figure><h3 id="二、浏览器尺寸"><a href="#二、浏览器尺寸" class="headerlink" title="二、浏览器尺寸"></a>二、浏览器尺寸</h3><p><img src="https://img-blog.csdn.net/20161228000146700?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3M2NTEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è·åæµè§å¨å°ºå¯¸"></p><h4 id="1、浏览器的高度"><a href="#1、浏览器的高度" class="headerlink" title="1、浏览器的高度"></a>1、浏览器的高度</h4><blockquote><p>整个浏览器（内容+工具栏+滚动条）的高度/宽度。</p></blockquote><ul><li><code>window.outerHeight</code></li><li><code>window.outerWidth</code></li></ul><h4 id="2、页面可用高度"><a href="#2、页面可用高度" class="headerlink" title="2、页面可用高度"></a>2、页面可用高度</h4><blockquote><p>除去工具栏只有（显示内容区域内容+滚动条）。</p></blockquote><ul><li><code>window.innerHeight</code></li><li><code>window.innerWidth</code></li></ul><p>可求出工具栏的高度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.outerHeight - window.innerHeight</span><br></pre></td></tr></table></figure><h3 id="三、屏幕的尺寸"><a href="#三、屏幕的尺寸" class="headerlink" title="三、屏幕的尺寸"></a>三、屏幕的尺寸</h3><p><img src="https://img-blog.csdn.net/20161227235703448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3M2NTEx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="å±å¹å°ºå¯¸çè·å"></p><h4 id="1、屏幕高度"><a href="#1、屏幕高度" class="headerlink" title="1、屏幕高度"></a>1、屏幕高度</h4><blockquote><p>整个屏幕的高度（内容+任务栏）。</p></blockquote><ul><li><code>screen.Height</code></li><li><code>screen.Width</code></li></ul><h4 id="2、屏幕可用高度"><a href="#2、屏幕可用高度" class="headerlink" title="2、屏幕可用高度"></a>2、屏幕可用高度</h4><blockquote><p>除去任务栏的屏幕可用高度。</p></blockquote><ul><li><code>screen.availHeight</code></li><li><code>screen.availWidth</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器中的高度由内而外分为页面、窗口、屏幕！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【浏览器缓存机制】</title>
    <link href="http://yoursite.com/2019/06/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/30/前端面试之道【浏览器缓存】/</id>
    <published>2019-06-29T23:52:38.994Z</published>
    <updated>2019-06-30T01:23:34.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浏览器的缓存机制涉及到性能优化领域！</p><a id="more"></a><h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h2><blockquote><p><strong>缓存是性能优化中最高效的一种方式，可以较少网络传输所带来的损耗</strong>。</p></blockquote><p>一个数据请求分为三个阶段，发起网络请求、后台处理、浏览器响应。浏览器的缓存优化主要是在网络请求和浏览器响应这两个步骤中优化性能。第一种情况，直接使用缓存，不发起请求；第二种情况，发起请求，发现后端存储的数据和前端一致，就没必要传回来了。</p><h3 id="一、缓存位置"><a href="#一、缓存位置" class="headerlink" title="一、缓存位置"></a>一、缓存位置</h3><blockquote><p>缓存位置分为大体分为四种，会依次查看当前数据是否在缓存中，如果没有则会请求网络。</p></blockquote><ul><li><strong>Service Worker</strong></li><li><strong>Memory Cache</strong></li><li><strong>Disk Cache</strong></li><li><strong>Push Cache</strong></li><li><strong>网络请求</strong></li></ul><h4 id="1、Service-Worker"><a href="#1、Service-Worker" class="headerlink" title="1、Service Worker"></a>1、Service Worker</h4><blockquote><p>Service 是运行在浏览器背后<strong>独立的线程</strong>，一般可用来实现缓存功能。因为 Service Worker 中涉及到请求拦截，所以必须使用 <strong>HTTPS</strong> 协议来保证安全。</p></blockquote><h6 id="▉-如何使用？"><a href="#▉-如何使用？" class="headerlink" title="▉ 如何使用？"></a>▉ 如何使用？</h6><blockquote><p>注册 <code>Service Worker</code>，然后监听到 <code>install</code> 事件之后就可以缓存需要的文件，用户在下次访问的时候就会拦截请求，然后查询是否已缓存，缓存的话就直接读取缓存文件，否则就去请求数据。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 注册 Service Worker</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">'sw.js'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'service worker 注册成功'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'servcie worker 注册失败'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 `install` 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, e =&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'my-cache'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">'./index.html'</span>, <span class="string">'./index.js'</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, e =&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'fetch source'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器的缓存机制涉及到性能优化领域！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之浏览器【数据存储】</title>
    <link href="http://yoursite.com/2019/06/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%90%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/26/前端面试之浏览器【数据存储】/</id>
    <published>2019-06-26T11:20:39.202Z</published>
    <updated>2019-06-26T12:05:30.013Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浏览器的数据存储！</p><a id="more"></a><h2 id="浏览器中的存储功能"><a href="#浏览器中的存储功能" class="headerlink" title="浏览器中的存储功能"></a>浏览器中的存储功能</h2><blockquote><p>有四种存储功能：cookie、localStorage、sessionStorage、indexDB。</p></blockquote><h3 id="一、各个存储方式的区别？"><a href="#一、各个存储方式的区别？" class="headerlink" title="一、各个存储方式的区别？"></a>一、各个存储方式的区别？</h3><h6 id="▉-数据生命周期"><a href="#▉-数据生命周期" class="headerlink" title="▉ 数据生命周期"></a>▉ 数据生命周期</h6><table><thead><tr><th><strong>cookie</strong></th><th>一般由服务器生成，可以设置过期时间。</th></tr></thead><tbody><tr><td><strong>localStorage</strong></td><td><strong>除非被清理，否则一直存在。</strong></td></tr><tr><td><strong>sessionStorage</strong></td><td><strong>页面关闭就清理。</strong></td></tr><tr><td><strong>indexDB</strong></td><td><strong>除非被清理，否则一直存在。</strong></td></tr></tbody></table><h6 id="▉-数据存储大小"><a href="#▉-数据存储大小" class="headerlink" title="▉ 数据存储大小"></a>▉ 数据存储大小</h6><table><thead><tr><th><strong>cookie</strong></th><th>4K</th></tr></thead><tbody><tr><td><strong>localStorage</strong></td><td><strong>5M</strong></td></tr><tr><td><strong>sessionStorage</strong></td><td><strong>5M</strong></td></tr><tr><td><strong>indexDB</strong></td><td><strong>无限</strong></td></tr></tbody></table><h6 id="▉-与服务器通信"><a href="#▉-与服务器通信" class="headerlink" title="▉ 与服务器通信"></a>▉ 与服务器通信</h6><table><thead><tr><th><strong>cookie</strong></th><th>每次都会携带在 header 中，对于请求性能影响</th></tr></thead><tbody><tr><td><strong>localStorage</strong></td><td><strong>不参与</strong></td></tr><tr><td><strong>sessionStorage</strong></td><td><strong>不参与</strong></td></tr><tr><td><strong>indexDB</strong></td><td><strong>不参与</strong></td></tr></tbody></table><h3 id="二、谈谈-Cookie"><a href="#二、谈谈-Cookie" class="headerlink" title="二、谈谈 Cookie"></a>二、谈谈 Cookie</h3><h4 id="1、Cookie-的由来"><a href="#1、Cookie-的由来" class="headerlink" title="1、Cookie 的由来"></a>1、Cookie 的由来</h4><blockquote><p>因为 Http 是不保存状态的协议，所以在请求中插入一个 token 作为标识，但是这种方式易出错，所以有了 Cookie 的出现。</p></blockquote><h4 id="2、Cookie-的原理"><a href="#2、Cookie-的原理" class="headerlink" title="2、Cookie 的原理"></a>2、Cookie 的原理</h4><blockquote><p>第一次访问网站，浏览器发出请求，服务器响应之后，将 Cookie 放到响应中。当浏览器发送第二次请求的时候，就会携带 Cookie 用于辨别用户身份，服务器收到信息之后就会辨别用户的信息，做出相应的回应。</p></blockquote><h4 id="3、不可跨域性"><a href="#3、不可跨域性" class="headerlink" title="3、不可跨域性"></a>3、不可跨域性</h4><blockquote><p>在不同的域名下，每个 Cookie 会绑定单一的域名。</p></blockquote><h4 id="4、Cookie-的属性"><a href="#4、Cookie-的属性" class="headerlink" title="4、Cookie 的属性"></a>4、Cookie 的属性</h4><ul><li><strong>name:</strong> 代表 cookie 的名字，不同的 name 会被覆盖掉。</li><li><strong>value:</strong> 代表 cookie 的值。由于cookie规定是名称/值是不允许包含分号，逗号，空格的，所以为了不给用户到来麻烦，考虑服务器的兼容性，任何存储 cookie 的数据都应该被 URL 编码。</li><li><strong>domain:</strong> 代表当前 Cookie 绑定的域名。统一域名的二级域名是不能交换 Cookie 的。</li><li><strong>path:</strong> 默认设置为 ‘/’ ，否则会将路径路由绑定 Cookie。</li><li><p><strong>expires：</strong>Cookie 的有效期，已经逐渐被 Max-Age 逐渐取代。默认的配置是当关闭浏览器，Cookie自动会被删除。该字段是以秒为单位的，整数时，过了多少秒之后就会被删除。为 0 时，删除 Cookie。为负数时，就会当浏览器窗口关闭时，Cookie 的就会消失。</p></li><li><p><strong>secure：</strong>当这个属性设置为true时，此cookie只会在 https 和 ssl 等安全协议下传输。</p></li><li><strong>HttpOnly:</strong> 如果设置为 true，就不能通过 js 脚本获取，有效防止 XSS 攻击。</li></ul><h4 id="5、设置-Cookie"><a href="#5、设置-Cookie" class="headerlink" title="5、设置 Cookie"></a>5、设置 Cookie</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &apos;myname=laihuamin;path=/;domain=.baidu.com&apos;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器的数据存储！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道之【浏览器知识汇总】</title>
    <link href="http://yoursite.com/2019/06/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/26/前端面试之道【浏览器知识汇总】/</id>
    <published>2019-06-26T10:44:41.282Z</published>
    <updated>2019-06-26T11:19:22.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浏览器的相关必会的知识！</p><a id="more"></a><h3 id="一、浏览器的工作原理"><a href="#一、浏览器的工作原理" class="headerlink" title="一、浏览器的工作原理"></a>一、浏览器的工作原理</h3><h4 id="1、浏览器的工作原理"><a href="#1、浏览器的工作原理" class="headerlink" title="1、浏览器的工作原理"></a>1、浏览器的工作原理</h4><blockquote><p><strong>面试题：</strong>说一说浏览器工作的基本流程？</p></blockquote><p><a href="[http://luxiangqiang.xn--6qq986b3xl/2019/05/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B9%8B%E3%80%90%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%91/](http://luxiangqiang.xn--6qq986b3xl/2019/05/22/浏览器是如何工作的之[工作流程]/">浏览器的工作原理</a>)</p><h4 id="2、浏览器的渲染原理"><a href="#2、浏览器的渲染原理" class="headerlink" title="2、浏览器的渲染原理"></a>2、浏览器的渲染原理</h4><blockquote><p>面试题：说一说浏览器的渲染原理？</p></blockquote><p><a href="[http://luxiangqiang.xn--6qq986b3xl/2019/06/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E3%80%91/](http://luxiangqiang.xn--6qq986b3xl/2019/06/21/前端面试之道[浏览器渲染原理]/">浏览器的渲染原理</a>)</p><h4 id="3、浏览器的事件机制"><a href="#3、浏览器的事件机制" class="headerlink" title="3、浏览器的事件机制"></a>3、浏览器的事件机制</h4><blockquote><p><strong>面试题：</strong>事件的触发过程是怎么样的？</p></blockquote><h4 id="4、浏览器的事件代理-委托"><a href="#4、浏览器的事件代理-委托" class="headerlink" title="4、浏览器的事件代理(委托)"></a>4、浏览器的事件代理(委托)</h4><blockquote><p><strong>面试题：</strong>知道什么是事件代理嘛？</p></blockquote><p><a href="[http://luxiangqiang.xn--6qq986b3xl/2019/05/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%8E%E5%A7%94%E6%89%98%E3%80%91/](http://luxiangqiang.xn--6qq986b3xl/2019/05/02/前端面试之道[事件流与委托]/">事件委托</a>)</p><h4 id="5、浏览器的运行机制-Event-Loop"><a href="#5、浏览器的运行机制-Event-Loop" class="headerlink" title="5、浏览器的运行机制(Event Loop)"></a>5、浏览器的运行机制(Event Loop)</h4><blockquote><p>面试题：浏览器的运行机制包括哪些？</p></blockquote><p><a href="[http://luxiangqiang.xn--6qq986b3xl/2019/06/02/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E3%80%91/](http://luxiangqiang.xn--6qq986b3xl/2019/06/02/前端进阶深入系列之[浏览器的运行机制]/">浏览器的运行机制</a>)</p><h3 id="二、浏览器跨域问题"><a href="#二、浏览器跨域问题" class="headerlink" title="二、浏览器跨域问题"></a>二、浏览器跨域问题</h3><blockquote><p><strong>面试题：</strong>什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求嘛？</p></blockquote><p><a href="[http://luxiangqiang.xn--6qq986b3xl/2019/04/10/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E3%80%91/](http://luxiangqiang.xn--6qq986b3xl/2019/04/10/前端进阶深入系列之[跨域问题]/">浏览器的跨域问题</a>)</p><h3 id="三、浏览器器的数据存储"><a href="#三、浏览器器的数据存储" class="headerlink" title="三、浏览器器的数据存储"></a>三、浏览器器的数据存储</h3><blockquote><p><strong>面试题：</strong>有几种方式可以实现存储功能，分别有什么优缺点？</p></blockquote><h3 id="四、浏览器的缓存机制"><a href="#四、浏览器的缓存机制" class="headerlink" title="四、浏览器的缓存机制"></a>四、浏览器的缓存机制</h3><blockquote></blockquote><h3 id="五、Service-Worker"><a href="#五、Service-Worker" class="headerlink" title="五、Service Worker"></a>五、Service Worker</h3><blockquote><p><strong>面试题：</strong>什么是 Service Worker？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器的相关必会的知识！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端框架之【Vue全家桶】</title>
    <link href="http://yoursite.com/2019/06/24/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8B%E3%80%90Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/24/前端框架之【Vue全家桶】/</id>
    <published>2019-06-23T22:57:09.306Z</published>
    <updated>2019-06-25T12:33:06.149Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vue 全家桶（Vue-router、Vuex ）浅入浅出！</p><a id="more"></a><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h3><h4 id="1、created"><a href="#1、created" class="headerlink" title="1、created"></a>1、created</h4><blockquote><p>一般会在下边这个钩子函数中初始化页面的数据。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 做服务器请求什么的</span><br><span class="line">created：&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、computed"><a href="#2、computed" class="headerlink" title="2、computed"></a>2、computed</h4><blockquote><p>DOM 加载完成进行渲染，计算属性，实时响应，根据data中的值实时做出处理，就用 computed。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">方法（）&#123;</span><br><span class="line">return ； // 通过方法返回值来使页面的数据进行变换</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、指令"><a href="#二、指令" class="headerlink" title="二、指令"></a>二、指令</h3><h4 id="1、v-show"><a href="#1、v-show" class="headerlink" title="1、v-show"></a>1、v-show</h4><blockquote><p>用于控制控件的显示。</p></blockquote><h4 id="2、v-model"><a href="#2、v-model" class="headerlink" title="2、v-model"></a>2、v-model</h4><blockquote><p>用于数据双向绑定，一般用于 input。</p></blockquote><h4 id="3、v-for"><a href="#3、v-for" class="headerlink" title="3、v-for"></a>3、v-for</h4><blockquote><p>用于循环渲染数据。</p></blockquote><h4 id="4、-click"><a href="#4、-click" class="headerlink" title="4、@click"></a>4、@click</h4><blockquote><p>用于事件绑定。</p></blockquote><h3 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h3><blockquote><p>所有的组件存放到文件夹中，然后再 App.vue 进行导入。</p></blockquote><h4 id="1、公共组件"><a href="#1、公共组件" class="headerlink" title="1、公共组件"></a>1、公共组件</h4><blockquote><p>公共组件写到一个公共的文件夹中。</p></blockquote><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><blockquote><p>路由主要实现一级页面的跳转，二级页面跳转，三级页面跳转。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装路由</span><br><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure><h4 id="1、导入-使用路由"><a href="#1、导入-使用路由" class="headerlink" title="1、导入/使用路由"></a>1、导入/使用路由</h4><blockquote><p>新建一个路由文件夹，新建 router.js 文件，导入路由，使用路由。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Router)</span><br></pre></td></tr></table></figure><h4 id="2、实例化路由对象"><a href="#2、实例化路由对象" class="headerlink" title="2、实例化路由对象"></a>2、实例化路由对象</h4><blockquote><p>新建一个路由对象，然后暴露接口，在 Vue 的对象中去使用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode:&apos;history&apos;,</span><br><span class="line">  routes: []</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3、配置路由的跳转路径"><a href="#3、配置路由的跳转路径" class="headerlink" title="3、配置路由的跳转路径"></a>3、配置路由的跳转路径</h4><blockquote><p>配置路由跳转对象，有三个参数：</p></blockquote><ul><li>path：跳转路径。</li><li>name：路由的名字。</li><li>component ：跳转的组件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Menu from &apos;@/components/Menu&apos;</span><br><span class="line">&#123;path: &apos;/menu&apos;,name: &apos;MenuLink&apos;,component: Menu&#125;</span><br></pre></td></tr></table></figure><h4 id="4、在跳转的组件上设置跳转"><a href="#4、在跳转的组件上设置跳转" class="headerlink" title="4、在跳转的组件上设置跳转"></a>4、在跳转的组件上设置跳转</h4><blockquote><p>使用 router-link 标签进行设置跳转。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// tag：替换的标签   :to : 使用的路由跳转对象（可以是由 path 也可以指定路由对象）</span><br><span class="line">// 方式一：静态绑定路由</span><br><span class="line">&lt;router-link to=&quot;/&quot;&gt;新闻&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">// 方式二：动态绑定路由</span><br><span class="line">&lt;router-link :to=&quot;homeLink&quot;&gt;新闻&lt;/router-link&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            homeLink:&apos;/&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 方式三：使用路由名字绑定路由</span><br><span class="line">&lt;router-link tag=&quot;div&quot; :to=&quot;&#123;name:&apos;historyLink&apos;&#125;&quot;&gt;新闻&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h6 id="▉-默认跳转页面"><a href="#▉-默认跳转页面" class="headerlink" title="▉  默认跳转页面"></a>▉  默认跳转页面</h6><blockquote><p>如果输入错误的 URL 需要设置默认的跳转页面。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 错误路径跳转根目录</span><br><span class="line">&#123;path: &apos;*&apos;,redirect:&apos;/&apos;&#125;,</span><br></pre></td></tr></table></figure><h6 id="▉-路由跳转方法"><a href="#▉-路由跳转方法" class="headerlink" title="▉  路由跳转方法"></a>▉  路由跳转方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 跳转上次浏览页面</span><br><span class="line">// this.$router.go(-1)</span><br><span class="line"></span><br><span class="line">// 指定跳转地址</span><br><span class="line">// this.$router.replace(&apos;/menu&apos;)</span><br><span class="line"></span><br><span class="line">// 指定跳转路由的名字下</span><br><span class="line">// this.$router.replace(&#123;name:&apos;MenuLink&apos;&#125;)</span><br><span class="line"></span><br><span class="line">// 通过push进行跳转(常用)</span><br><span class="line">this.$router.push(&apos;/menu&apos;)</span><br><span class="line">this.$router.push(&#123;name:&apos;MenuLink&apos;&#125;)</span><br></pre></td></tr></table></figure><h4 id="5、在页面使用路由"><a href="#5、在页面使用路由" class="headerlink" title="5、在页面使用路由"></a>5、在页面使用路由</h4><blockquote><p>全局的 Vue.app 下使用路由的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h4 id="6、二级路由和三级路由"><a href="#6、二级路由和三级路由" class="headerlink" title="6、二级路由和三级路由"></a>6、二级路由和三级路由</h4><blockquote><p>在路由文件中配置二级路由和三级路由。然后在对应的组件进行绑定路由名，和在二级或三级组件下进行显示跳转页面。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 二级路由</span><br><span class="line">&#123;path: &apos;/about&apos;,name: &apos;AboutLink&apos;,component: About,children:[</span><br><span class="line">      &#123;&#125;,</span><br><span class="line">  // 三级路由</span><br><span class="line">      &#123;&#125;,children:[</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">      ]&#125;,</span><br><span class="line">      &#123;&#125;,</span><br><span class="line">      &#123;&#125;,</span><br><span class="line">    ]&#125;,</span><br></pre></td></tr></table></figure><h4 id="7、进入默认显示页面"><a href="#7、进入默认显示页面" class="headerlink" title="7、进入默认显示页面"></a>7、进入默认显示页面</h4><blockquote><p>已进入二三级页面，要默认显示一个页面，而不是空白。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect:&apos; &apos;// 默认显示的组件路径</span><br></pre></td></tr></table></figure><h4 id="8、全局守卫"><a href="#8、全局守卫" class="headerlink" title="8、全局守卫"></a>8、全局守卫</h4><blockquote><p>全局守卫就是当进入整个路由页面时，要在进入之前做一些处理，比如弹框请先登录。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    // 判断如果是登录页面或注册页面直接进入,否则提示登录</span><br><span class="line">    if(to.path == &quot;/login&quot; || to.path == &quot;/register&quot;)&#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      alert(&quot;您还没有登录,请先登录！&quot;)</span><br><span class="line">      next(&quot;/login&quot;) // 将用户引导到登录页面中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="9、后置钩子"><a href="#9、后置钩子" class="headerlink" title="9、后置钩子"></a>9、后置钩子</h4><h4 id="10、路由独享守卫"><a href="#10、路由独享守卫" class="headerlink" title="10、路由独享守卫"></a>10、路由独享守卫</h4><blockquote><p>与全局守卫不同的是只作用于规定的路由页面。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;path: &apos;/admin&apos;,name: &apos;AdminLink&apos;,component: Admin,beforeEnter:(to, from, next)=&gt;&#123;</span><br><span class="line">    alert(&apos;非登陆状态进制访问！&apos;)</span><br><span class="line">    next();</span><br><span class="line">&#125;&#125;,</span><br></pre></td></tr></table></figure><h4 id="11、组件守卫"><a href="#11、组件守卫" class="headerlink" title="11、组件守卫"></a>11、组件守卫</h4><blockquote><p>在组件内使用，进入组件之前和离开组件之后进行做处理。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件内守卫(进入/离开组件时应该做的事情)</span></span><br><span class="line">  beforeRouteEnter:<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 页面的渲染顺序是先渲染组件内守卫，然后渲染data,所以在守卫里边直接拿不到data里的数据，所以要使用next回调函数</span></span><br><span class="line">      next(<span class="function">(<span class="params">vm</span>) =&gt;</span>&#123;</span><br><span class="line">          alert(<span class="string">"Hellow "</span>+vm.name)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 离开组件时的守卫</span></span><br><span class="line">  beforeRouteLeave:<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(confirm(<span class="string">"确定要离开本页面吗？"</span>) == <span class="literal">true</span>)&#123;</span><br><span class="line">          next();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          next(<span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="12、组件复用"><a href="#12、组件复用" class="headerlink" title="12、组件复用"></a>12、组件复用</h4><blockquote><p>想要在当前页面下复用其他组件，必须在相对应的路由中进行配置，components。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 想在根目录的主页中复用组件，所以在对应的路由中进行配置。</span><br><span class="line">&#123;path: &apos;/&apos;,name: &apos;HomeLink&apos;,components:&#123;</span><br><span class="line">      // 默认显示组件</span><br><span class="line">      default:Home,</span><br><span class="line">      // 组件复用</span><br><span class="line">      &quot;history&quot;:History,</span><br><span class="line">      &quot;delivery&quot;:Delivery,</span><br><span class="line">      &quot;orderingGuilde&quot;:OrderingGuilde</span><br><span class="line">    &#125;&#125;,</span><br></pre></td></tr></table></figure><h4 id="13、滚动行为"><a href="#13、滚动行为" class="headerlink" title="13、滚动行为"></a>13、滚动行为</h4><blockquote><p>滚动路由直接定位页面要展现的位置。</p></blockquote><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><blockquote><p>Vuex 可以很好的实现组件间的数据共享。</p></blockquote><h4 id="1、本地安装-vuex"><a href="#1、本地安装-vuex" class="headerlink" title="1、本地安装 vuex"></a>1、本地安装 vuex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><h4 id="2、在-src-下新建-store-文件夹以及文件-store-js"><a href="#2、在-src-下新建-store-文件夹以及文件-store-js" class="headerlink" title="2、在 src 下新建 store 文件夹以及文件 store.js"></a>2、在 src 下新建 store 文件夹以及文件 store.js</h4><h4 id="3、在文件中引入-Vuex"><a href="#3、在文件中引入-Vuex" class="headerlink" title="3、在文件中引入 Vuex"></a>3、在文件中引入 Vuex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br></pre></td></tr></table></figure><h4 id="4、使用-Vuex"><a href="#4、使用-Vuex" class="headerlink" title="4、使用 Vuex"></a>4、使用 Vuex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><h4 id="5、暴露出-Vuex-实例"><a href="#5、暴露出-Vuex-实例" class="headerlink" title="5、暴露出 Vuex 实例"></a>5、暴露出 Vuex 实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export const store = new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        // 设置属性</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">        // 获取属性的状态</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        // 改变属性的状态</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">        // 应用 mutations</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="6、在-main-js-全局中的-Vue-实例中导入使用"><a href="#6、在-main-js-全局中的-Vue-实例中导入使用" class="headerlink" title="6、在 main.js 全局中的 Vue 实例中导入使用"></a>6、在 main.js 全局中的 Vue 实例中导入使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;store&#125; from &apos;./store/store.js&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="7、必须通过-mutations-改变-state-中的属性"><a href="#7、必须通过-mutations-改变-state-中的属性" class="headerlink" title="7、必须通过 mutations 改变 state 中的属性"></a>7、必须通过 mutations 改变 state 中的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutations:&#123;</span><br><span class="line">       // 改变属性的状态</span><br><span class="line">       setMenuItem(state,data)&#123;</span><br><span class="line">           state.menuItems = data</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h4 id="8、将数据存入-store（存入状态）"><a href="#8、将数据存入-store（存入状态）" class="headerlink" title="8、将数据存入 store（存入状态）"></a>8、将数据存入 store（存入状态）</h4><blockquote><p>通过在组件中调用 mutations  的方法就可以将值传入.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&quot;setMenuItem&quot;,data) //全局调用 store 中的 commit 方法</span><br></pre></td></tr></table></figure><h4 id="9、在-store-取出数据（取出状态）"><a href="#9、在-store-取出数据（取出状态）" class="headerlink" title="9、在 store 取出数据（取出状态）"></a>9、在 store 取出数据（取出状态）</h4><blockquote><p>在组件中获取状态通过全局调用 store.state 就可以。如果页面响应数据实时变化，可以将方法写在 computed 中。</p></blockquote><h6 id="▉-第一种方式："><a href="#▉-第一种方式：" class="headerlink" title="▉ 第一种方式："></a>▉ 第一种方式：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这样获取有个缺点，直接将属性暴露在外部了</span><br><span class="line">this.$store.state.menuItems; // 全局获取 store 中的数据</span><br></pre></td></tr></table></figure><h6 id="▉-第二种方式："><a href="#▉-第二种方式：" class="headerlink" title="▉ 第二种方式："></a>▉ 第二种方式：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过 getter 获取</span><br><span class="line">this.$store.getters.getMenuItems; // 调用 getters 里边的方法</span><br></pre></td></tr></table></figure><h2 id="模块化分离"><a href="#模块化分离" class="headerlink" title="模块化分离"></a>模块化分离</h2><blockquote><p>将 Vuex 中的各功能部分进行分离。分别建立独立文件，然后实现模块化。</p></blockquote><h4 id="1、四种状态进行分离"><a href="#1、四种状态进行分离" class="headerlink" title="1、四种状态进行分离"></a>1、四种状态进行分离</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export const 功能</span><br><span class="line">import * as getters from &apos;./getters&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export const store = new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        // 设置属性</span><br><span class="line">        menuItems:&#123;&#125;,  // Menu 菜单 </span><br><span class="line">        menuItems2:&#123;&#125;, // Admin 菜单 </span><br><span class="line">        username:null, // 当前用户名</span><br><span class="line">        isLogin:false  // 当前的登录状态</span><br><span class="line">    &#125;,</span><br><span class="line">    getters,</span><br><span class="line">    mutations,</span><br><span class="line">    actions</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2、使用-Moudle-优化分离"><a href="#2、使用-Moudle-优化分离" class="headerlink" title="2、使用 Moudle 优化分离"></a>2、使用 Moudle 优化分离</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getters = &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mutations = &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const actions = &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    state,</span><br><span class="line">    getters,</span><br><span class="line">    mutations,</span><br><span class="line">    actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import users from &apos;./Module/users&apos;</span><br><span class="line">export const store = new Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        menu,</span><br><span class="line">        status,</span><br><span class="line">        users</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 全家桶（Vue-router、Vuex ）浅入浅出！&lt;/p&gt;
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="前端框架" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【浏览器渲染原理】</title>
    <link href="http://yoursite.com/2019/06/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/21/前端面试之道【浏览器渲染原理】/</id>
    <published>2019-06-21T06:22:40.806Z</published>
    <updated>2019-06-23T00:01:00.022Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浏览器的渲染原理！</p><a id="more"></a><h2 id="一、浏览器的渲染原理"><a href="#一、浏览器的渲染原理" class="headerlink" title="一、浏览器的渲染原理"></a>一、浏览器的渲染原理</h2><blockquote><p>JS 代码执行有自己的 JS 引擎，而浏览器的渲染也有一个引擎叫做渲染引擎。<strong>Firefox</strong> 的渲染引擎叫做 <strong>Gecko</strong>，<strong>Chrome</strong> 和 <strong>Safari</strong> 中都是基于 <strong>WebKit</strong> 开发的。</p></blockquote><h3 id="1、DOM-树的构建"><a href="#1、DOM-树的构建" class="headerlink" title="1、DOM 树的构建"></a>1、DOM 树的构建</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167542b09875a74a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>① 当我们在网页中向服务器请求对应的 HTML 时，服务器将 HTML、CSS、JS 文件转化为 0,1字节数据在网络中传输给浏览器。</p><p>② 浏览器将接收到的字节数据转化为字符串。</p><p>③ 转化为字符串之后，浏览器再将这些字符串通过词法分析转化为标记（token）—— 代码的最小单位,这一过程叫做标记化。</p><p>④ 结束标记化后，将这些标记转化为 Node 结点，浏览器根据不同的结点构建为一棵 DOM 树。</p><h3 id="2、构建-CSSOM-树"><a href="#2、构建-CSSOM-树" class="headerlink" title="2、构建 CSSOM 树"></a>2、构建 CSSOM 树</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>① 将 CSS 文件转化为 CSSOM 树。这个过程和上述过程是类似的，但是有一点不同，浏览器为了确定结点的样式，这个过程是非常耗时的。</p><p>② 浏览器通过递归的方式 DOM 树为结点设置样式。通过过先找到具体的标签，然后递归找到设置的上级标签，最后确定选择器选择的所选标签的样式。</p><p>③ 所以应该避免书写过于具体的 CSS 选择器，少一些添加无意义的 HTML 标签，有利于提高习页面的性能。</p><h3 id="3、DOM-CSSOM-生成渲染树"><a href="#3、DOM-CSSOM-生成渲染树" class="headerlink" title="3、DOM + CSSOM 生成渲染树"></a>3、DOM + CSSOM 生成渲染树</h3><blockquote><p>将生成的 DOM 树和 CSSOM 树进行合并生成渲染树（Render Tree）。</p></blockquote><p>① 两者并不是简单的合并，而是渲染树只会包括需要<strong>显示的结点</strong>，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</p><p>② 浏览器生成渲染树的时候，就会根据渲染树进行布局（回流），调用 GPU 绘制，合成图层，显示在屏幕上。这一部分属于底层操作。</p><h2 id="二、浏览器的渲染流程"><a href="#二、浏览器的渲染流程" class="headerlink" title="二、浏览器的渲染流程"></a>二、浏览器的渲染流程</h2><blockquote><p>由于我们屏幕的刷新率为每秒 60 次，也就是 16.7 ms 一次，所有说在刷新一次之间页面重新绘制两次是没有意义的，只会影响性能。</p></blockquote><h4 id="1、渲染帧的流程"><a href="#1、渲染帧的流程" class="headerlink" title="1、渲染帧的流程"></a>1、渲染帧的流程</h4><blockquote><p>渲染帧指的是一次完整绘制的过程。所以在 16.7 ms 一帧内渲染完成才会保证不会掉帧，否则页面会有卡顿感。（屏幕都渲染完成了，你的动画确还没有变化）</p></blockquote><p>一帧需要完成以下操作：</p><p>①  <strong>脚本执行（JavaScript）：</strong>脚本造成了需要重绘的改动，比如增删 DOM、请求动画等；</p><p>②  <strong>样式计算（CSS Object Model）：</strong>级联地生成每个节点的生效样式；</p><p>③  <strong>布局（Layout）：</strong>计算布局，执行渲染算法；</p><p>④  <strong>重绘（Paint）：</strong>各层分别进行绘制（比如 3D 动画）；</p><p>⑤   <strong>合成（Composite）：</strong>合成各层的渲染结果；</p><h4 id="2、耗时的-JS-会阻塞渲染"><a href="#2、耗时的-JS-会阻塞渲染" class="headerlink" title="2、耗时的 JS 会阻塞渲染"></a>2、耗时的 JS 会阻塞渲染</h4><blockquote><p>可以观察到虽然每秒都会写一次 DOM，但在 5s 结束后才会全部渲染出来，明显耗时脚本阻塞了渲染。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">&lt;div id=<span class="string">"message"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> then = <span class="built_in">Date</span>.now()</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'message'</span>)</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">if</span> (now - then &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i++ &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    el.innerText += <span class="string">'hello!\n'</span></span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    then = now</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、为什么操作-DOM-慢"><a href="#三、为什么操作-DOM-慢" class="headerlink" title="三、为什么操作 DOM 慢"></a>三、为什么操作 DOM 慢</h2><blockquote><p>因为操作 DOM 是属于渲染引擎的东西，而 JS 属于 JS 引擎的东西，所以我们通过 JS 操作 DOM 的时候，这个过程涉及到两个线程的通信，那就回带来一些性能上的损耗。如果操作 DOM 次数过多，就相当于两个线程之间一直通信，并且操作 DOM 会导致重绘回流的情况，性能就会有所下降。</p></blockquote><h4 id="1、插入几万-DOM-怎么实现页面不卡顿？"><a href="#1、插入几万-DOM-怎么实现页面不卡顿？" class="headerlink" title="1、插入几万 DOM 怎么实现页面不卡顿？"></a>1、插入几万 DOM 怎么实现页面不卡顿？</h4><blockquote><p>两种解决方案：</p><p>1）第一种通过 <code>requestAnimationFrame</code> 的方式循环插入 DOM。</p><p>2）第二种方式是通过<strong>虚拟滚动</strong>。</p></blockquote><h4 id="2、两种实现方式"><a href="#2、两种实现方式" class="headerlink" title="2、两种实现方式"></a>2、两种实现方式</h4><blockquote><p>requestAnimationFrame 实现。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> total = <span class="number">30000</span>;              <span class="comment">// 总 DOM 数</span></span><br><span class="line"><span class="keyword">const</span> size = <span class="number">100</span>;                 <span class="comment">// 每次渲染的 DOM 数</span></span><br><span class="line"><span class="keyword">const</span> bathCount = total / size;   <span class="comment">// 一共处理 300 次</span></span><br><span class="line"><span class="keyword">var</span> countDone = <span class="number">0</span>;                <span class="comment">// 已经处理完的多少次</span></span><br><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addItems</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="comment">// 一次渲染 100 个DOM </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">        li.innerText = <span class="string">'item '</span> + (countDone * size + i);</span><br><span class="line">        fragment.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次插入 100 个结点就修改 DOM 一次</span></span><br><span class="line">    ul.appendChild(fragment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经完成插入的次数</span></span><br><span class="line">    countDone++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否处理完成</span></span><br><span class="line">    <span class="keyword">if</span>(countDone &lt; bathCount)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(addItems);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">addItems();</span><br></pre></td></tr></table></figure><blockquote><p>虚拟滚动实现：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、什么情况阻塞渲染"><a href="#四、什么情况阻塞渲染" class="headerlink" title="四、什么情况阻塞渲染"></a>四、什么情况阻塞渲染</h2><h4 id="1、阻塞的原因"><a href="#1、阻塞的原因" class="headerlink" title="1、阻塞的原因"></a>1、阻塞的原因</h4><blockquote><p>1）渲染的前提是生成渲染树才能下一步的渲染，所以生成渲染树的过程也就是加载 HTML 和 CSS 肯定会阻塞渲染。（<strong>js 阻塞渲染也会阻塞解析，而CSS 只会阻塞渲染，不会阻塞解析</strong>）</p><p>2）当浏览器在解析 script 标签的时候会暂停 DOM，完成后会在从暂停的地方重新开始。</p></blockquote><h4 id="2、减少阻塞"><a href="#2、减少阻塞" class="headerlink" title="2、减少阻塞"></a>2、减少阻塞</h4><blockquote><p>1）要想渲染的越快，就必须降低渲染文件的大小，优化选择器。</p><p>2）想要第一次加载页面加载的快，所以将 JS 文件标签放在 body 底部。</p><p>3）当 <code>script</code> 标签加上 <code>defer</code> 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 <code>script</code> 标签放在任意位置。</p><p>4）对于没有任何依赖的 JS 文件可以加上 <code>async</code> 属性，表示 JS 文件下载和解析不会阻塞渲染。</p></blockquote><p><strong>补充：</strong></p><ul><li>async 异步下载脚本，下载完执行执行，在 onload 事件触发之前，不会阻塞页面但是不能保证脚本出现的顺序执行。</li><li>defer 属性也会异步下载，但是会按照页面脚本的执行顺序下载，脚本的执行是按照页面脚本顺序执行的。而且是在 DOM 解析完成和 onload 触发之前执行。</li></ul><h2 id="五、重绘（Repaint）和回流-Reflow"><a href="#五、重绘（Repaint）和回流-Reflow" class="headerlink" title="五、重绘（Repaint）和回流(Reflow)"></a>五、重绘（Repaint）和回流(Reflow)</h2><blockquote><p><strong>回流必将引起重绘，重绘不一定会引起回流。</strong></p></blockquote><h4 id="1、重绘"><a href="#1、重绘" class="headerlink" title="1、重绘"></a>1、重绘</h4><blockquote><p>在文档流中的位置并未发生改变，重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘。</p></blockquote><h4 id="2、回流"><a href="#2、回流" class="headerlink" title="2、回流"></a>2、回流</h4><blockquote><p>在文档流中为止发生改变，回流是布局或者几何属性需要改变就称为回流。</p></blockquote><h4 id="3、重绘-回流与EventLoop"><a href="#3、重绘-回流与EventLoop" class="headerlink" title="3、重绘/回流与EventLoop"></a>3、重绘/回流与EventLoop</h4><p>① 当 EventLoop 执行完微任务后，会判断 <code>document</code> 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次；</p><p>② 然后判断是否有 <code>resize</code> 或者 <code>scroll</code> 事件，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 16ms 才会触发一次，并且自带节流功能；</p><p>③ 判断是否触发了 media query；</p><p>④ 更新动画并且发送事件；</p><p>⑤ 判断是否有全屏操作事件；</p><p>⑥ 执行 <code>requestAnimationFrame</code> 回调；</p><p>⑦ 执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好；</p><p>⑧ 更新界面；</p><p>⑨ 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调。</p><h4 id="4、如何减少重绘和回流"><a href="#4、如何减少重绘和回流" class="headerlink" title="4、如何减少重绘和回流"></a>4、如何减少重绘和回流</h4><p>①  使用 <code>transform</code> 替代 <code>top</code>；</p><p>②  使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）;</p><p>③  不要把节点的属性值放在一个循环里当成循环里的变量;</p><p>④  不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局;</p><p>⑤ 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code>;</p><p>⑥ CSS 选择符<strong>从右往左</strong>匹配查找，避免节点层级过多;</p><p>⑦ 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器的渲染原理！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【CSS3的新特性】</title>
    <link href="http://yoursite.com/2019/06/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90CSS3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/20/前端面试之道【CSS3的新特性】/</id>
    <published>2019-06-19T23:14:33.256Z</published>
    <updated>2019-06-20T23:47:55.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CSS3 的有哪些新特性？</p><a id="more"></a><h3 id="一、CSS3新增选择器"><a href="#一、CSS3新增选择器" class="headerlink" title="一、CSS3新增选择器"></a>一、CSS3新增选择器</h3><ul><li><code>p:first-of-type</code> |  <code>p:last-of-type</code> ` 选择所有父元素该元素出现的第一个(最后一个)元素。</li><li><code>p:nth-child(2)</code>  选择父元素的第二个元素。</li><li><code>p:first-child</code>  | <code>p:last-child</code>  选择父元素的第一个元素或最后一个元素。</li><li><code>p:only-of-type</code> 选择父元素唯一没有兄弟节点的元素。</li><li><code>:enabled</code>  <code>:disabled</code> 选择表单禁用状态的输入框。</li><li><code>:checked</code>  选择单选按钮或复选框被选择状态的。</li></ul><h3 id="二、文本"><a href="#二、文本" class="headerlink" title="二、文本"></a>二、文本</h3><ul><li><code>text-shadow:参数1 参数2 参数3 参数4</code>   向右偏移  向下偏移  渐变像素  渐变颜色；</li><li><code>white-space: nowrap;</code> 禁止文字换行；</li><li><code>text-overflow: ellipsis</code> 文字溢出部分显示省略号（必须隐藏元素overflow:hidden）；<ul><li><code>clip:</code>文字溢出部分剪切掉。</li></ul></li><li><code>word-wrap:</code>  对长的不可分割的单词进行分割并换行到下一行</li></ul><h3 id="三、边框"><a href="#三、边框" class="headerlink" title="三、边框"></a>三、边框</h3><ul><li><p><code>border-radius:</code>圆角边框</p></li><li><p><code>border-shaow:</code>盒阴影</p></li><li><p><code>border-shadow:</code> 右偏移 下偏移  模糊程度 阴影颜色</p></li><li><p><code>border-images-*:</code></p><ul><li><code>source</code> 图片路径 </li><li><code>slice</code> 向内偏移 </li><li><code>width</code> 边框宽度 </li><li><code>outset</code>边框区域超出边框的量 </li><li><code>repeat :</code> <code>repeat/round/stretch</code> 是否平铺/铺满/拉伸</li></ul></li></ul><h3 id="四、背景"><a href="#四、背景" class="headerlink" title="四、背景"></a>四、背景</h3><ul><li><code>background-image:</code>背景图片</li><li><code>background-size：</code>指定背景图片的大小 cover : 缩放不变 /contain：保持最大大小</li><li><code>background-origin：</code>定位背景图片的位置 <code>content-box/border-box/padding-box</code></li><li><code>background-clip：</code>规定背景的绘制区域</li></ul><h3 id="五、渐变"><a href="#五、渐变" class="headerlink" title="五、渐变"></a>五、渐变</h3><blockquote><p>渐变分为线性渐变（Linear-gradient）和径向渐变(Radial-gradient)</p></blockquote><h4 id="1、线性渐变"><a href="#1、线性渐变" class="headerlink" title="1、线性渐变"></a>1、线性渐变</h4><ul><li><code>background:linear-gradient (起始位置，起始颜色，终止颜色);</code><ul><li>top bottom left right 以及对角线组合;</li><li>自定义角度（30deg）— 顺时针;</li><li>颜色可多个组合;</li><li>透明度渐变(rgba CSS3新属性);</li></ul></li><li><code>repeating-linear-gradient()</code> 函数用于重复线性渐变;</li></ul><h4 id="2、径向渐变"><a href="#2、径向渐变" class="headerlink" title="2、径向渐变"></a>2、径向渐变</h4><ul><li><p><code>background: radial-gradient(center, shape size, start-color, ..., last-color);</code></p><ul><li>center 渐变中心</li><li>指定渐变颜色大小 size （不均匀分布）</li><li>第一参数：设置形状（circle、ellipse椭圆）</li><li>也可以设置成尺寸</li></ul></li><li><p><code>repeating-radial-gradient()</code> 函数用于重复线性渐变;</p></li></ul><h3 id="六、过渡"><a href="#六、过渡" class="headerlink" title="六、过渡"></a>六、过渡</h3><h3 id="七、动画、旋转"><a href="#七、动画、旋转" class="headerlink" title="七、动画、旋转"></a>七、动画、旋转</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS3 的有哪些新特性？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【垃圾回收机制】</title>
    <link href="http://yoursite.com/2019/06/19/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/19/前端进阶深入系列之【垃圾回收机制】/</id>
    <published>2019-06-19T10:57:46.695Z</published>
    <updated>2019-06-19T13:14:19.654Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JS 引擎以及 V8 引擎的垃圾回收机制是怎么样的？</p><a id="more"></a>s<br><br><br><br>### 内存泄漏<br><br>#### 1、什么是内存泄漏？<br><br>&gt; 不再用到的内存，没有及时释放，就叫做内存泄漏。<br><br><strong>内存泄漏是指我们已经无法再通过js代码来引用到某个对象，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它</strong>。导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。<br><br><br><br>#### 2、怎么解决内存泄漏？<br><br>&gt; 很多编程语言需要手动释放内存，但是很多开发者喜欢系统提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”。<br><br><br><br>### 一、为什么有垃圾回收机制？<br><br>&gt; js 中的字符串、对象、数组等只有确定固定大小时，才会动态分配内存，只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃<br><br><br><br>### 二、js 的垃圾回收机制<br><br>&gt; JavaScript 与其他语言不同，它具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。<br><br><br><br>### 三、垃圾回收机制原理<br><br>&gt; 找出那些不再继续使用的变量，然后释放其内存。垃圾回收器会按照固定的时间间隔，周期性的执行该垃圾回收操作。<br><br><br><br>### 四、两种垃圾回收策略<br><br>&gt; js 中最常用的就是标记清除法。垃圾收集器必须跟踪哪个变量有用哪个没用，对于没有用的变量打上标记，以备将来收集其内存。<br><br>- <strong>标记清除法</strong><br>- <strong>引用计数法</strong><br><br><br><br>#### 1、标记清除法<br><br>&gt; 垃圾回收器会在运行的时候，会给存储在内存中的所有变量都加上标记，然后它会去掉环境中变量以及被环境中的变量引用的变量的标记。剩下的就视为即将要删除的变量，原因是在环境中无法访问到这些变量了。最后垃圾回收器完成内存清除操作。<br><br><br><br>###### ▉ 实现原理<br><br>&gt; 通过判断一个变量是否在执行环境中被引用，来进行标记删除。<br><br><br><br>###### ▉ 标记清除的缺陷<br><br>&gt; 其实标记清除和引用计数的缺陷相同的，因为都是判断变量在执行环境中的引用来确定该变量是否应该被回收，当保持着引用时，改变变量会一直在内存中存储。<br><br><br><br>#### 2、引用计数法<br><br>&gt; 引用计数的垃圾收集策略不常用，引用计数的最基本含义就是跟踪记录每个值被引用的次数。<br><br><br><br>###### ▉ 实现原理<br><br>&gt; 当声明变量并将一个引用类型的值赋值给该变量时，则这个值的引用次数加 1，同一值被赋予另一个变量，该值的引用计数加 1 。当引用该值的变量被另一个值所取代，则引用计数减 1，当计数为 0 的时候，说明无法在访问这个值了，所有系统将会收回该值所占用的内存空间。<br><br><br><br>###### ▉ 引用计数的缺陷<br><br>&gt; 两个对象的相互循环引用，在函数执行完成的时候，两个对象相互的引用计数并未归 0 ，而是依然占据内存，无法回收，当该函数执行多次时，内存占用就会变多，导致大量的内存得不到回收。<br><br><strong>举例：</strong>最常见的就是在 IE BOM 和 DOM 中，使用的对象并不是 js 对象，所以垃圾回收是基于计数策略的。但是在 IE9 已经将 BOM 和 DOM 真正的转化为了 js 对象，所以循环引用的问题得到解决。<br><br><br><br>#### 3、管理内存<br><br>&gt; 虽然说是 js 的内存都是自动管理的，但是对于 js 还是存在一些问题的，最主要的一个问题就是<strong>分配给 Web 浏览器的可用内存数量通常比分配给桌面应用程序的少</strong>。<br><br><br><br>###### ▉ 主要原因<br><br>&gt; 也是为了安全方面考虑，防止运行 js 网页将系统内存耗尽，导致整个系统崩溃。内存限制问题不仅影响到了给变量分配内存，还会影响调用栈以及线程同时执行的语句数量。<br><br><br><br>###### ▉ 解决方案<br><br>&gt; 为了能够让页面获得最好的性能，必须确保 js 变量占用最少的内存，最好的方式就是将不用的变量引用释放掉，也叫做<strong>解除引用</strong>。<br><br>- 对于局部变量来说，函数执行完成离开环境变量，变量将自动解除。<br>- 对于全局变量我们需要进行手动解除。（注意：解除引用并不意味被收回，而是将变量真正的脱离执行环境，下一次垃圾回收将其收回）<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;  <span class="comment">// 在堆内存中给数值变量分配空间</span></span><br><span class="line">alert(a + <span class="number">100</span>);  <span class="comment">// 使用内存</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>; <span class="comment">// 使用完毕之后，释放内存空间</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>补充：</strong>因为通过上边的垃圾回收机制的标记清除法的原理得知，只有与环境变量失去引用的变量才会被标记回收，所用上述例子通过将对象的引用设置为 null ，此变量也就失去了引用，等待被垃圾回收器回收。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 引擎以及 V8 引擎的垃圾回收机制是怎么样的？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【网络攻击】</title>
    <link href="http://yoursite.com/2019/06/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E4%B9%8B%E3%80%90H5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/19/前端面试之道之【H5的新特性】/</id>
    <published>2019-06-18T23:07:11.542Z</published>
    <updated>2019-06-19T01:26:45.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>H5 的新特性有哪些呢？</p><a id="more"></a><h2 id="H5-的新特性有哪些？"><a href="#H5-的新特性有哪些？" class="headerlink" title="H5 的新特性有哪些？"></a>H5 的新特性有哪些？</h2><ul><li><p>语义化标签</p></li><li><p>多媒体</p></li><li><p>用于绘画的 canvas</p></li><li><p>离线 &amp; 存储。对本地离线存储的更好的支持,local Store,Cookies。</p></li></ul><h3 id="一、新增标签"><a href="#一、新增标签" class="headerlink" title="一、新增标签"></a>一、新增标签</h3><h4 id="1、结构标签（10个）"><a href="#1、结构标签（10个）" class="headerlink" title="1、结构标签（10个）"></a>1、结构标签（10个）</h4><ul><li>\<article> ：标记一篇文章。 </article></li><li>\<header> ：标记一个页面的头部或一个区域的头部。</header></li><li>\<nav>：标记定义导航链接。</nav></li><li>\<section>：标记定义一个区域。</section></li><li>\<aside>：标记定义页面内容部分的侧边栏。</aside></li><li>\<hgroup>：标记定义文件中的一个区块的相关信息。</hgroup></li><li>\<figure>：标记定义一组媒体内容以及它们的标题。</figure></li><li>\<figcaption>：标记定义 figure元素的标题。</figcaption></li><li>\<footer>：标记定义一个页面或一个区域的底部。</footer></li><li>\<dialog>：标记定义一个对话框类似微信。</dialog></li></ul><h4 id="2、多媒体标签（5个）"><a href="#2、多媒体标签（5个）" class="headerlink" title="2、多媒体标签（5个）"></a>2、多媒体标签（5个）</h4><ul><li>video：定义一个视频。</li><li>audio：定义音频内容。</li><li>source：定义媒体资源。</li><li>canvas：画布。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//对于不是 mp4 格式的视频，使用 source 来解决</span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>  <span class="attr">src</span>=<span class="string">" "</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> <span class="attr">width</span>=<span class="string">""</span> <span class="attr">height</span>=<span class="string">""</span> <span class="attr">controls</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">//需要进行转码</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">" "</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span> &gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//对于不是 mp3 格式的音频，使用 source 来解决</span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">autoplay</span>=<span class="string">" "</span>&gt;</span></span><br><span class="line">//需要进行转码</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">" "</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、应用标签（5个）"><a href="#3、应用标签（5个）" class="headerlink" title="3、应用标签（5个）"></a>3、应用标签（5个）</h4><h6 id="▉-状态标签"><a href="#▉-状态标签" class="headerlink" title="▉ 状态标签"></a>▉ 状态标签</h6><ul><li><p><code>&lt;meter&gt;</code>：状态标签（实时状态显示：气压、气温）</p></li><li><p><code>&lt;progress&gt;</code>：状态标签（任务过程：安装、加载)</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"380"</span> <span class="attr">min</span>=<span class="string">"20"</span> <span class="attr">max</span>=<span class="string">"380"</span> <span class="attr">low</span>=<span class="string">"200"</span> <span class="attr">high</span>=<span class="string">"240"</span> <span class="attr">optimum</span>=<span class="string">"220"</span>&gt;</span><span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"0.75"</span>&gt;</span>75%<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;progress value=&quot;30&quot; max=&quot;100&quot;&gt; &lt;/progress&gt;</span><br><span class="line">&lt;progress max=&quot;100&quot;&gt;</span><br></pre></td></tr></table></figure><h6 id="▉-列表标签"><a href="#▉-列表标签" class="headerlink" title="▉ 列表标签"></a>▉ 列表标签</h6><ul><li><p><code>&lt;datalist&gt;</code>：为 input 添加下拉列表。</p></li><li><p><code>&lt;details&gt;</code>：隐藏、显示详细内容。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 兼容性：Firefox、Opera</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"请选择您喜欢的手机品牌"</span> <span class="attr">list</span>=<span class="string">"phoneList"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"phoneList"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"iphone"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"sumsung"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"HUawei"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"HTC"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Meizu"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器兼容 ：Chrome。</span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;问候&lt;/summary&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><h3 id="二、新增属性"><a href="#二、新增属性" class="headerlink" title="二、新增属性"></a>二、新增属性</h3><ul><li><strong>Input 标签</strong></li><li><strong>表单属性</strong></li><li><strong>链接属性</strong></li><li><strong>其它属性</strong></li></ul><h4 id="1、Input-标签"><a href="#1、Input-标签" class="headerlink" title="1、Input 标签"></a>1、Input 标签</h4><blockquote><p>1）针对于 iphone 手机端：<code>email /url /tel /number/Date Pickers</code></p><p>2）针对于客户端：<code>Range / Search /Color</code></p></blockquote><ul><li><strong>email类型：</strong>针对于手机端，出现特殊的键盘，电子邮件 Input 类型。</li><li><strong>url 类型：</strong>只应用于苹果手机端，特殊键盘。</li><li><strong>tel 类型：</strong>出现特殊的电话号码键盘。</li><li><strong>number 类型：</strong>出现数字运算键盘。</li><li><strong>Data Pickers 类型：</strong>日期类型，手机端只应用于 iphone**<ul><li><strong>Date</strong> —— 选取日、月、年。</li><li><strong>Month</strong> —— 选取月年。</li><li><strong>Week </strong> —— 选取周和年。</li><li><strong>Time</strong> —— 选取时间（小时和分钟）。</li><li><strong>Datetime</strong> —— 选取时间、日、月、年（UTC 时间）。</li><li><strong>Datetime-local</strong> —— 选取时间、日、月、年（本地时间）。</li></ul></li></ul><blockquote><p><strong>Datetime 和 Datetime-local  的区别？</strong></p><p><strong>1)兼容性。</strong><code>Datetime</code>类型只有 <code>Safire</code> 和<code>Opera</code>浏览器兼容；而  <code>Datetime-local</code>兼容 <code>Chrome</code> 、 <code>Safire</code>和 <code>Opera</code>。</p><p><strong>2) 返回类型不同。</strong>local  返回本地时间，而 Date 返回时区。</p></blockquote><h4 id="2、表单属性"><a href="#2、表单属性" class="headerlink" title="2、表单属性"></a>2、表单属性</h4><ul><li><strong>autocomplete 属性：</strong>当重新加载页面时，输入框重置，是否提示。autocomplete=”on/off”</li><li><strong>aotufocus 属性</strong>：页面加载时，自动获取属性。</li><li><strong>multiple 属性：</strong>规定输入域可选择多个值。一般应用于<strong>上传文件</strong>（file）和<strong>邮件 （email ）</strong>输入框。</li><li><strong>placeholder 属性：</strong>提供一种提示（hint）。</li><li><strong>require 属性：</strong>主要用来进行输入域验证（不能为空），必填字段</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">""</span> autocomplete=<span class="string">"on"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"text"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"email"</span> name=<span class="string">"email"</span> autocomplete=<span class="string">"off"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;text&quot; autofocus=&quot;autofocus&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;text&quot; placeholder=&quot;请输入您的用户名&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//填写完整才能进行提交</span><br><span class="line">&lt;input type=&quot;email&quot; name=&quot;email&quot; required=&quot;required&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="3、链接属性"><a href="#3、链接属性" class="headerlink" title="3、链接属性"></a>3、链接属性</h4><ul><li><strong>sizes 属性：</strong>根据屏幕不同的分辨率来调整不同的sizes。</li><li><strong>target 属性：</strong>base标签写在 \<hread> 之间。</hread></li><li><strong>超链接</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;icon.gif&quot; type=&quot;image/gif&quot; size=&quot;16X16&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//控制所有的页面的超链接默认选择新窗口。</span><br><span class="line">&lt;base href=&quot;http://localhost/&quot; target=&quot;_blank&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a：media=&quot;&quot;//表示对设备进行优化，handhelp对手持设备进行支持，tv 对“电视”设备进行支持。</span><br><span class="line">a:hreflang=&quot;zh&quot;//设置语言，这里设置的中文</span><br><span class="line">a:rel=&quot;external&quot; //这里的超链接为外部链接</span><br></pre></td></tr></table></figure><h4 id="4、其它属性"><a href="#4、其它属性" class="headerlink" title="4、其它属性"></a>4、其它属性</h4><ul><li><p><strong>script 标签：</strong></p><ul><li><p>defer 属性：（只兼容 IE 浏览器）加载完浏览器之后，再加载 js 外部文件夹。</p></li><li><p>async 属性：（兼容一切浏览器）加载页面的同时也加载外部文件。</p></li></ul></li><li><p><strong>ol 标签：</strong></p><ul><li><p>Start —— 起始值：有序列表的起始值。</p></li><li><p>Reversed —— 有序列表倒序输出。</p></li></ul></li><li><p><strong>html 标签：</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html mainifest=&quot;index.mainifest&quot;&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="H5-提供的新的API"><a href="#H5-提供的新的API" class="headerlink" title="H5 提供的新的API"></a>H5 提供的新的API</h2><ul><li><strong>canvas。</strong>可以画出很多绚丽的图形，甚至可以直接做出伪3D游戏。</li><li><p><strong>媒体控制。</strong>直译就是回放功能，假如只用 html5.0 以下的标签写，以前的音乐播放是不可能实现滚动条的。</p></li><li><p><strong>离线网页程序。</strong>在无网络的情况下也可以查看网页，可以把资源文件完全缓存在客户端，并且通过js的一些方法清空缓存 manifest 属性。</p></li><li><strong>拖动。</strong>可以将文件拖动到某些区域上传。</li><li><strong>跨文档请求</strong>。websocket，一种更加高效的通讯方式。</li><li><strong>客户端数据存储。</strong>localstoage、sessionstoage。</li></ul><h2 id="H5-最常用考面试题"><a href="#H5-最常用考面试题" class="headerlink" title="H5 最常用考面试题"></a>H5 最常用考面试题</h2><h5 id="1、新的-HTML5-文档类型和字符集是？"><a href="#1、新的-HTML5-文档类型和字符集是？" class="headerlink" title="1、新的 HTML5 文档类型和字符集是？"></a>1、新的 HTML5 文档类型和字符集是？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=”UTF-8″&gt;</span><br></pre></td></tr></table></figure><h4 id="2、HTML5-中如何嵌入音频？"><a href="#2、HTML5-中如何嵌入音频？" class="headerlink" title="2、HTML5 中如何嵌入音频？"></a>2、HTML5 中如何嵌入音频？</h4><blockquote><p>HTML5 支持 MP3、Wav 和 Ogg 格式的音频。</p></blockquote><h4 id="3、HTML5-中如何嵌入视频？"><a href="#3、HTML5-中如何嵌入视频？" class="headerlink" title="3、HTML5 中如何嵌入视频？"></a>3、HTML5 中如何嵌入视频？</h4><blockquote><p>HTML5支持 MP4、WebM 和 Ogg 格式的视频</p></blockquote><h4 id="4、除了-audio-和-video，HTML5-还有哪些媒体标签？"><a href="#4、除了-audio-和-video，HTML5-还有哪些媒体标签？" class="headerlink" title="4、除了 audio 和 video，HTML5 还有哪些媒体标签？"></a>4、除了 audio 和 video，HTML5 还有哪些媒体标签？</h4><ul><li>\<embed> ：标签定义嵌入的内容，比如插件。</li><li>\<source>：对于定义多个数据源很有用。</li><li>\<track>：具体用于播放带有字幕的视频。</li></ul><h4 id="5、HTML5-Canvas-元素有什么用？"><a href="#5、HTML5-Canvas-元素有什么用？" class="headerlink" title="5、HTML5 Canvas 元素有什么用？"></a>5、HTML5 Canvas 元素有什么用？</h4><blockquote><p>Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在  HTML 上进行图形操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=”canvas1″ width=”300″ height=”100″&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><h4 id="6、HTML5-存储类型有什么区别？"><a href="#6、HTML5-存储类型有什么区别？" class="headerlink" title="6、HTML5 存储类型有什么区别？"></a>6、HTML5 存储类型有什么区别？</h4><blockquote><p>HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。</p></blockquote><ul><li><strong>localStorage</strong> ： 用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。</li><li><strong>sessionStorage</strong>： 同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 <code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。</li></ul><h4 id="7、HTML5-废弃了哪些-HTML4-标签？"><a href="#7、HTML5-废弃了哪些-HTML4-标签？" class="headerlink" title="7、HTML5 废弃了哪些 HTML4 标签？"></a>7、HTML5 废弃了哪些 HTML4 标签？</h4><ul><li>frame</li><li>frameset</li><li>noframe</li><li>applet</li><li>big</li><li>center</li><li>basefront</li></ul><h4 id="8、HTML5-应用程序缓存和浏览器缓存有什么区别？"><a href="#8、HTML5-应用程序缓存和浏览器缓存有什么区别？" class="headerlink" title="8、HTML5 应用程序缓存和浏览器缓存有什么区别？"></a>8、HTML5 应用程序缓存和浏览器缓存有什么区别？</h4><blockquote><p>应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML、CSS、图片以及 JavaScript。这个特性可以提高网站性能，它的实现借助于 manifest 文件。与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;H5 的新特性有哪些呢？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【事件循环】</title>
    <link href="http://yoursite.com/2019/06/14/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/14/前端进阶深入系列之【事件循环】/</id>
    <published>2019-06-14T11:32:21.425Z</published>
    <updated>2019-07-04T08:05:04.671Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深入 JS 内部的事件循环机制！</p><a id="more"></a><h2 id="什么是进程和线程？"><a href="#什么是进程和线程？" class="headerlink" title="什么是进程和线程？"></a>什么是进程和线程？</h2><p><strong>※ 答✔：进程和线程的区别是什么？</strong></p><blockquote><p><strong>1）进程：</strong>进程是 CPU <strong>资源分配</strong>的最小单位，系统会为每个进程进行分配内存空间。比如一个 Tab 页面就是一个进程。</p><p><strong>2）线程：</strong>线程是 CPU <strong>调度</strong>的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程由多个线程组成，比如：渲染线程、Js 引擎线程、HTTP 请求线程等）。</p></blockquote><h2 id="为什么-JS-会选择单线程？"><a href="#为什么-JS-会选择单线程？" class="headerlink" title="为什么 JS 会选择单线程？"></a>为什么 JS 会选择单线程？</h2><p><strong>※ 答✔：js为什么会用单线程？</strong></p><blockquote><p>1）js 单线程的特点就是同一时刻只能执行一个任务，js 的任务基本都是与用户互动，以及操作 DOM，所以使用单线程，否则会带来复杂的同步问题。</p><p>2）如果为多线程，多个线程同时操作 DOM 就会造成浏览器不知道以哪个为标准的问题。</p><p>3）如果执行同步问题的话，多线程需要加锁，执行任务造成非常的繁琐。</p><p>4）H5 新的规定。允许 JavaScript 脚本创建多个线程，但是子线程完全<strong>受主线程控制</strong>，且<strong>不得操作DOM</strong>。</p></blockquote><h2 id="为什么会有事件循环"><a href="#为什么会有事件循环" class="headerlink" title="为什么会有事件循环?"></a>为什么会有事件循环?</h2><p><strong>※ 答✔：为什么会有事件循环？</strong></p><blockquote><p>由于 JS 的代码是单线程执行的，所以为了保证 <strong>js 同步代码</strong>的执行顺序以及<strong>异步代码的执行顺序</strong>，内部引入了事件循环机制。</p></blockquote><h2 id="什么是微观任务和宏观任务？"><a href="#什么是微观任务和宏观任务？" class="headerlink" title="什么是微观任务和宏观任务？"></a>什么是微观任务和宏观任务？</h2><blockquote><p><strong>宏观任务：</strong>从浏览器的角度看，宏观任务就是代表一个离散的、独立工作单元。如：各种事件、执行主线程、setTimeout、解析 HTML 等。</p><p><strong>微观任务：</strong>所谓的微观任务就是更小的任务，主要是为了更新应用程序的状态，必须保证它在页面重新渲染 UI 之前执行。如:promise。</p></blockquote><h2 id="事件循环的运行机制（具体实现）？"><a href="#事件循环的运行机制（具体实现）？" class="headerlink" title="事件循环的运行机制（具体实现）？"></a>事件循环的运行机制（具体实现）？</h2><p><strong>※ 答✔：事件循环的运行机制（具体实现）？</strong></p><blockquote><p>1）所有同步任务都在主线程上执行，形成一个执行栈。</p><p>2）主线程之外，还存在一个”任务队列”。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p><p>3）不同的任务源分配到不同的 Task 队列中，任务源分为微任务和宏任务。</p><p>4）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p><p>5）只要主线程空了，就会去读取”任务队列”。</p></blockquote><h4 id="4、事件循环原理"><a href="#4、事件循环原理" class="headerlink" title="4、事件循环原理"></a>4、事件循环原理</h4><p><strong>※ 答✔：事件循环的原理？</strong></p><blockquote><p>1）当主线程没有执行任务时，事件迭代循环去任务队列查看是否有已完成的异步任务。</p><p>2）事件每循环一次就是一次迭代循环，每一次迭代循环最多在宏观任务队列中取出一个宏观任务加入到执行栈中执行，完成后就会执行微观队列中的任务，直到微观队列中的微观任务全部执行完成才会新渲染一次UI，然后进入下一次的迭代循环中。</p><p>3）每个微任务都会在下一次渲染 UI 之前执行完成，为了保证渲染前更新应用程序状态</p><p>4）浏览器每秒渲染 60 次页面，达到每秒 60 帧的速度，也就是说每 16 ms 完成一次刷新，所以执行单个宏任务和附带的微任务不能超过这个时间，否则会影响平滑流畅度，甚至页面会产生无响应。</p></blockquote><h3 id="三、Node-中的事件循环"><a href="#三、Node-中的事件循环" class="headerlink" title="三、Node 中的事件循环"></a>三、Node 中的事件循环</h3><blockquote><p>Node.js 是基于事件驱动型、非阻塞的 IO 模型。</p><p>1）所谓的事件驱动模型，当服务器接受到请求时，将其关闭进行处理，然后去接受下一个请求。当这个请求执行完成，就会被放到消息队列，当达到队列头部的时候，就会将结果返回给用户。</p><p>3）所谓的非阻塞 IO 操作，因为 webserver 一直接受请求而不等待任何读写操作。</p></blockquote><h3 id="四、两种计时器"><a href="#四、两种计时器" class="headerlink" title="四、两种计时器"></a>四、两种计时器</h3><blockquote><p>延迟计时器可以可以延迟一段代码的执行，可以将长时间运行的任务分解为不阻塞事件循环的小任务，以阻止浏览器渲染，浏览器的过程会使得程序运行缓慢、没有反应。</p></blockquote><ul><li>延迟计时器（setTimeout)</li><li>间隔计时器（setInterval)</li></ul><h4 id="1、延迟计时器（setTimeout）"><a href="#1、延迟计时器（setTimeout）" class="headerlink" title="1、延迟计时器（setTimeout）"></a>1、延迟计时器（setTimeout）</h4><blockquote><p>延迟计时器会在设定的时间内延迟执行回调函数。</p></blockquote><p><strong>注意：</strong></p><p>① 由于 javascript 是单线程执行的，<strong>只能控制计时器何时被加入队列，而无法控制计时器何时执行</strong>。</p><p>② 使用 0 ms 作为超时时间并不代表将在 0 ms 执行回调，这意味着使用 0 ms 尽快执行回调，在回调之前可以进行 UI 渲染的。</p><h4 id="2、间隔计时器（setInterval）"><a href="#2、间隔计时器（setInterval）" class="headerlink" title="2、间隔计时器（setInterval）"></a>2、间隔计时器（setInterval）</h4><blockquote><p>每一间隔就会执行一次回调。</p></blockquote><h4 id="3、H5-新增定时器"><a href="#3、H5-新增定时器" class="headerlink" title="3、H5 新增定时器"></a>3、H5 新增定时器</h4><blockquote><p>传统的动画是由 setTimeout 或者 setInterval 完成的，但是存在两个问题：</p></blockquote><ul><li>动画的循环时间间隔不好确定，设置过长动画不够平滑，过短不够浏览器重绘达到瓶颈。</li><li>定时器设置的时间只是加入队列的时间，而不是立即执行的时间。</li></ul><p>所以 H5 新增加了 <code>requestAnimationFrame</code>。</p><h6 id="▉-优点"><a href="#▉-优点" class="headerlink" title="▉ 优点"></a>▉ 优点</h6><p>1、 requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。</p><p>2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量。</p><p>3、requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。</p><h2 id="常用定时器面试题"><a href="#常用定时器面试题" class="headerlink" title="常用定时器面试题"></a>常用定时器面试题</h2><blockquote><p>面试题：setTimeout、setInterval、requestAnimationFrame 各有什么特点？</p></blockquote><h5 id="※-答✔：setTimeout-的特点？"><a href="#※-答✔：setTimeout-的特点？" class="headerlink" title="※ 答✔：setTimeout 的特点？"></a>※ 答✔：setTimeout 的特点？</h5><blockquote><p>setTimeout 并不是设置了多久执行就是多久执行，因为 js 是单线程的，如果前边的任务执行的时间长，就会导致<code>setTimeout</code> 不会按期执行。</p></blockquote><h5 id="※-答✔：setInterval的特点？"><a href="#※-答✔：setInterval的特点？" class="headerlink" title="※ 答✔：setInterval的特点？"></a>※ 答✔：setInterval的特点？</h5><blockquote><p>setInterval 该函数是每隔一段时间执行一次回调函数。通常来说不建议使用 <code>setInterval</code>，因为</p></blockquote><ul><li><p>第一，不能保证在预期的时间执行任务。</p></li><li><p>第二，它存在执行累积的问题：如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。</p></li></ul><blockquote><p><strong>补充：</strong>如果有循环定时器的需求，其实完全可以通过 <code>requestAnimationFrame</code> 来实现。</p></blockquote><h5 id="※-答✔：requestAnimationFrame-的特点？"><a href="#※-答✔：requestAnimationFrame-的特点？" class="headerlink" title="※ 答✔：requestAnimationFrame  的特点？"></a>※ 答✔：requestAnimationFrame  的特点？</h5><p><a href="https://javascript.ruanyifeng.com/htmlapi/requestanimationframe.html" target="_blank" rel="noopener">点击查看详细教程</a></p><blockquote><p>1、ruestAnimationFrame 是浏览器用于定时循环操作的一个接口，主要用途是按帧对网页进行重绘。设置这个API的目的是为了让各种网页动画效果能够有一个统一IDE刷新机制，节省资源，提高系统的性能。</p><p>2、<code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题。</p></blockquote><h3 id="五、处理复杂任务"><a href="#五、处理复杂任务" class="headerlink" title="五、处理复杂任务"></a>五、处理复杂任务</h3><blockquote><p>在开发中，js 单线程的特性是最大的问题，因为当 js 忙于执行时，浏览器和用户的交互会变的很迟钝，甚至无响应，这是由于 js 执行任务时，重新更新 UI 渲染就会暂停，导致浏览器出现卡顿现象。可以通过 setTimeout 将大任务分割成小块任务循环渲染 UI 转化为非阻塞的操作。</p></blockquote><h6 id="▉-setTimeout-解决"><a href="#▉-setTimeout-解决" class="headerlink" title="▉ setTimeout 解决"></a>▉ setTimeout 解决</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rowCount = <span class="number">2000</span>; <span class="comment">// 行</span></span><br><span class="line"><span class="keyword">const</span> divdeInto = <span class="number">4</span>;   <span class="comment">// 分 4 个阶段渲染</span></span><br><span class="line"><span class="keyword">const</span> chunkSize = rowCount / divdeInto; <span class="comment">// 每个阶段渲染 500 行</span></span><br><span class="line"><span class="keyword">let</span> iteration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> table = <span class="built_in">document</span>.querySelectorAll(<span class="string">'tbody'</span>)[<span class="number">0</span>];</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">generateRows</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 计算上次渲染的位置</span></span><br><span class="line">    <span class="keyword">const</span> base = chunkSize * iteration;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; chunkSize; i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> tr = <span class="built_in">document</span>.createElement(<span class="string">"tr"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> t = <span class="number">0</span>; t &lt; <span class="number">6</span>;t++)&#123;</span><br><span class="line">            <span class="keyword">const</span> td = <span class="built_in">document</span>.createElement(<span class="string">"td"</span>);</span><br><span class="line">            td.appendChild(<span class="built_in">document</span>.createTextNode((i + base) + <span class="string">","</span> + t + <span class="string">","</span> + iteration));</span><br><span class="line">            tr.appendChild(td);</span><br><span class="line">        &#125;</span><br><span class="line">        table.appendChild(tr)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    iteration ++;</span><br><span class="line">    <span class="keyword">if</span>(iteration &lt; divdeInto)&#123;</span><br><span class="line">        setTimeout(generateRows,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h6 id="▉-虚拟滚动解决"><a href="#▉-虚拟滚动解决" class="headerlink" title="▉ 虚拟滚动解决"></a>▉ 虚拟滚动解决</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入 JS 内部的事件循环机制！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【变量类型】</title>
    <link href="http://yoursite.com/2019/06/10/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/10/前端进阶深入系列之【变量类型】/</id>
    <published>2019-06-10T12:23:14.364Z</published>
    <updated>2019-06-10T13:42:03.585Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深入探究 javascript 变量类型！</p><a id="more"></a><h3 id="一、变量的分类"><a href="#一、变量的分类" class="headerlink" title="一、变量的分类"></a>一、变量的分类</h3><blockquote><p>在 javascript 中，我们通常使用三个关键字来定义变量：var、let、const。我们从两个角度对这三个变量进行分类：可变性和词法环境。</p></blockquote><h4 id="1、分类一：可变性"><a href="#1、分类一：可变性" class="headerlink" title="1、分类一：可变性"></a>1、分类一：可变性</h4><blockquote><p>可变性表示的是变量一旦声明，后续是否是可变的，分为两组，分别为 {const} 和 {let、var}。</p></blockquote><h6 id="▉-const-特性一："><a href="#▉-const-特性一：" class="headerlink" title="▉ const 特性一："></a>▉ const 特性一：</h6><blockquote><p>const 声明的是静态变量，一旦声明并赋予初始值，就不允许重新赋值，否则 javascript 就会抛出异常。</p></blockquote><h6 id="▉-const-特性二："><a href="#▉-const-特性二：" class="headerlink" title="▉ const 特性二："></a>▉ const 特性二：</h6><blockquote><p>虽然不可以对变量进行赋值，但是可以对 const 声明的对象进行重新修改。</p></blockquote><h6 id="▉-const-特性三："><a href="#▉-const-特性三：" class="headerlink" title="▉ const 特性三："></a>▉ const 特性三：</h6><blockquote><p>用 const 声明的数组也是一样的，不能重新赋值但是可以进行修改。</p></blockquote><h4 id="2、分类二：词法环境（作用域）"><a href="#2、分类二：词法环境（作用域）" class="headerlink" title="2、分类二：词法环境（作用域）"></a>2、分类二：词法环境（作用域）</h4><blockquote><p>按照词法环境进行分类，其实就是按照作用域进行分类，分为两组分别为 {var} 和 {let，const}。</p></blockquote><h6 id="▉-关键词-var"><a href="#▉-关键词-var" class="headerlink" title="▉ 关键词 var"></a>▉ 关键词 var</h6><blockquote><p>该关键词是在距离最近的<strong>函数内部</strong>或<strong>全局的作用域</strong>（变量将挂载到 <code>window</code> 对象上）中定义的（忽略块级作用域）。—— 在块级作用域外可以访问到块级作用域内的变量。</p></blockquote><h6 id="▉-关键词-let-和-const"><a href="#▉-关键词-let-和-const" class="headerlink" title="▉ 关键词 let 和 const"></a>▉ 关键词 let 和 const</h6><blockquote><p>let 和 const 直接在最近的作用域中定义变量（包括块级作用域、函数内、全局作用域）。</p></blockquote><h3 id="二、词法环境中注册标识符"><a href="#二、词法环境中注册标识符" class="headerlink" title="二、词法环境中注册标识符"></a>二、词法环境中注册标识符</h3><blockquote><p>这部分内容是变量提升的真正原理。变量的声明提升至函数的顶部，函数的声明提升至全局代码的顶部。真正的原理是，代码在执行前，先在词法环境中进行了注册。</p></blockquote><h4 id="1、标识符的注册过程"><a href="#1、标识符的注册过程" class="headerlink" title="1、标识符的注册过程"></a>1、标识符的注册过程</h4><blockquote><p>javascript 代码执行是分成两个阶段的，<strong>一但创建新的词法环境，就会执行第一阶段。</strong></p></blockquote><ul><li><p><strong>第一阶段：</strong>javascript 引擎会访问并注册当前词法环境（作用域）中的所有变量和函数。</p></li><li><p><strong>第二阶段：</strong>本阶段的执行主要取决于<strong>变量的类型</strong>（let、var、const）和<strong>环境类型</strong>（全局环境、局部环境、块级作用域）。</p><blockquote><p>1）如果创建的是一个函数环境，那么就创建形参及函数参数的默认值（非函数环境则跳过）。</p><p>2）扫描当前代码进行函数声明（只扫描当前的函数环境内）。如果创建的是全局或函数环境，</p><p>（<strong>注意：</strong>此过程不会扫描<strong>函数表达式</strong>和<strong>箭头函数</strong>）。对于找到的函数声明，将创建该函数，并将标识符绑定到当前环境中相同的标识符上。若已经存在，则将覆盖。</p><p>3）扫描当前代码进行进行变量声明。在函数或全局作用域中，找到当前函数以及其他函数之外 var 声明的变量。并找到其他函数或代码块之外 let 或 const 声明的变量。</p><p>4）在块级作用域中，仅查找当前块中通过 let 或 const 声明的变量。</p><p>5）对于所查找到的变量，若标识符不存在，则标识为 undefined ，否则存储当前的值。</p></blockquote></li></ul><h6 id="▉-函数声明之前调用函数"><a href="#▉-函数声明之前调用函数" class="headerlink" title="▉ 函数声明之前调用函数"></a>▉ 函数声明之前调用函数</h6><blockquote><p>若函数是作为函数声明定义的，则可以在声明之前调用函数。如果以函数表达式或箭头函数定义的，则不可以在声明之前访问函数。</p></blockquote><h6 id="▉-函数的重载"><a href="#▉-函数的重载" class="headerlink" title="▉ 函数的重载"></a>▉ 函数的重载</h6><blockquote><p>函数的重载之所以出现下面这种原因，是直接由标识符的注册导致的，也就是人们所说的变量提升。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun) <span class="comment">// “function”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun) <span class="comment">// “number”</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1、在处理过程中，通过函数声明定义的函数在代码执行之前定义过了，所以 fun 已经有值的。</p><p>2、在处理变量的声明时，当前环境中未声明的变量将会注册为 undefined，因为 fun 早已经注册过了，所以当执行代码执行到 fun 等于 1 时，就会改变。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入探究 javascript 变量类型！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>玩转 ES6 之【Generator生成器】</title>
    <link href="http://yoursite.com/2019/06/09/%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90Generator%E7%94%9F%E6%88%90%E5%99%A8%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/09/玩转 ES6 之【Generator生成器】/</id>
    <published>2019-06-09T11:46:25.468Z</published>
    <updated>2019-07-08T07:26:28.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用 ES6 的生成器可以优雅的实现异步操作！</p><a id="more"></a><h3 id="一、生成器函数"><a href="#一、生成器函数" class="headerlink" title="一、生成器函数"></a>一、生成器函数</h3><blockquote><p>1、使用生成器函数可以生成一组值的序列，每个值的生成是基于每次请求的，并不同于标准函数立即生成。</p><p>2、调用生成器不会直接执行，而是通过叫做<strong>迭代器</strong>的对象控制生成器执行。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"3"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> WeaponGenerator())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><h3 id="二、使用迭代器控制生成器"><a href="#二、使用迭代器控制生成器" class="headerlink" title="二、使用迭代器控制生成器"></a>二、使用迭代器控制生成器</h3><h4 id="2-1-迭代器的使用"><a href="#2-1-迭代器的使用" class="headerlink" title="2.1 迭代器的使用"></a>2.1 迭代器的使用</h4><p>1、通过调用生成器返回一个迭代器对象，用来控制生成器的执行。</p><p>2、调用迭代器的 next 方法向生成器请求一个值。</p><p>3、请求的结果返回一个对象，对象中包含一个 value 值和 done 布尔值，告诉我们生成器是否还会生成值。</p><p>4、如果没有可执行的代码，生成器就会返回一个 undefined 值，表示整个生成器已经完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"3"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = WeaponGenerator();</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br></pre></td></tr></table></figure><h4 id="2-2-生成器的状态"><a href="#2-2-生成器的状态" class="headerlink" title="2.2 生成器的状态"></a>2.2 生成器的状态</h4><p>1、每当代码执行到 yield 属性，就会生成一个中间值，返回一个对象。</p><p>2、每当生成一个值后，生成器就会非阻塞的挂起执行，等待下一次值的请求。</p><p>3、再次调用 next 方法，将生成器从挂起状态唤醒，中断执行的生成器从上次离开的位置继续执行。</p><p>4、直到遇到下一个 yield ，生成器挂起。</p><p>5、 当执行到没有可执行代码了，就会返回一个结果对象，value 的值为 undefined , done 的值为 true，生成器执行完成。</p><h4 id="2-3-将执行权交给下一个生成器"><a href="#2-3-将执行权交给下一个生成器" class="headerlink" title="2.3 将执行权交给下一个生成器"></a>2.3 将执行权交给下一个生成器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"4"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"5"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"6"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"3"</span>;</span><br><span class="line">    <span class="keyword">yield</span> *XiaoLuGenerator(); <span class="comment">// 将执行权交给另一个生成器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> WeaponGenerator())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、生成器的应用"><a href="#三、生成器的应用" class="headerlink" title="三、生成器的应用"></a>三、生成器的应用</h3><h4 id="1、为对象赋唯一-ID-标识"><a href="#1、为对象赋唯一-ID-标识" class="headerlink" title="1、为对象赋唯一 ID 标识"></a>1、为对象赋唯一 ID 标识</h4><blockquote><p>当创建某些对象时，需要为对象赋一个唯一的 ID 值。通常使用一个全局计时器变量，但是这种写法很容易使代码变的混乱。所以使用生成器可以实现这个功能。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span>* <span class="title">IdGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">yield</span> ++id;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> idIterator = IdGenerator();</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj4 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj5 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br></pre></td></tr></table></figure><h4 id="2、遍历-DOM-树"><a href="#2、遍历-DOM-树" class="headerlink" title="2、遍历 DOM 树"></a>2、遍历 DOM 树</h4><blockquote><p>通常遍历 DOM 树最简单的方法是使用递归，但是使用生成器也可以进行遍历代码。很多情况下，使用迭代器比使用递归更要自然。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"xiaolu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Spam<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">DomTraversal</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1、打印当前元素</span></span><br><span class="line">    <span class="keyword">yield</span> element;</span><br><span class="line">    <span class="comment">// 2、寻找当前元素的子元素</span></span><br><span class="line">    element = element.firstElementChild;</span><br><span class="line">    <span class="comment">// 3、循环遍历子元素（子元素可能多个）</span></span><br><span class="line">    <span class="keyword">while</span> (element) &#123;</span><br><span class="line">        <span class="comment">// 4、子元素可能还有子元素（递归）</span></span><br><span class="line">        <span class="keyword">yield</span>* DomTraversal(element);</span><br><span class="line">        <span class="comment">// 5、遍历兄弟元素的子元素</span></span><br><span class="line">        element = element.nextElementSibling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subTree = <span class="built_in">document</span>.getElementById(<span class="string">"xiaolu"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> node <span class="keyword">of</span> DomTraversal(subTree))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、生成器数据交互"><a href="#四、生成器数据交互" class="headerlink" title="四、生成器数据交互"></a>四、生成器数据交互</h3><blockquote><p>生成器中可以进行双向通信，通过 yield 可以返回值，也可以通过 next 传入值。</p><p><strong>注意：</strong>如果没有等待的 yield 表达式，也就是没有值可以应用，所以第一次的 yield 无法传值。</p></blockquote><h4 id="1、构造函数的初始化"><a href="#1、构造函数的初始化" class="headerlink" title="1、构造函数的初始化"></a>1、构造函数的初始化</h4><blockquote><p>生成器可以像其他函数一样接受标准的参数，并在生成器内使用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="keyword">yield</span> (<span class="string">"4"</span>+action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = XiaoLuGenerator(<span class="string">"3333"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br></pre></td></tr></table></figure><h4 id="2、next-方法传递值"><a href="#2、next-方法传递值" class="headerlink" title="2、next 方法传递值"></a>2、next 方法传递值</h4><blockquote><p>next 传递的参数是作为上一执行的结果返回。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="keyword">yield</span> (<span class="string">"4"</span>+action);</span><br><span class="line">    <span class="keyword">yield</span> (<span class="string">"next"</span> + n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = XiaoLuGenerator(<span class="string">"3333"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next(<span class="string">"嘿嘿"</span>));</span><br><span class="line"><span class="comment">// &#123;value: "43333", done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: "next嘿嘿", done: false&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3、抛出异常"><a href="#3、抛出异常" class="headerlink" title="3、抛出异常"></a>3、抛出异常</h4><blockquote><p>生成器除了有一个 next 方法，还有一个 throw 方法来抛出异常，当生成器内部发生错误时，我们可以通过抛出异常来抛出错误。抛出的错误就会被 try-catch 捕获。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> n = <span class="keyword">yield</span> <span class="string">"4"</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"抛出错误！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = XiaoLuGenerator(<span class="string">"3333"</span>);</span><br><span class="line">weapon.next()</span><br><span class="line">weapon.throw(<span class="string">"错误!"</span>)</span><br></pre></td></tr></table></figure><h3 id="五、生成器的内部结构"><a href="#五、生成器的内部结构" class="headerlink" title="五、生成器的内部结构"></a>五、生成器的内部结构</h3><blockquote><p>生成器更像是一个状态运动的状态机。</p></blockquote><ul><li>挂起开始状态——创建一个生成器处于未执行状态。</li><li>执行状态——生成器的执行状态。</li><li>挂起让渡状态——生成器执行遇到第一个 yield 表达式。</li><li>完成状态——代码执行到 return 全部代码就会进入全部状态。</li></ul><h4 id="1、执行上下文跟踪生成器函数"><a href="#1、执行上下文跟踪生成器函数" class="headerlink" title="1、执行上下文跟踪生成器函数"></a>1、执行上下文跟踪生成器函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"1"</span>+action;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"3"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Iterator = WeaponGenerator(<span class="string">"xiaolu"</span>);</span><br><span class="line"><span class="keyword">let</span> result1 = Iterator.next()</span><br><span class="line"><span class="keyword">let</span> result2 = Iterator.next()</span><br><span class="line"><span class="keyword">let</span> result3 = Iterator.next()</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>① 在调用生成器之前的状态——只有全局执行上下文，全局环境中除了生成器变量的引用，其他的变量都为 undefined。</p><p>② 调用生成器并没有执行函数，而是返回一个 Iterator 迭代器对象并指向当前生成器的上下文。</p><p>③ 一般函数调用完成上下文弹出栈，然后被摧毁。当生成器的函数调用完成之后，当前生成器的上下文出栈，但是在全局的迭代器对象还与保持着与生成器执行上下文引用，且生成器的词法环境还存在。</p><p>④ 执行 next 方法，一般的函数会重新创建执行上下文。而生成器会重新激活对应的上下文并推入栈中（这也是为什么标准函数重复调用时，重新从头执行的原因所在。与标准函数相比较，生成器暂时会挂起并将来恢复）。</p><p>⑤ 当遇到 yield 关键字的时候，生成器上下文出栈，但是迭代器还是保持引用，处于非阻塞暂时挂起的状态。</p><p>⑥ 如果遇到 next 指向方法继续在原位置继续 执行，直到遇到 return 语句，并返回值结束生成器的执行，生成器进入结束状态。</p><table><thead><tr><th style="text-align:center">执行上下文栈</th><th style="text-align:center">当前环境</th><th>变量</th></tr></thead><tbody><tr><td style="text-align:center">全局执行上下文</td><td style="text-align:center">全局环境</td><td>WeaponGenerator:function*(){}<br>Iterator: undefined<br>result1: undefined<br>result2: undefined<br>result3: undefined</td></tr></tbody></table><p>从未执行状态变为执行状态：</p><table><thead><tr><th style="text-align:center">执行上下文栈</th><th style="text-align:center">当前环境</th><th>变量</th></tr></thead><tbody><tr><td style="text-align:center">全局执行上下文</td><td style="text-align:center">全局环境</td><td>WeaponGenerator:function*(){}<br>Iterator: Iterator<br>result1: undefined<br>result2: undefined<br>result3: undefined</td></tr><tr><td style="text-align:center">WeaponGenerator <br>上下文</td><td style="text-align:center">WeaponGenerator<br>环境</td><td>action: xiaolu</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 ES6 的生成器可以优雅的实现异步操作！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/ES6/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【闭包和作用域】</title>
    <link href="http://yoursite.com/2019/06/09/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E9%97%AD%E5%8C%85%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/09/前端进阶深入系列之【闭包和作用域】/</id>
    <published>2019-06-09T00:55:28.201Z</published>
    <updated>2019-07-06T13:16:04.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深入闭包以及闭包的应用！</p><a id="more"></a><h3 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h3><p><strong>1、作用域：</strong>限定变量和函数的可用性的范围叫做<strong>作用域</strong>。</p><p><strong>2、作用域链：</strong>保证对<strong>执行函数</strong>有权访问的所有变量和函数的<strong>有序访问</strong>。</p><h3 id="二、理解闭包？"><a href="#二、理解闭包？" class="headerlink" title="二、理解闭包？"></a>二、理解闭包？</h3><h4 id="1、什么是闭包？"><a href="#1、什么是闭包？" class="headerlink" title="1、什么是闭包？"></a>1、什么是闭包？</h4><blockquote><p>闭包是在函数内可以访问并操作函数外部的变量。只要变量或函数存在于声明的函数的作用域内，闭包就可以使用函数访问到这些变量。</p></blockquote><h4 id="2、如何理解闭包？"><a href="#2、如何理解闭包？" class="headerlink" title="2、如何理解闭包？"></a>2、如何理解闭包？</h4><blockquote><p> 在外部函数声明内部函数的时候，就创建了一个闭包。闭包包含了当前声明的函数作用域中所有的函数和变量。只要声明的函数存在，当前闭包就会存在。</p></blockquote><h6 id="▉-注意一："><a href="#▉-注意一：" class="headerlink" title="▉ 注意一："></a>▉ 注意一：</h6><blockquote><p>每一个通过闭包访问变量的函数都具有一个作用域链，作用域链包含闭包的全部信息。</p></blockquote><h6 id="▉-注意二："><a href="#▉-注意二：" class="headerlink" title="▉ 注意二："></a>▉ 注意二：</h6><blockquote><p>闭包不能过度使用，因为闭包所有的变量都存在内存中，直到不会被使用到（页面卸载）时才会被垃圾回收，多度的使用闭包会影响性能。</p></blockquote><h3 id="三、闭包的应用"><a href="#三、闭包的应用" class="headerlink" title="三、闭包的应用"></a>三、闭包的应用</h3><h4 id="1、应用一：封装私有变量"><a href="#1、应用一：封装私有变量" class="headerlink" title="1、应用一：封装私有变量"></a>1、应用一：封装私有变量</h4><blockquote><p>由于原生的 JavaScript 不支持私有变量，所以只能通过闭包的方式来实现。</p></blockquote><ul><li><p>在构造函数中的外部是无法访问到函数内部的变量的，只能通过闭包的形式访问内部的变量。</p></li><li><p>通过 new 的方式创建一个新对象，改变函数内 this 的指向，为实例对象添加新属性，返回一个新对象，通过对象的方式可以访问到构造函数内部的属性。</p></li><li>通过闭包内部的方法获取到私有变量的值，但是不能直接进行访问私有变量，有效的阻止了对变量不可控的修改。</li></ul><h4 id="2、应用二：回调函数"><a href="#2、应用二：回调函数" class="headerlink" title="2、应用二：回调函数"></a>2、应用二：回调函数</h4><blockquote><p>由于处理回调函数是一种异步的调用函数，需要在回调函数中频繁的访问外部的数据，所以用闭包来解决这个问题。</p></blockquote><ul><li><p>闭包解决问题回调可以有效的防止污染全局变量。当不使用闭包的时候，所有的变量全部都在全局作用域下，多个异步操作同时对变量进行读或取，那么就会发生冲突，就污染到了全局的作用域。</p></li><li><p>如果没有闭包，一次性做许多事情就会变得非常的困难，例如：事件绑定、动画甚至服务器请求。</p></li><li><p>闭包不是存在于创建的那一时刻，而是一个真实状态的封装，只要闭包存在，就可以对变量就行修改。</p></li></ul><h3 id="四、闭包与作用域的关系"><a href="#四、闭包与作用域的关系" class="headerlink" title="四、闭包与作用域的关系"></a>四、闭包与作用域的关系</h3><blockquote><p>闭包和作用域是强相关的，JavaScript 的作用域有一定的规则以及 javaScript 的内部运行机制。</p><p>1）javascript 引擎是如何跟踪函数执行又回到函数的位置？</p></blockquote><h4 id="1、javaScript-的执行上下文跟踪函数"><a href="#1、javaScript-的执行上下文跟踪函数" class="headerlink" title="1、javaScript 的执行上下文跟踪函数"></a>1、javaScript 的执行上下文跟踪函数</h4><blockquote><p>因为 JavaScript 的运行机制是基于单线程的，某个特定的时刻只能执行特定的代码，所以要通过执行上下文栈来确定函数的执行顺序。</p></blockquote><h6 id="▉-基本概念"><a href="#▉-基本概念" class="headerlink" title="▉ 基本概念"></a>▉ 基本概念</h6><ul><li><p>js 代码类型分为两种：<strong>全局代码</strong>，在所有函数的外部定义；<strong>局部代码</strong>，在函数的内部定义。</p></li><li><p>每个函数的执行都会在一个特定的执行上下文中。<strong>全局执行上下文</strong>只有一个（每个页面只有一个）；而<strong>函数执行上下文</strong>是每当执行一个函数时，就会先创建一个函数执行上下文。</p></li><li><p><strong>注意：</strong>this 访问函数上下文和函数执行上下文是两个不同的概念。</p><p>​        </p></li></ul><h6 id="▉-跟踪过程"><a href="#▉-跟踪过程" class="headerlink" title="▉ 跟踪过程"></a>▉ 跟踪过程</h6><blockquote><p>1）程序开始运行只有执行上下文栈中只有全局执行上下文。</p><p>2）当调用函数的时候，当前函数就会创建一个新的执行上下文入栈，就说明当前的函数正在执行。</p><p>3）如果当前的函数执行完毕，所创建的执行上下文就会出栈，将控制权教给上一级。</p><p>4）直到所有有执行上下文出栈，全局执行上下文恢复执行。</p></blockquote><h4 id="2、javascript-引擎跟踪词法环境"><a href="#2、javascript-引擎跟踪词法环境" class="headerlink" title="2、javascript 引擎跟踪词法环境"></a>2、javascript 引擎跟踪词法环境</h4><blockquote><p>词法环境是每个（函数）执行上下文中所有变量和函数存储的环境。词法环境是 JavaScript 内部的实现机制，通常称为作用域。</p></blockquote><h6 id="▉-词法环境的作用"><a href="#▉-词法环境的作用" class="headerlink" title="▉ 词法环境的作用"></a>▉ 词法环境的作用</h6><blockquote><p>词法环境主要是 JavaScript 引擎用来<strong>如何跟踪变量</strong>以及如果<strong>判断变量的可访问性</strong>。</p></blockquote><h6 id="▉-关联性"><a href="#▉-关联性" class="headerlink" title="▉ 关联性"></a>▉ 关联性</h6><blockquote><p>词法环境与 JavaScript 的代码就够进行关联，如：函数、代码片段等是相互关联的。</p></blockquote><h4 id="2-1-代码嵌套"><a href="#2-1-代码嵌套" class="headerlink" title="2.1 代码嵌套"></a>2.1 代码嵌套</h4><blockquote><p>词法环境主要与代码嵌套（代码嵌套的结构）相关联的，每执行代码，代码结构就会获取与之相关联的词法环境，用来确保内部环境可访问外部环境。</p></blockquote><h4 id="2-2-代码嵌套与词法环境的关系"><a href="#2-2-代码嵌套与词法环境的关系" class="headerlink" title="2.2 代码嵌套与词法环境的关系"></a>2.2 代码嵌套与词法环境的关系</h4><blockquote><p>词法环境查询变量时，根据执行上下文对应的词法环境由内而外依次进行查找，直到查找到最外层的全局作用域。</p></blockquote><h6 id="▉-函数-执行上下文-词法环境的关系"><a href="#▉-函数-执行上下文-词法环境的关系" class="headerlink" title="▉ 函数 - 执行上下文 - 词法环境的关系"></a>▉ 函数 - 执行上下文 - 词法环境的关系</h6><p>1、每个执行上下文都对应一个词法环境（函数的局部作用域）；</p><p>2、每个局部函数中的内部属性 [[Environment]] 与创建的执行上下文相关联（所在当前函数的执行上下文）；</p><h3 id="五、闭包的工作原理"><a href="#五、闭包的工作原理" class="headerlink" title="五、闭包的工作原理"></a>五、闭包的工作原理</h3><h4 id="1、闭包模拟私有变量"><a href="#1、闭包模拟私有变量" class="headerlink" title="1、闭包模拟私有变量"></a>1、闭包模拟私有变量</h4><blockquote><p>闭包模拟 js 的私有变量时，会 new 一个实例对象，实例对象就会通过闭包获取或改变构造函数内的局部变量模拟面向对象。每次调用构造函数，都会创建一个新的词法环境，该词法环境会保持着构造函数内部的局部变量。</p></blockquote><h6 id="▉-内部实现步骤"><a href="#▉-内部实现步骤" class="headerlink" title="▉ 内部实现步骤"></a>▉ 内部实现步骤</h6><blockquote><p>1）new 一个实例对象。</p><p>2）进入构造函数，为<strong>构造函数创建一个新的词法环境</strong>，它始终保持着对局部变量的引用。</p><p>3）然后为空对象添加两个函数，这两个函数 [[Envrionment]] 都保持着对<strong>新创建函数的词法环境</strong>的引用，返回新对象。</p><p>4）当调用对象的函数时，就会创建新的执行上下文推入执行栈中，这回引起创建的新的词法环境（内部函数）。</p><p>5）js 引擎会检查当前函数的词法环境中有没有想要的变量，如果没有，则会到外部变量（构造函数的词法环境）中去查找，查找到了就返回。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入闭包以及闭包的应用！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【浏览器的运行机制】</title>
    <link href="http://yoursite.com/2019/06/02/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/02/前端进阶深入系列之【浏览器的运行机制】/</id>
    <published>2019-06-02T06:02:01.187Z</published>
    <updated>2019-06-05T06:51:52.376Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深入浅出 JS 的运行机制！</p><a id="more"></a><h3 id="一、区分进程和线程"><a href="#一、区分进程和线程" class="headerlink" title="一、区分进程和线程"></a>一、区分进程和线程</h3><blockquote><p>CPU 的作用是主要是解释计算机的指令以及处理计算机软件中的数据。</p></blockquote><ul><li><p><strong>进程：</strong>进程是 CPU <strong>资源分配</strong>的最小单位，系统会为每个进行分配内存空间。</p></li><li><p><strong>线程：</strong>线程是 CPU <strong>调度</strong>的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程由多个线程组成）。</p></li></ul><h3 id="二、浏览器是多进程的"><a href="#二、浏览器是多进程的" class="headerlink" title="二、浏览器是多进程的"></a>二、浏览器是多进程的</h3><blockquote><p>1、浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）。</p><p>2、浏览器是多进程的，每打开一个 Tab 页，相当于创建了一个独立的浏览器进程。</p><p>3、浏览器有时可以将多个进程合并，比如打开多个空白页，将这些空白页合成一个进程。</p></blockquote><h4 id="1、浏览器有哪些进程？"><a href="#1、浏览器有哪些进程？" class="headerlink" title="1、浏览器有哪些进程？"></a>1、浏览器有哪些进程？</h4><ul><li><p><strong>Browser 进程：</strong></p><blockquote><p>浏览器的主进程（负责协调、主控），只有一个</p></blockquote><ul><li>负责浏览器界面显示，与用户交互。如前进，后退等；</li><li>负责各个页面的管理，创建和销毁其他进程；</li><li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；</li><li>网络资源的管理，下载等</li></ul></li><li><p><strong>第三方插件进程：</strong></p><blockquote><p>每种类型的插件对应一个进程，仅当使用该插件时才创建。</p></blockquote></li><li><p><strong>GPU 进程：</strong></p><blockquote><p>用于 3D 绘制等；</p></blockquote></li><li><p><strong>浏览器渲染进程（浏览器内核）：</strong></p><blockquote><p>默认每个Tab页面一个进程，互不影响。</p></blockquote><ul><li>页面渲染，脚本执行，事件处理等</li></ul></li></ul><h4 id="2、浏览器多进程的优势？"><a href="#2、浏览器多进程的优势？" class="headerlink" title="2、浏览器多进程的优势？"></a>2、浏览器多进程的优势？</h4><blockquote><p>多进程的浏览器资源消耗有点大，难道空间换时间思想。<strong>如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；</strong></p></blockquote><ul><li>避免单个页面崩溃影响整个浏览器；</li><li>避免第三方插件崩溃影响整个浏览器；</li><li>多进程利用多核优势；</li><li>……</li></ul><h4 id="3、重点：浏览器的内核（渲染进程）"><a href="#3、重点：浏览器的内核（渲染进程）" class="headerlink" title="3、重点：浏览器的内核（渲染进程）"></a>3、重点：浏览器的内核（渲染进程）</h4><blockquote><p>前端浏览器最重要的点就是<strong>渲染进程</strong>，而且渲染进程是是多线程的。页面的渲染、js 的执行、时间的想都会在这个进程内进行。</p></blockquote><p>渲染进程包括哪些线程：</p><h5 id="①-GUI-渲染线程"><a href="#①-GUI-渲染线程" class="headerlink" title="① GUI 渲染线程"></a>① GUI 渲染线程</h5><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。</li><li>GUI渲染线程与JS引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</li></ul><h5 id="②-JS-引擎线程"><a href="#②-JS-引擎线程" class="headerlink" title="② JS 引擎线程"></a>② JS 引擎线程</h5><ul><li>也称为 JS 内核，负责处理 Javascript 脚本程序（V8 引擎）。</li><li>JS 引擎线程负责解析 Javascript 脚本，运行代码。</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。</li><li>GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><h5 id="③-事件触发线程"><a href="#③-事件触发线程" class="headerlink" title="③ 事件触发线程"></a>③ 事件触发线程</h5><ul><li>属于浏览器的线程而不是 js 引擎，用来控制事件循环。</li><li>当 JS 引擎执行代码块如 setTimeOut 时，会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。</li><li>由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。</li></ul><h5 id="④-定时触发器线程"><a href="#④-定时触发器线程" class="headerlink" title="④ 定时触发器线程"></a>④ 定时触发器线程</h5><ul><li><code>setInterval</code>与<code>setTimeout</code>所在线程。</li><li>浏览器定时计数器并不是由 JavaScript 引擎计数的（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）。</li><li>通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）。</li><li>W3C在HTML标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</li></ul><h5 id="⑤-异步-http-请求线程"><a href="#⑤-异步-http-请求线程" class="headerlink" title="⑤ 异步 http 请求线程"></a>⑤ 异步 http 请求线程</h5><ul><li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入浅出 JS 的运行机制！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
