<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小鹿的博客</title>
  
  <subtitle>Ordinary life , Unwilling to be ordinary code farmers</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-06T00:09:13.321Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小鹿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端面试之【CSS 常用布局】</title>
    <link href="http://yoursite.com/2019/05/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90CSS%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/06/前端面试之道【CSS常用布局】/</id>
    <published>2019-05-05T23:43:01.094Z</published>
    <updated>2019-05-06T00:09:13.321Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CSS 中常用的几种布局方式！</p><a id="more"></a><h2 id="三种最基本的布局方式"><a href="#三种最基本的布局方式" class="headerlink" title="三种最基本的布局方式"></a>三种最基本的布局方式</h2><h3 id="1、流式布局"><a href="#1、流式布局" class="headerlink" title="1、流式布局"></a>1、流式布局</h3><blockquote><p>流动布局模型就是<strong>默认的</strong>网页布局模式。</p></blockquote><ul><li><strong>块级元素</strong>都会在所处的最近父级容器元素内<strong>自上而下</strong>按顺序垂直顺延分布，块元素的宽度一般为 100%，也就是父元素的宽度。</li><li><strong>内联元素</strong>一般<strong>从左到右</strong>依次分布显示。</li></ul><h3 id="2、浮动布局"><a href="#2、浮动布局" class="headerlink" title="2、浮动布局"></a>2、浮动布局</h3><blockquote><p>流式布局的元素基本都是在整个文档流中的，如果使用浮动布局，需要给某一元素设置浮动属性，脱离当前文档流。</p></blockquote><h3 id="3、层级布局"><a href="#3、层级布局" class="headerlink" title="3、层级布局"></a>3、层级布局</h3><blockquote><p>层级布局指的是通过<strong>相对定位</strong>以及<strong>绝对定位</strong>以及<strong>固定定位</strong>的方式来进行布局。</p><p>1）通过设置 top、left、right、bottom 来记性定位元素。</p><p>2）缺点：对于相应式的布局，该布局方式还有很多不便之处。</p></blockquote><ul><li><strong>fixed 定位：</strong>固定定位，相对于浏览器窗口进行定位，不随窗口滚动，可以和其他元素重叠，不占据空间。</li><li><strong>relative 定位：</strong>相对定位，相对于正常位置进行定位，原本的空间不会改变。</li><li><strong>absolute 定位：</strong>绝对定位，是相对于已经定位的父元素进行定位，如果没有父元素，就相当于 <code>&lt;html&gt;</code> ，不占据任何空间，定位元素可以和其他元素进行重叠。</li></ul><h2 id="弹性布局（Flex）"><a href="#弹性布局（Flex）" class="headerlink" title="弹性布局（Flex）"></a>弹性布局（Flex）</h2><h2 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h2><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><h2 id="两种自适应布局"><a href="#两种自适应布局" class="headerlink" title="两种自适应布局"></a>两种自适应布局</h2><h3 id="1、双飞翼布局"><a href="#1、双飞翼布局" class="headerlink" title="1、双飞翼布局"></a>1、双飞翼布局</h3><h3 id="2、圣杯布局"><a href="#2、圣杯布局" class="headerlink" title="2、圣杯布局"></a>2、圣杯布局</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 中常用的几种布局方式！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【盒模型】</title>
    <link href="http://yoursite.com/2019/05/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E7%9B%92%E6%A8%A1%E5%9E%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/06/前端面试之道【盒模型】/</id>
    <published>2019-05-05T23:12:51.565Z</published>
    <updated>2019-05-05T23:42:55.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>盒模型相关知识点！</p><a id="more"></a><h2 id="css-盒模型"><a href="#css-盒模型" class="headerlink" title="css 盒模型"></a>css 盒模型</h2><h3 id="一、盒模型的分类"><a href="#一、盒模型的分类" class="headerlink" title="一、盒模型的分类"></a>一、盒模型的分类</h3><blockquote><p>IE 盒模型和 W3C 标准盒模型。</p></blockquote><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><blockquote><p>一个盒子模型是由 外边距（margin）、边框（border）、内边距（padding）、内容（content）四部分组成的。</p></blockquote><h4 id="IE-盒模型"><a href="#IE-盒模型" class="headerlink" title="IE 盒模型"></a>IE 盒模型</h4><blockquote><p>盒子的属性 <code>width</code>  和 <code>height</code> 指的是 <code>content + padding + border</code>。</p></blockquote><h4 id="W3C-标准盒模型"><a href="#W3C-标准盒模型" class="headerlink" title="W3C 标准盒模型"></a>W3C 标准盒模型</h4><blockquote><p>盒子的属性 <code>width</code>  和 <code>height</code> 指的是 <code>content</code>。</p></blockquote><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><blockquote><p>1）只有在 IE8 + 版本中可以通过 <code>box-sizing（centent-box 标准盒模型/border-sizing IE 盒模型）</code> 切换 IE 盒模型和 W3C 标准盒模型。其他浏览器需要加上前缀。</p><p>2）在 IE6、IE7、IE8 中添加 <code>&lt;!DOCTYPE&gt;</code> 就会使用 <code>W3C</code> 标准盒模型。否则出现不同浏览器兼容性问题（IE浏览器会将盒子模型解释为 IE 盒子模型，FireFox等会将其解释为 W3C 盒子模型）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;盒模型相关知识点！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【网络攻击】</title>
    <link href="http://yoursite.com/2019/05/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/02/前端面试之道【网络攻击】/</id>
    <published>2019-05-02T12:21:03.578Z</published>
    <updated>2019-05-04T03:09:38.879Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常见的网络攻击！</p><a id="more"></a><h2 id="一、XSS-攻击"><a href="#一、XSS-攻击" class="headerlink" title="一、XSS 攻击"></a>一、XSS 攻击</h2><h4 id="1、XSS-是什么"><a href="#1、XSS-是什么" class="headerlink" title="1、XSS 是什么"></a>1、XSS 是什么</h4><blockquote><p>XSS 攻击称为跨站脚本攻击，是一种代码注入的攻击。攻击者通过向目标网站注入恶意脚本，使之在浏览器中运行。利用脚本获取到用户的信息。</p></blockquote><p>XSS 常见几种注入方法：</p><ul><li>以 javascript 标签的形式注入。</li><li>在内联 javascript 中，拼接的数据突破了原本的限制（字符串、变量等）</li><li>在属性标签中，恶意内容包含引号，突破属性值的限制，注入其他属性。</li><li>在标签的 href、src 等属性中，包含 js 可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制的代码。</li></ul><h4 id="2、XSS-攻击的分类"><a href="#2、XSS-攻击的分类" class="headerlink" title="2、XSS 攻击的分类"></a>2、XSS 攻击的分类</h4><ul><li>存储型 XSS</li><li>反射型 XSS</li><li>DOM型 XSS</li></ul><h5 id="▉-存储型-XSS"><a href="#▉-存储型-XSS" class="headerlink" title="▉ 存储型 XSS"></a>▉ 存储型 XSS</h5><blockquote><p>最危险的一种跨站脚本攻击，危害比反射性和DOM型都要大，因为不需要用户手动触发。<strong>恶意代码存储在数据库中</strong>。</p></blockquote><p>1）攻击者将恶意代码提交至目标网站的数据库中。</p><p>2）用户打开网站，网站将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</p><p>3）浏览器将服务器返回的 HTML 进行解析，恶意代码被执行。</p><p>4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。</p><h5 id="▉-反射型-XSS"><a href="#▉-反射型-XSS" class="headerlink" title="▉ 反射型 XSS"></a>▉ 反射型 XSS</h5><blockquote><p>需要用户主动打开 URL 。<strong>恶意代码存储在 URL 中</strong>。常见的用于 URL 传递参数的功能，如：网站搜索、跳转等。</p></blockquote><p>1）攻击者伪造包含恶意代码的URL。</p><p>2）用户打开恶意的URL，服务端将恶意的 <code>URL</code> 代码取出拼接在<code>HTML</code> 后返回给浏览器。</p><p>3）用户浏览器解析请求，恶意代码得到执行。</p><p>4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。</p><h5 id="▉DOM-型-XSS"><a href="#▉DOM-型-XSS" class="headerlink" title="▉DOM 型 XSS"></a>▉DOM 型 XSS</h5><blockquote><p>DOM 型 XSS 攻击中，取出和执行<strong>恶意代码由浏览器端完成</strong>，属于前端 <code>JavaScript</code> 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 </p></blockquote><p>1）攻击者伪造包含恶意代码的 <code>URL</code>。</p><p>2）用户打开恶意的 <code>URL</code>。</p><p>3）前端 <code>Javascript</code> 取出 <code>URL</code> 中的恶意代码<strong>由浏览器完成</strong>，属于前端 <code>javascript</code> 自身的安全漏洞，触发XSS <strong>靠的是浏览器端的DOM解析</strong> 。</p><p>4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。</p><h4 id="3、防御-XSS"><a href="#3、防御-XSS" class="headerlink" title="3、防御 XSS"></a>3、防御 XSS</h4><h5 id="▉-常用的防御方法"><a href="#▉-常用的防御方法" class="headerlink" title="▉ 常用的防御方法"></a>▉ 常用的防御方法</h5><blockquote><p>一般页面输入的地方会存在 XSS 攻击的危险。</p></blockquote><ul><li><strong>httpOnly:</strong> 在 <code>cookie</code> 中设置 <code>HttpOnly</code> 属性后，js 脚本无法读取到 <code>Cookie</code> 信息。</li><li><strong>输入过滤：</strong>用于对输入格式的检查（邮箱、电话号码等）。前后台多要进行过滤检查，因为攻击者完全可以绕过前端直接利用接口对后端发送设置。</li><li><strong>白名单：</strong>名单控制允许的 <code>HTML</code>标签及各标签的属性 。</li><li><strong>转义 HTML：</strong>如果拼接 <code>HTML</code> 是必要的，对于引号，尖括号，斜杠进行转义（可以借助转义库）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">'&amp;#96;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2F;'</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="▉-预防存储型和反射性-XSS-攻击"><a href="#▉-预防存储型和反射性-XSS-攻击" class="headerlink" title="▉ 预防存储型和反射性 XSS 攻击"></a>▉ 预防存储型和反射性 XSS 攻击</h5><blockquote><p>这两种攻击一般在服务器端取出恶意代码，拼接到 <code>HTML</code> 中，然后被浏览器所执行。</p></blockquote><p><strong>1、改成纯前端渲染，使代码和数据分离。</strong></p><blockquote><p><strong>作用：</strong>明确告诉浏览器，要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了 。</p><p><strong>缺点：</strong>需要避免 DOM 型的 XSS 攻击。</p><p>1）浏览器先加载一个静态 <code>HTML</code>，此 <code>HTML</code> 中不包含任何跟业务相关的数据。</p><p>2）然后浏览器执行 <code>HTML</code> 中的 <code>JavaScript</code>。</p><p>3）<code>JavaScript</code> 通过 <code>Ajax</code> 加载业务数据，调用 <code>DOM API</code> 更新到页面上 </p></blockquote><p><strong>2、对 HTML 做充分的转义。</strong></p><blockquote><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题,这时就需要对HTML进行充分的转义。 </p></blockquote><h5 id="▉-预防-DOM-型-XSS-攻击"><a href="#▉-预防-DOM-型-XSS-攻击" class="headerlink" title="▉ 预防 DOM 型 XSS 攻击"></a>▉ 预防 DOM 型 XSS 攻击</h5><blockquote><p>由于前端的 javascript 代码本身不够严谨，把不可信的数据当做代码执行了。</p></blockquote><p><strong>1、HTML 插入数据</strong></p><blockquote><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等 </p></blockquote><p><strong>2、DOM 内联监听</strong></p><blockquote><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;</span><br><span class="line">&lt;img onclick=<span class="string">"UNTRUSTED"</span> onerror=<span class="string">"UNTRUSTED"</span> src=<span class="string">"data:image/png,"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 链接内包含恶意代码 --&gt;</span><br><span class="line">&lt;a href=<span class="string">"UNTRUSTED"</span>&gt;<span class="number">1</span>&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ setTimeout()/</span>setInterval() 中调用恶意代码</span><br><span class="line">setTimeout(<span class="string">"UNTRUSTED"</span>)</span><br><span class="line">setInterval(<span class="string">"UNTRUSTED"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// location 调用恶意代码</span></span><br><span class="line">location.href = <span class="string">'UNTRUSTED'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eval() 中调用恶意代码</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"UNTRUSTED"</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、CSRF-跨站请求伪造"><a href="#二、CSRF-跨站请求伪造" class="headerlink" title="二、CSRF 跨站请求伪造"></a>二、CSRF 跨站请求伪造</h2><h3 id="2-1-跨站请求伪造（CSRF）"><a href="#2-1-跨站请求伪造（CSRF）" class="headerlink" title="2.1 跨站请求伪造（CSRF）"></a>2.1 跨站请求伪造（CSRF）</h3><blockquote><p>跨站伪造请求（Cross-site request forgery ），缩写为 CSRF。冒充用户发起请求（在用户不知情的情况下）， 完成一些违背用户意愿的事情（如修改用户信息，删初评论等）。 </p></blockquote><h4 id="1、攻击原理"><a href="#1、攻击原理" class="headerlink" title="1、攻击原理"></a>1、攻击原理</h4><blockquote><p>攻击者通过技术手段欺骗用户的浏览器去访问一个曾经认证过的网站，所以用户不用进行重新认证，这是一个用户身份验证的一个漏洞：<strong>简单身份认证只保证请求来自某个用户的浏览器，确不能保证请求的本身是用户自愿发出的。</strong>攻击者诱导用户在刚访问不久的网站中点击设定的链接（本页的论坛、博客等自动生成的链接内容）。</p></blockquote><h4 id="2、防御措施"><a href="#2、防御措施" class="headerlink" title="2、防御措施"></a>2、防御措施</h4><h6 id="▉-检查-Referer-字段"><a href="#▉-检查-Referer-字段" class="headerlink" title="▉ 检查 Referer 字段"></a>▉ 检查 Referer 字段</h6><blockquote><p>HTTP 头有一个 <code>Referer</code> 字段，用来标记请求来源于哪个地址。<code>Referer</code> 字段应和请求的地址位于同一域名下。 服务器在处理请求的时候，可以判断该字段是否位于正确的源地址下发送的请求。如果是 CSRF 攻击，该字段会包含恶意的网址。</p><p><strong>局限性：</strong>设置 <code>Referer</code> 有本身的局限性，攻击者可以篡改 <code>Referer</code> 字段来达到攻击的目的。</p></blockquote><h6 id="▉-Token-验证"><a href="#▉-Token-验证" class="headerlink" title="▉  Token 验证"></a>▉  Token 验证</h6><blockquote><p>CSRF 的本质是在于攻击者欺骗自己去访问设置的地址，如果在请求数据的时候，用户不把信息保存到浏览器的 <code>Cookie</code> 中，那么攻击者无法获取数据校验，从而不能进行 CSRF 攻击。</p></blockquote><ul><li><strong>第一步：</strong>后端随机产生一个 <code>token</code>，把这个 <code>token</code> 保存到 <code>session</code> 状态中；同时后端把这个 <code>token</code> 交给前端页面；</li><li><strong>第二步：</strong>前端页面提交请求时，把 <code>token</code> 加入到请求数据或者头信息中，一起传给后端；</li><li><strong>第三步：</strong>端验证前端传来的 <code>token</code> 与 <code>session</code> 是否一致，一致则合法，否则是非法请求。</li></ul><h2 id="四、DNS-攻击"><a href="#四、DNS-攻击" class="headerlink" title="四、DNS 攻击"></a>四、DNS 攻击</h2><h4 id="1、什么是-DNS-攻击？"><a href="#1、什么是-DNS-攻击？" class="headerlink" title="1、什么是 DNS 攻击？"></a>1、什么是 DNS 攻击？</h4><blockquote><p>利用 DNS（域名系统）中的漏洞，发起 DNS 攻击。</p></blockquote><h6 id="▉-DNS-的工作原理"><a href="#▉-DNS-的工作原理" class="headerlink" title="▉ DNS 的工作原理"></a>▉ DNS 的工作原理</h6><blockquote><p>将用户输入的域名转换成相对应的 IP 地址。</p></blockquote><ul><li>DNS 首先搜索缓存中是否存在该域名的 IP 地址。</li><li>如果找不到该域名的地址，就到 DNS 服务器查找该域名准确的 IP 地址。</li><li>DNS 一直循环工作，DNS 服务器之间可以相互查询到域名的 IP 地址的DNS 服务器。</li><li>DNS 一旦找到 IP 地址，就将当前的 IP 地址返回给请求的程序，将其存储缓存中。</li></ul><h6 id="▉-如何利用-DNS-攻击"><a href="#▉-如何利用-DNS-攻击" class="headerlink" title="▉ 如何利用 DNS 攻击"></a>▉ 如何利用 DNS 攻击</h6><blockquote><p>1）DNS 不太注重安全问题，所以容易被攻击者发起 DNS 攻击。攻击者利用一种方式来用恶意的 IP 地址替换 DNS 解析的域名的 IP 地址，那么用户发送的数据发送到这个攻击者替换的 IP 假地址中去。</p><p>2）DNS 服务器配置不记得它的默认配置，所以利用这一漏洞进行攻击。</p></blockquote><h6 id="▉-DNS-的攻击类型"><a href="#▉-DNS-的攻击类型" class="headerlink" title="▉ DNS 的攻击类型"></a>▉ DNS 的攻击类型</h6><ul><li><strong>零日攻击：</strong>利用 DNS 服务器软件和协议堆栈中未知的漏洞。</li><li><strong>Fast Flux DNS ： </strong>以高频率交换 DNS 记录以重定向 DNS 请求，也有利于攻击者避免检测。</li><li><strong>DNS 欺骗：</strong>攻击者通过用服务器缓存中的伪造 IP 地址替换授权的 IP 地址来破坏整个DNS服务器。通过这种方式，他们将整个流量重定向到恶意网站并收集重要信息。 </li></ul><h2 id="五、DDOS-攻击"><a href="#五、DDOS-攻击" class="headerlink" title="五、DDOS 攻击"></a>五、DDOS 攻击</h2><blockquote><p>DDoS 攻击称为<strong>分布式拒绝服务攻击</strong>。 通过多台计算机对 DNS 服务器发送大量的请求，达到目标的 DNS 服务器无法进行正常队请求进行解析回应的目的。DDoS 攻击可能导致整个 DNS 服务器崩溃并使用户无法访问 Web。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的网络攻击！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之题型篇【查找和排序】</title>
    <link href="http://yoursite.com/2019/05/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A2%98%E5%9E%8B%E7%AF%87%E3%80%90%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/02/数据结构与算法之题型篇【查找和排序】/</id>
    <published>2019-05-02T10:57:10.751Z</published>
    <updated>2019-05-04T08:37:35.439Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据结构与算法中所必会的查找和排序算法。</p><a id="more"></a><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><h2 id="一、查找和排序的基础练习（阶段一）"><a href="#一、查找和排序的基础练习（阶段一）" class="headerlink" title="一、查找和排序的基础练习（阶段一）"></a>一、查找和排序的基础练习（阶段一）</h2><h2 id="二、查找和排序的进阶练习（阶段二）"><a href="#二、查找和排序的进阶练习（阶段二）" class="headerlink" title="二、查找和排序的进阶练习（阶段二）"></a>二、查找和排序的进阶练习（阶段二）</h2><h3 id="1、旋转数组的最小数字"><a href="#1、旋转数组的最小数字" class="headerlink" title="1、旋转数组的最小数字"></a>1、旋转数组的最小数字</h3><blockquote><p>题目：把一个数组最开始的若干个元素搬移到数组的尾部，称为旋转数组。输入一个递增排序的数组的一个旋转，输出旋转数组中最小的值。</p></blockquote><h4 id="1-1-问题分析与解决"><a href="#1-1-问题分析与解决" class="headerlink" title="1.1 问题分析与解决"></a>1.1 问题分析与解决</h4><h6 id="▉-问题分析"><a href="#▉-问题分析" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><blockquote><p>1）最先想到的方法是暴力破解法，能否遍历整个数组，得出最小值呢？</p><p>2）暴力破解法时间复杂度太高，是否还有其他方法减少时间复杂度呢？查找一个数据，我们想到的方法是二分查找，但是二分查找是查找一个给定值的数据。能够自己改进一下，借助二分查找的思想呢？</p><p>我们发现旋转数组是由两个升序的数组组成的，最小值的位置是在第一个升序数组的后边，第二个数组的最大值小于第一个升序数组中最小值的，我们发现是有规律可循的。</p></blockquote><h6 id="▉-算法思路"><a href="#▉-算法思路" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote><p>暴力破解法：</p><p>1）遍历整个数组，找出数组中的最小值。</p><p>二分查找法：</p><p>1）首先声明两个指针分别指向数组的起始位置和终止位置，取中间元素 mid。</p><p>2）判断当前数据 mid 和起始指针的大小，如果大于<strong>起始指针</strong>（或等于），说明这个中间数据一定是第一个数组中的值。那数组中的最小值一定在该数字的后边。</p><p>3）判断当前数据 mid 和起始指针的大小，如果小于<strong>终止指针</strong>（或等于），说明这个中间数据一定是第二个数组中的值。那数组中的最小值一定在该数字的前边。</p><p>4）我们把指针指向中间元素，将搜索范围缩小到原来的一半了，循环以上过程。</p><p>5）那么终止条件是什么呢？我们不断的缩小范围，我们会发现，起始指针和终止指针最终相邻，起始指针会指向数组的最后一个元素，终止指针会指向第二个数组的起始元素。那么终止指针指向的就是我们要查找的最小值。（之所以两个指针最后相邻，是因为我们不断你的在第一个或第二个数组中移动起始或终止指针，该指针永远不会越界指向超出本身数组的值）</p></blockquote><h6 id="▉-边界条件"><a href="#▉-边界条件" class="headerlink" title="▉ 边界条件"></a>▉ 边界条件</h6><blockquote><p>虽然我们上述的算法思路可以实现，但是有几个特殊情况需要处理一下：</p><p>1）如果数组中有重复的值，上述的方法不再适用。假如三个数组{11101} 是 {01111}的旋转数组，那么起始指针与终止指针以及中间元素相等，无法再用之前的判断，此时遇到这种情况需要遍历当前数组。</p><p>2）向后移动 0 个元素也算是一个旋转数组呀，相当于数组本身。此时需要判断数组的最后一个元素是否大于第一个元素，如果是这种情况，那就说明旋转数组就是本身。</p></blockquote><h6 id="▉-测试用例"><a href="#▉-测试用例" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote><p>1）空数组</p><p>2）原数组</p><p>3）重复元素的数组</p><p>4）正常旋转数组（升序数组，为一个值的数组）</p></blockquote><h6 id="▉-代码实现"><a href="#▉-代码实现" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="▉-性能分析"><a href="#▉-性能分析" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><blockquote><p>暴力破解法</p><ul><li>时间复杂度：O(n)。遍历整个数组。</li><li>空间复杂度：O(1)。不需要额外的内存空间。</li></ul><p>二分查找法</p><ul><li>时间复杂度：log(n)。二分查找，每次都缩小范围的 1/2 。</li><li>空间复杂度：不需要额外的内存空间 O(1)。</li></ul></blockquote><h4 id="1-2-小结"><a href="#1-2-小结" class="headerlink" title="1.2 小结"></a>1.2 小结</h4><h6 id="▉-考查内容"><a href="#▉-考查内容" class="headerlink" title="▉ 考查内容"></a>▉ 考查内容</h6><blockquote><p>1）对二分查找的充分理解。</p><p>2）能在短时间内了解旋转数组这种新的概念。</p><p>3）问题的全面性。（重复元素以及向后移动 0 个元素）</p></blockquote><h6 id="▉-扩展思考"><a href="#▉-扩展思考" class="headerlink" title="▉ 扩展思考"></a>▉ 扩展思考</h6><blockquote><p>1）对二分查找条件的变换，使得问题可以举一反三。</p></blockquote><h3 id="2、二叉查找树的后续序列"><a href="#2、二叉查找树的后续序列" class="headerlink" title="2、二叉查找树的后续序列"></a>2、二叉查找树的后续序列</h3><blockquote><p>题目：给你一个整型数组，判断该数组是否为二叉查找树的后序遍历。如果是返回 true，如果不是返回 false。</p></blockquote><h4 id="2-1-问题分析与解决"><a href="#2-1-问题分析与解决" class="headerlink" title="2.1 问题分析与解决"></a>2.1 问题分析与解决</h4><h6 id="▉-问题分析-1"><a href="#▉-问题分析-1" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><blockquote><p>1）根据二叉查找树后续遍历的特点，先遍历左子树，然后遍历右子树，最后遍历根节点。存储在数组中的二叉查找树是有规律的，所以观察数组中的数据，与后序遍历是否存在一些规律和关系呢？</p><p>2）二叉查找树的后序遍可以用递归实现遍历的，如果判断一组数据是否为后序遍历是否也可以通过递归来进行判断呢？</p></blockquote><h6 id="▉-算法思路-1"><a href="#▉-算法思路-1" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote><p>1）数组中的数据最后一个数据一定是树的根节点。</p><p>2）如果为一棵二叉查找树，除最后一个根节结点外，数组分为两份数据，我们发现前一份数据小于根节点，后一份数据大于根节点。也就是说，前一半数据为树的左子节点，后一半数据为树的右子节点。</p><p>3）然后对左右两部分的数据分别递归按照上述的方法进行判断。</p></blockquote><h6 id="▉-测试用例-1"><a href="#▉-测试用例-1" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote><p>1）空树</p><p>2）非二叉查找树</p><p>3）只有一个结点的二叉查找树。</p><p>4）只有右/左子树的二叉查找树。</p></blockquote><h6 id="▉-代码实现-1"><a href="#▉-代码实现-1" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><blockquote></blockquote><h6 id="▉-性能分析-1"><a href="#▉-性能分析-1" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><blockquote></blockquote><h4 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><h6 id="▉-考查内容-1"><a href="#▉-考查内容-1" class="headerlink" title="▉ 考查内容"></a>▉ 考查内容</h6><blockquote><p>1）对问题的分析能力，能否找到解题问题的规律。</p><p>2）对二叉查找树遍历的理解。</p><p>3）递归的灵活运用。</p></blockquote><h6 id="▉-扩展思考-1"><a href="#▉-扩展思考-1" class="headerlink" title="▉ 扩展思考"></a>▉ 扩展思考</h6><blockquote><p>1）判断一个数组是否为树的前序遍历或中序遍历？</p><p>2）”重建二叉树“ 也是同样的解题思路。</p></blockquote><h2 id="三、查找和排序的高级练习（阶段三）"><a href="#三、查找和排序的高级练习（阶段三）" class="headerlink" title="三、查找和排序的高级练习（阶段三）"></a>三、查找和排序的高级练习（阶段三）</h2><h2 id="四、查找和排序的总结"><a href="#四、查找和排序的总结" class="headerlink" title="四、查找和排序的总结"></a>四、查找和排序的总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中所必会的查找和排序算法。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【事件流与委托】</title>
    <link href="http://yoursite.com/2019/05/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%8E%E5%A7%94%E6%89%98%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/02/前端面试之道【事件流与委托】/</id>
    <published>2019-05-01T23:18:56.655Z</published>
    <updated>2019-05-02T12:21:00.845Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>事件流与委托是前端重点内容之一！</p><a id="more"></a><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><blockquote><p>浏览器开发团队遇到的问题是，当点击页面的某一元素的时候，不仅点击了当前源苏苏，而且也点击了包含当前元素的容器，也相当于点击了整个页面。然而为了规范页面中的事件的接收顺序，两个浏览器团队提出了完全相反的想法。</p></blockquote><h3 id="一、事件流"><a href="#一、事件流" class="headerlink" title="一、事件流"></a>一、事件流</h3><blockquote><p>所谓的事件流描述的是从页面中接收事件的顺序。</p><p>1）IE 提出的是<strong>事件冒泡流</strong>。</p><p>2）NC 提出的是<strong>事件捕获流</strong>。</p></blockquote><h4 id="1、事件冒泡"><a href="#1、事件冒泡" class="headerlink" title="1、事件冒泡"></a>1、事件冒泡</h4><blockquote><p>IE 的事件流叫做事件冒泡。事件是从具体的元素接收，向上传播到不具体的结点。</p><p>1）所有的浏览器都支持事件冒泡。</p><p>2）IE 5 之前事件冒泡会跳过<code>&lt;html&gt;</code> 元素，从 <code>body</code> 到 <code>document</code>。</p><p>3）<code>IE 9</code>、<code>Firefox</code>、<code>Safari</code>、<code>Chrome</code> 等浏览器事件一直冒泡到 <code>window</code> 对象。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 例子</span><br><span class="line">div &gt; body &gt; html &gt; document &gt; window // 当点击页面的 div 元素时，事件的传播顺序</span><br></pre></td></tr></table></figure><h4 id="2、事件捕获"><a href="#2、事件捕获" class="headerlink" title="2、事件捕获"></a>2、事件捕获</h4><blockquote><p>NC 提出的另一个事件流叫做事件捕获。事件从不具体的结点到具体的元素。用意是事件到达预定的目标结点之前捕获它。</p><p>1）老版本的浏览器只支持事件冒泡，不支持事件捕获。</p><p>2）一般没有特殊要求，都是用事件冒泡。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 例子</span><br><span class="line">window &gt; document &gt; html &gt; body &gt; div // 当点击页面的 div 元素时，事件的传播顺序</span><br></pre></td></tr></table></figure><h4 id="3、DOM-事件流"><a href="#3、DOM-事件流" class="headerlink" title="3、DOM 事件流"></a>3、DOM 事件流</h4><blockquote><p>“DOM2” 的事件流包括三个阶段，<strong>事件捕获、处于目标阶段、事件冒泡阶段</strong>。</p><p>1）一般「处于目标阶段」属于事件「冒泡阶段」的一部分。</p><p>1）<code>IE 9</code>、<code>Firefox</code>、<code>Safari</code>、<code>Chrome</code> 等浏览器会在事件捕获阶段触发事件对象上的目标。相当于有两个机会在目标对象上操作事件。</p><p>2）<code>IE 8</code> 更早的版本不支持 <code>DOM</code> 事件流。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 事件捕获</span><br><span class="line">window &gt; document &gt; html &gt; body</span><br><span class="line">// 处于目标阶段</span><br><span class="line">body &gt; div </span><br><span class="line">// 事件冒泡阶段</span><br><span class="line">div &gt; body &gt; html &gt; document &gt; window</span><br></pre></td></tr></table></figure><h3 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h3><p>链接：<a href="http://luxiangqiang.xn--6qq986b3xl/2019/04/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%91/" target="_blank" rel="noopener">事件绑定和事件对象</a></p><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><blockquote><p>事件处理程序的数量直接关系到页面的性能问题，主要分为两个方面：</p><p>1）每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。</p><p>2）事先指定所有事件处理程序而导致的 <code>DOM</code> 访问次数过多，会延迟整个页面的交互就绪时间。</p></blockquote><h3 id="一、事件委托"><a href="#一、事件委托" class="headerlink" title="一、事件委托"></a>一、事件委托</h3><blockquote><p>为了解决“事件绑定”过多的问题，解决方案是<strong>事件委托</strong>。利用事件冒泡，只需绑定一个事件处理程序，就可以管理页面所有的事件。</p></blockquote><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><blockquote><p>1）事件委托，只需将事件处理程序绑定到 <code>DOM</code> 树最高的层次上。</p><p>2）一般考虑绑定到页面的 <code>document</code> 对象上。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定到 document 对象上</span></span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"click"</span>, handler);</span><br><span class="line"><span class="keyword">const</span> handler = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent();</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.getTarget(event);</span><br><span class="line">    <span class="keyword">if</span> (target.name &amp;&amp; target.id) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (target.name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'delete'</span>:   </span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'edit'</span>:</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'selectImg'</span>:</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'updataImg'</span>:</span><br><span class="line">               </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'modifyStaffInfo'</span>:</span><br><span class="line">               </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'modelYes'</span>:   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h4><blockquote><p>1）<code>document</code> 很快就可以访问，页面呈现的元素立即具备了绑定的功能。</p><p>2）页面设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的 <code>DOM</code> <strong>引用更少</strong>，<strong>时间就越少</strong>。</p><p>3）整个页面占用的<strong>内存空间少</strong>，提升了整体的性能。</p></blockquote><h3 id="二、移除事件绑定"><a href="#二、移除事件绑定" class="headerlink" title="二、移除事件绑定"></a>二、移除事件绑定</h3><blockquote><p>页面元素在绑定事件处理程序的时候，浏览器中的代码就会和 javascript 代码之间建立一个链接。这种链接越多，页面就会越慢。</p><p>1）事件委托减少事件绑定，限制连接的数量。</p><p>2）在不需要时移除时间绑定程序（内存中留有不用的处理程序）。</p></blockquote><h4 id="1、两种情况"><a href="#1、两种情况" class="headerlink" title="1、两种情况"></a>1、两种情况</h4><blockquote><p>造成以上问题的两种情况：</p><p><strong>1）文档中移除绑定事件的元素。</strong>虽然元素被移除，但是事件处理程序还在内存中，无法当做垃圾被回收,因为虽然元素被移除了，但是在内存中与元素保持的引用的关系。</p><p>例如：<code>removeChild()</code> 和 <code>replaceChild()</code> 方法，更多的是使用 <code>innerHtml</code> 替换页面的一部分。</p><p><strong>2）卸载页面的时候。</strong>如果在页面卸载之前没有清理干净事件处理程序，还会存储在内存中。不断的刷新、卸载页面使得内存中事件处理程序的数量越来越多，因为事件处理程序占用的内存空间有没释放掉。</p></blockquote><h4 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h4><blockquote><p>通过 onunload 事件处理在页面卸载的时候，将页面中绑定的事件处理程序全部移除掉。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件流与委托是前端重点内容之一！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端功能之【Datatables插件】</title>
    <link href="http://yoursite.com/2019/04/28/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E4%B9%8B%E3%80%90Datatables%E6%8F%92%E4%BB%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/28/前端功能之【Datatables插件】/</id>
    <published>2019-04-28T14:43:59.565Z</published>
    <updated>2019-04-28T15:44:37.722Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Datatables 功能插件的使用详细讲解！</p><a id="more"></a><h3 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h3><h4 id="1、引用插件"><a href="#1、引用插件" class="headerlink" title="1、引用插件"></a>1、引用插件</h4><blockquote><p>首先引入 Datatables 插件、Bootstrap、jQuery 插件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--DataTables js--&gt;</span><br><span class="line">&lt;script src=<span class="string">"assets/plugins/Datatable/js/jquery.dataTables.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"assets/plugins/Datatable/js/dataTables.bootstrap4.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2、HTML-表格"><a href="#2、HTML-表格" class="headerlink" title="2、HTML 表格"></a>2、HTML 表格</h4><blockquote><p>在界面添加 HTML 表格代码。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 行标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每列的标题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-15p"</span>&gt;</span>权限<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-15p"</span>&gt;</span>登陆号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-20p"</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-15p"</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表格内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bella<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Chloe<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>System Developer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>2018/03/12<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、Datatables-语言设置"><a href="#3、Datatables-语言设置" class="headerlink" title="3、Datatables 语言设置"></a>3、Datatables 语言设置</h4><blockquote><p>Datatables 默认的语言设置是英文，我们要将其设置为中文。在 <code>$(document).render(function(){})</code> <code>HTML</code> 结构渲染完进行设置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">let</span> table = $(<span class="string">'#example'</span>).DataTable(&#123;</span><br><span class="line">        <span class="comment">// Datatable 语言设置</span></span><br><span class="line">        <span class="string">'language'</span>: &#123;</span><br><span class="line">            <span class="comment">// 左上角的显示数量设置</span></span><br><span class="line">            <span class="string">"lengthMenu"</span>: <span class="string">'每页显示&lt;select class="form-control"&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="10"&gt;10&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="20"&gt;20&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="30"&gt;30&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="40"&gt;40&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="50"&gt;50&lt;/option&gt;'</span> + <span class="string">'&lt;/select&gt;条'</span>,</span><br><span class="line">            <span class="comment">// 右下角的翻页设置</span></span><br><span class="line">            <span class="string">"paginate"</span>: &#123;</span><br><span class="line">                <span class="string">"first"</span>: <span class="string">"首页"</span>,</span><br><span class="line">                <span class="string">"last"</span>: <span class="string">"尾页"</span>,</span><br><span class="line">                <span class="string">"previous"</span>: <span class="string">"上一页"</span>,</span><br><span class="line">                <span class="string">"next"</span>: <span class="string">"下一页"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"processing"</span>: <span class="string">"加载中..."</span>,  <span class="comment">// DataTables载入数据时，是否显示进度条 </span></span><br><span class="line">            <span class="string">"emptyTable"</span>: <span class="string">"暂无数据"</span>,   <span class="comment">// 表格无数据时显示情况</span></span><br><span class="line">            <span class="string">"info"</span>: <span class="string">"共 _PAGES_ 页  _TOTAL_ 条数据  "</span>,</span><br><span class="line">            <span class="string">"infoEmpty"</span>: <span class="string">"暂无数据"</span>,</span><br><span class="line">            <span class="string">"emptyTable"</span>: <span class="string">"暂无要处理的数据..."</span>,  <span class="comment">//表格中无数据</span></span><br><span class="line">            <span class="string">"search"</span>: <span class="string">"搜索:"</span>,</span><br><span class="line">            <span class="string">"infoFiltered"</span>: <span class="string">" —— 从  _MAX_ 条数据中筛选"</span>,</span><br><span class="line">            <span class="string">"zeroRecords"</span>: <span class="string">"没有找到记录"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// datatables 自带的 ajax 请求数据</span></span><br><span class="line">        <span class="string">"ajax"</span>: &#123;</span><br><span class="line">            url: <span class="string">''</span>, <span class="comment">// 请求的 url</span></span><br><span class="line">            method: <span class="string">'post'</span>, <span class="comment">// 请求方式</span></span><br><span class="line">            timeout: <span class="number">5000</span>,  <span class="comment">// 请求延迟</span></span><br><span class="line">            dataType: <span class="string">'JSON'</span>, <span class="comment">// 数据类型</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">let</span> alldata = [<span class="string">'role'</span>, <span class="string">'name'</span>, <span class="string">'password'</span>];</span><br><span class="line">        <span class="comment">// 设置后台返回的字段名，Datatable 会自动填充</span></span><br><span class="line"><span class="string">'columns'</span>: [</span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'role'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'name'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'password'</span> &#125;,</span><br><span class="line"><span class="comment">// name 为每一行传入的 data 字段</span></span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'name'</span>,</span><br><span class="line"><span class="string">'render'</span>:<span class="function"><span class="keyword">function</span>(<span class="params">data,type,row,meta</span>)</span>&#123;</span><br><span class="line">                                <span class="comment">// 自定义代码（一般添加增、删、改按钮），data 为传入的 name 值</span></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">`&lt;button name="add" id="add_<span class="subst">$&#123;data&#125;</span>"&gt;添加&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;button name="delete" id="delete_<span class="subst">$&#123;data&#125;</span>"&gt;删除&lt;/button&gt;`</span> </span><br><span class="line"><span class="keyword">return</span> html;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">         <span class="comment">// cells 存储着所有行对象（通过 . 可获取属性）</span></span><br><span class="line">         createdRow: <span class="function"><span class="keyword">function</span> (<span class="params">row, data, dataIndex, cells</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; alldata.length; i++) &#123;</span><br><span class="line">             <span class="comment">// 为每一行元素添加唯一标识 ID</span></span><br><span class="line">             cells[i].id = alldata[i]</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、为-Table-添加点击事件"><a href="#4、为-Table-添加点击事件" class="headerlink" title="4、为 Table 添加点击事件"></a>4、为 Table 添加点击事件</h4><blockquote><p>通过事件委托的方式添加事件监听。</p><p>1）虽然监听事件添加到 <code>table</code> 上，但是可以通过  <code>event</code> 事件对象判断点击了哪一个 <code>id</code> 或 <code>name</code> 的控件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#example'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每一行数据中每个字段的 name 值和 id 值</span></span><br><span class="line">    <span class="keyword">if</span> (event.target.name &amp;&amp; event.target.id) &#123;</span><br><span class="line">        <span class="comment">// 通过判断 name 值来确定删除/添加</span></span><br><span class="line">        <span class="keyword">switch</span> (event.target.name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">                <span class="comment">// 对表格做添加数据</span></span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'delete'</span>:</span><br><span class="line">                <span class="comment">// 对该行做删除处理</span></span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5、获取同行的所有数据"><a href="#5、获取同行的所有数据" class="headerlink" title="5、获取同行的所有数据"></a>5、获取同行的所有数据</h4><blockquote><p>通过点击某按钮的 id 获取父节点，从而达到获取同行的数据。</p><p>1）得到同一行数据之后，我们可以进行传值编辑或者删除一行数据。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同行某点击事件的 id</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSameValue</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取该 id 父节点的所有兄弟节点（存储所有数据的结点）</span></span><br><span class="line">    <span class="keyword">let</span> values = $(<span class="string">'#'</span> + id).parent().parent().siblings();</span><br><span class="line">    <span class="comment">// 以键值对的方式存储到 map 中</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 将同一行的数据 name:value 遍历出来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> obj <span class="keyword">of</span> values) &#123;</span><br><span class="line">        <span class="comment">// 通过结点得到想要的属性存储起来</span></span><br><span class="line">        result.set(obj.id, obj.outerText);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 map</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、删除一行数据"><a href="#6、删除一行数据" class="headerlink" title="6、删除一行数据"></a>6、删除一行数据</h4><blockquote><p>得到同一行数据之后，进行删除操作。</p><p>1）删除一行需要的到该行的 DOM 对象，可以通过目标值的父节点获取</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> row = event.target.parentNode.（...）.parentNode;</span><br><span class="line"><span class="comment">// 进行删除更新</span></span><br><span class="line">table.row(row).remove().draw(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h4 id="7、添加一行数据"><a href="#7、添加一行数据" class="headerlink" title="7、添加一行数据"></a>7、添加一行数据</h4><blockquote></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> table = $(<span class="string">'#example'</span>).DataTable(&#123;&#125;)</span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line">table.ajax.reload(<span class="literal">null</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Datatables 功能插件的使用详细讲解！&lt;/p&gt;
    
    </summary>
    
      <category term="前端功能实现" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="前端功能实现" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【事件绑定】</title>
    <link href="http://yoursite.com/2019/04/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/28/前端面试之道【事件绑定】/</id>
    <published>2019-04-28T02:12:55.467Z</published>
    <updated>2019-04-30T00:53:47.799Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>js 事件的处理程序！</p><a id="more"></a><h2 id="事件绑定（事件处理程序）"><a href="#事件绑定（事件处理程序）" class="headerlink" title="事件绑定（事件处理程序）"></a>事件绑定（事件处理程序）</h2><h3 id="一、HTML-事件绑定"><a href="#一、HTML-事件绑定" class="headerlink" title="一、HTML 事件绑定"></a>一、HTML 事件绑定</h3><blockquote><p>最直接的事件绑定就是在 <code>HTML</code> 上做处理，显式的为按钮绑定 <code>click</code> 事件，用户点击按钮就会触发事件。</p></blockquote><h4 id="1、事件绑定定义"><a href="#1、事件绑定定义" class="headerlink" title="1、事件绑定定义"></a>1、事件绑定定义</h4><p>1）<code>onClick</code> 特性的值是 <code>javascript</code> ，所以不能在内使用未转义的 <code>HTML</code> 语法字符。</p><p>2）<code>onClick</code> 也可以调用页面定义的脚本（函数名）。也可以是外部文件，事件处理程序有权访问全局变量。</p><p>3）<code>onClick</code> 内定义的函数自带的一个 <code>event</code>变量存储事件对象，通过 <code>event</code> 变量可以访问事件对象的属性值（也可以使用 <code>this</code> ，<code>this</code> 指向事件对象本身）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、onClick 内不能使用未转义的 HTML 语法字符（单引号）</span></span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"alert(&amp;quot;Clicked&amp;quot;)"</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、调用页面其他地方的脚本</span></span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"showMessage()"</span> /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">showMessage = ()=&#123;</span><br><span class="line">        alert(<span class="string">"Hello Word"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、event 事件对象</span></span><br><span class="line">&lt;!--两个都输出‘点击我’--&gt;</span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"alert('event.value')"</span> /&gt; </span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"alert(this.value)"</span> /&gt;</span><br></pre></td></tr></table></figure><h4 id="2、存在的缺点"><a href="#2、存在的缺点" class="headerlink" title="2、存在的缺点"></a>2、存在的缺点</h4><h6 id="▉-缺点"><a href="#▉-缺点" class="headerlink" title="▉ 缺点"></a>▉ 缺点</h6><blockquote><p>1）用户在 <code>HTML</code> 元素一出现就点击元素触发相应的事件，但可能改事件还没有初始化（尚未具备执行的条件），导致报错。</p><p>2）<code>HTML</code> 和 <code>Javascript</code> 紧密耦合。修改事件时，会修改两处，所以一般不使用 <code>HTML</code> 事件绑定。</p></blockquote><h6 id="▉-解决"><a href="#▉-解决" class="headerlink" title="▉ 解决"></a>▉ 解决</h6><blockquote><p>1）加入 <code>try catch</code> 语句，在脚本函数没有被解析之前就点击了元素，就会引出错误。该错误不会让用户看见，而是被捕获。</p><p>2）不使用 <code>HTML</code> 事件绑定，而是转向使用 <code>javascript</code> 执行事件处理程序。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"try&#123;showMessage();&#125;catch(ex)&#123;&#125;"</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="二、DOM0-级事件绑定"><a href="#二、DOM0-级事件绑定" class="headerlink" title="二、DOM0 级事件绑定"></a>二、DOM0 级事件绑定</h3><blockquote><p>通过将一个函数的值赋值给事件处理程序的属性来绑定事件。</p><p>1）简单</p><p>2）跨浏览器</p></blockquote><h3 id="1、事件绑定定义-1"><a href="#1、事件绑定定义-1" class="headerlink" title="1、事件绑定定义"></a>1、事件绑定定义</h3><blockquote><p>1）先获取某个拥有事件处理程序属性的对象（属性一般都是小写，如 <code>onclick</code>），然后将该属性指向一个事件处理函数。</p><p>2）该方法被认为定义了元素的方法，处理事件是在该元素的作用域执行的，所以 <code>this</code>  指向该元素（可以通过 <code>this</code> 访问该元素的任何属性和方法）。</p><p>3）DOM0级事件处理是在事件的冒泡阶段进行绑定的。</p><p>4）删除元素的绑定事件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = documentElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var btn = documentElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id) <span class="comment">// 输出 myBtn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="三、DOM2级事件绑定"><a href="#三、DOM2级事件绑定" class="headerlink" title="三、DOM2级事件绑定"></a>三、DOM2级事件绑定</h3><blockquote><p>DOM2 级事件处理程序定义了两个方法，分别是处理事件和删除事件的两个操作：<code>addEventListener()</code> 和 <code>removeEventListener()</code> 。</p></blockquote><h4 id="1、事件绑定定义-2"><a href="#1、事件绑定定义-2" class="headerlink" title="1、事件绑定定义"></a>1、事件绑定定义</h4><blockquote><p>1）可以添加多个事件处理函数。</p><p>2）移除函数必须和移除函数相同的参数。并且 <code>addEventListener()</code> 函数必须使用 <code>removeEventListener()</code> 才能移除。</p></blockquote><p>该函数接受三个参数：</p><ul><li>要处理的事件名；</li><li>绑定的函数；</li><li>布尔值（<code>true</code>：表示捕获阶段调用事件程序，<code>false</code>：表示冒泡阶段调用事件程序）；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为 btn 绑定了两个事件处理函数，按顺序执行</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>) <span class="comment">// 先执行 HelloWord</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)  <span class="comment">// 再执行 ID</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这里的 function 和上方不是同一个函数，所以移除失败</span></span><br><span class="line"><span class="comment">// 通过将同一个函数赋值给统一的变量，就可以视作为统一参数</span></span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h4 id="2、兼容性"><a href="#2、兼容性" class="headerlink" title="2、兼容性"></a>2、兼容性</h4><blockquote><p>1）DOM2 级事件处理程序兼容的浏览器有 IE9、Firefox、Safari、Chrome 和 Opera 。</p><p>2）大多情况下，都将事件处理程序添加到冒泡阶段，为了最大限度的兼容各种浏览器。</p></blockquote><h3 id="四、IE-事件绑定"><a href="#四、IE-事件绑定" class="headerlink" title="四、IE 事件绑定"></a>四、IE 事件绑定</h3><blockquote><p>1）IE 实现了与 DOM 类中的两个方法：<code>attachEvent()</code> 和 <code>detachEvent()</code>。</p><p>2）IE8 版本之前所有的事件绑定都是在冒泡阶段。</p><p>3）IE 与 <code>DOM0</code> 级绑定事件的区别在于事件的作用域是「<strong>全局变量</strong>」（ <code>this</code> 指向 <code>window</code> 作用域）。</p><p>4）可以通过 <code>attach</code> 添加多个事件，且「<strong>执行顺序和 <code>DOM2</code> 级相反</strong>」。</p><p>5）<code>detachEvent</code> 删除事件也必须提供相同的参数，匿名函数无效。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.attach(<span class="string">'onclick'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>) <span class="comment">// 再执行 HelloWord</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)  <span class="comment">// 先执行 ID</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除无效</span></span><br><span class="line">btn.detachEvent(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="五、跨浏览器的事件绑定"><a href="#五、跨浏览器的事件绑定" class="headerlink" title="五、跨浏览器的事件绑定"></a>五、跨浏览器的事件绑定</h3><blockquote><p>为了能够保证事件绑定能在大多数的浏览器下运行，一般有两种方式：</p><p>1）使用能够隔离浏览器差异的 javascript 库。</p><p>2）自己开发合适的功能，使用能力检测，保证能够在大多数的浏览器下运行。</p><p>3）该程序没有考虑到浏览器的所有问题。如：在 IE 中的作用域问题。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    <span class="comment">// 绑定事件</span></span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 解除绑定</span></span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.detachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><blockquote><p>当触发 DOM 的某个事件时，就会产生一个 event 对象，对象中包含着与事件相关信息。</p></blockquote><h3 id="一、DOM-中的事件对象"><a href="#一、DOM-中的事件对象" class="headerlink" title="一、DOM 中的事件对象"></a>一、DOM 中的事件对象</h3><h4 id="1、this、currentTarget、target"><a href="#1、this、currentTarget、target" class="headerlink" title="1、this、currentTarget、target"></a>1、this、currentTarget、target</h4><blockquote><p>1）当事件直接绑定到目标事件时，三者的值相同。</p><p>2）当事件绑定到目标事件的父节点上，<code>this</code>  与<code>currentTarget</code> 的值与 <code>target</code> 的值不相同。</p><p>当点击该按钮时，事件的绑定是按钮的父节点，所以目标对象 target 是指向按钮元素的（<code>click</code> 的真正目标），由于按钮没有绑定事件处理程序，所以 <code>click</code> 事件冒泡到 <code>document.body</code> 事件才得到处理 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将事件绑定 btn 按钮的父节点上</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    alert(event.target === <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、处理多个事件"><a href="#2、处理多个事件" class="headerlink" title="2、处理多个事件"></a>2、处理多个事件</h4><blockquote><p>为了能够减少代码量，通过 <code>event.type</code> 来确定一个函数处理多个事件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">handler = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">            <span class="comment">//要处理的点击事件</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">            <span class="comment">// 要处理的鼠标进入事件</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">            <span class="comment">// 要处理的鼠标滑出事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.mouseover = handler;</span><br><span class="line">btn.mouseout = handler;</span><br></pre></td></tr></table></figure><h4 id="3、阻止默认的事件行为"><a href="#3、阻止默认的事件行为" class="headerlink" title="3、阻止默认的事件行为"></a>3、阻止默认的事件行为</h4><blockquote><p>可以通过使用 <code>preventDefault()</code> 方法来取消默认的行为（必须设置属性 <code>cancelable</code> 为 <code>true</code>），如 <code>a</code>标签的链接事件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">link.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event.cancelable = <span class="literal">true</span>;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、立即停止事件的传播"><a href="#4、立即停止事件的传播" class="headerlink" title="4、立即停止事件的传播"></a>4、立即停止事件的传播</h4><blockquote><p>通过设置 <code>stopPropagation()</code> 方法立即停止在 DOM 层次中的传播（停止事件的捕获或冒泡）。</p><p>1）通过这种方式可以避免发生在父节点绑定的事件处理程序。</p></blockquote><h3 id="二、IE-中的事件对象"><a href="#二、IE-中的事件对象" class="headerlink" title="二、IE 中的事件对象"></a>二、IE 中的事件对象</h3><blockquote><p>IE 中事件对象 <code>event</code> 有一种不同的方式。</p><p>1）DOM0 级：<code>event</code> 作为 <code>window</code> 的一个属性。</p><p>2）attatach 添加的：传入一个 event 对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">    alert(event.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、srcElement"><a href="#1、srcElement" class="headerlink" title="1、srcElement"></a>1、srcElement</h4><blockquote><p><code>srcElement</code> 属性相当于 <code>DOM</code> 中的 <code>target</code> 属性，用来确定事件目标对象的。</p><p>1）因为事件处理程序的作用域是根据指定它的方式来确定，所以 <code>this</code> 不一定指向目标对象。因此我们通常用 <code>srcElement</code> 来替换。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>,(event)=&gt;&#123;</span><br><span class="line">    alert(event.srcElement === <span class="keyword">this</span>) <span class="comment">// false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2、阻止默认的事件行为"><a href="#2、阻止默认的事件行为" class="headerlink" title="2、阻止默认的事件行为"></a>2、阻止默认的事件行为</h4><blockquote><p>只要将 <code>returnValue</code> 设置为 <code>false</code> 就可以阻止默认的行为。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">link.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、立即停止事件的传播"><a href="#3、立即停止事件的传播" class="headerlink" title="3、立即停止事件的传播"></a>3、立即停止事件的传播</h4><blockquote><p>设置 <code>cancelBubble</code> 属性即可停止事件的传播。由于 IE 中只有冒泡阶段，所以也只能阻止冒泡阶段在 DOM 层次中的传播。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble  = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、跨浏览器的事件对象"><a href="#三、跨浏览器的事件对象" class="headerlink" title="三、跨浏览器的事件对象"></a>三、跨浏览器的事件对象</h3><blockquote><p>不同浏览器中的 Event 对象是不同的，所以要写一个跨浏览器的事件对象。</p></blockquote><h4 id="1、定义-Event-事件"><a href="#1、定义-Event-事件" class="headerlink" title="1、定义 Event 事件"></a>1、定义 Event 事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> EventUtil = &#123;</span><br><span class="line">    <span class="comment">// 绑定事件</span></span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 解除绑定</span></span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.detachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取事件对象</span></span><br><span class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取事件目标对象</span></span><br><span class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 阻止事件</span></span><br><span class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event.preventDefault)&#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            event.returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 立即停止事件传播</span></span><br><span class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event.stopPropagation)&#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、调用-Event-对象事件"><a href="#2、调用-Event-对象事件" class="headerlink" title="2、调用 Event 对象事件"></a>2、调用 Event 对象事件</h4><blockquote><p>1）<code>getEvent()</code></p><p>2）<code>getTarget()</code></p><p>3）<code>preventDefault（）</code></p><p>4）<code>stopPropagation（）</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IE 不存在 event (undefined)就返回 window.event</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标对象</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.getTarget(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻止事件</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.preventDefault(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即停止事件传播</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.stopPropagation(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js 事件的处理程序！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【异步编程】</title>
    <link href="http://yoursite.com/2019/04/25/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/25/前端面试之道【异步编程】/</id>
    <published>2019-04-25T09:17:54.497Z</published>
    <updated>2019-04-27T12:55:53.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>js 异步常考面试题！</p><a id="more"></a><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><blockquote><p>面试题一：并发和并行的区别？</p></blockquote><p><strong>※ 答✔：</strong></p><ul><li>并发：宏观概念。两个任务在一段时间内同时完成切换。</li><li>并行：微观概念。同时完成两个任务。</li></ul><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><blockquote><p>面试题二：什么是回调函数？回调函数有什么缺点？如何理解回调地狱的问题？</p></blockquote><p><strong>※ 答✔：什么是回调函数</strong></p><blockquote><p>回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该<strong>事件</strong>或<strong>条件</strong>进行响应 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>※ 答✔：回调函数有什么缺点？</strong></p><blockquote><p>容易写成回调地狱问题。也就是多个请求存在依赖性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>※ 答✔：如何理解回调地狱问题？</strong></p><blockquote><p>回调地狱存在几个问题如下：</p><p>1）嵌套函数存在耦合性，一旦有所改动，牵一发而动全身。</p><p>2）嵌套函数一多，就很难处理错误。</p><p>3）回调函数不能使用 <code>try catch</code>  捕获异常(异常的捕获只能在函数执行的时候才能捕获到)。</p><p>4）回调函数不能直接 <code>return</code> 。</p></blockquote><p><strong>※ 答✔：如何解决回调地狱问题？</strong></p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote><p>面试三：你理解的 Generator 是什么？</p></blockquote><blockquote><p>1）一般 <code>generator</code> 配合 co 库（用于 <code>generator</code> 函数的自动执行 ）去使用。</p><p><code>Generator</code> 最大的特点就是可以控制函数的执行，下面是最容易困惑的点也是难点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span> (y + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = foo(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.next()); =&gt; &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="number">4</span>));=&gt; &#123;<span class="attr">value</span>: <span class="number">10</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="number">1</span>));=&gt; &#123;<span class="attr">value</span>: <span class="number">9</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><p>执行过程分析：</p><p>1）<code>generator</code> 函数的调用会返回一个迭代器。</p><p>2）执行第一次 <code>next</code> ，传入的 <code>next</code> 参数会被忽略，执行会停止在第一个 <code>yield</code> 处，返回其值。</p><p>3）执行第二次 <code>next</code> ，传入的参数代表第一个 <code>yield</code> 的返回值，<code>let y = 2 * 4</code> ，所以返回 <code>y + 2 = 8 + 2 = 10</code>  。如果不传入参数，就返回 <code>undefined</code>，打印的值为 <code>NAN</code> 。</p><p>4）执行第三个 <code>next</code>，传入的参数会代表第二个 <code>yield</code> 的返回值，<code>y + z = 8 + 1 = 9</code> 。</p><blockquote><p>我们可以通过 <code>generator</code> 解决回调地狱问题。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> ajax(url, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url1, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url2, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch()</span><br><span class="line"><span class="keyword">let</span> result1 = it.next()</span><br><span class="line"><span class="keyword">let</span> result2 = it.next()</span><br><span class="line"><span class="keyword">let</span> result3 = it.next()</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote><p>面试四：Promise 的特点是什么？分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？</p></blockquote><p>1、了解 Promise 吗？</p><p>2、Promise 解决的痛点是什么？</p><p>3、Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。</p><p>4、Promise 如何使用？</p><p>5、Promise 常用的方法有哪些？它们的作用是什么？</p><p>6、Promise 在事件循环中的执行过程是怎样的？</p><p>7、Promise 的业界实现都有哪些？</p><p>8、能不能手写一个 Promise 的 polyfill。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js 异步常考面试题！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端功能之【选取图片并显示】</title>
    <link href="http://yoursite.com/2019/04/21/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E4%B9%8B%E3%80%90%E9%80%89%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/21/前端功能之【选取图片并显示】/</id>
    <published>2019-04-21T00:33:00.035Z</published>
    <updated>2019-04-21T01:33:49.516Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本地选取图片并显示！</p><a id="more"></a><h3 id="一、选取本地图片"><a href="#一、选取本地图片" class="headerlink" title="一、选取本地图片"></a>一、选取本地图片</h3><h4 id="1、HTML"><a href="#1、HTML" class="headerlink" title="1、HTML"></a>1、HTML</h4><h6 id="▉-accept-属性"><a href="#▉-accept-属性" class="headerlink" title="▉ accept 属性"></a>▉ accept 属性</h6><blockquote><p>控制选取照片的类型。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 建议只选择照片使用这种写法</span><br><span class="line">accept=&quot;image/png, image/jpeg, image/gif, image/jpg&quot;</span><br><span class="line">// 其次这种写法</span><br><span class="line">accept=&quot;image/*&quot;</span><br></pre></td></tr></table></figure><h6 id="▉-multiple-属性"><a href="#▉-multiple-属性" class="headerlink" title="▉ multiple 属性"></a>▉ multiple 属性</h6><blockquote><p>用来选择多个文件上传。</p></blockquote><h6 id="▉-改变样式"><a href="#▉-改变样式" class="headerlink" title="▉ 改变样式"></a>▉ 改变样式</h6><blockquote><p>通过使用 <code>lable</code>  <code>for</code> 的联动改变上传按钮的样式。</p><p>1）<code>input</code> 需要设置 <code>display:none</code> 属性进行隐藏。</p><p>2）然后通过 <code>lable</code> 的 <code>for</code> 的值为<code>input</code> 的<code>ID</code> 属性值。</p></blockquote><h6 id="▉-实例"><a href="#▉-实例" class="headerlink" title="▉ 实例"></a>▉ 实例</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// input 选取</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"user_icon"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">onchange</span>=<span class="string">"preImg(this.id,'image_icon',this)"</span> <span class="attr">style</span>=<span class="string">"display: none"</span> /&gt;</span></span><br><span class="line">// 按钮</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"choose_icon"</span>&gt;</span>选择照片<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// 显示图片</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"image_icon"</span> <span class="attr">width</span>=<span class="string">"138"</span> <span class="attr">height</span>=<span class="string">"150"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、javascript"><a href="#2、javascript" class="headerlink" title="2、javascript"></a>2、javascript</h4><h6 id="▉-限制照片大小"><a href="#▉-限制照片大小" class="headerlink" title="▉ 限制照片大小"></a>▉ 限制照片大小</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加内容：图片大小限制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">limitFileSize</span>(<span class="params">sourceId</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//图片大小限制</span></span><br><span class="line">    <span class="keyword">var</span> fileSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> fileMaxSize = <span class="number">1024</span>;<span class="comment">//1024k</span></span><br><span class="line">    <span class="comment">// 通过 input ID 获取到图片的大小</span></span><br><span class="line">    fileSize = <span class="built_in">document</span>.getElementById(sourceId).files.item(<span class="number">0</span>).size;</span><br><span class="line">    <span class="keyword">var</span> size = fileSize / <span class="number">1024</span>; <span class="comment">//转换成 KB</span></span><br><span class="line">    <span class="keyword">if</span>(size &gt;= fileMaxSize)&#123;</span><br><span class="line">        alert(<span class="string">"文件大小不能大于 1 M！"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        alert(<span class="string">"文件大小不能小于 0 M！"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-显示图片"><a href="#▉-显示图片" class="headerlink" title="▉ 显示图片"></a>▉ 显示图片</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示图片</span></span><br><span class="line"><span class="comment">// sourceId: ipnput id,sourceId: image id file: input object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preImg</span>(<span class="params">sourceId, targetId,file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = getFileUrl(sourceId);</span><br><span class="line">    <span class="keyword">var</span> imgPre = <span class="built_in">document</span>.getElementById(targetId);</span><br><span class="line">    <span class="comment">// 获取到的图片本地 url 设置 img 的 src 属性就 ok 了</span></span><br><span class="line">    imgPre.src = url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-判断浏览器类型"><a href="#▉-判断浏览器类型" class="headerlink" title="▉ 判断浏览器类型"></a>▉ 判断浏览器类型</h6><blockquote><p>不同的浏览器，选取图片 URL 的路径方式不相同。</p><p>1） 照片的路径就是 input 的 value 的值</p><p>2）选择 url 之前，要判断图片的大小。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择图片按钮监听</span></span><br><span class="line">$(<span class="string">"#choose_icon"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"#user_icon"</span>).click();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选取本地文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileUrl</span>(<span class="params">sourceId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url;</span><br><span class="line">    <span class="keyword">if</span> (navigator.userAgent.indexOf(<span class="string">"MSIE"</span>)&gt;=<span class="number">1</span>) &#123; <span class="comment">// IE</span></span><br><span class="line">        <span class="comment">//限制文件大小</span></span><br><span class="line">        <span class="keyword">if</span>(limitFileSize(sourceId))&#123;</span><br><span class="line">            <span class="comment">// 照片的路径就是 input 的 value 的值</span></span><br><span class="line">            url = <span class="built_in">document</span>.getElementById(sourceId).value;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(navigator.userAgent.indexOf(<span class="string">"Firefox"</span>)&gt;<span class="number">0</span>) &#123; <span class="comment">// Firefox</span></span><br><span class="line">        <span class="comment">//限制文件大小</span></span><br><span class="line">        <span class="keyword">if</span>(limitFileSize(sourceId))&#123;</span><br><span class="line">            url = <span class="built_in">window</span>.URL.createObjectURL(<span class="built_in">document</span>.getElementById(sourceId).files.item(<span class="number">0</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(navigator.userAgent.indexOf(<span class="string">"Chrome"</span>)&gt;<span class="number">0</span>) &#123; <span class="comment">// Chrome</span></span><br><span class="line">        <span class="comment">//限制文件大小</span></span><br><span class="line">        <span class="keyword">if</span>(limitFileSize(sourceId))&#123;</span><br><span class="line">            url = <span class="built_in">window</span>.URL.createObjectURL(<span class="built_in">document</span>.getElementById(sourceId).files.item(<span class="number">0</span>)); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、上传本地图片"><a href="#二、上传本地图片" class="headerlink" title="二、上传本地图片"></a>二、上传本地图片</h3><blockquote><p><code>enctype</code> 属性规定在发送到服务器之前应该如何对表单数据进行编码，默认的编码是：” <code>application/x-www-form-urlencoded</code> “。对于普通数据是挺适用的，对于文件，就不能乱编码了，该什么就是什么，只能使用 <code>multipart/form-data</code> 作为 <code>enctype</code> 属性值。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地选取图片并显示！&lt;/p&gt;
    
    </summary>
    
      <category term="前端功能实现" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="前端功能实现" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>小学生都能学会的 Git 之【Github 提交篇】</title>
    <link href="http://yoursite.com/2019/04/18/%E5%B0%8F%E5%AD%A6%E7%94%9F%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%20Git%20%E4%B9%8B%E3%80%90Github%E6%8F%90%E4%BA%A4%E7%AF%87%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/18/小学生都能学会的 Git 之【Github提交篇】/</id>
    <published>2019-04-18T14:42:23.921Z</published>
    <updated>2019-04-30T02:41:45.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Git 版本控制完整使用流程！</p><a id="more"></a><p>[TOC]</p><h3 id="一、创建版本库"><a href="#一、创建版本库" class="headerlink" title="一、创建版本库"></a>一、创建版本库</h3><h4 id="1、初始化仓库"><a href="#1、初始化仓库" class="headerlink" title="1、初始化仓库"></a>1、初始化仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h4 id="2、添加文件到版本库的缓存区"><a href="#2、添加文件到版本库的缓存区" class="headerlink" title="2、添加文件到版本库的缓存区"></a>2、添加文件到版本库的缓存区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xiaolu.txt</span><br></pre></td></tr></table></figure><h4 id="3、将缓存区文件提交到本地正式仓库"><a href="#3、将缓存区文件提交到本地正式仓库" class="headerlink" title="3、将缓存区文件提交到本地正式仓库"></a>3、将缓存区文件提交到本地正式仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;wrote a file&quot;</span><br></pre></td></tr></table></figure><h4 id="4、当前版本库的状态"><a href="#4、当前版本库的状态" class="headerlink" title="4、当前版本库的状态"></a>4、当前版本库的状态</h4><blockquote><p>比如修改了内容。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h4 id="5、查看修改的内容"><a href="#5、查看修改的内容" class="headerlink" title="5、查看修改的内容"></a>5、查看修改的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 文件名</span><br></pre></td></tr></table></figure><h4 id="6、查看提交记录"><a href="#6、查看提交记录" class="headerlink" title="6、查看提交记录"></a>6、查看提交记录</h4><blockquote><p><code>--pretty=oneline</code> 用于格式化。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure><h3 id="二、时光穿梭"><a href="#二、时光穿梭" class="headerlink" title="二、时光穿梭"></a>二、时光穿梭</h3><h4 id="1、版本回退"><a href="#1、版本回退" class="headerlink" title="1、版本回退"></a>1、版本回退</h4><blockquote><p>回到上一个版本 <code>HEAD^</code>，上上版本就是 <code>HEAD^^</code> ，100 个之前的版本 <code>HEAD~100</code> </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><h4 id="2、向后回滚"><a href="#2、向后回滚" class="headerlink" title="2、向后回滚"></a>2、向后回滚</h4><blockquote><p>1）如果窗口不关闭的情况下可以找到 <code>commit id</code> 。</p><p>2)  如果窗口关闭了，需要使用 <code>git reflog</code> 命令找到 <code>commit id</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1094a // 提供的提交 ID</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查看命令历史记录</span><br><span class="line">git reflog</span><br><span class="line">//878eae2 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 878ea</span><br><span class="line">//ad3b64b HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">//878eae2 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: 第二次提交</span><br><span class="line">//ad3b64b HEAD@&#123;3&#125;: commit (initial): xiaolu.txt</span><br></pre></td></tr></table></figure><h4 id="3、管理修改"><a href="#3、管理修改" class="headerlink" title="3、管理修改"></a>3、管理修改</h4><blockquote><p>查看工作区和版本区最新版本的区别。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD -- xiaolu.txt</span><br><span class="line"></span><br><span class="line">diff --git a/xiaolu.txt b/xiaolu.txt</span><br><span class="line">index fda2ac1..4832c20 100644</span><br><span class="line">--- a/xiaolu.txt</span><br><span class="line">+++ b/xiaolu.txt</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> 1111</span><br><span class="line"> 2222</span><br><span class="line">-333    // 版本区</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+333^M</span><br><span class="line">+444               // 工作区</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><h4 id="4、撤销修改"><a href="#4、撤销修改" class="headerlink" title="4、撤销修改"></a>4、撤销修改</h4><ul><li><strong>丢弃工作区的修改。</strong></li><li><strong>丢弃缓存区的添加</strong></li></ul><blockquote><p>让这个文件回到最近一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p><p>1）文件修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； </p><p>2）文件经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态 ；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- xiaolu.txt</span><br></pre></td></tr></table></figure><blockquote><p><strong>丢弃缓存区的添加</strong>，就是撤销 <code>git add</code> 命令操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD xiaolu.txt // HEAD 代表最新版本</span><br></pre></td></tr></table></figure><h4 id="5、删除文件"><a href="#5、删除文件" class="headerlink" title="5、删除文件"></a>5、删除文件</h4><blockquote><p>工作区删除了文件，导致工作区和版本库中的版本不一致所以杰西莱有两种选择。</p><p>1）将版本库中的该文件进行删除，然后提交。</p><p>2）不小心误删了工作区的文件，要回复工作区误删除的文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将版本库中的该文件进行删除</span><br><span class="line">git rm test.md</span><br><span class="line">git commit -m &apos;删除test&apos;</span><br><span class="line">// 恢复误删除的文件</span><br><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure><h3 id="三、远程仓库"><a href="#三、远程仓库" class="headerlink" title="三、远程仓库"></a>三、远程仓库</h3><blockquote><p>本地仓库和远程的仓库通信需要 SSH 加密的，需要设计一样的秘钥才可以进行通信。</p></blockquote><h6 id="▉-创建秘钥"><a href="#▉-创建秘钥" class="headerlink" title="▉ 创建秘钥"></a>▉ 创建秘钥</h6><p>本地仓库设置密钥需要和远程仓库及逆行加密通信。</p><blockquote><p>在 window 下创建 SSH Key，一路回车。在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><h6 id="▉-Github设置-key"><a href="#▉-Github设置-key" class="headerlink" title="▉ Github设置 key"></a>▉ Github设置 key</h6><p>在远程仓库设置一个或多个公钥知道有哪里的本地仓库要通信。</p><blockquote><p>登陆GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容，点“Add Key”，你就应该看到已经添加的Key 。</p></blockquote><h4 id="1、添加远程仓库"><a href="#1、添加远程仓库" class="headerlink" title="1、添加远程仓库"></a>1、添加远程仓库</h4><blockquote><p>1）将本地仓库和远程仓库进行关联之后才可以推送信息。</p><p>2）将本地所有内容推送到远程仓库。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 关联远程仓库</span><br><span class="line">git remote add origin 远程仓库地址</span><br><span class="line"></span><br><span class="line">//-u 参数不但会把 master 分支推上去，还会将关联两个分支</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h4 id="2、克隆仓库"><a href="#2、克隆仓库" class="headerlink" title="2、克隆仓库"></a>2、克隆仓库</h4><blockquote><p>从远程克隆下仓库。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 仓库地址</span><br></pre></td></tr></table></figure><h3 id="四、创建与合并分支"><a href="#四、创建与合并分支" class="headerlink" title="四、创建与合并分支"></a>四、创建与合并分支</h3><blockquote><p>HEAD 指针是指向 master 的，master 是指向提交的，通过切换 HEAD 指针来切换指针。</p></blockquote><h4 id="1、创建分支"><a href="#1、创建分支" class="headerlink" title="1、创建分支"></a>1、创建分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建分支</span><br><span class="line">git branch dev</span><br><span class="line">//切换分支</span><br><span class="line">git checkout dev</span><br><span class="line">// 创建并切换分支</span><br><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><h4 id="2、查看当前分支"><a href="#2、查看当前分支" class="headerlink" title="2、查看当前分支"></a>2、查看当前分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><h4 id="3、合并分支"><a href="#3、合并分支" class="headerlink" title="3、合并分支"></a>3、合并分支</h4><blockquote><p>Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 合并分支</span><br><span class="line">git merge dev</span><br><span class="line">Updating 9220589..b12c1f2</span><br><span class="line">Fast-forward</span><br><span class="line"> xiaolu.txt | 4 +++-</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><h4 id="4、删除分支"><a href="#4、删除分支" class="headerlink" title="4、删除分支"></a>4、删除分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><h3 id="五、解决冲突"><a href="#五、解决冲突" class="headerlink" title="五、解决冲突"></a>五、解决冲突</h3><blockquote><p>创建的新分支与主分支 master 都进行修改了，分支进行了分叉，出现合并冲突，不能正常合并。必须手动解决冲突。</p></blockquote><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0" alt="git-br-feature1"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 尝试合并,产生冲突</span><br><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging xiaolu.txt</span><br><span class="line">CONFLICT (content): Merge conflict in xiaolu.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 冲突信息</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:   xiaolu.txt</span><br></pre></td></tr></table></figure><blockquote><p>查看文件内容 <code>vi xiaolu.txt</code> 可以查看不同分值冲突的内容。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 查看文件内容</span><br><span class="line">vi xiaolu.txt</span><br><span class="line"></span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">333</span><br><span class="line">444</span><br><span class="line">dev·ÖÖ§¸üÐÂ</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">featrue ·ÖÖ§</span><br><span class="line">master ·ÖÖ§ÐÞ¸Ä</span><br><span class="line">=======</span><br><span class="line">featrue ·ÖÖ§</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00138490913052149c4b2cd9702422aa387ac024943921b000/0" alt="git-br-conflict-merged"> </p><blockquote><p>用 <code>git log</code> 带参数的情况看到分治合并情况。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 带参查看合并分支情况</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">*   34b90d1 (HEAD -&gt; master) 解决冲突后提交</span><br><span class="line">|\</span><br><span class="line">| * e890412 (feature1) featrue提交</span><br><span class="line">* | 775427c master提交</span><br><span class="line">|/</span><br><span class="line">* b12c1f2 在dev分支提交</span><br><span class="line">* 9220589 删除test文件</span><br><span class="line">* 89bd80c 添加新文件</span><br><span class="line">* 5564077 第三次提交</span><br><span class="line">* 878eae2 第二次提交</span><br><span class="line">* ad3b64b xiaolu.txt</span><br></pre></td></tr></table></figure><h3 id="六、分支管理策略"><a href="#六、分支管理策略" class="headerlink" title="六、分支管理策略"></a>六、分支管理策略</h3><blockquote><p>合并分支时，如果可能，Git会用 <code>Fast forward</code> 模式，但这种模式下，删除分支后，会丢掉分支信息 。要强制关闭该模式，git 就会在 merge 时生成一个新的 commit。</p></blockquote><h4 id="1、合并分支强制禁用-ff-模式"><a href="#1、合并分支强制禁用-ff-模式" class="headerlink" title="1、合并分支强制禁用 ff 模式"></a>1、合并分支强制禁用 ff 模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git merge --no-ff -m &apos;merge with no-ff&apos; dev</span><br><span class="line"></span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> xiaolu.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><h4 id="2、查看合并记录"><a href="#2、查看合并记录" class="headerlink" title="2、查看合并记录"></a>2、查看合并记录</h4><blockquote><p>不使用 Fast forward 模式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">*   9885e46 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * d303c02 (dev) dev分支提交修改</span><br><span class="line">|/</span><br><span class="line">*   34b90d1 解决冲突后提交</span><br><span class="line">|\</span><br><span class="line">| * e890412 featrue提交</span><br><span class="line">* | 775427c master提交</span><br><span class="line">|/</span><br><span class="line">* b12c1f2 在dev分支提交</span><br><span class="line">* 9220589 删除test文件</span><br><span class="line">* 89bd80c 添加新文件</span><br><span class="line">* 5564077 第三次提交</span><br><span class="line">* 878eae2 第二次提交</span><br><span class="line">* ad3b64b xiaolu.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909222841acf964ec9e6a4629a35a7a30588281bb000/0" alt="git-no-ff-mode"> </p><h4 id="3、分支策略"><a href="#3、分支策略" class="headerlink" title="3、分支策略"></a>3、分支策略</h4><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909239390d355eb07d9d64305b6322aaf4edac1e3000/0" alt="git-br-policy"> </p><blockquote><p>实际开发，按照这几个基本原则进行分支管理。</p><p>1）master 主分治，只用于发布新的版本，平时开发不能在此分支。</p><p>2）开发都在 dev 分支开发。每到一个阶段就要合并 master 分支进行版本发布。</p><p>3）多人合作，创建自己的分支，时不时的向 dev 分支合并。</p></blockquote><h3 id="七、Bug-分支"><a href="#七、Bug-分支" class="headerlink" title="七、Bug 分支"></a>七、Bug 分支</h3><blockquote><p>每当开发中有 Bug 时，需要通过新的临时分支来修复，修复后合并分支，然后临时分支删除。</p></blockquote><p>如果接到修改 Bug ，当前在 dev 分支工作还没提交，又不想提交，一天后才能开发完毕。只能将现场保护起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   test.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   xiaolu.txt</span><br></pre></td></tr></table></figure><h4 id="1、存储当前开发进度"><a href="#1、存储当前开发进度" class="headerlink" title="1、存储当前开发进度"></a>1、存储当前开发进度</h4><blockquote><p>当前的进度存储起来之后，回到主分支，然后创建 <code>bug</code> 分支，修改 <code>bug</code> 后提交，然后合并到 <code>master</code>分支，然后恢复现场进度。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 存储当前开发进度</span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: 9885e46 merge with no-ff</span><br></pre></td></tr></table></figure><h4 id="2、查看进度存储列表"><a href="#2、查看进度存储列表" class="headerlink" title="2、查看进度存储列表"></a>2、查看进度存储列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 9885e46 merge with no-ff</span><br></pre></td></tr></table></figure><h4 id="3、恢复开发进度"><a href="#3、恢复开发进度" class="headerlink" title="3、恢复开发进度"></a>3、恢复开发进度</h4><blockquote><p>两种方法：</p><p>1）<code>git stash apply</code> 恢复后的 stash 并不删除；通过 <code>git stash drop</code> 删除。</p><p>2）<code>git stash pop</code> 进行删除，stash 存储的开发进度被删除了。</p></blockquote><h4 id="4、恢复指定存储"><a href="#4、恢复指定存储" class="headerlink" title="4、恢复指定存储"></a>4、恢复指定存储</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><h3 id="八、Feature-分支"><a href="#八、Feature-分支" class="headerlink" title="八、Feature 分支"></a>八、Feature 分支</h3><blockquote><p>软件开发出现新功能，需要单独创建 <code>feature</code> 分支进行开发。</p></blockquote><p>如果开发增加一个功能，需要在新分支进行开发，但是中途取消了开发，就地需要删除已经开发的。回到主分支，删除该分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch &apos;feature-vulcan&apos; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;.</span><br></pre></td></tr></table></figure><blockquote><p>分支还没有进行合并，不能删除分支，所以我们要进行强制删除分支。</p></blockquote><h4 id="1、强制删除分支"><a href="#1、强制删除分支" class="headerlink" title="1、强制删除分支"></a>1、强制删除分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D feature-vulcan</span><br></pre></td></tr></table></figure><h3 id="九、多人合作"><a href="#九、多人合作" class="headerlink" title="九、多人合作"></a>九、多人合作</h3><blockquote><p>从远程仓库进行克隆，Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code> </p></blockquote><h4 id="1、远程仓库信息"><a href="#1、远程仓库信息" class="headerlink" title="1、远程仓库信息"></a>1、远程仓库信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remove -v</span><br></pre></td></tr></table></figure><h4 id="2、推送分支"><a href="#2、推送分支" class="headerlink" title="2、推送分支"></a>2、推送分支</h4><blockquote><p>把该分支上的所有<strong>本地提交</strong>推送到<strong>远程库</strong>。推送时，要指定本地分支。Git就会把该分支推送到远程库对应的远程分支上 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h4 id="3、抓取分支"><a href="#3、抓取分支" class="headerlink" title="3、抓取分支"></a>3、抓取分支</h4><blockquote><p>1）多人合作，克隆远程仓库，只能看到本地 <code>master</code> 分支。</p><p>2）要在 dev 开发，就必须创建远程 <code>origin</code> 的 <code>dev</code> 分支到本地，于是他用这个命令创建本地<code>dev</code>分支： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将本地 git 的头指针指向 origin 库的 dev 分支</span><br><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><h4 id="4、创建远程仓库分支"><a href="#4、创建远程仓库分支" class="headerlink" title="4、创建远程仓库分支"></a>4、创建远程仓库分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b my-test  //在当前分支下创建my-test的本地分支分支</span><br><span class="line">git push origin my-test  //将my-test分支推送到远程</span><br><span class="line">git branch --set-upstream-to=origin/my-test //将本地分支my-test关联到远程分支my-test上   </span><br><span class="line">git branch -a //查看远程分支</span><br></pre></td></tr></table></figure><h4 id="5、推送失败"><a href="#5、推送失败" class="headerlink" title="5、推送失败"></a>5、推送失败</h4><blockquote><p>1）如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并。</p><p>2）如果合并有冲突，则解决冲突，并在本地提交； </p><p>3）如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 版本控制完整使用流程！&lt;/p&gt;
    
    </summary>
    
      <category term="Git版本控制" scheme="http://yoursite.com/categories/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Git版本控制" scheme="http://yoursite.com/tags/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【原型】</title>
    <link href="http://yoursite.com/2019/04/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8E%9F%E5%9E%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/18/前端进阶深入系列之【原型】/</id>
    <published>2019-04-18T11:56:07.738Z</published>
    <updated>2019-04-21T08:08:48.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小鹿把自己想象成 js 的设计者，这一篇就让你搞明白是什么 js 中的原型！</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>小鹿，程序员一名，来自某大型公司，在这个兵荒马乱的年代，人人都盛行 java ，这时公司给小鹿下达任务，说小鹿呀，现今 java 那么盛行，咱们公司也没什么前景了，都让那个什么 java 公司把便宜占去了，如果咱们还不能有点创新或者说比无法超过现在流行的 java 的话 ，公司迟早要破产。</p><p>这样吧，给你个任务，这个任务关系重大，公司的生死存亡就掌握到你手中了 。你要在两星期内给我设计一款语言，并且在短时间内把现在流行的 java 超过去，事后给你 300 万美金，给你放个假可以去旅游。</p><p>小鹿一听，既兴奋又困惑。困惑的是，现在 java 那么盛行，用的人如此之多，设计一款什么样的语言才能脱颖而出，让大家真正的喜欢上这款语言呢？小鹿的内心还是很困惑的。</p><p>半夜，小鹿躺在床上怎么也不能入眠，想着要想真正的设计出一门出色的语言，一定要与众不同。</p><ul><li>设计结构一定要和 java 不同。</li><li>java 针对于后台服务器语言设计的，那么这门语言设计为前端交互性语言吧。</li><li>为了能够在两星期之内设计出来，有必要模仿一下 java 里边的设计。</li></ul><p>小鹿又想，设计的这门语言一定要起一个好名字，等这门语言发布了，名字都没听过说，怎么能让别人接受呢？这时，小鹿一机灵，可否语言名字中带有 java 的名字，这样一来，当人们新接触到这门语言时，就会对其产生好奇心，误认为是 java 的升级版，只能借此机会赌一把了！就叫做 javascript 吧！</p><h4 id="一、遇到的第一个问题（语言类型）"><a href="#一、遇到的第一个问题（语言类型）" class="headerlink" title="一、遇到的第一个问题（语言类型）"></a>一、遇到的第一个问题（语言类型）</h4><blockquote><p>面对现在盛行的 java ，是一款面向对象的设计语言，小鹿想了想，不想也在设计一款完全面向对象的语言，但是为了能够可以做到 java 能做到的一些操作，就将 java 拿来进行分析和模仿了。</p></blockquote><h4 id="1、原型模式"><a href="#1、原型模式" class="headerlink" title="1、原型模式"></a>1、原型模式</h4><blockquote><p><code>Java</code>：<code>Java</code> 中有类的概念，类中有一个构造器，通过构造器可以通过 new 生成一个实例。</p></blockquote><p>※ <code>Javascript</code> 的设计：</p><p><code>JavaScript</code> 起初没有引进类的概念，所以继承以及共享数据就成为了 <code>JavaScript</code>  设计的一个问题，后来，小鹿想，要想实现数据共享以及继承，要设计成没有类的概念也能完成这些操作，于是有了下面的原型模式。</p><h6 id="▉-实例对象"><a href="#▉-实例对象" class="headerlink" title="▉ 实例对象"></a>▉ 实例对象</h6><blockquote><p>在 java 中生成一个对象，直接通过 <code>new 类名()</code> 就可以生成对象，但是在 js 中并没有类的概念，小鹿是怎么设计的呢？</p></blockquote><p>在 <code>java</code> 中虽然  <code>new</code> 了一个类，但是这个过程中调用了构造函数；<code>javascript</code> 中虽然没有类的概念，那就直接 <code>new</code> 构造函数生成一个对象实例吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 猴子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monkey</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huanhuan = <span class="keyword">new</span> Monkey(<span class="string">'欢欢'</span>);</span><br><span class="line"><span class="keyword">let</span> lele = <span class="keyword">new</span> Dog(<span class="string">'乐乐'</span>);</span><br></pre></td></tr></table></figure><h6 id="▉-原型对象"><a href="#▉-原型对象" class="headerlink" title="▉ 原型对象"></a>▉ 原型对象</h6><blockquote><p>虽然可以通过 new 构造函数的的方式生成一个实例对象，但是存在一个问题就是生成的两个实例对象共享一个属性和方法应该怎么办？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monkey</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">'动物'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huanhuan = <span class="keyword">new</span> Monkey(<span class="string">'欢欢'</span>);</span><br><span class="line"><span class="keyword">let</span> lele = <span class="keyword">new</span> Monkey(<span class="string">'乐乐'</span>);</span><br><span class="line">alert(huanhuan.species === lele.species) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>虽然这种方式可行，但是这两个 <code>species</code> 是两个不同的属性，这样的话在内存比较浪费空间，那应该怎么设计才能共享这一个公共的属性呢？ </p><p>这时，小鹿想到，如果设计一个” 容器 “专门才存放公共的属性和方法就好了，然后让不同构造函数生成的对象公共的属性都指向这个“ 容器 ”里的属性和方法不就可以了吗？</p><p>【图】</p><p>那么问题又来了，用什么来充当这个容器呢？然后小鹿专门对象来存储公共的属性和方法，又因为这个对象非常的特别，所以起名叫 “ 原型对象 ”。</p><p>为了能够让构造函数和原型对象产生关联，就为构造函数设计了一个默认的属性叫做 <code>prototype</code> ，这个属性专门指向原型对象的，那么原型对象又要指向构造函数，怎么办呢？所以小鹿又给每个原型对象指定了一个属性叫做 <code>constructor</code> ，原型对象的这个属性专门指向构造函数。</p><p>【图】</p><blockquote><p><strong>注意：</strong></p><p>1）最后又为构造函数生成的实例对象设置了一个属性 <code>_proto_</code> 用于指向原型对象。其实就是指向了 <code>prototype</code> 所指向的。</p><p>2）每个实例对象也是有一个属性指向自己的构造函数的（可以知道自己是由哪个构造函数生成的），也就是 <code>constructor</code> 属性，其实这个属性就是原型对象中 <code>constructor</code> 所指向的构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monkey</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Monkey.prototype.species = <span class="string">'动物'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huanhuan = <span class="keyword">new</span> Monkey(<span class="string">'欢欢'</span>);</span><br><span class="line"><span class="keyword">let</span> lele = <span class="keyword">new</span> Monkey(<span class="string">'乐乐'</span>);</span><br><span class="line">alert(huanhuan.species === lele.species) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小鹿把自己想象成 js 的设计者，这一篇就让你搞明白是什么 js 中的原型！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【原型链和继承】</title>
    <link href="http://yoursite.com/2019/04/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/18/前端进阶深入系列之【原型链和继承】/</id>
    <published>2019-04-18T11:50:51.788Z</published>
    <updated>2019-04-23T06:04:21.642Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一篇让你完全明白 js 中原型链和继承！</p><a id="more"></a><h3 id="一、原型链"><a href="#一、原型链" class="headerlink" title="一、原型链"></a>一、原型链</h3><blockquote><p>回顾上一节的内容《原型》，我们知道了构造函数与实例以及原型对象之间的关系，下面我们来看原型链。</p></blockquote><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><blockquote><p>所谓的原型链就是，一个构造函数的原型对象是另一个构造函数的实例。·</p></blockquote><h4 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h4><blockquote><p>要在引用的对象（实例 instance）中引用某个属性，首先在对象内部查找，然后再到原型对象中查找（instance.__proto__ (constructor1.prototype)）,如果这个原型对象是另一构造函数的实例的话，就会继续沿着这个实例的原型对象继续查找。</p></blockquote><h4 id="3、原型链"><a href="#3、原型链" class="headerlink" title="3、原型链"></a>3、原型链</h4><blockquote><p>这种实例与原型的链条叫做原型链。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索轨迹: instance1--&gt; instance2 --&gt; （instance2.__proto__ ）constructor2.prototype…--&gt;Object.prototype</span><br></pre></td></tr></table></figure><blockquote><p><strong>补充：</strong>所有的对象都继承与 Object 对象。</p></blockquote><h4 id="4、原型和实例的关系"><a href="#4、原型和实例的关系" class="headerlink" title="4、原型和实例的关系"></a>4、原型和实例的关系</h4><h6 id="▉-instanceof-（实例-—-gt-原型）"><a href="#▉-instanceof-（实例-—-gt-原型）" class="headerlink" title="▉ instanceof （实例 —&gt; 原型）"></a>▉ instanceof （实例 —&gt; 原型）</h6><blockquote><p>用于测试实例（instance）在原型链中出现的构造函数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(instance instanceof Object);//true</span><br><span class="line">alert(instance instanceof Father);//true</span><br></pre></td></tr></table></figure><h6 id="▉-isPrototypeOf-（原型-—-gt-实例）"><a href="#▉-isPrototypeOf-（原型-—-gt-实例）" class="headerlink" title="▉ isPrototypeOf()（原型 —&gt; 实例）"></a>▉ isPrototypeOf()（原型 —&gt; 实例）</h6><blockquote><p>只要该实例出现在原型链中，就会返回 true。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.prototype.isPrototypeOf(instance));//true</span><br></pre></td></tr></table></figure><h4 id="5、原型链的问题"><a href="#5、原型链的问题" class="headerlink" title="5、原型链的问题"></a>5、原型链的问题</h4><blockquote><p>问题一：当原型链中包含引用类型值的原型（实例）时,该引用类型值会被所有实例共享; </p><p>问题二：在创建子类型(例如创建 Son 的实例) ,不能向超类型(例如 Father )的构造函数中传递参数. </p></blockquote><h3 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h3><blockquote><p>为了能够解决上面的问题，所以使用一下几种继承的方式。</p></blockquote><h4 id="1、经典继承（构造函数）"><a href="#1、经典继承（构造函数）" class="headerlink" title="1、经典继承（构造函数）"></a>1、经典继承（构造函数）</h4><h6 id="▉-基本思想"><a href="#▉-基本思想" class="headerlink" title="▉ 基本思想"></a>▉ 基本思想</h6><blockquote><p>在子类型构造函数的内部调用超类型构造函数. </p></blockquote><h6 id="▉-代码实现"><a href="#▉-代码实现" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><blockquote><p>1）保证了原型链中引用类型值（实例）的独立，不被所有实例共享。</p><p>2）子类创建的时候可以向父类进行传参。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 详细解析</span></span><br><span class="line"><span class="comment">//1、当用调用 call 方法时，this 带边 son 。</span></span><br><span class="line"><span class="comment">//2、此时 Father 构造函数中的 this 指向 son。</span></span><br><span class="line"><span class="comment">//3、也就是说 son 有了 colors 的属性。</span></span><br><span class="line"><span class="comment">//4、每 new 一个 son ，都会产生不同的对象，每个对象的属性都是相互独立的。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Father.call(<span class="keyword">this</span>);<span class="comment">//继承了Father,且向父类型传递参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red,blue,green" 可见引用类型值是独立的</span></span><br></pre></td></tr></table></figure><h6 id="▉-缺陷"><a href="#▉-缺陷" class="headerlink" title="▉ 缺陷"></a>▉ 缺陷</h6><blockquote><p>1）继承的方法都在构造函数中定义，构造函数不能够复用了（Father 的 this 已经绑定到 son，this 只能用于 son ，所以说 Father 构造函数不能复用了 ）</p><p>2）父类中定义的方法对于子类型而言是不可见的。</p></blockquote><h4 id="2、组合继承（最常见的继承模式）"><a href="#2、组合继承（最常见的继承模式）" class="headerlink" title="2、组合继承（最常见的继承模式）"></a>2、组合继承（最常见的继承模式）</h4><blockquote><p>上述的构造函数模式因为存在的两个缺点，所以不经常被使用。组合继承是将<strong>原型链技术</strong>和<strong>构造函数</strong>来实现堆实例属性的继承。</p></blockquote><h6 id="▉-基本思想-1"><a href="#▉-基本思想-1" class="headerlink" title="▉ 基本思想"></a>▉ 基本思想</h6><blockquote><p>使用<strong>原型链</strong>实现对<strong>「原型属性和方法」</strong>的继承,通过借用<strong>构造函数</strong>来实现对<strong>「实例属性」</strong>的继承. </p></blockquote><h6 id="▉-代码实现-1"><a href="#▉-代码实现-1" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><blockquote><p>1）在原型对象上定义的方法实现了函数的复用。</p><p>2）每个实例都有属于自己的属性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法定义在原型对象上（共享）</span></span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 子类继承父类的属性  </span></span><br><span class="line">Father.call(<span class="keyword">this</span>,name);     <span class="comment">//继承实例属性，第一次调用 Father()</span></span><br><span class="line">    <span class="comment">// 每个实例都有自己的属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将父类的实例变为子类的原型对象                                 </span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();   <span class="comment">//继承父类方法,第二次调用 Father()</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();  <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();  <span class="comment">//10</span></span><br></pre></td></tr></table></figure><h6 id="▉-缺陷-1"><a href="#▉-缺陷-1" class="headerlink" title="▉ 缺陷"></a>▉ 缺陷</h6><blockquote><p>1）组合继承调用了两次父类的构造函数，造成了不必要的消耗。</p></blockquote><h6 id="▉-改进"><a href="#▉-改进" class="headerlink" title="▉ 改进"></a>▉ 改进</h6><blockquote><p>也就是寄生组合式继承。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">Father.call(<span class="keyword">this</span>,name);<span class="comment">//继承实例属性，第一次调用Father()</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">extend(Son,Father)<span class="comment">//继承父类方法,此处并不会第二次调用Father()</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();<span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName();<span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();<span class="comment">//10</span></span><br></pre></td></tr></table></figure><h4 id="3、原型继承"><a href="#3、原型继承" class="headerlink" title="3、原型继承"></a>3、原型继承</h4><h6 id="▉-基本思想-2"><a href="#▉-基本思想-2" class="headerlink" title="▉ 基本思想"></a>▉ 基本思想</h6><blockquote><p>创建临时性的构造函数（无任何属性），将传入的对象作为该构造函数的原型对象，然后返回这个新构造函数的实例。</p></blockquote><h6 id="▉-代码实现-2"><a href="#▉-代码实现-2" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><blockquote><p>对传入的 o 对象进行了一次浅拷贝。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">F.prototype = o;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>浅拷贝。</p><p>1）object 所产生的对象是不相同的，但是原型对象都是 person 对象，所改变存在原型对象的属性所有生成的实例所共享，不仅被 Person 所拥有，而且被子类生成的实例所共享。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例 1</span></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="comment">// 实例 2</span></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line"><span class="comment">// 都添加至原型对象的属性(所共享)</span></span><br><span class="line">alert(person.friends); <span class="comment">// "Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure><h6 id="▉-object-create"><a href="#▉-object-create" class="headerlink" title="▉ object.create()"></a>▉ <strong>object.create()</strong></h6><blockquote><p>在 ECMAScript5 中,通过新增 <strong>object.create()</strong> 方法规范化了上面的原型式继承.。</p><p>两个参数：</p><p>1）参数一：新对象的原型的对象。</p><p>2）参数二：先对象定义额外的属性（可选）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line">alert(person.friends);<span class="comment">//"Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">"Van"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">name : &#123;</span><br><span class="line">value : <span class="string">"Louis"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);<span class="comment">//"Louis"</span></span><br></pre></td></tr></table></figure><h4 id="4、寄生式继承"><a href="#4、寄生式继承" class="headerlink" title="4、寄生式继承"></a>4、寄生式继承</h4><blockquote><p>寄生继承对原型继承的改进，原型继承生成的子类实例是通过 create 的第二个参数设定的；而寄生式继承是靠函数的封装，将封装好的对象实例进行返回。</p></blockquote><h6 id="▉-基本思想-3"><a href="#▉-基本思想-3" class="headerlink" title="▉ 基本思想"></a>▉ 基本思想</h6><blockquote><p>同样调用 object 函数，将返回的对象和对象的额外的方法和属性封装成一个函数进行返回。</p></blockquote><h6 id="▉-代码实现-3"><a href="#▉-代码实现-3" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用object函数创建一个新对象</span></span><br><span class="line">clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-缺陷-2"><a href="#▉-缺陷-2" class="headerlink" title="▉ 缺陷"></a>▉ 缺陷</h6><blockquote><p>寄生式继承将对象封装起来，导致不能做到函数的复用，使得效率降低。</p></blockquote><h4 id="5、寄生组合式继承"><a href="#5、寄生组合式继承" class="headerlink" title="5、寄生组合式继承"></a>5、寄生组合式继承</h4><blockquote><p>寄生组合式继承就是为了解决组合继承中两次调用构造函数的开销。</p></blockquote><h6 id="▉-基本思想-4"><a href="#▉-基本思想-4" class="headerlink" title="▉ 基本思想"></a>▉ 基本思想</h6><blockquote><p>不必为了指定子类型的原型而调用超类型的构造函数（避免第二次调用的构造函数）。</p></blockquote><h6 id="▉-代码实现-4"><a href="#▉-代码实现-4" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><blockquote><p>F 的构造函数指向父类的原型对象，让 F 的实例的 constructor 指向子类构造函数，子类的构造函数的原型指向 F 的实例对象。</p><p>1）这样做避免了在 F 的实例上创建不必要的属性，也没有调用 superClass 构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subClass:子类构造函数</span></span><br><span class="line"><span class="comment">// superClass:父类构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass,superClass</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> prototype = object(superClass.prototype);<span class="comment">//创建对象</span></span><br><span class="line">prototype.constructor = subClass;<span class="comment">//增强对象</span></span><br><span class="line">subClass.prototype = prototype;<span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype = superClass.prototype;<span class="comment">//直接指向超类型prototype</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>之所以没有进行如上操作，就是因为如上操作只不过是子类和父类共享原型对象，并没有实现继承。</p></blockquote><h6 id="▉-extend-有效扩展"><a href="#▉-extend-有效扩展" class="headerlink" title="▉ extend 有效扩展"></a>▉ extend 有效扩展</h6><blockquote><p>将 object() 里边的内容扩展开，将整体封装成函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = superClass.prototype;</span><br><span class="line">  subClass.prototype = <span class="keyword">new</span> F(); </span><br><span class="line">  subClass.prototype.constructor = subClass;</span><br><span class="line"></span><br><span class="line">  subClass.superclass = superClass.prototype;</span><br><span class="line">  <span class="keyword">if</span>(superClass.prototype.constructor == <span class="built_in">Object</span>.prototype.constructor) &#123;</span><br><span class="line">    superClass.prototype.constructor = superClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、new-运算符"><a href="#三、new-运算符" class="headerlink" title="三、new 运算符"></a>三、new 运算符</h3><blockquote><p>new 运算符创建对象的过程中，新创建一个对象，然后对对象进行一系列的关联。</p></blockquote><ul><li>创建一个空对象。</li><li>将空对象的原型指向构造函数的原型对象。</li><li>对构造函数的属性和方法进行浅拷贝到新对象中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = F.prototype;</span><br><span class="line">F.call(obj);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇让你完全明白 js 中原型链和继承！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【ES6 常考点】</title>
    <link href="http://yoursite.com/2019/04/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90ES6%E5%B8%B8%E8%80%83%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/17/前端面试之道【ES6常考点】/</id>
    <published>2019-04-17T12:07:23.423Z</published>
    <updated>2019-05-07T00:46:20.975Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ES6 面试常考的知识点！</p><a id="more"></a><h2 id="一、var、let、const区别"><a href="#一、var、let、const区别" class="headerlink" title="一、var、let、const区别"></a>一、var、let、const区别</h2><blockquote><p>面试题一：1、什么是提升？2、什么是暂时性死区？3、var、let 及 const 区别？ </p></blockquote><p><strong>※ 答✔：什么是提升？</strong></p><p>1）所谓的提升就是虽然变量没有声明，但是可以使用这个未声明的变量。</p><p>2）函数也有提升并且优先于变量的提升。函数提升会把整个函数挪到作用域顶部。</p><p>3）<code>var</code> 的变量会被提升到作用域的顶部。</p><p><strong>※ 答✔：什么是暂时性死区？</strong></p><p>1）如果使用 <code>let</code>、<code>const</code> 声明变量，在声明之前就是用了变量就会报错，报错的原因就是暂时性死区。这里的提升和 <code>var</code> 是有区别的，，虽然变量在编译的环节中被告知在这块作用域中可以访问，但是访问是受限制的。 </p><p><strong>※ 答✔：var、let 及 const 区别？</strong></p><p>1）<code>var</code> 在全局作用域下声明变量会导致变量挂载在 <code>window</code> 上，其他两者不会</p><p>2）<code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值。</p><p><strong>※ 扩展✔：为什么或存在提升？</strong></p><p>1）根本原因就是为了解决函数间互相调用的情况。</p><h2 id="二、原型继承和-Class-继承"><a href="#二、原型继承和-Class-继承" class="headerlink" title="二、原型继承和 Class 继承"></a>二、原型继承和 Class 继承</h2><blockquote><p>面试题二：原型如何实现继承？Class 如何实现继承？Class 本质是什么？ </p></blockquote><p><strong>※ 答✔：原型如何实现继承？</strong></p><p>1）组合继承、寄生组合继承、Class 继承  原文链接：<a href="http://luxiangqiang.xn--6qq986b3xl/2019/04/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF%E3%80%91/" target="_blank" rel="noopener">JavaScript 中的原型链和继承</a></p><p><strong>※ 答✔：Class 如何实现继承？</strong></p><p>1）<code>Class</code> 实现继承主要使用 <code>extends</code> 来明确继承自哪个父类，并且再子类中调用 <code>super</code>，可以将这段代码看做 <code>Parent.call(this,value)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>※ 答✔：Class 本质是什么？</strong></p><p>1）js 中并不存在类，Class 只是语法糖，Class 的本质还是函数。</p><h2 id="三、模块化"><a href="#三、模块化" class="headerlink" title="三、模块化"></a>三、模块化</h2><blockquote><p>面试题三：为什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</p></blockquote><p><strong>※ 答✔：为什么使用模块化？</strong></p><blockquote><p>通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。 </p></blockquote><ul><li>解决命名冲突</li><li>提供复用性</li><li>提高代码可维护性</li></ul><p><strong>※ 答✔：都有哪几种方式可以实现模块化？</strong></p><p><strong>1）立即执行函数（IIFE）</strong></p><blockquote><p>立即执行函数中的匿名函数中有独立的 词法作用域，避免了外界访问此作用域的变量。<strong>通过函数作用域解决了命名冲突、污染全局作用域的问题</strong> 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Barry"</span>; </span><br><span class="line">    <span class="keyword">return</span> name; </span><br><span class="line">&#125;)(); </span><br><span class="line"><span class="comment">// IIFE 执行后返回的结果：</span></span><br><span class="line">result; <span class="comment">// "Barry"</span></span><br></pre></td></tr></table></figure><p><strong>2）AMD 和 CMD</strong></p><blockquote><p>目前很少见，只需了解即可。</p></blockquote><ul><li><p><strong>AMD </strong></p><blockquote><p>AMD 采用异步的加载方式，加载之后不影响它后面语句的运行。require.js 实现 AMD 规范的模块化 ， <code>require.config()</code> 指定引用路径等，用 <code>define()</code> 定义模块，用 <code>require()</code> 加载模块。 </p></blockquote></li></ul><ul><li><p><strong>CMD </strong></p><blockquote><p>CMD 的不同点在于推崇依赖前置、提前执行，CDM 推崇依赖就近、延迟执行。</p></blockquote></li></ul><p><strong>3）CommonJS</strong></p><blockquote><p>① <code>CommonJS</code> 的规范主要用在 <code>Node.js</code> 中，为模块提供了四个接口：<code>module、exports、require、global</code>。</p><p>② <code>CommonJS</code> 用同步的方式加载模块（服务器端），在浏览器端使用的是异步加载模块。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对外暴露接口</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载外部模块</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="comment">// 原始类型的值被缓存，所以就没有被改变（commonJS 不会随着执行而去模块随时调用）</span></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>4）ES6 Module</strong></p><blockquote><p>ES6 实现的模块非常简单，用于浏览器和服务器端。<code>mport</code>命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码 .主要有两个命令组成：<code>export</code>和<code>import</code>:</p><ul><li><code>export</code>命令用于规定模块的<strong>对外接口</strong>。</li><li><code>import</code>命令引入其他模块的功能。 </li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定指定的值暴露对外的接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块中的某个值</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="comment">// ES6 模块不同的是，静态加载完毕之后，每执行到模块中的方法，就去模块内调用（外部的变量总是与模块进行绑定的），而且值不会被缓存。</span></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong>5）ES6 模块与 CommonJS 模块的区别</strong></p><blockquote><p><strong>1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong></p><ul><li>所谓值的拷贝，原始类型的值被缓存，不随模块内部的改变而改变。</li><li>ES6 模块是<strong>动态引用</strong>，<strong>不缓存值</strong>，模块内外是<strong>绑定</strong>的，而且是<strong>只读引用</strong>，不能修改值。ES6 的 js 引擎对脚本静态分析的时候，遇到加载命令模块 <code>import</code> ，就会生成一个只读引用，当真正用到模块里边的值的时候，就会去模块内部去取。</li></ul><p><strong>2、CommonJS 模块是运行时加载，ES6 模块是编译时加载输出接口。</strong></p><ul><li><strong>运行时加载</strong>：<code>CommonJS</code> 模块就是对象；是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 </li><li><strong>编译时加载：</strong>ES6 模块不是对象，而是通过 <code>export</code> 命令「显式指定输出的代码」。<code>import</code> 时采用静态命令的形式，即在<code>import</code>指定「加载某个输出值」，而「不是加载整个模块」，这种加载称为“编译时加载”。 </li></ul></blockquote><p><strong>6）总结</strong></p><blockquote><ul><li>CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li><li>AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li><li>CMD 规范与 AMD  规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重。</li><li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li></ul></blockquote><h2 id="四、Proxy"><a href="#四、Proxy" class="headerlink" title="四、Proxy"></a>四、Proxy</h2><h2 id="五、map-filter-reduce"><a href="#五、map-filter-reduce" class="headerlink" title="五、map,filter,reduce"></a>五、map,filter,reduce</h2><blockquote><p>面试题：map,filter,reduce 各自有什么作用？</p></blockquote><p><strong>※ map 有什么作用？</strong> </p><blockquote><p>map 的作用是 map 中传入一个函数，该函数会遍历该数组，对每一个元素做变换之后返回新数组。</p></blockquote><h6 id="1）该函数存在三个参数："><a href="#1）该函数存在三个参数：" class="headerlink" title="1）该函数存在三个参数："></a>1）该函数存在三个参数：</h6><ul><li>element :  对应数组的每个元素。</li><li>index : 数组元素的下标。</li><li>arr : 原数组。</li></ul><h6 id="2）代码实现"><a href="#2）代码实现" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">arr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">element,index,arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index]+<span class="number">1</span>;</span><br><span class="line">&#125;) <span class="comment">// [3,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>※ filter 有什么作用？</strong> </p><blockquote><p><code>filter</code> 的作用是也是生成一个数组，传入的函数返回值确实布尔类型，返回值为 true 的元素放入新数组，通常来筛选删除不需要的元素。</p></blockquote><h6 id="1）该函数存在三个参数：-1"><a href="#1）该函数存在三个参数：-1" class="headerlink" title="1）该函数存在三个参数："></a>1）该函数存在三个参数：</h6><ul><li>element :  对应数组的每个元素。</li><li>index : 数组元素的下标。</li><li>arr : 原数组。</li></ul><h6 id="2）代码实现-1"><a href="#2）代码实现-1" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr = array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> element != <span class="number">6</span>;</span><br><span class="line">&#125;)<span class="comment">// [1,2,4]</span></span><br></pre></td></tr></table></figure><p><strong>※ reduce 有什么作用？</strong> </p><blockquote><p>reduce 可以将数组中的元素通过回调函数最终转换为一个值。</p></blockquote><h6 id="1）传入-reduce-两个参数："><a href="#1）传入-reduce-两个参数：" class="headerlink" title="1）传入 reduce 两个参数："></a>1）传入 reduce 两个参数：</h6><ul><li>回调函数<ul><li>accum：累计值(第一次的值代表初始化的值)。</li><li>element：当前元素。</li><li>index：当前索引。</li><li>arr：原数组。</li></ul></li><li>初始值</li></ul><h6 id="2）代码实现-2"><a href="#2）代码实现-2" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">acc,element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> acc + element;</span><br><span class="line">&#125;,<span class="number">0</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h6 id="2）reduce-的执行过程"><a href="#2）reduce-的执行过程" class="headerlink" title="2）reduce 的执行过程"></a>2）reduce 的执行过程</h6><ul><li>初始值为 0 ，该值会传入第一次回调函数。</li><li>回到函数接收四个值，第一个值是累计值。</li><li>第一次执行回调函数将「初始值」和「当前值」做运算。</li><li>然后将结果值传入第二次执行的回调函数。</li><li>第二次回调函数会和当前值再做运算。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 面试常考的知识点！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/ES6/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/ES6/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之爬虫【基本流程】</title>
    <link href="http://yoursite.com/2019/04/15/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E7%88%AC%E8%99%AB%E3%80%90%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/15/数据分析之爬虫【基本流程】/</id>
    <published>2019-04-14T16:11:36.357Z</published>
    <updated>2019-04-17T00:20:42.456Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/images/爬虫基本流程.png" alt=""></p><p>本篇文章教你数据分析爬虫的基本流程！</p><a id="more"></a><h3 id="一、爬虫的基本流程"><a href="#一、爬虫的基本流程" class="headerlink" title="一、爬虫的基本流程"></a>一、爬虫的基本流程</h3><blockquote><p>三个基本流程：</p><ul><li>打开网页: Request 访问网页，得到服务器返回的数据，包括 HTML 和 JSON 数据。</li><li>提取数据: 针对 HTML 使用 XPath 元素定位；针对 JSON 使用 JSON 进行解析。</li><li>保存数据：使用 Pandas 保存数据，最后导出 XSL 或 CSV 文件。</li></ul></blockquote><h4 id="1、Request-访问页面"><a href="#1、Request-访问页面" class="headerlink" title="1、Request 访问页面"></a>1、Request 访问页面</h4><blockquote><p>Request 是 Python 的 HTTP 的客户端库，两种访问方式 GET 和 POST 。请求回来的数据可以通过 <code>text</code> 或 <code>content</code> 来获取 HTML 的正文。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// get 方式</span><br><span class="line">r = requests.get(<span class="string">'http://www.douban.com'</span>)</span><br><span class="line">// post 方式</span><br><span class="line">r = requests.post(<span class="string">'http://xxx.com'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="2、XPath-定位"><a href="#2、XPath-定位" class="headerlink" title="2、XPath 定位"></a>2、XPath 定位</h4><blockquote><p>XPath 是 XML 的路径语言，通过元素和属性进行导航，定位位置。</p><p>1）XPath 有 100 多个内置函数进行快速的定位。</p><p>2）XPath 需要借助一个解析库 lxml 。例如:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 得到 HTML 的所有列表项目</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.HTML(html)</span><br><span class="line">result = html.xpath(<span class="string">'//li'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/3b/ea/3bcb311361c76bfbeb90d360b21195ea.jpg" alt="img"></p><h4 id="3、JSON-对象"><a href="#3、JSON-对象" class="headerlink" title="3、JSON 对象"></a>3、JSON 对象</h4><blockquote><p>Python 中有 JSON 库，可以将 Python 对象和 JSON 对象相互转换。</p></blockquote><p><img src="https://static001.geekbang.org/resource/image/9a/43/9a6d6564a64cf2b1c256265eea78c543.png" alt="img"></p><h4 id="4、使用-JSON-数据爬取实战"><a href="#4、使用-JSON-数据爬取实战" class="headerlink" title="4、使用 JSON 数据爬取实战"></a>4、使用 JSON 数据爬取实战</h4><blockquote><p>抓取的页面时动态页面，需要关注 XHR 数据，动态页面是通过原生的 XHR 数据对象发送 HTTP 请求，得到服务器返回的值，在进行处理。（使用谷歌开发工具可以查看）</p></blockquote><h6 id="▉-导包"><a href="#▉-导包" class="headerlink" title="▉ 导包"></a>▉ 导包</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><h6 id="▉-查看-XHR-请求的页数"><a href="#▉-查看-XHR-请求的页数" class="headerlink" title="▉ 查看 XHR 请求的页数"></a>▉ 查看 XHR 请求的页数</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range(开始，结束，步长)  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">23287</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="comment"># XHR 请求的路径</span></span><br><span class="line">    url = <span class="string">'https://www.douban.com/j/search_photo?q='</span> + query + <span class="string">'&amp;limit=20&amp;start='</span> + str(i)</span><br></pre></td></tr></table></figure><h6 id="▉-进行-XHR-请求"><a href="#▉-进行-XHR-请求" class="headerlink" title="▉ 进行 XHR 请求"></a>▉ 进行 XHR 请求</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取服务器返回的文本</span></span><br><span class="line">html = requests.get(url).text</span><br></pre></td></tr></table></figure><h6 id="▉-将-JSON-对象转化为-Python-对象进行解析"><a href="#▉-将-JSON-对象转化为-Python-对象进行解析" class="headerlink" title="▉ 将 JSON 对象转化为 Python 对象进行解析"></a>▉ 将 JSON 对象转化为 Python 对象进行解析</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 JSON 转化为 Python 对象</span></span><br><span class="line">response = json.loads(html,encoding=<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><h6 id="▉-循环遍历出内容"><a href="#▉-循环遍历出内容" class="headerlink" title="▉ 循环遍历出内容"></a>▉ 循环遍历出内容</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># images: [&#123;src: "https://img3.doubanio.com/view/photo/thumb/public/p637714342.jpg", author: "華生",…&#125;,…]</span></span><br><span class="line"><span class="comment"># 获取内容数组</span></span><br><span class="line">response[<span class="string">'images'</span>]</span><br><span class="line"><span class="comment"># 获取数组中的每个对象</span></span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> response[<span class="string">'images'</span>]</span><br><span class="line"><span class="comment"># 获取每个对象中的值</span></span><br><span class="line">image[<span class="string">'src'</span>]</span><br></pre></td></tr></table></figure><h6 id="▉-下载图片"><a href="#▉-下载图片" class="headerlink" title="▉ 下载图片"></a>▉ 下载图片</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(src,id)</span>:</span></span><br><span class="line">    <span class="comment"># 设置路径和图片命名</span></span><br><span class="line">    dir = <span class="string">'./'</span> + str(id) + <span class="string">'.jpg'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># timeout 设置爬虫超时操作</span></span><br><span class="line">        pic = requests.get(src,timeout = <span class="number">10</span>)</span><br><span class="line">        <span class="comment"># 内置函数 open 用于打开文件(wb 二进制文件只写入)</span></span><br><span class="line">        fp = open(dir,<span class="string">'wb'</span>)</span><br><span class="line">        <span class="comment"># 以二进制方式写入本地文件</span></span><br><span class="line">        fp.write(pic.content)</span><br><span class="line">        fp.close()</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.ConnectionError:</span><br><span class="line">        print(<span class="string">'图片无法下载'</span>)</span><br></pre></td></tr></table></figure><h4 id="5、使用-XPath-爬取数据"><a href="#5、使用-XPath-爬取数据" class="headerlink" title="5、使用 XPath 爬取数据"></a>5、使用 XPath 爬取数据</h4><blockquote><p>网页除了用  XHR 做请求，也会用 JS 做请求，如果用到 JS 做请求，那么我们就用 XPath 做解析。用 XPath 做解析必须 JS 请求后接受到整个页面之后，才能进行解析。</p><p>1）快速定位 XPath 的方法就是使用谷歌插件 XPath Helper 使用快捷键 Ctrl + Shift + X ,直接定位你想要的元素。</p><p>2）使用 lxml 库来进行对获取的网页进行解析。</p></blockquote><h5 id="1、Selenium-模拟测试工具"><a href="#1、Selenium-模拟测试工具" class="headerlink" title="1、Selenium 模拟测试工具"></a>1、Selenium 模拟测试工具</h5><blockquote><p>因为 XPath 的使用必须在页面加载完成才可以，所以使用 Request 获取页面的 HTML 时候，发现 XPath 并不存在，所以必须借助 Selenium 模拟工具（模拟用户操作页面的工具）。</p><p>1）必须下载 Driver 执行程序才能正常打开浏览器。</p></blockquote><h5 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h5><h6 id="▉-加载浏览器程序"><a href="#▉-加载浏览器程序" class="headerlink" title="▉ 加载浏览器程序"></a>▉ 加载浏览器程序</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Chrome(<span class="string">'C:/Program Files (x86)/Google/Chrome/Application/chromedriver.exe'</span>)</span><br></pre></td></tr></table></figure><h6 id="▉-打开指定网址"><a href="#▉-打开指定网址" class="headerlink" title="▉ 打开指定网址"></a>▉ 打开指定网址</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 尽情请求</span><br><span class="line">browser.get(url)</span><br></pre></td></tr></table></figure><h6 id="▉-获取网页源代码"><a href="#▉-获取网页源代码" class="headerlink" title="▉  获取网页源代码"></a>▉  获取网页源代码</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取打开网页的源代码</span><br><span class="line">browser.page_source</span><br><span class="line">// 转化为可以被 lxml 解析的对象</span><br><span class="line">html = etree.HTML(browser.page_source)</span><br></pre></td></tr></table></figure><h6 id="▉-获取到-XPath-匹配的元素"><a href="#▉-获取到-XPath-匹配的元素" class="headerlink" title="▉  获取到 XPath 匹配的元素"></a>▉  获取到 XPath 匹配的元素</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src_xpath = <span class="string">"//div[@class='result']/div[@class='pic']/a[@class='nbg']/img/@src"</span></span><br><span class="line">srcs = html.xpath(src_xpath)</span><br></pre></td></tr></table></figure><h6 id="▉-遍历获取数据"><a href="#▉-遍历获取数据" class="headerlink" title="▉  遍历获取数据"></a>▉  遍历获取数据</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zip 将对象中对应的元素打包成元组</span></span><br><span class="line"><span class="keyword">for</span> src,title <span class="keyword">in</span> zip(srcs,titles):</span><br><span class="line">    print(src)</span><br><span class="line">    download(src,title.text)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/爬虫基本流程.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇文章教你数据分析爬虫的基本流程！&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/python/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="数据分析" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>吃透 JQuery 之【完整篇】</title>
    <link href="http://yoursite.com/2019/04/13/%E5%90%83%E9%80%8F%20JQuery%20%E4%B9%8B%E3%80%90%E5%AE%8C%E6%95%B4%E7%AF%87%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/13/吃透 JQuery 之【完整篇】/</id>
    <published>2019-04-13T05:17:23.146Z</published>
    <updated>2019-04-23T00:05:13.323Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一篇 JQuery 核心内容文章！</p><a id="more"></a><p>[TOC]</p><h2 id="一、选择器"><a href="#一、选择器" class="headerlink" title="一、选择器"></a>一、选择器</h2><h3 id="1、基本选择器"><a href="#1、基本选择器" class="headerlink" title="1、基本选择器"></a>1、基本选择器</h3><h4 id="1-1-按-ID-查找"><a href="#1-1-按-ID-查找" class="headerlink" title="1.1 按 ID 查找"></a>1.1 按 ID 查找</h4><blockquote><p>返回 jQuery 对象，jQuery 对象类似数组，每个元素都是引用了 DOM 节点的对象。<code>[&lt;div id=&quot;abc&quot;&gt;...&lt;/div&gt;]</code>，如果找不到该对象，返回 <code>[]</code> 空对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照 ID 查找</span></span><br><span class="line">&lt;div id=<span class="string">"abc"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>jQuery 对象与 DOM 对象之间的转化：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>);    <span class="comment">// 获取 jQuery 对象 ‘#abc’ 执行了 document.getElementById('#abc');</span></span><br><span class="line"><span class="keyword">var</span> divDOM = div.get(<span class="number">0</span>);<span class="comment">// 获取第一个 DOM 对象</span></span><br><span class="line"><span class="keyword">var</span> anthor = $(divDOM); <span class="comment">// 重新把 DOM 封装为 jQuery 对象</span></span><br></pre></td></tr></table></figure><h4 id="1-2-按-tag-查找"><a href="#1-2-按-tag-查找" class="headerlink" title="1.2 按 tag 查找"></a>1.2 按 tag 查找</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ps = $(<span class="string">'p'</span>);<span class="comment">//获取所有的 &lt;p&gt; 节点</span></span><br><span class="line">ps.length;      <span class="comment">//统计 &lt;p&gt; 节点的个数</span></span><br></pre></td></tr></table></figure><h4 id="1-3-按-class-查找"><a href="#1-3-按-class-查找" class="headerlink" title="1.3 按 class 查找"></a>1.3 按 class 查找</h4><blockquote><p>查找之前要加一个 ‘.’；</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ps = $(<span class="string">'.red'</span>);<span class="comment">// 所有节点包含`class="red"`都将返回</span></span><br></pre></td></tr></table></figure><h4 id="1-4-按属性查找"><a href="#1-4-按属性查找" class="headerlink" title="1.4 按属性查找"></a>1.4 按属性查找</h4><blockquote><p>DOM 节点很多属性，可以根据属性来快速定位节点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出属性为 [name=email] 的节点</span></span><br><span class="line"><span class="keyword">var</span> email = $(<span class="string">'[name^=email]'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按属性查找使用前缀或后缀查找</span></span><br><span class="line"><span class="keyword">var</span> icons = $(<span class="string">'name^= icon'</span>)       <span class="comment">// 找出所有 name 属性值以 icon 开头的 DOM</span></span><br><span class="line"><span class="keyword">var</span> names = $(<span class="string">'[name$=with]'</span>);     <span class="comment">// 找出所有 name 属性值以 with 结尾的 DOM</span></span><br><span class="line"><span class="keyword">var</span> icons = $(<span class="string">'[class^="icon-"]'</span>); <span class="comment">// class 经常使用到</span></span><br></pre></td></tr></table></figure><h4 id="1-5-组合查找"><a href="#1-5-组合查找" class="headerlink" title="1.5 组合查找"></a>1.5 组合查找</h4><blockquote><p>通常选择会选择所有的属性，但是有时我们只选择某标签里的属性进行使用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标签和属性组合</span></span><br><span class="line"><span class="keyword">var</span> emilInput = $(<span class="string">'input[name = email]'</span>);</span><br><span class="line"><span class="comment">// 标签和 Class 组合</span></span><br><span class="line"><span class="keyword">var</span> tr = $(<span class="string">'tr.red'</span>);</span><br></pre></td></tr></table></figure><h4 id="1-6-多项选择器"><a href="#1-6-多项选择器" class="headerlink" title="1.6 多项选择器"></a>1.6 多项选择器</h4><blockquote><p>多个选择器用 <code>，</code> 组合起来一块选。选出来的元素是按照它们在 HTML 中出现的顺序排列的，而且不会有重复元素。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 &lt;p&gt; 和 &lt;div&gt; 都选出来</span></span><br><span class="line">$(<span class="string">'p,div'</span>)</span><br><span class="line"><span class="comment">// 把 &lt;p class="red"&gt; 和 &lt;p class="green"&gt; 都选出来</span></span><br><span class="line">$(<span class="string">'p.red,p.green'</span>)</span><br></pre></td></tr></table></figure><h3 id="2、层级选择器"><a href="#2、层级选择器" class="headerlink" title="2、层级选择器"></a>2、层级选择器</h3><blockquote><p>由于 DOM 的结构是层级结构，经常需要根据层级来进行选择，所以 jQuery 层级选择器更加灵活。</p><p><strong>优点： </strong>层级选择器的好处就是在于缩小了选择的范围，定位父元素后再定位子元素，避免了不相干页面的干扰。</p></blockquote><h4 id="2-1-层级选择器"><a href="#2-1-层级选择器" class="headerlink" title="2.1 层级选择器"></a>2.1 层级选择器</h4><blockquote><p>如果两个 DOM 元素有层级结构，可以使用 <code>$(&#39;ancestor descendant&#39;)</code> 来选择，层级之间需要用空格隔开。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'form[name=upload] input'</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-子选择器（Child-Selector）"><a href="#2-2-子选择器（Child-Selector）" class="headerlink" title="2.2 子选择器（Child Selector）"></a>2.2 子选择器（Child Selector）</h4><blockquote><p>类似层级选择器，但是限定了只能选择父元素的子元素。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul &gt; li'</span>) <span class="comment">//选择 &lt;ul&gt; 父节点下的子节点 &lt;li&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-过滤器（Filter）"><a href="#2-3-过滤器（Filter）" class="headerlink" title="2.3 过滤器（Filter）"></a>2.3 过滤器（Filter）</h4><blockquote><p>过滤器通常不单独使用，附加到选择器中使用，更精确的定位元素。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang li'</span>); <span class="comment">// 选出 JavaScript、Python 和 Lua 3个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择节点的第一个节点</span></span><br><span class="line">$(<span class="string">'ul.lang li:first-child'</span>);     <span class="comment">// 仅选出 JavaScript</span></span><br><span class="line"><span class="comment">// 选择最后一个元素</span></span><br><span class="line">$(<span class="string">'ul.lang li:last-child'</span>);      <span class="comment">// 仅选出 Lua</span></span><br><span class="line"><span class="comment">// 选出第 n 的元素，n 从 1 开始</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(2)'</span>);  </span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(even)'</span>); <span class="comment">// 选出序号为偶数的元素</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(odd)'</span>);  <span class="comment">// 选出序号为奇数的元素</span></span><br></pre></td></tr></table></figure><h4 id="2-4-表单相关"><a href="#2-4-表单相关" class="headerlink" title="2.4 表单相关"></a>2.4 表单相关</h4><blockquote><p>针对表单，jQuery 有一组特殊的选择器。</p></blockquote><ul><li><code>:input</code>：可以选择 <code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code> 和 <code>&lt;button&gt;</code>；</li><li><code>:file</code>：可以选择 <code>&lt;input type=&quot;file&quot;&gt;</code> 和 <code>input[type=file]</code> 一样；</li><li><code>:checkbox</code>：可以选择复选框，和 <code>input[type=checkbox]</code> 一样；</li><li><code>:radio</code>：可以选择单选框和 <code>input[type=radio]</code> 一样；</li><li><code>:focus</code>：可以选择当前输入焦点的元素，例如把光标放到一个 <code>&lt;input&gt;</code> 上，用 <code>$(&#39;input:focus&#39;)</code> 就可以选出；</li><li><code>:checked</code>：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如<code>$(&#39;input[type=radio]:checked&#39;)</code>；</li><li><code>:enabled</code>：可以选择可以正常输入的 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>  等，也就是没有灰掉的输入；</li><li><code>:disabled</code>：和 <code>:enabled</code> 正好相反，选择那些不能输入的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div:visible'</span>); <span class="comment">// 所有可见的div</span></span><br><span class="line">$(<span class="string">'div:hidden'</span>); <span class="comment">// 所有隐藏的div</span></span><br></pre></td></tr></table></figure><h3 id="3、查找和过滤"><a href="#3、查找和过滤" class="headerlink" title="3、查找和过滤"></a>3、查找和过滤</h3><blockquote><p>最常用的是在某个节点的所有子节点中查找，使用 find 方法，接受一个选择器进行选择。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"js dy"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dy"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"swift"</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dy"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">name</span>=<span class="string">"haskell"</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'ul.lang'</span>);               <span class="comment">// 获得 &lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> dy = ul.find(<span class="string">'.dy'</span>);             <span class="comment">// 获得 JavaScript, Python, Scheme</span></span><br><span class="line"><span class="keyword">var</span> swf = ul.find(<span class="string">'#swift'</span>);         <span class="comment">// 获得 Swift</span></span><br><span class="line"><span class="keyword">var</span> hsk = ul.find(<span class="string">'[name=haskell]'</span>); <span class="comment">// 获得 Haskell</span></span><br></pre></td></tr></table></figure><p>向上查找使用 <code>parent()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swf = $(<span class="string">'#swift'</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> parent = swf.parent(); <span class="comment">// 获得 Swift 的上层节点 &lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = swf.parent(<span class="string">'.red'</span>); <span class="comment">// 获得 Swift 的上层节点 &lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空 jQuery 对象</span></span><br></pre></td></tr></table></figure><p>同级元素使用 <code>next（）</code> 和 <code>prev（）</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swift = $(<span class="string">'#swift'</span>);</span><br><span class="line"></span><br><span class="line">swift.next(); <span class="comment">// Scheme</span></span><br><span class="line">swift.next(<span class="string">'[name=haskell]'</span>); <span class="comment">// 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]</span></span><br><span class="line"></span><br><span class="line">swift.prev(); <span class="comment">// Python</span></span><br><span class="line">swift.prev(<span class="string">'.dy'</span>); <span class="comment">// Python，因为 Python 同时符合过滤器条件.dy</span></span><br></pre></td></tr></table></figure><h4 id="3-1-过滤"><a href="#3-1-过滤" class="headerlink" title="3.1 过滤"></a>3.1 过滤</h4><blockquote><p>函数式编程中的 map、filter类似，jQuery 也有自己类似的方法。</p></blockquote><p>filter() 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>);<span class="comment">// 拿到 JavaScript, Python, Swift, Scheme 和 Haskell</span></span><br><span class="line"><span class="keyword">var</span> a = langs.filter(<span class="string">'.dy'</span>) <span class="comment">// 拿到 JavaScript, Python, Scheme</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个函数</span></span><br><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到 JavaScript, Python, Swift, Scheme 和 Haskell</span></span><br><span class="line">langs.filter(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 函数内部的 this 被绑定为 DOM 对象，不是 jQuery 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML.indexOf(<span class="string">'S'</span>) === <span class="number">0</span>; <span class="comment">// 检查每个子节点，返回 S 开头的节点</span></span><br><span class="line">&#125;</span><br><span class="line">); <span class="comment">// 拿到Swift, Scheme</span></span><br></pre></td></tr></table></figure><p>map() 方法：把一个  jQuery 对象包含的若干 DOM 节点转化为其他对象 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到 JavaScript, Python, Swift, Scheme 和 Haskell</span></span><br><span class="line"><span class="keyword">var</span> arr = langs.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML;</span><br><span class="line">&#125;).get(); </span><br><span class="line"><span class="comment">// 用 get() 拿到包含 string 的 Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell']</span></span><br></pre></td></tr></table></figure><p>一个jQuery对象如果包含了不止一个DOM节点，<code>first()</code>、<code>last()</code>和<code>slice()</code>方法可以返回一个新的 jQuery对象，把不需要的 DOM 节点去掉： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>);  <span class="comment">// 拿到 JavaScript, Python, Swift, Scheme 和 Haskell</span></span><br><span class="line"><span class="keyword">var</span> js = langs.first();       <span class="comment">// JavaScript，相当于 $('ul.lang li:first-child')</span></span><br><span class="line"><span class="keyword">var</span> haskell = langs.last();   <span class="comment">// Haskell, 相当于 $('ul.lang li:last-child')</span></span><br><span class="line"><span class="keyword">var</span> sub = langs.slice(<span class="number">2</span>, <span class="number">4</span>);  <span class="comment">// Swift, Scheme 参数和数组的 slice() 方法一致</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var inputs = $(&apos;#test-form :input&apos;).not(&apos;button&apos;);</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">inputs.filter(function()&#123;</span><br><span class="line"> if(this.type !== &quot;radio&quot; || this.checked);</span><br><span class="line"> obj[this.name] = this.value;</span><br><span class="line">&#125;)</span><br><span class="line">json = JSON.stringify(obj);</span><br></pre></td></tr></table></figure><h2 id="二、操作-DOM"><a href="#二、操作-DOM" class="headerlink" title="二、操作 DOM"></a>二、操作 DOM</h2><h3 id="1-操作-DOM"><a href="#1-操作-DOM" class="headerlink" title="1. 操作 DOM"></a>1. 操作 DOM</h3><h4 id="1-1-修改-Text-和-HTML"><a href="#1-1-修改-Text-和-HTML" class="headerlink" title="1.1 修改 Text 和 HTML"></a>1.1 修改 Text 和 HTML</h4><blockquote><p>jQuery 对象的 text() 和 html() 方法分别获取节点文本和原始的 HTML 文本。</p><p>1）jQuery 可以获取一组数据进行统一设置文本。</p><p>2）jQuery 如果不存在结点对象，将不会报错。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test-ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"js"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">name</span>=<span class="string">"book"</span>&gt;</span>Java &amp;amp; JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文本</span></span><br><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).text(); <span class="comment">// 'Java &amp; JavaScript'</span></span><br><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).html(); <span class="comment">// 'Java &amp;amp; JavaScript'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文本</span></span><br><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).text(<span class="string">'JavaScript &amp; ECMAScript'</span>); </span><br><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).html(<span class="string">'&lt;span style="color: red"&gt;JavaScript&lt;/span&gt;'</span>);</span><br></pre></td></tr></table></figure><h4 id="1-2-修改-CSS"><a href="#1-2-修改-CSS" class="headerlink" title="1.2 修改 CSS"></a>1.2 修改 CSS</h4><blockquote><p>调用 jQuery 对象的 <code>css(&quot;name&quot;,&quot;value&quot;)</code> 方法。</p><p>1）CSS 属性可以使用 <code>&#39;background-color&#39;</code> 和  <code>&#39;backgroundColor&#39;</code>两种格式。</p><p>2）css() 方法将作用于 DOM 节点的 style 属性，具有最高的优先级。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：jQuery 的所有方法返回的是对象，可以链式调用。</span></span><br><span class="line">$(<span class="string">'#test-css li.dy&gt;span'</span>).css(<span class="string">'background-color'</span>, <span class="string">'#ffd351'</span>).css(<span class="string">'color'</span>, <span class="string">'red'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>修改 <code>class</code> 属性，jQuery 提供一下方法：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test'</span>);</span><br><span class="line">div.hasClass(<span class="string">'container'</span>);<span class="comment">// 判断该结点 class 是否包含 container 属性</span></span><br><span class="line">div.addClass(<span class="string">'container'</span>);<span class="comment">// 添加 container 这个 Class</span></span><br><span class="line">div.removeClass(<span class="string">'container'</span>); <span class="comment">// 删除 container 这个 Class</span></span><br></pre></td></tr></table></figure><h4 id="1-3-显示和隐藏-DOM"><a href="#1-3-显示和隐藏-DOM" class="headerlink" title="1.3 显示和隐藏 DOM"></a>1.3 显示和隐藏 DOM</h4><blockquote><p>显示或隐藏 DOM 需要设置 CSS 属性的 display 属性。</p><p>1）隐藏 DOM 需要设置 CSS 的 display 属性为 none。</p><p>2）显示 DOM 需要知道 display 之前的属性（block,inline）。</p><p>3）jQuery 对象提供的 show() 和 hide() 方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'div'</span>);</span><br><span class="line">a.hide(); <span class="comment">// 隐藏</span></span><br><span class="line">a.show(); <span class="comment">// 显示(并没有删除 DOM 结点，影响了 DOM 结点的显示)</span></span><br></pre></td></tr></table></figure><h4 id="1-4-获取-DOM-信息"><a href="#1-4-获取-DOM-信息" class="headerlink" title="1.4 获取 DOM 信息"></a>1.4 获取 DOM 信息</h4><blockquote><p>无序针对特定的浏览器编写特定的代码，jQuery 对象的方法直接获取。</p><p>1）操作 DOM 节点的属性：<code>attr()</code> 和 <code>removeAttr()</code> 方法。</p><p>2）操作 H5 中无值属性：<code>prop()</code> 但会 <code>boolean</code> 值，也可以用 <code>is</code> 判断。  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器可视窗口大小:</span></span><br><span class="line">$(<span class="built_in">window</span>).width(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="built_in">window</span>).height(); <span class="comment">// 600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML文档大小:</span></span><br><span class="line">$(<span class="built_in">document</span>).width(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="built_in">document</span>).height(); <span class="comment">// 3500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个div的大小:</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.width(); <span class="comment">// 600</span></span><br><span class="line">div.height(); <span class="comment">// 300</span></span><br><span class="line">div.width(<span class="number">400</span>); <span class="comment">// 设置CSS属性 width: 400px，是否生效要看CSS是否有效</span></span><br><span class="line">div.height(<span class="string">'200px'</span>); <span class="comment">// 设置CSS属性 height: 200px，是否生效要看CSS是否有效</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.attr(<span class="string">'data'</span>);<span class="comment">// undefined 属性值不存在</span></span><br><span class="line">div.attr(<span class="string">'name'</span>);<span class="comment">// test 获取属性值</span></span><br><span class="line">div.attr(<span class="string">'name'</span>,<span class="string">'Hello'</span>); <span class="comment">// 设置属性值</span></span><br><span class="line">div.removeAttr(<span class="string">'name'</span>); <span class="comment">//删除 name 属性</span></span><br><span class="line">div.attr(<span class="string">'name'</span>);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"test-radio"</span> type=<span class="string">"radio"</span> name=<span class="string">"test"</span> checked value=<span class="string">"1"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> radio = $(<span class="string">'#test-radio'</span>);</span><br><span class="line">radio.prop(<span class="string">'checked'</span>); <span class="comment">// true</span></span><br><span class="line">radio.is(<span class="string">':checked'</span>); <span class="comment">// true</span></span><br><span class="line">is(<span class="string">':selected'</span>);<span class="comment">// 下拉属性判断</span></span><br></pre></td></tr></table></figure><h4 id="1-5-操作表单"><a href="#1-5-操作表单" class="headerlink" title="1.5 操作表单"></a>1.5 操作表单</h4><blockquote><p>对于 jQuery 操作表单，统一使用 <code>val()</code> 方法获取和设置对应的 <code>value</code> 属性：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    &lt;input id="test-input" name="email" value=""&gt;</span></span><br><span class="line"><span class="comment">    &lt;select id="test-select" name="city"&gt;</span></span><br><span class="line"><span class="comment">        &lt;option value="BJ" selected&gt;Beijing&lt;/option&gt;</span></span><br><span class="line"><span class="comment">        &lt;option value="SH"&gt;Shanghai&lt;/option&gt;</span></span><br><span class="line"><span class="comment">        &lt;option value="SZ"&gt;Shenzhen&lt;/option&gt;</span></span><br><span class="line"><span class="comment">    &lt;/select&gt;</span></span><br><span class="line"><span class="comment">    &lt;textarea id="test-textarea"&gt;Hello&lt;/textarea&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    input = $(<span class="string">'#test-input'</span>),</span><br><span class="line">    select = $(<span class="string">'#test-select'</span>),</span><br><span class="line">    textarea = $(<span class="string">'#test-textarea'</span>);</span><br><span class="line"></span><br><span class="line">input.val(); <span class="comment">// 'test'</span></span><br><span class="line">input.val(<span class="string">'abc@example.com'</span>); <span class="comment">// 文本框的内容已变为abc@example.com</span></span><br><span class="line"></span><br><span class="line">select.val(); <span class="comment">// 'BJ'</span></span><br><span class="line">select.val(<span class="string">'SH'</span>); <span class="comment">// 选择框已变为Shanghai</span></span><br><span class="line"></span><br><span class="line">textarea.val(); <span class="comment">// 'Hello'</span></span><br><span class="line">textarea.val(<span class="string">'Hi'</span>); <span class="comment">// 文本区域已更新为'Hi'</span></span><br></pre></td></tr></table></figure><h3 id="2、修改-DOM"><a href="#2、修改-DOM" class="headerlink" title="2、修改 DOM"></a>2、修改 DOM</h3><blockquote><p>原生的浏览器 API 修改 DOM 需要根据不同的浏览器进行写不同的代码。</p></blockquote><h4 id="2-1-添加-DOM"><a href="#2-1-添加-DOM" class="headerlink" title="2.1 添加 DOM"></a>2.1 添加 DOM</h4><blockquote><p>添加 DOM 结点除了使用 <code>html()</code> 方法外还可以使用 <code>append()</code> 方法。</p><p>1) append() 方法可以接收一下几个参数：</p><ul><li>DOM 对象</li><li>jQuery 对象</li><li>函数对象(该函数要返回一个字符串、DOM 对象、jQuery对象)</li></ul><p>2）<code>append()</code> 把DOM添加到最后，<code>prepend()</code> 则把 DOM 添加到最前。 </p><p>3）<code>after()</code> 方法和 <code>before()</code> 方法将 DOM 插入指定位置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*&lt;div id="test-div"&gt;</span></span><br><span class="line"><span class="comment">    &lt;ul&gt;</span></span><br><span class="line"><span class="comment">        &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">        &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">        &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt;*/</span></span><br><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'#test-div&gt;ul'</span>);</span><br><span class="line">ul.append(<span class="string">'&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建DOM对象:</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">ps.innerHTML = <span class="string">'&lt;span&gt;Pascal&lt;/span&gt;'</span>;</span><br><span class="line"><span class="comment">// 添加DOM对象:</span></span><br><span class="line">ul.append(ps);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加jQuery对象:</span></span><br><span class="line">ul.append($(<span class="string">'#scheme'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加函数对象:</span></span><br><span class="line">ul.append(<span class="function"><span class="keyword">function</span> (<span class="params">index, html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;li&gt;&lt;span&gt;Language - '</span> + index + <span class="string">'&lt;/span&gt;&lt;/li&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意：jQuery的 <code>append()</code> 可能作用于一组 DOM 节点，只有传入函数才能针对每个 DOM 生成不同的子节点。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = $(<span class="string">'#test-div&gt;ul&gt;li:first-child'</span>);</span><br><span class="line">js.after(<span class="string">'&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-删除节点"><a href="#2-2-删除节点" class="headerlink" title="2.2 删除节点"></a>2.2 删除节点</h4><blockquote><p>拿到 jQuery 对象之后，直接执行 <code>remove()</code> 方法可以删除一组或单个节点。</p></blockquote><h3 id="3、事件"><a href="#3、事件" class="headerlink" title="3、事件"></a>3、事件</h3><blockquote><p>1) 浏览器获取到鼠标事件，自动在对应的 DOM 结点上触发响应的时间，如果该结点绑定了函数，函数就触发响应的事件，然后调用绑定了对应的 javascript 处理函数，该函数就会自动调用。</p><p>2) 不同浏览器的代码是不一样的，jQuery 屏蔽了不同浏览器的差异。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-1-鼠标事件"><a href="#3-1-鼠标事件" class="headerlink" title="3.1 鼠标事件"></a>3.1 鼠标事件</h4><ul><li>click : 单击事件</li><li>dbclick: 双击事件</li><li>mouseenter: 鼠标进入时触发</li><li>mouseleace: 鼠标离开时触发</li><li>mousemove: 鼠标在 DOM 内部移动时触发</li><li>hover: 鼠标进入和退出时触发两个函数，相当于 mouseenter 加上 mouseleave。</li></ul><h4 id="3-2-键盘事件"><a href="#3-2-键盘事件" class="headerlink" title="3.2 键盘事件"></a>3.2 键盘事件</h4><blockquote><p>键盘事件仅作用在当前焦点 DOM 上，通常是 <code>&lt;imput&gt;</code> 和 <code>&lt;textarea&gt;</code>。</p></blockquote><ul><li>keydown：键盘按下时触发</li><li>keyup：键盘松开时触发</li><li>keypress：按一次键后触发</li></ul><h4 id="3-3-其他事件"><a href="#3-3-其他事件" class="headerlink" title="3.3 其他事件"></a>3.3 其他事件</h4><ul><li>focus：当 DOM 获取焦点时触发；</li><li>blur：当 DOM 失去焦点时触发；</li><li>change：当 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 或 <code>&lt;textarea&gt;</code> 的内容改变时触发；</li><li>submit：当 <code>&lt;form&gt;</code> 提交时触发；</li><li>ready：当页面被载入并且 DOM 树完成初始化后触发（仅作用于 document 对象）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-4-事件参数"><a href="#3-4-事件参数" class="headerlink" title="3.4 事件参数"></a>3.4 事件参数</h4><blockquote><p>有些事件需要传入参数，获取到按键的值和鼠标的位置。所有事件都传入 Event 对象作为参数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#testMouseMoveDiv'</span>).mousemove(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#testMouseMoveSpan'</span>).text(<span class="string">'pageX = '</span> + e.pageX + <span class="string">', pageY = '</span> + e.pageY);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-5-取消绑定"><a href="#3-5-取消绑定" class="headerlink" title="3.5  取消绑定"></a>3.5  取消绑定</h4><blockquote><p>一个绑定的事件可以被解除，通过 <code>off（‘click’, function）</code> 实现：</p><p>1) off 无参会一次性移除已绑定的所有类型的事件处理函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.click(hello); <span class="comment">// 绑定事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10秒钟后解除绑定:</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a.off(<span class="string">'click'</span>, hello);</span><br><span class="line">&#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h4 id="3-6-事件触发条件"><a href="#3-6-事件触发条件" class="headerlink" title="3.6 事件触发条件"></a>3.6 事件触发条件</h4><blockquote><p>事件的触发是由用户操作引发的。</p><p>1）change 事件的触发是由用户改变文本框内容触发的，在 js 修改文本框内容则不会触发。</p><p>2）用代码触发 change 事件，可以直接调用无参数的 change() 方法来触发事件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.change(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'changed...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.val(<span class="string">'change it!'</span>);</span><br><span class="line">input.change(); <span class="comment">// 触发change事件,相当于 input.trigger('change')</span></span><br></pre></td></tr></table></figure><h4 id="3-7-浏览器安全限制"><a href="#3-7-浏览器安全限制" class="headerlink" title="3.7 浏览器安全限制"></a>3.7 浏览器安全限制</h4><blockquote><p>有些 javascript 代码只有用户触发才能执行，如 <code>window.open()</code> 函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法弹出新窗口，将被浏览器屏蔽:</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.open(<span class="string">'/'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4、AJAX"><a href="#4、AJAX" class="headerlink" title="4、AJAX"></a>4、AJAX</h3><blockquote><p>jQuery 的 AJAX 不用针对不同浏览器写不同代码，代码也得到很大的简化。</p></blockquote><h4 id="4-1-ajax"><a href="#4-1-ajax" class="headerlink" title="4.1 ajax"></a>4.1 ajax</h4><blockquote><p>jQuery 在全局对象中（$）绑定了 ajax() 函数。</p><p>1）<code>ajax(url,settings)</code> 函数需要接收一个 URL 和一个可选的 settings 对象</p></blockquote><ul><li><p><strong>async </strong>：默认 true</p></li><li><p><strong>method： </strong>发送的 Method ，默认为 <code>GET</code>。</p></li><li><p><strong>contentType： </strong>发送的 POST 格式，默认值为 <code>&#39;application/x-www-form-urlencoded; charset=UTF-8&#39;</code></p><p>其余格式为 <code>text/plain</code>、<code>application/json</code>；</p></li><li><p><strong>data： </strong>发送的数据，可以是字符串、数组或 object。如果是 GET 请求，data 转换为 query 附加到 URL 上。如果是 POST 根据 contentType 将数据序列化成合适的格式；</p></li><li><p><strong>headers： </strong>发送额外的 HTTP 头，必须是一个 object;</p></li><li><p><strong>dataType：</strong>接受的数据格，<code>html</code> 、<code>xml</code>、<code>json</code> 、<code>text</code> 等，没有设置的情况下根据 contentType 来定义。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(<span class="string">'/api/categories'</span>,&#123;</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>响应方式：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(<span class="string">'/api/categories'</span>, &#123;</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'成功, 收到的数据: '</span> + <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;).fail(<span class="function"><span class="keyword">function</span> (<span class="params">xhr, status</span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'失败: '</span> + xhr.status + <span class="string">', 原因: '</span> + status);</span><br><span class="line">&#125;).always(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'请求完成: 无论成功或失败都会调用'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-2-get-方法"><a href="#4-2-get-方法" class="headerlink" title="4.2 get 方法"></a>4.2 get 方法</h4><blockquote><p>最常见的写法；第二个参数会被拼接到 url 后边</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.get(url, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url?name=Bob%<span class="number">20</span>Lee&amp;check=<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="4-3-post-方法"><a href="#4-3-post-方法" class="headerlink" title="4.3 post 方法"></a>4.3 post 方法</h4><blockquote><p>虽然写法和 GET 类似，但是第二个参数被序列化了为 <code>application/x-www-form-urlencoded</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.post(<span class="string">'/path/to/resource'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-4-getJSON-对象"><a href="#4-4-getJSON-对象" class="headerlink" title="4.4 getJSON 对象"></a>4.4 getJSON 对象</h4><blockquote><p>通过 <code>getJSON()</code> 方法来快速通过 GET 获取一个 JSON 对象：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.getJSON(<span class="string">'/path/to/resource'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// data已经被解析为JSON对象了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-5-安全限制"><a href="#4-5-安全限制" class="headerlink" title="4.5 安全限制"></a>4.5 安全限制</h4><blockquote><p>关于跨域，jQuery 也是有限制的，和 JavaScript 一样。如果跨域加载数据，设置 <code>jsonp：‘callback’</code> ，这样就可以实现 jQuery 加载跨域数据了。</p></blockquote><h3 id="5、动画"><a href="#5、动画" class="headerlink" title="5、动画"></a>5、动画</h3><blockquote><p>jQuery 封装的动画非常简单，只需要一行代码就可以搞定。</p></blockquote><h4 id="5-1-show-hide"><a href="#5-1-show-hide" class="headerlink" title="5.1 show/hide"></a>5.1 show/hide</h4><blockquote><p>无参的<code>show()</code> <code>hide()</code> 方法用于隐藏、显示元素，传入一个时间参数就会变成动画。</p><p>1）参数可以是<code>&#39;slow&#39;</code>，<code>&#39;fast&#39;</code> 。</p><p>2）<code>toggle()</code> 根据当前的状态来决定显示还是隐藏。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#id'</span>);</span><br><span class="line">div.hide(<span class="number">3000</span>); <span class="comment">// 在 3 秒钟内逐渐消失</span></span><br></pre></td></tr></table></figure><h4 id="5-2-slideUp-slideDown"><a href="#5-2-slideUp-slideDown" class="headerlink" title="5.2 slideUp / slideDown"></a>5.2 slideUp / slideDown</h4><blockquote><p>这两个方法是垂直方向消失和隐藏的。</p><p>1) <code>slideToggle()</code> 根据状态来决定。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#id'</span>);</span><br><span class="line">div.slideUp(<span class="number">3000</span>); <span class="comment">// 在3秒钟内逐渐向上消失</span></span><br></pre></td></tr></table></figure><h4 id="5-3-fadeIn-fadeOut"><a href="#5-3-fadeIn-fadeOut" class="headerlink" title="5.3 fadeIn/fadeOut"></a>5.3 fadeIn/fadeOut</h4><blockquote><p>这两个方法的动画就是淡入淡出，通过设置 <code>opacity</code> 来实现的。</p><p>1）<code>fadeToggle()</code> 决定是否状态是否改变。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#id'</span>);</span><br><span class="line">div.fadeOut(<span class="string">'slow'</span>); <span class="comment">// 在 0.6 秒内淡出</span></span><br></pre></td></tr></table></figure><h4 id="5-4-自定义动画"><a href="#5-4-自定义动画" class="headerlink" title="5.4 自定义动画"></a>5.4 自定义动画</h4><blockquote><p><code>animate()</code> 可以实现自定义动画，传入的参数就是 DOM 元素最终的 CSS 状态和时间。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#id'</span>);</span><br><span class="line">div.animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.25</span>,</span><br><span class="line">    width: <span class="string">'256px'</span>,</span><br><span class="line">    height: <span class="string">'256px'</span></span><br><span class="line">&#125;, <span class="number">3000</span>); <span class="comment">// 在 3 秒钟内 CSS 过渡到设定值</span></span><br></pre></td></tr></table></figure><blockquote><p>第三个参数就是传入一个函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animate'</span>);</span><br><span class="line">div.animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.25</span>,</span><br><span class="line">    width: <span class="string">'256px'</span>,</span><br><span class="line">    height: <span class="string">'256px'</span></span><br><span class="line">&#125;, <span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动画已结束'</span>);</span><br><span class="line">    <span class="comment">// 恢复至初始状态:</span></span><br><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'opacity'</span>, <span class="string">'1.0'</span>).css(<span class="string">'width'</span>, <span class="string">'128px'</span>).css(<span class="string">'height'</span>, <span class="string">'128px'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5-5-串行动画"><a href="#5-5-串行动画" class="headerlink" title="5.5 串行动画"></a>5.5 串行动画</h4><blockquote><p>动画可以串行执行，通过 <code>delay（）</code>  方法可以实现暂停，可以实现更复杂的动画效果。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#id'</span>);</span><br><span class="line"><span class="comment">// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小</span></span><br><span class="line">div.slideDown(<span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'256px'</span>,</span><br><span class="line">       height: <span class="string">'256px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'128px'</span>,</span><br><span class="line">       height: <span class="string">'128px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-动画设置失败"><a href="#5-6-动画设置失败" class="headerlink" title="5.6 动画设置失败"></a>5.6 动画设置失败</h4><blockquote><p>1）有的动画没有效果，jQuery 动画的原理是逐渐改变 CSS 的值。很多元素不是 block 性质的 DOM 元素，对它们设置有的属性不起作用，所以没有动画效果。</p><p>2）jQuery也没有实现对<code>background-color</code>的动画效果，用<code>animate()</code>设置<code>background-color</code>也没有效果 。只能借助 CSS3 动画。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇 JQuery 核心内容文章！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JQuery" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JQuery/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JQuery" scheme="http://yoursite.com/tags/JQuery/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之题型篇【链表】</title>
    <link href="http://yoursite.com/2019/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A2%98%E5%9E%8B%E7%AF%87%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/13/数据结构与算法之题型篇【链表】/</id>
    <published>2019-04-13T02:58:26.185Z</published>
    <updated>2019-05-02T11:04:39.245Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有关链表的所有操作和题型的详细解析和扩展。</p><a id="more"></a><p>[TOC]</p><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><blockquote><p>如果你和小鹿一样，刚开始对链表的操作代码实现很懵的话，不妨按照小鹿经过一个月的时间对链表相关操作以及题型的整理总结，由浅入深进行适当的练习，我相信，当你真正的练习完这些题目，不但会让你失去链表对你心理上的困惑，而且对你学习其他数据结构有很大的信心和帮助！</p></blockquote><h4 id="1、学习建议"><a href="#1、学习建议" class="headerlink" title="1、学习建议"></a>1、学习建议</h4><blockquote><p>小鹿不建议你一口气去看完这篇所有的题目和练习，给自己制定一个小计划，我当初整理该题目的时候，每天都计划认真整理一到题目，把每道题分析透，这样才能达到最好的吸收。</p></blockquote><h4 id="2、学习路径"><a href="#2、学习路径" class="headerlink" title="2、学习路径"></a>2、学习路径</h4><blockquote><p>本篇分为三个阶段，基础练习阶段、进阶练习阶段、加强练习阶段。</p><p>1）基础练习阶段</p><p>首先进行第一个阶段之前，你已经对链表的基础知识能够熟练掌握，但是对于没有动手写过链表代码，那么你从第一阶段最基础的开始进行。确保每一个基础点要亲自动手用自己熟悉的语言写出来，虽然本篇中基本都是 javascript 代码实现的，但是算法思路是一成不变的，如果遇到困难可以自行百度或谷歌，也可以下方给我进行留言。</p><p>2）进阶练习阶段</p><p>如果你对上述的链表基本代码已经完全熟练掌握了，那么恭喜你可以进行下一个阶段，进阶阶段，这一阶段增加的难度就是链表的操作是对于实际问题来解决的，所以非常锻炼你对问题的分析能力和解决能力，也考验你对代码的全面性、鲁棒性。这一阶段非常的重要，下面的每道题我都做出了详细的分析。</p><p>3）加强练习阶段</p><p>如果上述的进阶练习阶段的题型你都了如指掌了，那么不妨我们实战一下，LeetCode 汇聚了很多面试的题型，所以我在上边整理了几个经典的题目，你可以尝试着解答它们，相关题目的代码以及解题思路我都整理好了。这一阶段的题目小鹿会在后期不断的更新，这些题目你能够完全掌握，链表对你来说小菜一碟了。</p></blockquote><h2 id="一、链表基础练习（阶段一）"><a href="#一、链表基础练习（阶段一）" class="headerlink" title="一、链表基础练习（阶段一）"></a>一、链表基础练习（阶段一）</h2><blockquote><p>自己首相尝试着一个个攻破下方的链表中最基础的操作，相关代码我也整理好了（先自己尝试着去解决哦）。</p></blockquote><ul><li>单链表的插入、删除、查找操作（<a href="https://github.com/luxiangqiang/Data-Structure-Coding/blob/master/Link_List/javascript/SinglyLinkedList.md" target="_blank" rel="noopener">点击查看代码实现</a>）。</li><li><p>循环链表的插入、删除、查找操作 (<a href="https://github.com/luxiangqiang/Data-Structure-Coding/blob/master/Link_List/javascript/CircularLinkedList.md" target="_blank" rel="noopener">点击查看代码实现</a>)。</p></li><li><p>双向链表的插入、删除、查找操作 (<a href="https://github.com/luxiangqiang/Data-Structure-Coding/blob/master/Link_List/javascript/DoubleLinkedList.md" target="_blank" rel="noopener">点击查看代码实现</a>)。</p></li></ul><h2 id="二、链表进阶练习（阶段二）"><a href="#二、链表进阶练习（阶段二）" class="headerlink" title="二、链表进阶练习（阶段二）"></a>二、链表进阶练习（阶段二）</h2><h3 id="1、单链表从尾到头打印"><a href="#1、单链表从尾到头打印" class="headerlink" title="1、单链表从尾到头打印"></a>1、单链表从尾到头打印</h3><blockquote><p>题目：输入一个链表的头结点，从尾到头反过来打印出每个节点的值。</p></blockquote><h4 id="1-1-问题分析与解决"><a href="#1-1-问题分析与解决" class="headerlink" title="1.1 问题分析与解决"></a>1.1 问题分析与解决</h4><h6 id="▉-问题分析"><a href="#▉-问题分析" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><blockquote><p>1）看到题目第一想到的就是反转链表在打印输出，一种反转链表的方法，但是这种方法改变了原有的链表结构。</p><p>缺点：使得链表的结构发生改变了。如果不改变链表结构应该怎么解决？</p><p>2）从问题中可以得出，我们想要从尾到头打印链表，正常情况下是从头到尾打印的，我们就会想到最后的数据先打印，开始的数据最后打印，有种“先进后出”的特点，我们就能想到用“栈”这种结构，用栈来实现。</p><p>缺点：代码不够简洁。</p><p>优点：鲁棒性好（在不确定的情况下，程序仍然可以正确的执行）。</p><p>3）提到栈这种数据结构，我们就会想到“递归”的实现就是用栈这种数据结构实现的。既然栈能实现，那么递归也能实现。</p><p>缺点：如果链表很长，递归深度很深，导致堆栈溢出。</p><p>优点：代码简洁、明了。</p></blockquote><h6 id="▉-算法思路"><a href="#▉-算法思路" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote><p>得出以下几种实现方式：</p><ul><li>反转链表法</li><li>栈实现</li><li>递归实现</li></ul><p>1）反转链表实现：</p><p>从尾到头输出链表的内容，一般的思路就是将链表反转过来，然后从头到尾输出数据。</p><p>2）栈实现</p><p>从头到尾遍历单链表，将数据存储按照顺序存储到栈中。然后遍历整个栈，打印输出数据。</p><p>2）递归实现：</p><p>可以通过递归的方式来实现单链表从尾到头依次输出，递归过程涉及到“递”和“归”，反转链表输出数据，正式利用了循环“递”的过程，所以数据先从头部输出，那么递归采用的是“归”的过程来输出内容，输出当前结点先要输出当前节点的下一节点。</p></blockquote><h6 id="▉-测试用例"><a href="#▉-测试用例" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote><p>在写代码之前，要想好测试用例才能写出健全、鲁棒性的代码，也是为了考虑到边界情况，往往也是整个程序最致命的地方，如果考虑不全面，就会出现 bug，导致程序崩溃。</p><p>测试用例：</p><p>1）输入空链表；</p><p>2）输入的链表只有一个结点；</p><p>3）输入的链表有多个结点。</p></blockquote><h6 id="▉-代码实现：反转链表法"><a href="#▉-代码实现：反转链表法" class="headerlink" title="▉ 代码实现：反转链表法"></a>▉ 代码实现：反转链表法</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 功能：单链表反转</span></span><br><span class="line">    <span class="comment">// 步骤:</span></span><br><span class="line">    <span class="comment">// 1、定义三个指针(pre=null/next/current)</span></span><br><span class="line">    <span class="comment">// 2、判断链表是否可反转(头节点是否为空、是否有第二个结点)</span></span><br><span class="line">    <span class="comment">// 3、尾指针指向第一个结点的 next</span></span><br><span class="line">    <span class="comment">// 4、尾指针向前移动</span></span><br><span class="line">    <span class="comment">// 5、当前指针(current)向后移动</span></span><br><span class="line">    <span class="comment">// 6、将 head 指向单转好的结点</span></span><br><span class="line">    reverseList = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//声明三个指针</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head; <span class="comment">//当前指针指向头节点</span></span><br><span class="line">        <span class="keyword">let</span> pre = <span class="literal">null</span>;<span class="comment">//尾指针</span></span><br><span class="line">        <span class="keyword">let</span> next;<span class="comment">//指向当前指针的下一个指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断单链表是否符合反转的条件(一个结点以上)？</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="literal">null</span> || <span class="keyword">this</span>.head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始反转</span></span><br><span class="line">        <span class="keyword">while</span>(current !== <span class="literal">null</span>)&#123;</span><br><span class="line">            next = current.next;</span><br><span class="line">            current.next = pre;</span><br><span class="line">            pre = current;</span><br><span class="line">            current = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.head = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-代码实现：循环栈"><a href="#▉-代码实现：循环栈" class="headerlink" title="▉ 代码实现：循环栈"></a>▉ 代码实现：循环栈</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法三：栈实现</span></span><br><span class="line"><span class="keyword">const</span> tailToHeadOutput = <span class="function">(<span class="params">currentNode</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">//遍历链表，将数据入栈</span></span><br><span class="line">    <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">        stack.push(currentNode.data);</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历栈，数据出栈</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-代码实现：递归"><a href="#▉-代码实现：递归" class="headerlink" title="▉ 代码实现：递归"></a>▉ 代码实现：递归</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤:</span></span><br><span class="line"><span class="comment">// 1、判断是否为空链表</span></span><br><span class="line"><span class="comment">// 2、终止条件（下一结点为空）</span></span><br><span class="line"><span class="comment">// 3、递归打印下一结点信息</span></span><br><span class="line"><span class="keyword">const</span> tailToHeadOutput = <span class="function">(<span class="params">head</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 判断是否空链表</span></span><br><span class="line"><span class="keyword">if</span>(head !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断下一结点是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(head.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 下一结点不为空，先输出下一结点</span></span><br><span class="line">        tailToHeadOutput(head.next)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(head.data);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"空链表"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-性能分析"><a href="#▉-性能分析" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><blockquote><p>反转链表实现：</p><ul><li>时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。</li><li>空间复杂度：O(1)。不需要额外的栈存储空间，空间复杂度为 O(1)。</li></ul><p>循环栈实现：</p><ul><li>时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。</li><li>空间复杂度：O(n)。需要额外的栈存储空间，空间复杂度为 O(n)。</li></ul><p>递归实现：</p><ul><li>时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。</li><li>空间复杂度：O(n)。需要额外的栈存储空间，空间复杂度为 O(n)。</li></ul></blockquote><h4 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><h6 id="▉-考察内容"><a href="#▉-考察内容" class="headerlink" title="▉ 考察内容"></a>▉ 考察内容</h6><blockquote><p>1）对单链表的基本操作。</p><p>2）代码的鲁棒性。</p><p>3）循环、递归、栈的灵活运用。</p></blockquote><h6 id="▉-扩展思考：循环和递归"><a href="#▉-扩展思考：循环和递归" class="headerlink" title="▉ 扩展思考：循环和递归"></a>▉ 扩展思考：循环和递归</h6><blockquote><p>适用条件：如果需要进行多次计算相同的问题，将采用循环或递归的方式。</p><p>递归的优点：代码简洁。</p><p>递归的缺点：</p><p>1）堆栈溢出：函数调用自身，函数的临时变量是压栈的操作，当函数执行完，栈才清空，如果递归的规模过大，在函数内部一直执行函数的自身调用，临时变量一直压栈，系统栈或虚拟机栈内存小，导致堆栈溢出。</p><p>2）重复计算：递归会出现很多的重复计算问题，重复计算对程序的性能有很大影响，导致消耗时间成指数增长，但是可以通过散列表的方式解决。</p><p>3）高空间复杂度：递归的每次函数调用都要涉及到在内存开辟空间，压栈、出栈等操作，即耗时又耗费空间，导致递归的效率并不如循环的效率。</p><p>扩展：</p><p>1）递归—栈：递归的本质是栈，通常用栈循环解决的问题适合于递归。</p><p>2）递归-动态规划：动态规划解决问题经常用递归的思路分析问题。关于递归重复计算问题，我们通常使用自下而上的解决思路（动态规划）来解决递归重复计算的问题。</p></blockquote><h6 id="▉-注意事项："><a href="#▉-注意事项：" class="headerlink" title="▉ 注意事项："></a>▉ 注意事项：</h6><blockquote><p>1）涉及到循环解决的问题，可以想一想能不能使用递归来解决。</p><p>2）用递归解决一定要铭记递归的缺点带来的性能问题。</p><p>3）递归解决的问题，能不能用动态规划来解决，使得性能更高。</p><p>4）用到栈这种数据结构，想一想递归是否可以实现呢。</p></blockquote><h3 id="2、删除链表结点"><a href="#2、删除链表结点" class="headerlink" title="2、删除链表结点"></a>2、删除链表结点</h3><blockquote><p>题目：在 O（1）的时间复杂度内删除链表节点。</p><p>给定单向链表的头指针和一个节点指针，定义一个函数在 O（1）时间内删除该节点。</p></blockquote><h4 id="2-1-问题分析与解决"><a href="#2-1-问题分析与解决" class="headerlink" title="2.1 问题分析与解决"></a>2.1 问题分析与解决</h4><h6 id="▉-问题分析-1"><a href="#▉-问题分析-1" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><blockquote><p>1）想必看到单链表删除节点的题，第一想到的就是删除链表结点需要以 O（n）时间复杂度遍历链表找到该结点的前结点，然后以 O（1）时间复杂度进行删除，时间复杂度为O（n）。而题目中的确实整体要求时间复杂度为 O（1）。</p><p>2）怎么才能达到 O（1）的时间复杂度删除链表？如果不遍历不就可以了？如果直接删除的时间复杂度为 O（1），前提是我们需要知道前结点才能做到。我们就会想怎么做到不用遍历数据才能获取到前结点呢？而且必须保证时间复杂度为 O（1）。</p><p>3）但是必须让自己多想一步就是如果删除的结点是尾结点怎么操作，如果删除的链表结点只有一个结点，即是尾结点又是头结点怎么办？</p></blockquote><h6 id="▉-算法思路-1"><a href="#▉-算法思路-1" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote><p>得出以下几种实现方式：</p><ul><li>交换结点法</li></ul><p>1）这一有种技巧很难想到，就是我把当前结点的数据与下一结点的数据进行交换，删除下一结点不就可以达到时间复杂度为O（1）了吗。而且我们知道当前结点就是下一结点的前节点，perfect。</p><p>2）针对以上两种特殊情况，如果是尾结点，没有下一结点，我们就从头遍历链表删除节点；如果即是尾结点又是头结点，那么删除头结点，并置于 null。</p></blockquote><h6 id="▉-测试用例-1"><a href="#▉-测试用例-1" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote><p>1)  输入空链表；</p><p>2）在多个结点链表中删除中间结点；</p><p>3）在多个链表中删除头结点；</p><p>4）在多个链表总删除尾结点；</p><p>5）在只有一个结点链表中删除唯一结点；</p></blockquote><h6 id="▉-代码实现"><a href="#▉-代码实现" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 value 查找结点</span></span><br><span class="line">    findByValue = <span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该结点是否找到</span></span><br><span class="line">        <span class="built_in">console</span>.log(currentNode)</span><br><span class="line">        <span class="keyword">return</span> currentNode === <span class="literal">null</span> ? <span class="number">-1</span> : currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素(指定元素向后插入)</span></span><br><span class="line">    insert = <span class="function">(<span class="params">value,element</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//先查找该元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.findByValue(element);</span><br><span class="line">        <span class="comment">//如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"未找到插入位置!"</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.next = currentNode.next;</span><br><span class="line">        currentNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点(核心代码)</span></span><br><span class="line">    deleteNode = <span class="function"><span class="params">node</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前查找的结点是否为 null</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 1、查找删除的结点</span></span><br><span class="line">        <span class="keyword">let</span> d_node = <span class="keyword">this</span>.findByValue(<span class="built_in">parseInt</span>(node.data))</span><br><span class="line">        <span class="comment">// 2、判断该结点是否为尾结点</span></span><br><span class="line">        <span class="keyword">if</span>(d_node.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 重新遍历链表</span></span><br><span class="line">            <span class="keyword">let</span> p = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">while</span>(current.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">                p = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尾结点置为 null</span></span><br><span class="line">            p.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 3、将删除结点的值与下一结点交换</span></span><br><span class="line">            d_node.data = d_node.next.data;</span><br><span class="line">            <span class="comment">// 4、删除下一结点</span></span><br><span class="line">            d_node.next = d_node.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 </span></span><br><span class="line">sortedList1 = <span class="keyword">new</span> LinkedList()</span><br><span class="line">sortedList1.insert(<span class="number">1</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">sortedList1.insert(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">sortedList1.insert(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">sortedList1.print();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------------------------------删除指定结点----------------------------'</span>)</span><br><span class="line"><span class="keyword">let</span> dnode = <span class="keyword">new</span> Node(<span class="string">'1'</span>)</span><br><span class="line">sortedList1.deleteNode(dnode)</span><br><span class="line">sortedList1.print();</span><br></pre></td></tr></table></figure><h6 id="▉-性能分析-1"><a href="#▉-性能分析-1" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><blockquote><ul><li><p>时间复杂度：O（1）。经过上述的方法，删除一个链表的结点，除了删除一个链表的尾结点之外，其他删除节点的时间复杂度为 O（1），获取删除的结点的前一结点，时间复杂度为 O（1），删除节点的时间复杂度为 O（1）。只有删除尾结点才需要遍历整个链表，但大部分删除节点是 O（1）的。使用分析时间复杂度的一个方法摊还分析，将删除节点的时间复杂度平均分到其他大部分情况下，所以平均时间复杂度为 O（1）。</p></li><li><p>空间复杂度：O（1）。不需要额外的内存空间。</p></li></ul></blockquote><h4 id="2-2-小结-1"><a href="#2-2-小结-1" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><h6 id="▉-内容考察"><a href="#▉-内容考察" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><blockquote><p>1）对单链表的删除基本操作。</p><p>2）对问题的有创新思维的解决能力：能不能将复杂问题的根源用另一种思维去优化。</p><p>3）问题考虑的全面性：考虑到问题出现的各种特殊情况，以及边界问题。</p></blockquote><h3 id="3、链表中的倒数第-K-个结点"><a href="#3、链表中的倒数第-K-个结点" class="headerlink" title="3、链表中的倒数第 K 个结点"></a>3、链表中的倒数第 K 个结点</h3><blockquote><p>题目：输入一个链表，输出该链表中倒数第 K 个节点。为符合大多数人的习惯，从 1 开始计数，即链表的尾结点是倒数第一个节点。</p></blockquote><h4 id="3-1-问题分析与解决"><a href="#3-1-问题分析与解决" class="headerlink" title="3.1 问题分析与解决"></a>3.1 问题分析与解决</h4><h6 id="▉-问题分析-2"><a href="#▉-问题分析-2" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><blockquote><p>1）看到这个题的第一想法就是从链表头遍历到链表尾部，然后尾部倒数 k 个数，因为是单链表，所以倒数并不能实现，想法行不通。</p><p>2）那我们只能将思路转移到头结点开始，怎么才能从头结点开始遍历到倒数第 k 个结点呢？大体我们可以得出至少需要遍历两次链表。</p><p>3）上述能不能再优化呢？遍历一次链表就可以完成查找？</p></blockquote><h6 id="▉-算法思路-2"><a href="#▉-算法思路-2" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote><p>得出以下几种实现方式：</p><ul><li>两次遍历法</li><li>一次遍历法</li></ul><p>前提条件：</p><p>1）<strong>不要忘记判断单链表是否为环型结构</strong></p><p>两次遍历法：</p><p>1）有一个规律就是链表的长度 n 减去 k 加 1 就是倒数第 k 个数据。所以需要遍历链表得到链表的长度，然后再遍历两次找到链表的倒数第 k 个数据。整个过程需要遍历两遍链表。</p><p>一次遍历法：</p><p>1）那我们就用到双指针，第一个指针指向第一个结点，第二个指针指向 k - 1 个结点，同时向前移动，直到第二个节点指向尾结点位置，第一个节点就指向了倒数第 k 结点。遍历一遍链表就完成查找。</p></blockquote><h6 id="▉-测试用例-2"><a href="#▉-测试用例-2" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote><p>1）k 的取值范围（0 &lt; k &lt; n）;输入不在范围内的数据。</p><p>2）输入空链表。</p><p>3）查找倒数第 k 结点为头结点/尾结点。    </p></blockquote><h6 id="▉-代码实现-1"><a href="#▉-代码实现-1" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 value 查找结点</span></span><br><span class="line">    findByValue = <span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该结点是否找到</span></span><br><span class="line">        <span class="built_in">console</span>.log(currentNode)</span><br><span class="line">        <span class="keyword">return</span> currentNode === <span class="literal">null</span> ? <span class="number">-1</span> : currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素(指定元素向后插入)</span></span><br><span class="line">    insert = <span class="function">(<span class="params">value,element</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//先查找该元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.findByValue(element);</span><br><span class="line">        <span class="comment">//如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"未找到插入位置!"</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.next = currentNode.next;</span><br><span class="line">        currentNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测单链表是否为环</span></span><br><span class="line">    checkCircle = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否为空链表</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="literal">null</span>) <span class="keyword">return</span> fast;</span><br><span class="line">        <span class="comment">// 定义快慢指针</span></span><br><span class="line">        <span class="keyword">let</span> fast = <span class="keyword">this</span>.head.next;</span><br><span class="line">        <span class="keyword">let</span> low = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="comment">//进行循环判断(当前 fast 结点/fast 移动两步后的结点是否为 null)</span></span><br><span class="line">        <span class="keyword">while</span>(fast !== <span class="literal">null</span> &amp;&amp; fast.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// fast 指针向前移动两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">// low 指针向前移动一步</span></span><br><span class="line">            low = low.next;</span><br><span class="line">            <span class="comment">// 如果为环，总有一天会相遇</span></span><br><span class="line">            <span class="keyword">if</span>(fast === low) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找倒数第 k 结点</span></span><br><span class="line">    findByIndexFromEnd = <span class="function"><span class="params">k</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//判断 k 是否大于0</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">'k 的大小不在搜索范围内'</span>;</span><br><span class="line">        <span class="comment">// 检测是否为环</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.checkCircle()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 定义两个指针进行遍历</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">let</span> fast = current;</span><br><span class="line">        <span class="keyword">let</span> low = current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt;= k - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// k 的大小超出链表大小的范围</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">'k 的大小超出链表的范围'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// low 和 fast 指针同时移动</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回倒数第 k 结点</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">list.insert(<span class="string">'1'</span>,<span class="string">'head'</span>);</span><br><span class="line"><span class="comment">// list.insert('2','1');</span></span><br><span class="line"><span class="comment">// list.insert('3','2');</span></span><br><span class="line"><span class="comment">// list.insert('4','3');</span></span><br><span class="line"><span class="comment">// list.insert('5','4');</span></span><br><span class="line"><span class="comment">// list.insert('6','5');</span></span><br><span class="line">list.print();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-------------------查找倒数第 k 结点----------------'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(list.findByIndexFromEnd(<span class="number">8</span>));</span><br></pre></td></tr></table></figure><h6 id="▉-性能分析-2"><a href="#▉-性能分析-2" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><blockquote><p>两次遍历法：</p><ul><li>时间复杂度：O（k*n）。当 k 趋近于 n 时，最坏时间复杂度为 O（n^2）。</li><li>空间复杂度：O（1）。不需要额外的内存空间。</li></ul><p>一次遍历法：</p><ul><li>时间复杂度：O（n）。只需要遍历一次单链表，所以时间复杂度为O（n）。</li><li>空间复杂度：O（1）。不需要额外的内存空间。</li></ul></blockquote><h4 id="3-2-小结"><a href="#3-2-小结" class="headerlink" title="3.2 小结"></a>3.2 小结</h4><h6 id="▉-内容考察-1"><a href="#▉-内容考察-1" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><blockquote><p>1）对单链表的基本操作。</p><p>2）代码的全面性、鲁棒性。</p></blockquote><h6 id="▉-注意事项"><a href="#▉-注意事项" class="headerlink" title="▉ 注意事项"></a>▉ 注意事项</h6><blockquote><p>1）当我们用一个指针不能解决时，想一想两个指针能否解决？</p></blockquote><h6 id="▉-相关题目"><a href="#▉-相关题目" class="headerlink" title="▉ 相关题目"></a>▉ 相关题目</h6><blockquote><p>1）求中间结点</p><p>2）求倒数第 k 个结点</p><p>3）检测环的存在</p></blockquote><h3 id="4、反转链表"><a href="#4、反转链表" class="headerlink" title="4、反转链表"></a>4、反转链表</h3><blockquote><p>题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转链表的头结点。</p></blockquote><h4 id="4-1-问题分析与解决"><a href="#4-1-问题分析与解决" class="headerlink" title="4.1 问题分析与解决"></a>4.1 问题分析与解决</h4><h6 id="▉-问题分析-3"><a href="#▉-问题分析-3" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><blockquote><p>1）反转链表的我们第一能够想到的方法就是最常用的方法，声明三个指针，把头结点变为尾结点，然后下一结点拼接到尾结点的头部，一次类推。说白了就是就是直接将链表指针反转就可以实现反转链表。</p></blockquote><h6 id="▉-算法思路-3"><a href="#▉-算法思路-3" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote><p>1）定义三个指针，分别为 Pnext、pre、current，current 存储当前结点， pre 指向反转好的结点的头结点，Pnext 存储下一结点信息。</p><p>2）判断当前结点是否可以反转（是否为空链表或链表大于 1 个结点）?</p><p>步骤：</p><p>1）Pnext 指针存储下一结点 。</p><p>2）当前结点的 next 结点是否为 null (为 null 的话当前结点就是最后的一个结点)，如果为 null，将当前节点赋值为 head 头指针（断裂处）。</p><p>3）将 pre 指针指向的结点赋值当前节点 current 的下一结点 next。</p><p>4）然后让 pre 指针指向当前节点 current。</p><p>5）current 继续遍历, 当前节点指向 current 指向 Pnext。</p><p>递归法（重点分析）：</p><p>1）先确定终止条件：当下一结点为  null  时，返回当前节点；</p><p>2）判断当前的链表是否为  null；</p><p>3）递归找到尾结点，将其存储为头结点。</p><p>4）此时递归的层次是第二层递归，所以要设置为头结点的下一结点就是当前第二层结点，并且将第二节点的下一结点设置为 bull。</p></blockquote><h6 id="▉-测试用例-3"><a href="#▉-测试用例-3" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote><p>1）链表是空链表。</p><p>2）当前链表的长度小于等于 1。</p><p>3）输入长度大于 1 的链表。</p></blockquote><h6 id="▉-代码实现-2"><a href="#▉-代码实现-2" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前链表是否为空链表</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义三个指针</span></span><br><span class="line">    <span class="keyword">let</span> [current,prev,next] = [head,<span class="literal">null</span>,<span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//1、存储下一结点</span></span><br><span class="line">        next = current.next;</span><br><span class="line">        <span class="keyword">if</span>(next == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = current;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = prev;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="▉-递归法"><a href="#▉-递归法" class="headerlink" title="▉ 递归法"></a>▉ 递归法</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function">(<span class="params">head</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//如果链表为空或者链表中只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//先反转后面的链表，走到链表的末端结点</span></span><br><span class="line">        <span class="keyword">let</span> newhead = reverseList(head.next);</span><br><span class="line">        <span class="comment">//再将当前节点设置为后面节点的后续节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-性能分析-3"><a href="#▉-性能分析-3" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><blockquote><ul><li>时间复杂度：O(n)。只需遍历整个链表就可以完成反转，时间复杂度为 O(n)。</li><li>空间复杂度：O(1)。只需要常量级的空间，空间复杂度为 O(1)。</li></ul></blockquote><h4 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h4><h6 id="▉-内容考察-2"><a href="#▉-内容考察-2" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><blockquote><p>1）对单链表的基本操作。</p><p>2）对指针操作顺序的逻辑性考察。</p><p>3）考察思维的全面性以及代码的鲁棒性。</p></blockquote><h6 id="▉-注意事项-1"><a href="#▉-注意事项-1" class="headerlink" title="▉ 注意事项"></a>▉ 注意事项</h6><blockquote><p>1）边界条件。</p><p>2）写代码之前想好测试用例，写完代码一一验证测试用例的正确性。</p></blockquote><h3 id="5、合并两个有序链表"><a href="#5、合并两个有序链表" class="headerlink" title="5、合并两个有序链表"></a>5、合并两个有序链表</h3><blockquote><p>题目：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p></blockquote><h4 id="5-1-问题分析与解决"><a href="#5-1-问题分析与解决" class="headerlink" title="5.1 问题分析与解决"></a>5.1 问题分析与解决</h4><h6 id="▉-问题分析-4"><a href="#▉-问题分析-4" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><blockquote><p>1）合并两个链表，经常犯的错误就是没有弄清除指针的指向，导致链表合并的时候断裂以及代码全面性考虑的不全，也就是代码的鲁棒性存在问题。</p><p>2）递归。每次都要比较两个结点大小，是否可以使用递归来解决呢？</p></blockquote><h6 id="▉-算法思路-4"><a href="#▉-算法思路-4" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote><p>一般解决法：</p><p>1）合并两个链表，首先需要两个指针，分别指向两个链表。</p><p>2）比较两个指针指向结点元素的大小，小的结点添加到新链表，然后指针向后移动继续比较。</p><p>3）直到其中一个链表没有结点了，另一个链表存在结点，将剩余的结点加入到新链表的尾部，完成合并。</p><p>递归法：（满足递归的三个条件）</p><p>比较当前结点大小先比较下一结点的大小。</p><p>1）结点之间的比较可以分的子问题为每个节点的比较。</p><p>2）终止条件：其中一个链表结点为 null。</p><p>3）子问题和总问题具有相同的解决思路。</p></blockquote><h6 id="▉-测试用例-4"><a href="#▉-测试用例-4" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote><p>1）输入两个空链表。</p><p>2）其中一个链表为空链表。</p><p>3）输入两个完整的链表。</p></blockquote><h6 id="▉-代码实现-3"><a href="#▉-代码实现-3" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功能:两个有序链表的合并</span></span><br><span class="line"><span class="comment">// 步骤:</span></span><br><span class="line"><span class="comment">// 1、判断两个链表是否为 null,并将链表赋予临时变量</span></span><br><span class="line"><span class="comment">// 2、声明合并链表,通过 currentNode 指向当前结点</span></span><br><span class="line"><span class="comment">// 3、两个链表比较大小,数值小的添加到合并链表中,合并链表进行指针移动</span></span><br><span class="line"><span class="comment">// 4、将链表剩余数据添加到合并链表后边</span></span><br><span class="line"><span class="keyword">const</span> mergeSortList = <span class="function">(<span class="params">listA,listB</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(listA === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(listB === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> a = listA;</span><br><span class="line">    <span class="keyword">let</span> b = listB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明合并链表,通过 currentNode 指向当前结点</span></span><br><span class="line">    <span class="keyword">let</span> resultList = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个链表比较大小,数值小的添加到合并链表中,合并链表进行指针移动</span></span><br><span class="line">    <span class="keyword">if</span> (a.data &lt; b.data) &#123;</span><br><span class="line">        resultList = a</span><br><span class="line">        a = a.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resultList = b</span><br><span class="line">        b = b.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> currentNode = resultList;</span><br><span class="line">    <span class="keyword">while</span> (a !== <span class="literal">null</span> &amp;&amp; b !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.data &lt; b.data) &#123;</span><br><span class="line">            currentNode.next = a</span><br><span class="line">            a = a.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentNode.next = b</span><br><span class="line">            b = b.next</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode = currentNode.next</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表剩余数据添加到合并链表后边 </span></span><br><span class="line">    <span class="keyword">if</span>(a !== <span class="literal">null</span>)&#123;</span><br><span class="line">        currentNode.next = a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        currentNode.next = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回合并链表</span></span><br><span class="line">    <span class="keyword">return</span> resultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-递归实现"><a href="#▉-递归实现" class="headerlink" title="▉ 递归实现"></a>▉ 递归实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断数值大小递归</span></span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">        result = l1;</span><br><span class="line">        result.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = l2;</span><br><span class="line">        result.next = mergeTwoLists(l2.next,l1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="▉-代码测试"><a href="#▉-代码测试" class="headerlink" title="▉ 代码测试"></a>▉ 代码测试</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 value 查找结点</span></span><br><span class="line">    findByValue = <span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该结点是否找到</span></span><br><span class="line">        <span class="built_in">console</span>.log(currentNode)</span><br><span class="line">        <span class="keyword">return</span> currentNode === <span class="literal">null</span> ? <span class="number">-1</span> : currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素(指定元素向后插入)</span></span><br><span class="line">    insert = <span class="function">(<span class="params">value,element</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//先查找该元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.findByValue(element);</span><br><span class="line">        <span class="comment">//如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"未找到插入位置!"</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.next = currentNode.next;</span><br><span class="line">        currentNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个链表</span></span><br><span class="line"><span class="keyword">var</span> mergeSortList = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断数值大小递归</span></span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">        result = l1;</span><br><span class="line">        result.next = mergeSortList(l1.next,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = l2;</span><br><span class="line">        result.next = mergeSortList(l2.next,l1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">sortedList1 = <span class="keyword">new</span> LinkedList()</span><br><span class="line">sortedList1.insert(<span class="number">9</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">8</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">7</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">6</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.print();</span><br><span class="line">sortedList2 = <span class="keyword">new</span> LinkedList()</span><br><span class="line">sortedList2.insert(<span class="number">21</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.insert(<span class="number">20</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.insert(<span class="number">19</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.insert(<span class="number">18</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.print();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'----------------合并两个有序的链表----------------'</span>)</span><br><span class="line"><span class="keyword">let</span> resultList = mergeSortList(sortedList1.head.next,sortedList2.head.next)</span><br><span class="line"><span class="keyword">while</span> (resultList !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resultList.date);</span><br><span class="line">    resultList = resultList.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-性能分析-4"><a href="#▉-性能分析-4" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><blockquote><ul><li>时间复杂度：O（n）。n 为较短的链表的长度。</li><li>空间复杂度：O（n+m）。需要额外的 n+m(两个链表长度之和) 大小的空间来存储合并的结点。</li></ul></blockquote><h4 id="5-2-小结"><a href="#5-2-小结" class="headerlink" title="5.2 小结"></a>5.2 小结</h4><h6 id="▉-内容考察-3"><a href="#▉-内容考察-3" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><blockquote><p>1）对链表的基本操作。</p><p>2）写代码考虑问题的全面性和鲁棒性。</p></blockquote><h6 id="▉-注意事项-2"><a href="#▉-注意事项-2" class="headerlink" title="▉ 注意事项"></a>▉ 注意事项</h6><blockquote><p>1）递归实现，注意递归解决问题的三个缺点。</p><ul><li>堆栈溢出</li><li>重复数据</li><li>高空间复杂度</li></ul></blockquote><h2 id="三、LeetCode-加强练习阶段（阶段三）"><a href="#三、LeetCode-加强练习阶段（阶段三）" class="headerlink" title="三、LeetCode 加强练习阶段（阶段三）"></a>三、LeetCode 加强练习阶段（阶段三）</h2><blockquote><p>如果你对基本的链表操作已经掌握，想进一步提高对链表熟练度的操作，可以练习一下 LeetCode 题目。每道题我都做了详细的解析，如：问题分析、算法思路、代码实现、考查内容等，有关链表的相关题目会不断更新……</p></blockquote><ul><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表 I</a> (<a href="https://github.com/luxiangqiang/JS-LeetCode/blob/master/LinkedListCycle.md" target="_blank" rel="noopener">题目解析</a> )</li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a> (<a href="https://github.com/luxiangqiang/JS-LeetCode/blob/master/LinkedListCycle2.md" target="_blank" rel="noopener">题目解析</a> )</li><li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a> (<a href="https://github.com/luxiangqiang/JS-LeetCode/blob/master/MergekSortedLists.md" target="_blank" rel="noopener">题目解析</a> )</li></ul><h2 id="四、链表总结"><a href="#四、链表总结" class="headerlink" title="四、链表总结"></a>四、链表总结</h2><blockquote><p>做了大量有关链表的题型之后，对链表的操作做一个总结和复盘，对链表有一个整体的把握和重新的认识。</p></blockquote><h4 id="1、结构上"><a href="#1、结构上" class="headerlink" title="1、结构上"></a>1、结构上</h4><blockquote><p>1）存储链表的内存空间是不连续的，所有需要使用指针将这些零碎内存空间连接起来，导致需要通过指针来进行操作，这也是为什么链表中大多数都是关于指针的操作的原因。</p><p>2）链表在结构上有两个特殊的地方就是链表头和链表尾，很多操作都要对链表头和链表尾进行特殊处理，所以我们可以借助哨兵思想（在链表头添加一个哨兵），这样带头的链表可以简化问题的解决。</p></blockquote><h4 id="2、操作上"><a href="#2、操作上" class="headerlink" title="2、操作上"></a>2、操作上</h4><blockquote><p>1）递归：链表中的很多操作都是可以用递归来进行解决的，因为链表的每个结点都有着相同的结构，再加上解决的问题可以分解为子问题进行解决。所以在链表中递归编程技巧还是非常常用的。如：从尾到头打印链表、合并两个有序链表、反转链表等。</p><p>2）双指针：链表中大部分都是进行指针操作，链表属于线性表结构（形如一条线的结构），很多问题可以使用双指针来解决，也是非常常用到的。如：查找倒数第K 结点、求链表的中间结点等。</p></blockquote><h4 id="3、性能上"><a href="#3、性能上" class="headerlink" title="3、性能上"></a>3、性能上</h4><blockquote><p>1）链表正是因为存储空间不连续，对 CPU 缓存不友好，随时访问只能从头遍历链表，时间复杂度为 O（n），但是链表的这种结构也有个好处就是。可以动态的申请内存空间，不需要提前申请。</p><p>2）指针的存储是需要额外的内存空间的，如果存储的数据远大于存储指针的内存空间，可以进行忽略。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有关链表的所有操作和题型的详细解析和扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【跨域问题】</title>
    <link href="http://yoursite.com/2019/04/10/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/10/前端进阶深入系列之【跨域问题】/</id>
    <published>2019-04-10T02:56:08.699Z</published>
    <updated>2019-04-18T11:51:57.747Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AJAX 以及跨域问题完整详细解析，面试、日常项目常用点。</p><a id="more"></a><p>[TOC]</p><h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><h2 id="一、同源策略"><a href="#一、同源策略" class="headerlink" title="一、同源策略"></a>一、同源策略</h2><h4 id="1-1-同源策略的由来"><a href="#1-1-同源策略的由来" class="headerlink" title="1.1 同源策略的由来"></a>1.1 同源策略的由来</h4><blockquote><p>为了防止网站遭到恶意攻击，这里所谓恶意攻击就是从自己服务器的页面代码 js 中通过别人的 URL 去请求别人的服务器资源，这样通俗一点。这会导致信息被窃取，所以浏览器设计了同源策略。</p></blockquote><p>例如：A 网站的服务器存有 A 网站用户的登录、账户等信息，该信息通常是由 A 网站的用户可获取的，但是如果没有同源策略，那么 B 网站的用户可以通过 AJAX 请求 A 网站服务器的资源，从而获取到用户的信息，导致用户信息被窃取。</p><h4 id="2-2-什么是同源策略"><a href="#2-2-什么是同源策略" class="headerlink" title="2.2 什么是同源策略"></a>2.2 什么是同源策略</h4><blockquote><p>1995年，同源政策由 Netscape 公司引入浏览器。 所谓的「同源」，浏览器规定 AJAX 做请求时，请求的服务器的 URL 的域名必须和当前页面的 URL 「域名相同」浏览器才会让你做请求（同源才会进行通信）。相同包括三个部分：</p></blockquote><ul><li>域名相同</li><li>协议相同</li><li>端口号相同</li></ul><p>举例：假设网址为 <a href="http://www.xiaolu.com/example/index.html" target="_blank" rel="noopener">http://www.xiaolu.com/example/index.html</a> ，请求的服务器 URL 必须在一下三个方面做到相同才可以请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//协议</span></span><br><span class="line">如果服务器使用 https 的协议： https:<span class="comment">//www.xiaolu.com/example/index.html （不同源，不能请求）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//端口号</span></span><br><span class="line">如果服务器使用 <span class="number">8016</span> 端口号：http:<span class="comment">//www.xiaolu.com：8016/example/index.html （不同源，不能请求）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//域名</span></span><br><span class="line">如果服务器使用其他域名：http:<span class="comment">//www.lu.xiaolu.com：8016/example/index.html （不同源，不能请求）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三者必须都相同</span></span><br><span class="line">http:<span class="comment">//www.xiaolu.com/example/index.html （同源，可以请求）</span></span><br></pre></td></tr></table></figure><h4 id="2-3-同源策略的问题"><a href="#2-3-同源策略的问题" class="headerlink" title="2.3 同源策略的问题"></a>2.3 同源策略的问题</h4><blockquote><p>虽然浏览器引入了同源策略，防止了恶意网站获取资源导致信息泄露。但是，会导致一下几个问题。</p></blockquote><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取。 </li><li>DOM 无法获得。 </li><li>AJAX 请求不能发送。 </li></ul><h5 id="1、不同源获取-Cookie"><a href="#1、不同源获取-Cookie" class="headerlink" title="1、不同源获取 Cookie"></a>1、不同源获取 Cookie</h5><blockquote><p>同源策略导致不同源的页面是不可以获取 Cookie 值的，如果有存在不同源的两个页面（一级域名相同，二级域名不同），想要共享 Cookie ，怎么做呢？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设两个共享 Cookie 的网址</span></span><br><span class="line">A 网址：http:<span class="comment">//v1.xiaolu.com/index.html</span></span><br><span class="line">B 网址：http:<span class="comment">//v2.xiaolu.com/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一：通过设置两个页面的 domain 值相同，就可以共享 Cookie</span></span><br><span class="line"><span class="comment">// 注意：只是适用于二级域名不同 Cookie 和 iframe,对于 LocalStorage 和 IndexDB 不适用。 </span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'.xiaolu.com'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：服务器设置 Cookie 的时候，指定 Cookie 所属一级域名，上述如果一级域名不同也不会存在限制</span></span><br><span class="line"><span class="built_in">Set</span>-Cookie: key=value; domain=.xiaolu.com; path=<span class="regexp">/</span></span><br></pre></td></tr></table></figure><h2 id="二、AJAX-跨域共享"><a href="#二、AJAX-跨域共享" class="headerlink" title="二、AJAX 跨域共享"></a>二、AJAX 跨域共享</h2><h3 id="2-1-架设代理服务器"><a href="#2-1-架设代理服务器" class="headerlink" title="2.1 架设代理服务器"></a>2.1 架设代理服务器</h3><blockquote><p>同源域名下架设代理服务器，JavaScript负责把请求发送到代理服务器，代理服务器将结果返回，准守了浏览器的同源策略。</p><p><strong>缺点：需要额外的服务器做开发</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;/proxy?url=http://www.baidu.com.cn&apos;</span><br></pre></td></tr></table></figure><h3 id="2-2-domain"><a href="#2-2-domain" class="headerlink" title="2.2 domain"></a>2.2 domain</h3><blockquote><p>同一主域的不同子域可以设置document.domain为主域来让他们同域,并且子域的协议和端口都要一致。</p><p>document.domain只能设置往上设置域名,需要载入iframe来相互操作。</p></blockquote><h3 id="2-3-JSONP"><a href="#2-3-JSONP" class="headerlink" title="2.3 JSONP"></a>2.3 JSONP</h3><blockquote><p>一些带 src 的 html 标签都可以实现跨域，link、font-face、img、video、audio、script等。 </p></blockquote><h4 id="1、本质"><a href="#1、本质" class="headerlink" title="1、本质"></a>1、本质</h4><blockquote><p>利用浏览器允许跨域引用  JavaScript 资源的功能。</p></blockquote><h4 id="2、缺点"><a href="#2、缺点" class="headerlink" title="2、缺点"></a>2、缺点</h4><blockquote><p>只能用 Get 请求，并且返回 javascript。</p></blockquote><h4 id="3、优点"><a href="#3、优点" class="headerlink" title="3、优点"></a>3、优点</h4><blockquote><p>简单适用，老式浏览器全部支持，服务器改造非常小 </p></blockquote><h4 id="4、基本流程"><a href="#4、基本流程" class="headerlink" title="4、基本流程"></a>4、基本流程</h4><blockquote><p>JSONP 通常以函数的形式返回，需要在页面写好返回的函数，页面动态的添加一个<code>&lt;script&gt;</code>节点，动态读取外域的 javascript 资源，然接受回调。（在外域的 javascript 文件中返回一个函数，函数中有我们需要的数据，我们在本地触发该函数就可以完成跨域）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">      script.setAttribute(<span class="string">"type"</span>,<span class="string">"text/javascript"</span>);</span><br><span class="line">      script.src = src;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      addScriptTag(<span class="string">'http://ip.jsontest.com/?callback=ip'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ip</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      alert(data.ip);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5、安全性"><a href="#5、安全性" class="headerlink" title="5、安全性"></a>5、安全性</h4><blockquote><p>当这个接口没有验证Referer头的时候,就存在JSONP劫持漏洞,即在任何域下都能窃取到传输的数据。</p><p>当接口返回的是一些敏感数据时(如CSRF TOKEN,用户个人信息等),危害是很大的。</p></blockquote><h3 id="2-4-WebSocket"><a href="#2-4-WebSocket" class="headerlink" title="2.4 WebSocket"></a>2.4 WebSocket</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><blockquote><p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，<strong>只要服务器支持</strong>，就可以通过它进行跨源通信。 </p></blockquote><h4 id="2、基本流程"><a href="#2、基本流程" class="headerlink" title="2、基本流程"></a>2、基本流程</h4><blockquote><p>浏览器发出的WebSocket请求的头信息。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/<span class="number">1.1</span></span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: <span class="number">13</span></span><br><span class="line">Origin: http:<span class="comment">//example.com</span></span><br></pre></td></tr></table></figure><blockquote><p>因为请求头部信息中的 origin 字段，所以 websocket 没有同源策略。服务器根据这个字段进行相应。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><h3 id="2-5-CORS"><a href="#2-5-CORS" class="headerlink" title="2.5 CORS"></a>2.5 CORS</h3><blockquote><p>CORS 是 “跨域资源共享” （Cross-origin resource sharing ）的缩写，解决 AJAX 只能同源通信的限制问题。</p></blockquote><h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><blockquote><p><strong>1）基本流程 ：</strong>整个 CORS 是浏览器自动完成的，浏览器一旦发现 AJAX 是跨域请求，自动添加一些信息在头部，只要服务器端能够识别在头部的信息，就可以完成跨域通信。</p><p><strong>2）设计思想：</strong>CORS 的设计思想就是使用自定义 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还应该是失败。</p></blockquote><h4 id="2、兼容性"><a href="#2、兼容性" class="headerlink" title="2、兼容性"></a>2、兼容性</h4><blockquote><p>CORS 需要浏览器和服务器同时支持，IE 不能低于 IE10。</p></blockquote><h4 id="3、CORS-两种请求方式"><a href="#3、CORS-两种请求方式" class="headerlink" title="3、CORS 两种请求方式"></a>3、CORS 两种请求方式</h4><blockquote><p>CORS 分为两种请求方式：</p></blockquote><ul><li><strong>普通请求:</strong> 简单的进行 AJAX 跨域请求，不需要服务器设置对请求的一些限制条件。</li><li><strong>高级请求 :</strong> 服务器对 AJAX 跨域请求设置限制条件，如：请求方法必须使用 Get 或者 Post、SSL 认证等。</li></ul><h4 id="4、请求流程"><a href="#4、请求流程" class="headerlink" title="4、请求流程"></a>4、请求流程</h4><blockquote><p>当浏览器发现是 AJAX 跨域请求时，就会识别此次跨域请求是普通请求还是高级请求，怎么识别普通请求和高级请求呢？根据浏览器发现 ajax 进行跨域请求时自动添加上的头部信息进行识别，如果头部信息符合一下两个条件就为「普通请求」，如果不符合一下两个条件，就判断为「高级请求」。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1）普通请求使用一下请求方法之一</span></span><br><span class="line">● HEAD </span><br><span class="line">● GET</span><br><span class="line">● POST</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2）自动添加的头部信息小于等于一下几个字段</span></span><br><span class="line">● Accept</span><br><span class="line">● Accept-Language</span><br><span class="line">● Content-Language</span><br><span class="line">● Last-Event-ID</span><br><span class="line">● Content-Type：application/x-www-form-urlencoded、multipart/form-data、text/plain 三个类型之一</span><br></pre></td></tr></table></figure><h5 id="4-1-普通请求"><a href="#4-1-普通请求" class="headerlink" title="4.1 普通请求"></a>4.1 普通请求</h5><h6 id="▉-判断请求方式"><a href="#▉-判断请求方式" class="headerlink" title="▉ 判断请求方式"></a>▉ 判断请求方式</h6><blockquote><p>AJAX 发送跨域请求，通过以上几个条件判断该请求是否为普通请求，如果满足条件，此次跨域请求为普通求请求。</p></blockquote><h6 id="▉-普通请求的基本流程"><a href="#▉-普通请求的基本流程" class="headerlink" title="▉ 普通请求的基本流程"></a>▉ 普通请求的基本流程</h6><blockquote><p>浏览器发现 AJAX 是跨域请求，然后再请求的头部添加一个 <code>Origin</code> 字段信息（发出请求的源地址）。然后浏览器检查请求信息确定此次的跨域的请求方式，如果为普通请求，请求信息相关字段如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/<span class="number">1.1</span>         <span class="comment">//请求方法</span></span><br><span class="line">Origin: http:<span class="comment">//xiaolu.com  //跨域字段（该字段的值为请求的源地址信息，包括域名、端口号、协议）</span></span><br><span class="line">Host: api.alice.com        <span class="comment">//主机地址</span></span><br><span class="line">Accept-Language: en-US     <span class="comment">//语言类型</span></span><br><span class="line">Connection: keep-alive     <span class="comment">//连接方式</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>... <span class="comment">//浏览器版本</span></span><br></pre></td></tr></table></figure><h6 id="▉-服务器端"><a href="#▉-服务器端" class="headerlink" title="▉ 服务器端"></a>▉ 服务器端</h6><blockquote><p>请求到达服务器，服务器提取 <code>Origin</code>信息，看是谁给我发来的请求信息，判断 <code>Origin</code> 是否为之前在服务器设置好的 <code>Origin</code> 字段信息，如果没有此信息，就返回一个正常的 HTTP 响应。如果有此信息，就在 HTTP 回应的头部添加几个字段，让浏览器根据服务器添加的几个字段再判断此次跨域请求是否同意了。</p></blockquote><p>如果此次请求被允许，HTTP 响应的头部添加一下几个字段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1)用来让浏览器判断该信息服务器是否允许了此次请求。</span></span><br><span class="line"><span class="comment">// 2)如果值为 * ，表示服务器可以接收任意域名的请求。</span></span><br><span class="line"><span class="comment">// 3）否则，代表服务器之允许设置好的域名进行跨域请求。</span></span><br><span class="line">Access-Control-Allow-Origin:  http:<span class="comment">//xiaolu.com </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）该字段表示浏览器是否可以向服务器发送 Cookie，默认情况 Cookie 不存在 CORS 请求中的。</span></span><br><span class="line"><span class="comment">// 2) 设置为 true，允许 Cookie 信息包含在请求中的。</span></span><br><span class="line"><span class="comment">// 3) 如果服务器不要浏览器发送Cookie，删除该字段即可</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）如果不设置此字段，浏览器接受到请求之后，只能通过 XMLHttpRequest 对象的 getResponseHeader()拿到最基本的 6 个字段。</span></span><br><span class="line"><span class="comment">// 2）如果想要拿到其他字段，需要在下面字段中指定。(下面设置了允许获取取 name 字段信息,通过 getResponseHeader('FooBar') 获取字段的值)</span></span><br><span class="line">Access-Control-Expose-Headers: name</span><br><span class="line"></span><br><span class="line"><span class="comment">//1）响应类型和字符编码</span></span><br><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure><h6 id="▉-客户端（AJAX-请求端）"><a href="#▉-客户端（AJAX-请求端）" class="headerlink" title="▉ 客户端（AJAX 请求端）"></a>▉ 客户端（AJAX 请求端）</h6><blockquote><p>当浏览器接收到服务器的响应信息后，判断响应头中是否包含 <code>Access-Control-Allow-Origin</code> 字段，如果没有包含，浏览器就不会将响应信息让开发人员做处理，直接抛出一个错误，回调 <code>XMLHttpRequest</code>的<code>onerror</code> 方法（虽然服务器返回的状态码可能是 200，但是被浏览器拦截了，就会被 onerror 所捕获）。</p></blockquote><h6 id="▉-withCredentials-属性"><a href="#▉-withCredentials-属性" class="headerlink" title="▉ withCredentials 属性"></a>▉ withCredentials 属性</h6><blockquote><p>CORS 请求默认不发送 Cookie 等认证信息。如果要发送 Cookie 信息，需要分别在服务器和 AJAX 请求中设置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端响应头部添加一下字段</span></span><br><span class="line"><span class="comment">//注意：发送 Cookie ,服务器的 Access-Control-Allow-Origin 的字段不能设置为 * 。必须指定明确的、与请求网页一致的域名。只有这样，服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传。</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端在 AJAX 请求中设置（即使服务器统一发送 Cookie ，但是浏览器不统一发送 Cookie 必须设置下字段）</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h5 id="4-2-高级请求"><a href="#4-2-高级请求" class="headerlink" title="4.2 高级请求"></a>4.2 高级请求</h5><h6 id="▉-判断请求方式-1"><a href="#▉-判断请求方式-1" class="headerlink" title="▉ 判断请求方式"></a>▉ 判断请求方式</h6><blockquote><p>发送 AJAX 跨域请求，浏览器检测请求信息中存在 PUT 或 DELETE 方法，或者 <code>Content-Type</code>字段的类型是<code>application/json</code>  ，就将此次跨域请求定义为「高级请求」。</p></blockquote><h6 id="▉-高级请求的基本流程"><a href="#▉-高级请求的基本流程" class="headerlink" title="▉ 高级请求的基本流程"></a>▉ 高级请求的基本流程</h6><blockquote><p>高级请求会在真正的请求之前，先和服务器“打电话”，问一下服务器当前网页的域名，以及请求方法能够进行此次通信。服务器说，这次通信可以使用 PUT 或 DELETE 方法，那么浏览器才会发出 AJAX 的正式请求，否则就会报错。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Ajax 跨域请求的正式内容：</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://xiaolu.com '</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h6 id="▉-preflight-预请求"><a href="#▉-preflight-预请求" class="headerlink" title="▉ preflight 预请求"></a>▉ preflight 预请求</h6><blockquote><p>上述中，在真正的请求之前，「浏览器」先和服务器“打电话”，打电话的过程称为 “preflight 请求“。preflight 预请求的内容如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: <span class="string">'http://xiaolu.com '</span>    <span class="comment">// 源地址 </span></span><br><span class="line">Access-Control-Request-Method: PUT  <span class="comment">//请求方法</span></span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure><p><strong>步骤一：浏览器发出请求</strong></p><blockquote><p>该预请求信息通过浏览器的 OPTIONS 方法来询问服务器，发送该预请求的内容，就是用来让服务器接受判断这些信息是否符合服务器端的要求。</p></blockquote><p><strong>步骤二：服务器响应请求</strong></p><blockquote><p>服务器接受到信息之后，取出字段进行以预先设置好的字段值进行判断，然后做出回应。如果与服务器设置的不符合条件，此次拒绝了 preflight 预先请求，就会返回一个正常的 HTTP 响应给浏览器。否则响应以下信息给浏览器。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="built_in">Date</span>: Mon, <span class="number">01</span> Dec <span class="number">2008</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> GMT</span><br><span class="line">Server: Apache/<span class="number">2.0</span><span class="number">.61</span> (Unix)</span><br><span class="line">Access-Control-Allow-Origin:  <span class="string">'http://xiaolu.com '</span></span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Max-Age: <span class="number">1728000</span> <span class="comment">//服务器运行此源地址请求的时间，一旦超过这个时间，就重新进行预请求</span></span><br><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br><span class="line">Keep-Alive: timeout=<span class="number">2</span>, max=<span class="number">100</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><p><strong>步骤三：浏览器接收请求 </strong></p><blockquote><p>1）浏览器接收到服务器的响应之后，发现只有简单的 HTPP 响应头部，没有任何的 CORS 请求信息，浏览器就知道了服务器拒绝这次 preflight 预请求，然后返回给开发人员一个错误信息，被 <code>XMLHttpRequest</code>对象的<code>onerror</code> 回调函数捕获 。</p><p>2）如果浏览器发现服务器返回的请求带有 CORS 请求头部，就获取字段判断，此次服务器允许了此次请求。</p></blockquote><p><strong>步骤四：AJAX 正常请求和回应</strong></p><blockquote><p>preflight 预请求一旦通过，浏览器就会向服务器发送正式的 AJAX 请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样。</p></blockquote><h4 id="5、安全性-1"><a href="#5、安全性-1" class="headerlink" title="5、安全性"></a>5、安全性</h4><blockquote><p><strong>安全漏洞：</strong>因为 <code>Access-Control-Allow-Origin</code>  设置成通配符”*”时,表示允许任何域名跨源，如果再把 <code>Access-Control-Allow-Credentials</code> 设置为 true,允许客户端带上 cookie 的话,无疑此时是非常危险的.因为攻击者很容易就能窃取到用户个人的数据。 </p><p><strong>保护机制：</strong>客户端不带 cookie 请求的话还是会正常呈现的,因为 cookie 是一种身份标识,一旦浏览器标识了用户身份,那么返回的数据必然属于用户个人,所以浏览器设计了这种措施来保护用户数据不被泄露。 </p></blockquote><h6 id="▉-配置错误"><a href="#▉-配置错误" class="headerlink" title="▉ 配置错误"></a>▉ 配置错误</h6><blockquote><p>尽管 CORS 在设计上考虑到安全问题，但是在用户配置时经常出现很多错误，如设置 ”Access-Control-Allow-Origin”的白名单时,正则写的不正确,导致预期外的域名可以跨域。 </p></blockquote><h3 id="2-5-CORS-与-JSONP-比较"><a href="#2-5-CORS-与-JSONP-比较" class="headerlink" title="2.5 CORS 与 JSONP 比较"></a>2.5 CORS 与 JSONP 比较</h3><blockquote><p>1、JSONP 只支持 GET 请求。CORS 支持所有的 HTTP 请求。</p><p>2、JSONP 支持老式浏览器以及向不支持 CORS 的服务器请求数据。CORS 只支持 IE10 版本以上浏览器。</p></blockquote><h3 id="2-6-IE-对-CORS-的实现"><a href="#2-6-IE-对-CORS-的实现" class="headerlink" title="2.6 IE 对 CORS 的实现"></a>2.6 IE 对 CORS 的实现</h3><blockquote><p>通过 XHR 实现 AJAX 通信是一个主要限制，默认情况下，XHR 对象只能访问与包含它页面在同一域下的资源</p></blockquote><h4 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h4><blockquote><p>微软在 IE8 中引入了 XDR 类型，部分实现了 CORS 的规范，使得 IE 可以完成跨域处理。             </p></blockquote><h4 id="2、XDR-与-XHR-的不同"><a href="#2、XDR-与-XHR-的不同" class="headerlink" title="2、XDR 与 XHR 的不同"></a>2、XDR 与 XHR 的不同</h4><ul><li>Cookie 不能随请求发送，也不会随响应返回。</li><li>只能设置请求头部的 Content-Type 字段。</li><li>不能访问响应头部的信息。</li><li>只支持 GET 和 POST 请求。</li></ul><h4 id="3、XDR-的使用"><a href="#3、XDR-的使用" class="headerlink" title="3、XDR 的使用"></a>3、XDR 的使用</h4><blockquote><p>1、XDR 与 XHR 的 open 方法稍有不同，XDR 的 open 函数只有两个参数（只有异步操作），请求返回后，会触发 onload 事件，可以获取到返回的文本内容。</p><p>2、响应只能访问文本文件，没有状态码可用，如果缺少 Access-Control-Allow-Origin 头部就会触发 onerror 事件。（所有的请求错误只能用 onerror 来捕获） </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(xdr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'响应错误'</span>);</span><br><span class="line">&#125;</span><br><span class="line">xdr.open(<span class="string">'get'</span>,<span class="string">'http://xiaolu.com/index.html'</span>);</span><br><span class="line">xdr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="4、POST-请求"><a href="#4、POST-请求" class="headerlink" title="4、POST 请求"></a>4、POST 请求</h4><blockquote><p>XDR 为了支持 post 请求，XDR 提供了 contentType 属性，用来表示发送数据的格式，</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xdr.Content-Type = <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">xdr.send(<span class="string">"name1=value1&amp;name2=value2"</span>)</span><br></pre></td></tr></table></figure><h3 id="2-7-其他浏览器对-CORS-的实现"><a href="#2-7-其他浏览器对-CORS-的实现" class="headerlink" title="2.7 其他浏览器对 CORS 的实现"></a>2.7 其他浏览器对 CORS 的实现</h3><blockquote><p>Firefox 3.5+、Safari 4+、Chrome、iso 和 Android 平台中的 webKit 都通过了 XMLHttpRequest 对象实现了对 CORS 的原生支持。</p></blockquote><h4 id="1、XHR"><a href="#1、XHR" class="headerlink" title="1、XHR"></a>1、XHR</h4><blockquote><p>在尝试打开不同来源的资源时，无序额外的编码触发这个行为，只需在 open 中传入绝对的 URL 就可以触发浏览器的跨域。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跨域的绝对 URL 路径</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>,<span class="string">"http://www.xiaolu2.com/page/index.html"</span>)</span><br></pre></td></tr></table></figure><h4 id="2、XHR-的限制"><a href="#2、XHR-的限制" class="headerlink" title="2、XHR 的限制"></a>2、XHR 的限制</h4><ul><li>不能使用 setRequestHeader() 设置自定义的头部。</li><li>不能发送和接受 Cookie。</li><li>调用 getAllResponseHeaders() 方法总返回空字符串。</li></ul><h3 id="2-7-跨浏览器的-CORS"><a href="#2-7-跨浏览器的-CORS" class="headerlink" title="2.7 跨浏览器的 CORS"></a>2.7 跨浏览器的 CORS</h3><blockquote><p>浏览器对 CORS 的支持程度不一样，但是都能实现简单（不带 preflight）的请求，所以要实现一个跨浏览器的方案。</p><p>1、检测 XHR 是否支持 CORS ：检测是否存在 <code>withCredentials</code> 属性(该属性只存在 IE 10 以上版本)。</p><p>2、检测 XDomain 对象是否存在：该属性只存在 IE 8 以上浏览器中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCORSRequest</span>(<span class="params">method,url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"withCredentials"</span> <span class="keyword">in</span> xhr)&#123; <span class="comment">// IE 10+</span></span><br><span class="line">       xhr.open(method,url,<span class="literal">true</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> XDomainRequest != <span class="string">"undefined"</span>)&#123; <span class="comment">// IE 8+</span></span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XDomainRequest();</span><br><span class="line">        xhr.open(<span class="string">'get'</span>,<span class="string">'http://xiaolu.com/index.html'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        xhr = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xhr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = createCORSRequest(<span class="string">"get"</span>,<span class="string">"http://www.xiaolu.com"</span>);</span><br><span class="line"><span class="keyword">if</span>(request)&#123;</span><br><span class="line">    request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 对 request.responseText 进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">     request.send</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论是 Firefox 3.5+、Safari 4+、Chrome 中的 XMLHttpRequest 对象还是 IE 中的XDomainRequest 对象，都可以使用以上的方法。</p></blockquote><ul><li>onerror：用于替代 <code>onreadystatechange</code> 检测错误。</li><li>onload：用于替代 <code>onreadystatechange</code> 检测成功。</li></ul><h2 id="三、跨域存在的两种攻击（XSS-CSRF）"><a href="#三、跨域存在的两种攻击（XSS-CSRF）" class="headerlink" title="三、跨域存在的两种攻击（XSS/CSRF）"></a>三、跨域存在的两种攻击（XSS/CSRF）</h2><h3 id="3-1-跨站请求伪造（CSRF）"><a href="#3-1-跨站请求伪造（CSRF）" class="headerlink" title="3.1 跨站请求伪造（CSRF）"></a>3.1 跨站请求伪造（CSRF）</h3><blockquote><p>跨站伪造请求（Cross-site request forgery ），缩写为 CSRF。CSRF 利用的是网站对用户网页浏览器的信任来进行恶意攻击的。</p></blockquote><h4 id="1、攻击原理"><a href="#1、攻击原理" class="headerlink" title="1、攻击原理"></a>1、攻击原理</h4><blockquote><p>攻击者通过技术手段欺骗用户的浏览器去访问一个曾经认证过的网站，所以用户不用进行重新认证，这是一个用户身份验证的一个漏洞：<strong>简单身份认证只保证请求来自某个用户的浏览器，确不能保证请求的本身是用户自愿发出的。</strong>攻击者诱导用户在刚访问不久的网站中点击设定的链接（本页的论坛、博客等自动生成的链接内容）。</p></blockquote><h4 id="2、防御措施"><a href="#2、防御措施" class="headerlink" title="2、防御措施"></a>2、防御措施</h4><h6 id="▉-检查-Referer-字段"><a href="#▉-检查-Referer-字段" class="headerlink" title="▉ 检查 Referer 字段"></a>▉ 检查 Referer 字段</h6><blockquote><p>HTTP 头有一个 Referer 字段，用来标记请求来源于哪个地址。Referer字段应和请求的地址位于同一域名下。 服务器在处理请求的时候，可以判断该字段是否位于正确的源地址下发送的请求。如果是 CSRF 攻击，该字段会包含恶意的网址。</p><p><strong>局限性：</strong>设置 Referer 有本身的局限性，攻击者可以篡改 Referer 字段来达到攻击的目的。</p></blockquote><h6 id="▉-添加校验-token"><a href="#▉-添加校验-token" class="headerlink" title="▉ 添加校验 token"></a>▉ 添加校验 token</h6><blockquote><p><strong>本质：</strong>CSRF 的本质是在于攻击者欺骗自己去访问设置的地址，如果在请求数据的时候，用户不把信息保存到浏览器的 Cookie 中，那么攻击者无法获取数据校验，从而不能进行 CSRF 攻击。</p><p><strong>随机校验：</strong>服务器为客户端的窗体设置一个伪随机数，客户端在提交请求的时候，将随机数与请求内容一并提交服务器，正常访问时，客户端将会收到正确得到并传回这个伪随机数。CSRF 攻击无从事先知道这个伪随机数，所以导致 token 值为空，拒绝请求。</p></blockquote><h6 id="▉-JSONP-劫持漏洞"><a href="#▉-JSONP-劫持漏洞" class="headerlink" title="▉ JSONP 劫持漏洞"></a>▉ JSONP 劫持漏洞</h6><blockquote><p>如果 JSONP 没有验证 Referer 头的时候,就存在JSONP劫持漏洞,即在任何域下都能窃取到传输的数据。 </p></blockquote><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul><li>Javascript 高级程序设计</li><li><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AJAX 以及跨域问题完整详细解析，面试、日常项目常用点。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>吃透 javascript 之【完整篇】</title>
    <link href="http://yoursite.com/2019/04/03/%E5%90%83%E9%80%8F%20JavaScript%20%E4%B9%8B%E3%80%90%E5%AE%8C%E6%95%B4%E7%AF%87%E3%80%91%20/"/>
    <id>http://yoursite.com/2019/04/03/吃透 JavaScript 之【完整篇】 /</id>
    <published>2019-04-03T15:40:12.431Z</published>
    <updated>2019-04-17T16:00:32.866Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Javascript 的重点学习路线完整篇。</p><a id="more"></a><h3 id="一、JavaScript-简介"><a href="#一、JavaScript-简介" class="headerlink" title="一、JavaScript 简介"></a>一、JavaScript 简介</h3><h4 id="1、诞生"><a href="#1、诞生" class="headerlink" title="1、诞生"></a>1、诞生</h4><blockquote><p>最早期网景公司开启 web 时代的第一代互联网，早起网景公司只是做静态页面，为了能够在静态页面添加一些动态的效果，所以叫Brendan Eich 这两个人两星期之内设计出 javascript ，不出所料，这两人只用了短短的10天时间。为了使其能够借助 java 的盛行，所以起名 javascript。</p></blockquote><h4 id="2、ECMAScript"><a href="#2、ECMAScript" class="headerlink" title="2、ECMAScript"></a>2、ECMAScript</h4><blockquote><p>网景开发了 javascript 之后，微软也模仿开发了 Jscript，为了能够让 javascript 称为全球的开发标准，所以几个公司联合发布了 ECMA 标准。ECMAScript 是一种语言标准，而网景公司开发的 javascript 是这一标准的实现。</p></blockquote><h4 id="3、版本"><a href="#3、版本" class="headerlink" title="3、版本"></a>3、版本</h4><blockquote><p>因为 javascript 的标准在短时间实现的，其中存在很多的缺陷，所以 javascript 的标准 ECMAScript 不断发展，到目前的 ES6 版本 2015 年发布。这里的 javascript 版本一般说的就是实现了 ECMAScript 哪个版本。</p></blockquote><h3 id="二、数据类型和变量"><a href="#二、数据类型和变量" class="headerlink" title="二、数据类型和变量"></a>二、数据类型和变量</h3><h4 id="1、-和-的区别？"><a href="#1、-和-的区别？" class="headerlink" title="1、== 和 ===的区别？"></a>1、<code>==</code> 和 <code>===</code>的区别？</h4><blockquote><p>== 是 javascript 的设计缺陷，一般使用 === 来比较。</p><p><code>==</code> : 两种之间比较需要先进行转换，然后进行比较，有时候出现很奇怪的情况。</p><p><code>===</code> :  先比较类型，如果类型相等，然后在比较值。</p></blockquote><h4 id="2、NAN-是-Number-特殊的值"><a href="#2、NAN-是-Number-特殊的值" class="headerlink" title="2、NAN 是 Number 特殊的值"></a>2、NAN 是 Number 特殊的值</h4><blockquote><p>NAN 与任何值都不相等，包括它本身自己。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN === NaN; // false</span><br></pre></td></tr></table></figure><blockquote><p>唯一能判断 <code>NaN</code> 的方法是通过 <code>isNaN()</code> 函数 </p></blockquote><h4 id="3、浮点型之间的比较"><a href="#3、浮点型之间的比较" class="headerlink" title="3、浮点型之间的比较"></a>3、浮点型之间的比较</h4><blockquote><p><strong>问题</strong>：浮点型在运算会产生误差，导致计算机无法准确表示无限循环小数，所以导致比较不相等。</p><p><strong>解决：</strong>要比较浮点型之间的大小，要比较两个浮点型之差的绝对值是否小于某一个阈值。</p></blockquote><h4 id="4、null-和-undefined"><a href="#4、null-和-undefined" class="headerlink" title="4、null 和 undefined"></a>4、null 和 undefined</h4><blockquote><p><code>NULL</code> 表示“空”。<code>undefined</code> 表示未定义。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。 </p></blockquote><h4 id="5、严格模式是什么？"><a href="#5、严格模式是什么？" class="headerlink" title="5、严格模式是什么？"></a>5、严格模式是什么？</h4><blockquote><p><strong>缘由：</strong>初期，为了方便，不强制要求 var 声明变量，所以会导致未被 var 声明的变量自动声明为全局变量，如果同一页面不同 js 文件都用到了 js 文件的相同变量，导致变量之间相互影响，也就是我们所说的污染全局环境变量。</p><p><strong>strict模式：</strong>不用<code>var</code>申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。 </p></blockquote><h3 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h3><h4 id="1、多行字符串"><a href="#1、多行字符串" class="headerlink" title="1、多行字符串"></a>1、多行字符串</h4><blockquote><p>多行字符串用 <code></code> 反引号来表示，ES6 新增加语法。</p></blockquote><h4 id="2、字符串拼接"><a href="#2、字符串拼接" class="headerlink" title="2、字符串拼接"></a>2、字符串拼接</h4><blockquote><p>关于字符串拼接用 ${name} 引用，ES6 新增加语法。</p></blockquote><h3 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h3><h4 id="1、indexof"><a href="#1、indexof" class="headerlink" title="1、indexof"></a>1、indexof</h4><blockquote><p>搜索一个指定的元素的位置 。</p></blockquote><h4 id="2、slice"><a href="#2、slice" class="headerlink" title="2、slice"></a>2、slice</h4><blockquote><p>字符串截取。单参数为从参数起到结束，双参数为中间元素（不包括尾元素），返回新数组。</p></blockquote><h4 id="3、push-和-pop"><a href="#3、push-和-pop" class="headerlink" title="3、push 和 pop"></a>3、push 和 pop</h4><blockquote><p>末尾添加元素和末尾删除元素。</p></blockquote><h4 id="4、unshift-和-shift"><a href="#4、unshift-和-shift" class="headerlink" title="4、unshift 和 shift"></a>4、unshift 和 shift</h4><blockquote><p>头部添加元素和头部删除元素。</p></blockquote><h4 id="5、sort"><a href="#5、sort" class="headerlink" title="5、sort"></a>5、sort</h4><blockquote><p>对当前数组进行排序。</p></blockquote><h4 id="6、reverse"><a href="#6、reverse" class="headerlink" title="6、reverse"></a>6、reverse</h4><blockquote><p>将数组元素反转。</p></blockquote><h4 id="7、splice"><a href="#7、splice" class="headerlink" title="7、splice"></a>7、splice</h4><blockquote><p>可以删除元素也可以删除同时添加元素。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;);</span><br></pre></td></tr></table></figure><h4 id="8、concat"><a href="#8、concat" class="headerlink" title="8、concat"></a>8、concat</h4><blockquote><p>合并两个数组，返回新数组。</p></blockquote><h4 id="9、join"><a href="#9、join" class="headerlink" title="9、join"></a>9、join</h4><blockquote><p>指定字符连接数组中的元素。</p></blockquote><h3 id="五、Map-和-Set"><a href="#五、Map-和-Set" class="headerlink" title="五、Map 和 Set"></a>五、Map 和 Set</h3><h4 id="1、Map"><a href="#1、Map" class="headerlink" title="1、Map"></a>1、Map</h4><blockquote><p>一组键值对，键必须为字符串类型。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;);</span><br><span class="line">m.set(&apos;Bob&apos;,59)</span><br><span class="line">m.delete(&apos;Adam&apos;);</span><br></pre></td></tr></table></figure><h4 id="2、Set"><a href="#2、Set" class="headerlink" title="2、Set"></a>2、Set</h4><blockquote><p>一组 key 的集合，不存储 value。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set([1, 2, 3]);</span><br><span class="line">s.add(4);</span><br><span class="line">s.delete(3);</span><br></pre></td></tr></table></figure><h3 id="六、iterable"><a href="#六、iterable" class="headerlink" title="六、iterable"></a>六、iterable</h3><h6 id="▉-普通-for-循环"><a href="#▉-普通-for-循环" class="headerlink" title="▉ 普通 for 循环"></a>▉ 普通 for 循环</h6><blockquote><p>当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率 。</p></blockquote><h6 id="▉-foreach-循环"><a href="#▉-foreach-循环" class="headerlink" title="▉ foreach 循环"></a>▉ foreach 循环</h6><blockquote><p><strong>功能：</strong>可以获取到 key 和 value 数组的本身。</p><p><strong>缺点：</strong></p><ul><li>不能用 break，continue 语句跳出循环。</li><li>函数内不能使用 return 语句。</li></ul><p><strong>注意：</strong>在不同浏览器下测试的结果都是 forEach 的速度不如 for 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//item 为数组元素</span></span><br><span class="line"><span class="comment">//index 为索引下标</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item,index,arr)</span><br><span class="line">&#125;,<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h6 id="▉-for…in-循环"><a href="#▉-for…in-循环" class="headerlink" title="▉  for…in 循环"></a>▉  for…in 循环</h6><blockquote><p><strong>for-in 循环遍历的是对象的属性。</strong>而不是数组的索引 ，除了遍历数组也可以遍历对象。</p><p><strong>缺点：</strong></p><ul><li>for-in 遍历的顺序并不是确定的。</li><li>它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。 </li><li>for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性 （Array 中的 length 不能遍历到），for-in 不适合遍历 Array 。【链接】：<a href="https://juejin.im/entry/5a1654e951882554b8373622" target="_blank" rel="noopener">https://juejin.im/entry/5a1654e951882554b8373622</a></li></ul></blockquote><h6 id="▉-for…of-循环"><a href="#▉-for…of-循环" class="headerlink" title="▉  for…of 循环"></a>▉  for…of 循环</h6><blockquote><p>ES6 新增语法。</p><p><strong>优点：</strong></p><ul><li>以正确响应 break, continue, return。 </li><li>for-of 循环不仅支持数组，还支持大多数类数组对象。</li><li>for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。</li><li>for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历 </li></ul></blockquote><h3 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h3><blockquote><p>在函数中如果没有 <code>return</code> 语句，函数执行完返回 <code>undefined</code>。</p></blockquote><h4 id="1、arguments"><a href="#1、arguments" class="headerlink" title="1、arguments"></a>1、arguments</h4><blockquote><p>此关键字只在函数内部起作用，并且永远指向当前函数调用者传入的所有参数。</p><p>1、即使函数不定义参数，也是可以通过 arguments 对象拿到传入的参数的。</p><p>2、通常用来判断传入参数的个数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x = '</span> + x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'arg '</span> + i + <span class="string">' = '</span> + <span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><h4 id="2、reset-参数（ES6）"><a href="#2、reset-参数（ES6）" class="headerlink" title="2、reset 参数（ES6）"></a>2、reset 参数（ES6）</h4><blockquote><p>由于 arguments 获取额外的传参非常的别扭，所以 ES6 新增了 rest 参数用来处理额外的参数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b,...rest</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入多余两个参数</span></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// Array[3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传入少于定义参数的个数</span></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//Array[] 空数组</span></span><br></pre></td></tr></table></figure><h4 id="3、注意-return-语句"><a href="#3、注意-return-语句" class="headerlink" title="3、注意 return  语句"></a>3、注意 return  语句</h4><blockquote><p>javascript 引擎会有一个行末添加分号的机制。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为&#123;表示语句尚未结束</span></span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>   <span class="comment">//这一行会可能被引擎自动加分号</span></span><br><span class="line">       &#123; <span class="attr">name</span>: <span class="string">'foo'</span>&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、变量作用域和解构赋值"><a href="#4、变量作用域和解构赋值" class="headerlink" title="4、变量作用域和解构赋值"></a>4、变量作用域和解构赋值</h4><h6 id="▉-全局作用域"><a href="#▉-全局作用域" class="headerlink" title="▉ 全局作用域"></a>▉ 全局作用域</h6><blockquote><p>javascript 只有一个全局作用域，如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报<code>ReferenceError</code>错误。 </p></blockquote><h6 id="▉-命名空间"><a href="#▉-命名空间" class="headerlink" title="▉ 命名空间"></a>▉ 命名空间</h6><blockquote><p>全局变量会绑定到 windows 上，不同的 javascript 文件使用相同的全局变量会产生命名冲突，我们很难发现，所以一般减少冲突的方法就是所有变量和函数全部绑定到一个全局变量中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line">MYAPP.name = <span class="string">'myapp'</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>许多 js 库都是这么干的，jQuery，YUI等。</p></blockquote><h6 id="▉-局部作用域"><a href="#▉-局部作用域" class="headerlink" title="▉ 局部作用域"></a>▉ 局部作用域</h6><blockquote><p>所谓的 js 作用域是在函数内部的，for 循环等语句块中是无法定义具有局部作用域变量的。ES6 引用了 let 代替 var 声明块级作用域变量。</p></blockquote><h6 id="▉-对多个变量同时赋值"><a href="#▉-对多个变量同时赋值" class="headerlink" title="▉ 对多个变量同时赋值"></a>▉ 对多个变量同时赋值</h6><blockquote><p>使用 ES6 新增加的解构赋值。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>];</span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><p>1、交换两个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>,y = <span class="number">2</span>;</span><br><span class="line">[x,y] = [y,x]</span><br></pre></td></tr></table></figure><p>2、快速获取当前页面的域名和路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">hostname</span>:domain, <span class="attr">pathname</span>:path&#125; = location;</span><br></pre></td></tr></table></figure><p>3、函数接受对象的属性为参数</p><blockquote><p>用解构直接将对象的属性绑定到变量中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildDate</span>(<span class="params">&#123;year, month, day, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(year + <span class="string">'-'</span> + month + <span class="string">'-'</span> + day + <span class="string">' '</span> + hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second);</span><br><span class="line">&#125;</span><br><span class="line">buildDate(&#123; <span class="attr">year</span>: <span class="number">2017</span>, <span class="attr">month</span>: <span class="number">1</span>, <span class="attr">day</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="5、方法"><a href="#5、方法" class="headerlink" title="5、方法"></a>5、方法</h4><h6 id="▉-this-指针"><a href="#▉-this-指针" class="headerlink" title="▉ this 指针"></a>▉ this 指针</h6><blockquote><p>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>。如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向全局对象，也就是<code>window</code>。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25, 正常结果</span></span><br><span class="line">getAge(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></span><br><span class="line">fn(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><blockquote><p>以上是 js 的设计错误，ECMA决定，在 strict 模式下让函数的<code>this</code>指向<code>undefined</code> 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="keyword">this</span>.birth; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>报错了，<code>this</code>  指针只在 <code>age</code> 方法的函数内指向 <code>xiaoming</code> 在函数内部定义的函数 ，this 指针指向 undefined ，他重新指向全局变量。</p></blockquote><p>改进方法，用 that 进行捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h6 id="▉-apply-方法"><a href="#▉-apply-方法" class="headerlink" title="▉ apply() 方法"></a>▉ apply() 方法</h6><blockquote><p><strong>作用： </strong>指针函数的 this 指向哪个对象。</p><p><strong>使用：</strong></p><ul><li>参数一：需要绑定的 this 变量。</li><li>参数二：传入的是 Array，表示函数本身的参数。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure><h6 id="▉-call-方法"><a href="#▉-call-方法" class="headerlink" title="▉ call() 方法"></a>▉ call() 方法</h6><blockquote><p>把参数按照顺序传入。</p></blockquote><h6 id="▉-装饰器"><a href="#▉-装饰器" class="headerlink" title="▉ 装饰器"></a>▉ 装饰器</h6><blockquote><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6、高阶函数"><a href="#6、高阶函数" class="headerlink" title="6、高阶函数"></a>6、高阶函数</h4><blockquote><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为<strong>高阶函数 </strong>。 </p></blockquote><h6 id="▉-map-对元素自身进行计算"><a href="#▉-map-对元素自身进行计算" class="headerlink" title="▉ map 对元素自身进行计算"></a>▉ map 对元素自身进行计算</h6><blockquote><p><code>map()</code> 方法定义在 JavaScript 的 <code>Array</code> 中 ,对数组中的每个数据做处理。</p><p><code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"><span class="built_in">console</span>.log(results);</span><br></pre></td></tr></table></figure><h6 id="▉-reduce-所有元素进行累加计算"><a href="#▉-reduce-所有元素进行累加计算" class="headerlink" title="▉ reduce 所有元素进行累加计算"></a>▉ reduce 所有元素进行累加计算</h6><blockquote><p>Array的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h6 id="▉-filter-过滤元素"><a href="#▉-filter-过滤元素" class="headerlink" title="▉ filter 过滤元素"></a>▉ filter 过滤元素</h6><blockquote><p>用于把  <code>Array</code>的某些元素过滤掉，然后返回剩下的元素。 和 <code>map()</code> 不同的是，<code>filter()</code> <strong>把传入的函数依次作用于每个元素，然后根据返回值是 <code>true</code> 还是 <code>false</code> 决定保留还是丢弃该元素。</strong> </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个Array中，删掉偶数，只保留奇数</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure><p><strong>● 回调函数</strong></p><blockquote><p>filter 有多个参数。</p><p><strong>1、一个参数：</strong>仅使用一个表示 Array 的某个元素。</p><p><strong>2、三个参数：</strong>回调函数可以接受另外两个参数，表示元素的<strong>位置</strong>和<strong>数组本身</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除重复元素依靠的是 indexOf 总是返回第一个元素的位置，后续的重复元素位置与 indexOf 返回的位置不相等，因此被 filter 滤掉了。</span></span><br><span class="line"><span class="keyword">var</span> r,</span><br><span class="line">arr = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'orange'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="▉-sort-排序"><a href="#▉-sort-排序" class="headerlink" title="▉ sort 排序"></a>▉ sort 排序</h6><blockquote><p>1、比较字符或者字符串，根据 ASCLL 码进行排序的。</p><p>2、比较数字，先将数组中的数字转换成字符串，然后再进行排序。</p></blockquote><p>sort 是一个高阶函数，可以传入函数来进行自定义的比较：</p><ul><li>数字比较</li></ul><blockquote><p>传入一个比较函数，-返回值为 1，-1，0；</p><p><strong>注意：</strong>sort 直接对 Array 进行修改，结果返回 Array。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="comment">//经断点调试，更像是一种插入排序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//变</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不变</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure><h4 id="6、闭包"><a href="#6、闭包" class="headerlink" title="6、闭包"></a>6、闭包</h4><blockquote><p>将闭包和 Java 类中的 get 获取内部私有变量做对比。</p></blockquote><h6 id="▉-什么是闭包？"><a href="#▉-什么是闭包？" class="headerlink" title="▉ 什么是闭包？"></a>▉ 什么是闭包？</h6><blockquote><p>只有函数内部的子函数才能读取局部变量，定义在一个函数内部的函数 。</p></blockquote><h6 id="▉-作用"><a href="#▉-作用" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>1）在函数的外部也可以获取到函数内部的局部变量。</p><p>2）让这些局部变量值始终保存在内存中，保证不会被 js “垃圾回收机制”回收。</p></blockquote><h6 id="▉-使用闭包注意事项"><a href="#▉-使用闭包注意事项" class="headerlink" title="▉ 使用闭包注意事项"></a>▉ 使用闭包注意事项</h6><blockquote><p>1）闭包会被保存到内存中，内存消耗很大，会造成网页性能问题，在 IE 会导致内存泄漏。在退出函数之前，将不适用的局部变量全部删除。</p></blockquote><h4 id="7、垃圾回收机制"><a href="#7、垃圾回收机制" class="headerlink" title="7、垃圾回收机制"></a>7、垃圾回收机制</h4><h6 id="▉-生命周期"><a href="#▉-生命周期" class="headerlink" title="▉ 生命周期"></a>▉ 生命周期</h6><blockquote><p>1）分配内存： javascript 自动完成内存的分配</p><p>2）使用内存（读或写）：使用值的过程实际上是对分配内存进行读取与写入的操作 </p><p>3）释放内存：在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。所以高级语言潜入垃圾回收机制。</p></blockquote><h6 id="▉-垃圾回收机制"><a href="#▉-垃圾回收机制" class="headerlink" title="▉ 垃圾回收机制"></a>▉ 垃圾回收机制</h6><blockquote><p>主要工作是跟踪内存的<strong>分配</strong>和<strong>使用</strong>，以便当分配的内存不再使用时，自动释放它。</p></blockquote><p><strong>1）引用</strong></p><blockquote><p>垃圾回收算法主要依赖于引用的概念 ，一个对象访问另一个对象就叫做引用。</p></blockquote><p><strong>2）引用计数垃圾收集</strong></p><blockquote><p>初级的垃圾回收算法，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p></blockquote><p><strong>3）限制：循环引用</strong></p><blockquote><p>当该函数调用完成离开作用域之后，可以被回收了，但是两个对象相互引用，所以不会被回收。（IE 6, 7对 DOM 结点进行计数垃圾回收）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）标记—清除算法</strong></p><blockquote><p>针对于“对象是否不再需要”。</p><p>1）算法假设有一个根对象（全局对象），垃圾回收器从根开始找所有从根开始引用的对象。</p><p>2）垃圾回收器将找到所有<strong>可以获得的对象</strong>和收集所有<strong>不能获得的对象</strong>。 （零引用总不可获得的）</p></blockquote><p><strong>5）限制：那些无法从根对象查询到的对象都将被清除</strong></p><h4 id="8、箭头函数"><a href="#8、箭头函数" class="headerlink" title="8、箭头函数"></a>8、箭头函数</h4><h6 id="▉-箭头中的-this"><a href="#▉-箭头中的-this" class="headerlink" title="▉ 箭头中的 this"></a>▉ 箭头中的 this</h6><blockquote><p>由于之前的函数中 this 绑定的错误处理，this 在箭头函数中被修复了。<strong>this 总是与词法作用域绑定</strong>（函数的作用域在函数定义的时候就决定了 ），由上下文确定 ，外层调用者 <code>obj</code>.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向window 或 undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="▉-注意"><a href="#▉-注意" class="headerlink" title="▉ 注意"></a>▉ 注意</h6><blockquote><p>由于<code>this</code>在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>调用箭头函数时，无法对<code>this</code>进行绑定，即传入的第一个参数被忽略。</p></blockquote><h4 id="9、generator-生成器"><a href="#9、generator-生成器" class="headerlink" title="9、generator 生成器"></a>9、generator 生成器</h4><h6 id="▉-定义"><a href="#▉-定义" class="headerlink" title="▉ 定义"></a>▉ 定义</h6><blockquote><p>整个 Generator 函数封装了异步任务。 标注 yield 地方都是异步需要暂停的地方（yield 将任务分为几个阶段）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-过程"><a href="#▉-过程" class="headerlink" title="▉ 过程"></a>▉ 过程</h6><blockquote><p><strong>1）</strong>调用 Generator 会返回一个指针对象（<strong>遍历器对象</strong> ），调用指针对象的的 next 方法，会移动指针的位置（异步任务的第一阶段），也就是指向遇到第一个 yield  的位置。 </p><p><strong>2）</strong>next 方法会返回一个当前阶段的对象，表示当前阶段的信息（value:当前阶段的值，yield：布尔值 ）表示 generator 是否执行完毕。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h6 id="▉-数据交换"><a href="#▉-数据交换" class="headerlink" title="▉ 数据交换"></a>▉ 数据交换</h6><blockquote><p>除了能够暂停、恢复之外，还可以作为函数体内外的数据交换。</p><p>1、不带有参数的 next 方法可以输出返回值。</p><p>2、带有参数的方法可以将参数作为上一阶段异步任务的返回结果，也就是输入。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><h6 id="▉-错误处理"><a href="#▉-错误处理" class="headerlink" title="▉ 错误处理"></a>▉ 错误处理</h6><blockquote><p>Generator 内部可以部署错误处理代码，捕获函数体外抛出的错误。</p><p>1、在函数外用指针的throw抛出的错误，被函数体内的  try … catch  代码块进行捕获。</p><p>2、实现了出错代码和处理错误的代码时间和空间上的分离。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw（<span class="string">'出错了'</span>）;</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><h6 id="▉-作用-1"><a href="#▉-作用-1" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>异步回调代码变成“同步”代码。</p></blockquote><h3 id="八、标准对象"><a href="#八、标准对象" class="headerlink" title="八、标准对象"></a>八、标准对象</h3><blockquote><p>总结一下，有这么几条规则需要遵守：</p></blockquote><ul><li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li><li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li><li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li><li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li><li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li><li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li><li>判断<code>null</code>请使用<code>myVar === null</code>；</li><li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li><li>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code>。</li></ul><blockquote><p>任何对象都有<code>toString()</code>方法吗？<code>null</code>和<code>undefined</code>就没有！确实如此，这两个特殊值要除外，虽然<code>null</code>还伪装成了<code>object</code>类型。</p></blockquote><h4 id="1、Date"><a href="#1、Date" class="headerlink" title="1、Date"></a>1、Date</h4><blockquote><p> JavaScript的 Date 对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure><h3 id="九、面向对象编程"><a href="#九、面向对象编程" class="headerlink" title="九、面向对象编程"></a>九、面向对象编程</h3><h4 id="1、继承设计思想"><a href="#1、继承设计思想" class="headerlink" title="1、继承设计思想"></a>1、继承设计思想</h4><h6 id="▉-js-的诞生"><a href="#▉-js-的诞生" class="headerlink" title="▉ js 的诞生"></a>▉ js 的诞生</h6><blockquote><p>为了让静态页面进行交互，设计一种语言完成不需要借助服务器完成的操作，如：表单验证。</p></blockquote><h6 id="▉-模仿其他-oop-进行设计"><a href="#▉-模仿其他-oop-进行设计" class="headerlink" title="▉  模仿其他 oop 进行设计"></a>▉  模仿其他 oop 进行设计</h6><blockquote><p>js 不像其他语言是面向对象语言有类的概念，为了能够即不引入类又能实现继承，所以 js 设计者模仿 oop 语言进行设计。</p><p>1、其他语言通过 new 来生成实例，所以 js 也通过 new 生成实例。</p><p>2、其他语言有类可以通过 new 来实现，js 并没有类，所以借助 new 构造函数来生成实例。</p><p>3、不同对象有不同的属性，也有相同的属性，对于每个对象相同的属性都需要在内存中开辟多个空间存储。能否使相同的属性只存一个呢？然后拥有该属性的对象都去引用它。</p></blockquote><h6 id="▉-prototype-属性"><a href="#▉-prototype-属性" class="headerlink" title="▉  prototype 属性"></a>▉  <strong>prototype</strong> 属性</h6><blockquote><p>我们就给构造函数设计一个 prototype 属性，用来存储不同对象相同的属性，共享的属性都存到这里边，不共享的属性就存放到构造函数中。其实 prototype 属性存储的就是一个对象，构造函数里边存放的都是变量，具体看变量和对象在内存中的引用。</p></blockquote><h6 id="▉-继承"><a href="#▉-继承" class="headerlink" title="▉  继承"></a>▉  继承</h6><blockquote><p>所有构造函数生成的对象都具有 prototype 对象里边的共享属性，就像是所有实例对象继承了 prototype 对象一样。</p></blockquote><h4 id="2、封装"><a href="#2、封装" class="headerlink" title="2、封装"></a>2、封装</h4><blockquote><p>其他语言因为有类的概念，对对象的封装是非常方便的，那么 js 是怎么封装对象的呢？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//猫对象</span></span><br><span class="line"><span class="keyword">var</span> Cat = &#123;</span><br><span class="line">    name : <span class="string">''</span>,</span><br><span class="line">    color : <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-原始模式"><a href="#▉-原始模式" class="headerlink" title="▉  原始模式"></a>▉  原始模式</h6><blockquote><p>下面简单的进行两个不同对象的封装，就会有两个问题：</p><p><strong>问题：</strong></p><p>1）生成多个实例对象写起来非常麻烦。</p><p>2）实例对象和原型对象之间没什么联系。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = &#123;&#125;; <span class="comment">// 创建一个空对象</span></span><br><span class="line">cat1.name = <span class="string">"大毛"</span>; <span class="comment">// 按照原型对象的属性赋值</span></span><br><span class="line">cat1.color = <span class="string">"黄色"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat2 = &#123;&#125;;</span><br><span class="line">cat2.name = <span class="string">"二毛"</span>;</span><br><span class="line">cat2.color = <span class="string">"黑色"</span>;</span><br></pre></td></tr></table></figure><h6 id="▉-原始模式改进"><a href="#▉-原始模式改进" class="headerlink" title="▉  原始模式改进"></a>▉  原始模式改进</h6><blockquote><p>用函数来解决代码重复的问题。</p><p><strong>问题：</strong></p><p>1）但是不能反映他们来自于同一个原型对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name:name,</span><br><span class="line">        color:color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成实例对象</span></span><br><span class="line"><span class="keyword">var</span> cat1 = Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = Cat(<span class="string">"二毛"</span>,<span class="string">"黑色"</span>);</span><br></pre></td></tr></table></figure><h6 id="▉-构造函数模式"><a href="#▉-构造函数模式" class="headerlink" title="▉  构造函数模式"></a>▉  构造函数模式</h6><blockquote><p>为了解决原型对象生成实例的问题，引入构造函数模式。</p><p>1）构造函数就是一个普通函数。</p><p>2）内部使用 this 变量，对构造函数使用 new 就能生成实例对象，内部的 this 指针就会指向实例对象。</p><p>3）每个实例对象都有 constructor 属性，并指向他们的构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.color=color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2）</span></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>,<span class="string">"黑色"</span>);</span><br><span class="line"><span class="comment">//3)</span></span><br><span class="line">alert(cat1.constructor == Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>问题：</strong></p><p>1）对于每个实例共享的属性，存在浪费内存的问题。</p></blockquote><h6 id="▉-原型模式（prototype-模式）"><a href="#▉-原型模式（prototype-模式）" class="headerlink" title="▉  原型模式（prototype 模式）"></a>▉  原型模式（prototype 模式）</h6><blockquote><p>每个构造函数都有一个 prototype 属性指向原型对象，我们将共享的属性存放到原型对象上，所有实例的共享属性其实都是同一个内存地址，指向<code>prototype</code>对象，因此就提高了运行效率。</p><p><strong>验证方法：</strong></p><p><strong>1）isPrototypeOf()</strong> ：验证实例与原型对象之间的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(Cat.prototype.isPrototypeOf(cat1)); //true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>2）hasOwnProperty()</strong>：判断某个属性来自本地还是原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>3）in运算符</strong>：判断某个实例是否拥有某个属性。以及遍历某个实例的所有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(&quot;name&quot; in cat1); // true</span><br><span class="line">&gt; for(var prop in cat1) &#123; alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2、原型继承"><a href="#2、原型继承" class="headerlink" title="2、原型继承"></a>2、原型继承</h4><h4 id="3、构造函数继承（五种）"><a href="#3、构造函数继承（五种）" class="headerlink" title="3、构造函数继承（五种）"></a>3、构造函数继承（五种）</h4><blockquote><p>两个构造函数。怎么让猫继承动物？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动物构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//猫的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第一种：构造函数的绑定"><a href="#▉-第一种：构造函数的绑定" class="headerlink" title="▉  第一种：构造函数的绑定"></a>▉  第一种：构造函数的绑定</h6><blockquote><p>用 call 或 apply 方法将父对象的构造函数绑定到子对象的构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//改变 this 的绑定</span></span><br><span class="line">    Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第二种：原型模式"><a href="#▉-第二种：原型模式" class="headerlink" title="▉  第二种：原型模式"></a>▉  第二种：原型模式</h6><blockquote><p>让猫构造函数的 prototype 等于 Animal 的实例，Animal 的实例拥有 Animal  的所有属性，所以相当于猫构造函数的 prototype 指向 Animal 实例了， 所有的猫的实例共享 Animal  里的属性了。</p><p>1) 每个实例都有 construct 属性，每个 prototype 也都有 construct 属性。</p><p>2）实例中的 construct 指向与 prototype 对象中 construct 指向同一个构造函数。也就是说改变 Cat 的原型对象之后，Cat 的实例对象 construct 属性指向的是 Animal 实例对象的 construct 属性，也就是 Animal 原型对象的 construct 属性，也就是构造函数 Animal 。</p><p>3）猫的实例对象是由 Cat 生成的，怎么能指向 Animal 呢，所以手动修改过来。</p><p>4）如果更换了 prototype对象 ，一定将 construct 属性修改过来。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><h6 id="▉-第三种：直接继承原型"><a href="#▉-第三种：直接继承原型" class="headerlink" title="▉  第三种：直接继承原型"></a>▉  第三种：直接继承原型</h6><blockquote><p>第二种方式的改进，跳过 Animal 的实例，直接将 Animal 的原型对象赋值给 Cat.prototype;</p><p><strong>优点：</strong>效率更高（不用执行和建立Animal的实例了 ）</p><p><strong>缺点：</strong><code>Cat.prototype</code> 和 <code>Animal.prototype</code> 现在指向了同一个对象，那么任何对 <code>Cat.prototype</code> 的修改，都会反映到 <code>Animal.prototype</code>。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = Animal.prototype;</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><h6 id="▉-第四种：空对象作为中介"><a href="#▉-第四种：空对象作为中介" class="headerlink" title="▉  第四种：空对象作为中介"></a>▉  第四种：空对象作为中介</h6><blockquote><p>对于第三种的缺点，第四种作为改进。F是空对象，所以几乎不占内存。 </p><p><strong>优点：</strong>修改Cat的prototype对象，就不会影响到Animal的prototype对象。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = Animal.prototype;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> F();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><p>将其封装成方法:</p><blockquote><p>这个 extend 函数，就是 YUI 库如何实现继承的方法。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　<span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">　　　　F.prototype = Parent.prototype;</span><br><span class="line">　　　　Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">　　　　Child.prototype.constructor = Child;</span><br><span class="line">　　　　Child.uber = Parent.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第五种：拷贝继承"><a href="#▉-第五种：拷贝继承" class="headerlink" title="▉  第五种：拷贝继承"></a>▉  第五种：拷贝继承</h6><blockquote><p>如果把父对象的 prototype 所有属性和方法，拷贝进子对象的 prototype 中 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> p = Parent.prototype;</span><br><span class="line">　　　　<span class="keyword">var</span> c = Child.prototype;</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　　　c[i] = p[i];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　c.uber = p;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h4 id="4、非构造函数继承"><a href="#4、非构造函数继承" class="headerlink" title="4、非构造函数继承"></a>4、非构造函数继承</h4><blockquote><p>让医生继承中国。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//父对象</span><br><span class="line">var Chinese = &#123;</span><br><span class="line">nation:&apos;中国&apos;</span><br><span class="line">&#125;;</span><br><span class="line">//子对象</span><br><span class="line">var Doctor =&#123;</span><br><span class="line">career:&apos;医生&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第一种：object-方法"><a href="#▉-第一种：object-方法" class="headerlink" title="▉  第一种：object()方法"></a>▉  第一种：object()方法</h6><blockquote><p>让中国成为医生的原型对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="▉-第二种：浅拷贝"><a href="#▉-第二种：浅拷贝" class="headerlink" title="▉  第二种：浅拷贝"></a>▉  第二种：浅拷贝</h6><blockquote><p>把父对象的属性，全部拷贝给子对象，也能实现继承。 拷贝继承分为浅拷贝和深拷贝。</p><p><strong>问题：</strong></p><p>1）如果父对象的属性等于数组或另一个对象，子对象获得的只是一个内存地址 ，子对象改变，父对象的属性也将改变。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function extendCopy(p) &#123;</span><br><span class="line">    var c = &#123;&#125;;</span><br><span class="line">    for (var i in p) &#123; </span><br><span class="line">    c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.uber = p;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第二种：深拷贝"><a href="#▉-第二种：深拷贝" class="headerlink" title="▉  第二种：深拷贝"></a>▉  第二种：深拷贝</h6><blockquote><p>弥补浅拷贝出现的问题，真正的将对象和数组及逆行拷贝，只要递归调用”浅拷贝”就行了 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　　　<span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">　　　　　　　　c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">　　　　　　　　deepCopy(p[i], c[i]);</span><br><span class="line">　　　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　　　　c[i] = p[i];</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> c;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><blockquote><p>jQuery库使用的就是这种继承方法。 </p></blockquote><h4 id="5、class-继承"><a href="#5、class-继承" class="headerlink" title="5、class 继承"></a>5、class 继承</h4><blockquote><p>class 的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用 class 的好处就是极大地简化了原型链代码。</p></blockquote><h3 id="十、浏览器"><a href="#十、浏览器" class="headerlink" title="十、浏览器"></a>十、浏览器</h3><h4 id="1、浏览器对象"><a href="#1、浏览器对象" class="headerlink" title="1、浏览器对象"></a>1、浏览器对象</h4><h6 id="▉-window"><a href="#▉-window" class="headerlink" title="▉ window"></a>▉ window</h6><blockquote><p><code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'window inner size: '</span> + <span class="built_in">window</span>.innerWidth + <span class="string">' x '</span> + <span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure><h6 id="▉-navigator"><a href="#▉-navigator" class="headerlink" title="▉ navigator"></a>▉ navigator</h6><blockquote><p><code>navigator</code>对象表示浏览器的信息，最常用的属性包括： </p></blockquote><ul><li>navigator.appName：浏览器名称；</li><li>navigator.appVersion：浏览器版本；</li><li>navigator.language：浏览器设置的语言；</li><li>navigator.platform：操作系统类型；</li><li>navigator.userAgent：浏览器设定的<code>User-Agent</code>字符串。</li></ul><h6 id="▉-screen"><a href="#▉-screen" class="headerlink" title="▉ screen"></a>▉ screen</h6><blockquote><p><code>screen</code>对象表示屏幕的信息，常用的属性有： </p></blockquote><ul><li>screen.width：屏幕宽度，以像素为单位；</li><li>screen.height：屏幕高度，以像素为单位；</li><li>screen.colorDepth：返回颜色位数，如8、16、24。</li></ul><h6 id="▉-location"><a href="#▉-location" class="headerlink" title="▉ location"></a>▉ location</h6><blockquote><p><code>location</code>对象表示当前页面的URL信息。 </p><p><strong>加载新页面：</strong>location.assign() 。</p><p><strong>重新加载：</strong>location.reload() 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</span></span><br><span class="line"><span class="comment">//可以用location.href获取</span></span><br><span class="line">location.protocol; <span class="comment">// 'http'</span></span><br><span class="line">location.host; <span class="comment">// 'www.example.com'</span></span><br><span class="line">location.port; <span class="comment">// '8080'</span></span><br><span class="line">location.pathname; <span class="comment">// '/path/index.html'</span></span><br><span class="line">location.search; <span class="comment">// '?a=1&amp;b=2'</span></span><br><span class="line">location.hash; <span class="comment">// 'TOP'</span></span><br></pre></td></tr></table></figure><h6 id="▉-document"><a href="#▉-document" class="headerlink" title="▉ document"></a>▉ document</h6><blockquote><p><code>document</code> 对象表示当前页面。由于 HTML 在浏览器中以 DOM 形式表示为树形结构，<code>document</code> 对象就是整个 DOM 树的根节点。 </p></blockquote><p><strong>Cookie</strong></p><blockquote><p>1) Cookie 是由服务器发送的 key-value 标示符。因为 HTTP 协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用 Cookie 来区分 。</p><p>2) 当一个用户成功登录后，服务器发送一个 Cookie 给浏览器，例如 <code>user=ABC123XYZ(加密的字符串)...</code>，此后，浏览器访问该网站时，会在请求头附上这个 Cookie，服务器根据 Cookie 即可区分出用户。<em>**</em></p><p><strong>安全性：</strong> </p><p>如果引入的第三方库存在恶意代码，则被第三方直接获取到用户登录信息。为了解决这个问题，服务器在设置 Cookie 的时候使用 <strong>httpOnly</strong>，设置的 Cookie 不能被 Javascript 读取。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie; <span class="comment">// 'v=123; remember=true; prefer=zh'</span></span><br></pre></td></tr></table></figure><h6 id="▉-history"><a href="#▉-history" class="headerlink" title="▉ history"></a>▉ history</h6><blockquote><p><code>history</code>对象保存了浏览器的历史记录，JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。 </p></blockquote><h4 id="2、操作-DOM"><a href="#2、操作-DOM" class="headerlink" title="2、操作 DOM"></a>2、操作 DOM</h4><h6 id="▉-更新-DOM"><a href="#▉-更新-DOM" class="headerlink" title="▉ 更新 DOM"></a>▉ 更新 DOM</h6><p><strong>1）<code>innerHtml</code>属性</strong></p><blockquote><p>修改文本。用<code>innerHTML</code>时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，<strong>要注意对字符编码来避免XSS攻击。</strong> </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC'</span>; <span class="comment">// &lt;p id="p-id"&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ'</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure><p><strong>2) 修改 innerText 或 textContent 属性</strong></p><blockquote><p>可以自动对字符串进行HTML编码，保证无法设置任何HTML标签： </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.innerText = <span class="string">'&lt;script&gt;alert("Hi")&lt;/script&gt;'</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br></pre></td></tr></table></figure><p><strong>3) 两者区别 </strong></p><blockquote><p>读取属性，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本。另外注意 <strong>IE&lt;9</strong> 支持<code>textContent</code>。 </p></blockquote><p><strong>4）设置 CSS 样式 </strong></p><blockquote><p>DOM节点的<code>style</code>属性对应所有的 CSS 。CSS允许<code>font-size</code>这样的名称使用驼峰命名法（fontSize）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.style.fontSize = &apos;20px&apos;;</span><br></pre></td></tr></table></figure><h6 id="▉-插入-DOM"><a href="#▉-插入-DOM" class="headerlink" title="▉ 插入 DOM"></a>▉ 插入 DOM</h6><p><strong>1）使用 <code>appendChild</code> 把一个子节点添加到父节点的最后一个子节点。 </strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">    haskell.id = <span class="string">'haskell'</span>;</span><br><span class="line">    haskell.innerText = <span class="string">'Haskell'</span>;</span><br><span class="line">    list.appendChild(haskell);</span><br></pre></td></tr></table></figure><p><strong>2) insertBefore 插入指定位置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将子节点插入到 referenceElement 之前</span><br><span class="line">parentElement.insertBefore(newElement, referenceElement);</span><br></pre></td></tr></table></figure><h6 id="▉-删除-DOM"><a href="#▉-删除-DOM" class="headerlink" title="▉ 删除 DOM"></a>▉ 删除 DOM</h6><blockquote><p>parentElement () 得到删除节点的父节点，然后 removeChild() 删除节点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">'to-be-removed'</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">var</span> parent = self.parentElement;</span><br><span class="line"><span class="comment">// 删除:</span></span><br><span class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>1、删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 </p><p>2、parent.children[0] 删除节点的时候注意下标。</p></blockquote><h4 id="3、操作表单"><a href="#3、操作表单" class="headerlink" title="3、操作表单"></a>3、操作表单</h4><p>HTML表单的输入控件主要有以下几种： </p><ul><li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li><li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li><li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li><li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li><li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li><li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li></ul><h6 id="▉-获取值"><a href="#▉-获取值" class="headerlink" title="▉ 获取值"></a>▉ 获取值</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type="text" id="email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>);</span><br><span class="line">input.value; <span class="comment">// '用户输入的值'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;</span></span><br><span class="line">mon.value; <span class="comment">// '1'</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure><h6 id="▉-提交表单"><a href="#▉-提交表单" class="headerlink" title="▉ 提交表单"></a>▉ 提交表单</h6><p><strong>方法一：</strong></p><blockquote><p>响应一个 button 方法。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"doSubmitForm()"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 提交form:</span></span></span><br><span class="line"><span class="undefined">    form.submit();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><blockquote><p>onsubmit 事件。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"input-password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"md5-password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'input-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'md5-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line"><span class="undefined">    md5_pwd.value = toMD5(input_pwd.value);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="4、操作文件"><a href="#4、操作文件" class="headerlink" title="4、操作文件"></a>4、操作文件</h4><blockquote><p>在表单提交文件时，from 表单的 enctype  属性应该使用 <code>multipart/form-data</code>  不对文件数据进行编码才能上传，其他数据默认 <code>application/x-www-form-urlencoded</code>  编码再提交。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//input 的 ID</span><br><span class="line">var f = document.getElementById(&apos;test-file-upload&apos;);</span><br><span class="line">var filename = f.value; // &apos;C:\fakepath\test.png&apos;</span><br><span class="line">if (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) &#123;</span><br><span class="line">    alert(&apos;Can only upload image file.&apos;);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-File-API-操作文件"><a href="#▉-File-API-操作文件" class="headerlink" title="▉ File API 操作文件"></a>▉ File API 操作文件</h6><blockquote><p>HTML5的File API提供了 <code>File</code> 和 <code>FileReader</code> 两个主要对象，可以获得文件信息并读取文件。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">            fileInput = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-file'</span>),</span><br><span class="line">            info = <span class="built_in">document</span>.getElementById(<span class="string">'test-file-info'</span>),</span><br><span class="line">            preview = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-preview'</span>);</span><br><span class="line">            <span class="comment">// 监听change事件:</span></span><br><span class="line">            fileInput.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 清除背景图片:</span></span><br><span class="line">                preview.style.backgroundImage = <span class="string">''</span>;</span><br><span class="line">                <span class="comment">// 检查文件是否选择:</span></span><br><span class="line">                <span class="keyword">if</span> (!fileInput.value) &#123;</span><br><span class="line">                    info.innerHTML = <span class="string">'没有选择文件'</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取File引用:</span></span><br><span class="line">                <span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 获取File信息:</span></span><br><span class="line">                info.innerHTML = <span class="string">'文件: '</span> + file.name + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                                <span class="string">'大小: '</span> + file.size + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                                <span class="string">'修改: '</span> + file.lastModifiedDate;</span><br><span class="line">                <span class="keyword">if</span> (file.type !== <span class="string">'image/jpeg'</span> &amp;&amp; file.type !== <span class="string">'image/png'</span> &amp;&amp; file.type !== <span class="string">'image/gif'</span>) &#123;</span><br><span class="line">                    alert(<span class="string">'不是有效的图片文件!'</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 读取文件:</span></span><br><span class="line">                <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">                <span class="comment">//异步操作的回调函数</span></span><br><span class="line">                reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span></span><br><span class="line">                        data = e.target.result; <span class="comment">// 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            </span></span><br><span class="line">                    preview.style.backgroundImage = <span class="string">'url('</span> + data + <span class="string">')'</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 以DataURL的形式读取文件:(异步操作)</span></span><br><span class="line">                reader.readAsDataURL(file);</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h4 id="5、AJAX"><a href="#5、AJAX" class="headerlink" title="5、AJAX"></a>5、AJAX</h4><blockquote><p>需要注意的几点：</p><p>1、通过检测<code>window</code>对象是否有<code>XMLHttpRequest</code>属性来确定浏览器是否支持标准的<code>XMLHttpRequest</code> </p><p>2、先设置<code>onreadystatechange</code>的回调函数。在回调函数中，通常我们只需通过<code>readyState === 4</code>判断请求是否完成 </p><p>3、<code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数，分别为请求方式、URL地址、是否使用异步。</p><p>4、send 发送，Get 不需要参数，Post 需要把 body 部分以字符串或者 FormData 对象传进去。</p><p>关于 FromData 请查看：<a href="https://wangdoc.com/javascript/bom/form.html#formdata-%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">FormData</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = <span class="string">'Error code: '</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">//现代浏览器</span></span><br><span class="line">    request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//低版本 IE 浏览器</span></span><br><span class="line">    request = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</span><br></pre></td></tr></table></figure><h4 id="6、Cookie"><a href="#6、Cookie" class="headerlink" title="6、Cookie"></a>6、Cookie</h4><h6 id="▉-定义-1"><a href="#▉-定义-1" class="headerlink" title="▉ 定义"></a>▉ 定义</h6><blockquote><p>1）概念：Cookie 小段文本信息，存储于计算机硬盘中，大小只有 4 k。</p><p>2）特点：每个 Cookie 文件都对应一个域名，同一域名下的所以页面可以共享 Cookie，不能跨域名访问。</p><p>3）使用：通常从 document 中提取 cookie 属性提供给 javascript，然后进行创建或发送 cookie 到服务器。</p></blockquote><h6 id="▉-作用-2"><a href="#▉-作用-2" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>cookie 是存在用户硬盘中，用户每次访问站点时，Web应用程序都可以读取 Cookie 包含的信息。当用户再次访问这个站点时，<strong>浏览器就会在本地硬盘上查找与该 URL 相关联的 <code>Cookie</code></strong>。如果该 Cookie 存在，浏览器就将它添加到 <code>request header</code> 的 <code>Cookie</code> 字段中，与 <code>http请求</code> 一起发送到该站点。 </p></blockquote><h6 id="▉-缺点"><a href="#▉-缺点" class="headerlink" title="▉ 缺点"></a>▉ 缺点</h6><ul><li>安全性：由于cookie在HTTP中是明文传递的，其中包含的数据都可以被他人访问，可能会被篡改、盗用。</li><li>大小限制：cookie的大小限制在4KB左右，若要做大量存储显然不是理想的选择。</li><li>增加流量：cookie每次请求都会被自动添加到Request Header中，无形中增加了流量。cookie信息越大，对服务器请求的时间也越长。</li></ul><h6 id="▉-用途"><a href="#▉-用途" class="headerlink" title="▉ 用途"></a>▉ 用途</h6><blockquote><p>Cookie 一般用于保存网页访问者的信息。</p><p>1）保存用户登录信息。在一些登录网站选择下次自动登录，登录成功后，后台对用户名和密码进行加密返回数据，客户端就会将数据存储到 Cookie 中。当用户下一次进行登录时，判断 Cookie 中否存在值，存在则将Cookie 信息加到 HTTP 头部发送到服务器，实现自动登录。</p><p>2）创建购物车。通常将选择的物品放入 Cookie 中，同一域名下页面实现 Cookie 共享，提交订单将 Cookie 传到后台。</p><p>3）跟踪用户。用 Cookie 记录用户的偏好信息，然后推广小广告，在侧边栏经常是我们之前搜索过的内容。</p></blockquote><h6 id="▉-其他存储机制"><a href="#▉-其他存储机制" class="headerlink" title="▉ 其他存储机制"></a>▉ 其他存储机制</h6><blockquote><p><strong>1）web存储机制 </strong> </p><ul><li>sessionStorage：用于一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除 </li><li>localStorage ：用于跨会话持久化地存储数据。</li></ul><p><strong>2）indexedDB </strong></p><ul><li>是 indexed Database API 的简称，是在浏览器中保存结构化数据的一种「数据库」，它类似SQL数据库的结构化数据存储机制 ， 它能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。 </li></ul></blockquote><h4 id="7、-同源跨域问题"><a href="#7、-同源跨域问题" class="headerlink" title="7、 同源跨域问题"></a>7、 同源跨域问题</h4><p>请查看另一篇：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript 的重点学习路线完整篇。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>前端 CSS3 之基础篇【转换】</title>
    <link href="http://yoursite.com/2019/04/02/%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E8%BD%AC%E6%8D%A2%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/02/前端 CSS3 之基础篇【转换】/</id>
    <published>2019-04-02T12:34:35.816Z</published>
    <updated>2019-04-04T00:51:51.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小鹿带你走进 CSS3 转换，好玩又是重点。</p><a id="more"></a><h3 id="一、Treansform"><a href="#一、Treansform" class="headerlink" title="一、Treansform"></a>一、Treansform</h3><blockquote><p>CSS3 变形属性。</p><p>让元素在一个坐标系中变形。这个属性包含一系列的变形函数，可以移动、旋转和缩放元素。</p></blockquote><h6 id="▉-语法"><a href="#▉-语法" class="headerlink" title="▉ 语法"></a>▉ 语法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform:none | &lt;tranform-function&gt;</span><br></pre></td></tr></table></figure><h6 id="▉-兼容性"><a href="#▉-兼容性" class="headerlink" title="▉ 兼容性"></a>▉ 兼容性</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IE12+、ForeFox16+、Chrome36+、Safari16+、Opera23+</span><br></pre></td></tr></table></figure><h3 id="二、2D-转换"><a href="#二、2D-转换" class="headerlink" title="二、2D 转换"></a>二、2D 转换</h3><ul><li>rotate() 旋转</li><li>translate() 平移</li><li>scale() 缩放</li><li>skew() 扭曲和斜切</li><li>matrix() 矩阵或混合</li></ul><h4 id="1、旋转-rotate"><a href="#1、旋转-rotate" class="headerlink" title="1、旋转 rotate"></a>1、旋转 rotate</h4><blockquote><p>通过指定的角度参数对原元素指定一个 2D rotation （2D 旋转）。</p></blockquote><h6 id="▉-语法-1"><a href="#▉-语法-1" class="headerlink" title="▉ 语法"></a>▉ 语法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(&lt;angle&gt;);</span><br></pre></td></tr></table></figure><h6 id="▉-参数说明"><a href="#▉-参数说明" class="headerlink" title="▉ 参数说明"></a>▉ 参数说明</h6><p>angle 指旋转角度，正数表示顺时针旋转，负数表示逆时针旋转。</p><h4 id="2、移动-translate"><a href="#2、移动-translate" class="headerlink" title="2、移动 translate"></a>2、移动 translate</h4><blockquote><p>根据左（X轴）和顶部（Y轴）位置给定的参数，从当前元素位置移动。</p></blockquote><h6 id="▉-语法-2"><a href="#▉-语法-2" class="headerlink" title="▉ 语法"></a>▉ 语法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: translate ();</span><br></pre></td></tr></table></figure><h6 id="▉-三种情况"><a href="#▉-三种情况" class="headerlink" title="▉ 三种情况"></a>▉ 三种情况</h6><ul><li>translateX(x) 仅仅水平方向移动（X 轴移动）；</li><li>translateY(Y) 仅垂直方向移动（Y 轴移动）;</li><li>translate(x,y) 水平方向和垂直方向同时移动（也就是 X 轴和 Y 轴同时移动）。</li></ul><h4 id="3、scale-缩放"><a href="#3、scale-缩放" class="headerlink" title="3、scale 缩放"></a>3、scale 缩放</h4><blockquote><p>2D 缩放。</p></blockquote><h6 id="▉-三种缩放"><a href="#▉-三种缩放" class="headerlink" title="▉ 三种缩放"></a>▉ 三种缩放</h6><ul><li>scaleX()  水平方向缩放</li><li>scaleY()  垂直方向缩放</li><li>scale()  x y 同时缩放</li></ul><h4 id="4、扭曲-skew"><a href="#4、扭曲-skew" class="headerlink" title="4、扭曲 skew"></a>4、扭曲 skew</h4><blockquote><p>斜切扭曲。</p></blockquote><h6 id="▉-三种扭曲"><a href="#▉-三种扭曲" class="headerlink" title="▉ 三种扭曲"></a>▉ 三种扭曲</h6><ul><li>skewX（）水平扭曲（正值，逆时针）</li><li>skewY（）垂直扭曲（正值，顺时针）</li><li>skew（）水平垂直同时扭曲</li></ul><h4 id="5、矩阵-matrix（难点）"><a href="#5、矩阵-matrix（难点）" class="headerlink" title="5、矩阵 matrix（难点）"></a>5、矩阵 matrix（难点）</h4><blockquote><p>矩阵分为 matrix 和 matrix3d 矩阵，分别为 3 <em> 3 和 4 </em> 4 的矩阵。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小鹿带你走进 CSS3 转换，好玩又是重点。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS3" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS3/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>前端 CSS3 之基础篇【图片切换】</title>
    <link href="http://yoursite.com/2019/03/31/%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2%E3%80%91/"/>
    <id>http://yoursite.com/2019/03/31/前端 CSS3 之基础篇【图片切换】/</id>
    <published>2019-03-31T09:50:04.971Z</published>
    <updated>2019-03-31T12:29:44.188Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CSS3 实现图片多样式切换！</p><a id="more"></a><h4 id="一、不同格式的字体对浏览器的兼容性不同"><a href="#一、不同格式的字体对浏览器的兼容性不同" class="headerlink" title="一、不同格式的字体对浏览器的兼容性不同"></a>一、不同格式的字体对浏览器的兼容性不同</h4><table><thead><tr><th>Browser</th><th>@font-face</th><th>TrueType</th><th>WOFF</th><th>EOT</th><th>SVG</th><th>SVGZ</th></tr></thead><tbody><tr><td><img src="https://pic002.cnblogs.com/images/2011/36987/2011020918254839.png" alt="img">IE</td><td>4+</td><td>9+</td><td>9+</td><td>4+</td><td></td><td></td></tr><tr><td><img src="https://pic002.cnblogs.com/images/2011/36987/2011020918264049.png" alt="img">火狐</td><td>3.5+</td><td>3.5+</td><td>3.6+</td><td></td><td></td><td></td></tr><tr><td><img src="https://pic002.cnblogs.com/images/2011/36987/2011020918271360.png" alt="img">谷歌</td><td>4+</td><td>4+</td><td>6+</td><td></td><td>4+</td><td>6+</td></tr><tr><td><img src="https://pic002.cnblogs.com/images/2011/36987/2011020918265934.png" alt="img">苹果</td><td>3.1+</td><td>3.1+</td><td>6+</td><td></td><td>3.1+</td><td>3.1+</td></tr><tr><td><img src="https://pic002.cnblogs.com/images/2011/36987/2011020918262177.png" alt="img">opera</td><td>10+</td><td>10+</td><td>11.1+</td><td></td><td>10+</td><td>10+</td></tr></tbody></table><h4 id="二、内联元素的自动转换"><a href="#二、内联元素的自动转换" class="headerlink" title="二、内联元素的自动转换"></a>二、内联元素的自动转换</h4><blockquote><p>当给一个<strong>内联</strong>元素加以下属性就会转换为<strong>块元素</strong>。</p><p>1、float;</p><p>2、position;</p><p>3、absolute;</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS3 实现图片多样式切换！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS3" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS3/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
</feed>
