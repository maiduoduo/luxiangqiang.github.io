<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小鹿的博客</title>
  
  <subtitle>Ordinary life , Unwilling to be ordinary code farmers</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-20T12:37:02.809Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小鹿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端 CSS 之【响应式】</title>
    <link href="http://yoursite.com/2019/05/20/%E5%89%8D%E7%AB%AF%20CSS%20%E4%B9%8B%E3%80%90%E5%93%8D%E5%BA%94%E5%BC%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/20/前端 CSS 之【响应式】/</id>
    <published>2019-05-20T11:37:12.064Z</published>
    <updated>2019-05-20T12:37:02.809Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>响应式设计！</p><a id="more"></a><h3 id="一、浏览器视口"><a href="#一、浏览器视口" class="headerlink" title="一、浏览器视口"></a>一、浏览器视口</h3><blockquote><p>通过 CSS 像素（不等于无力像素，和物理像素成比例）来合理利用视口空间。</p></blockquote><p>1、理想视口：与设备自身尺寸接近的视口称为理想视口。</p><p>2、默认视口：模拟一个大的视口，然后缩小页面进行显示，称为默认视口。</p><p>3、可见视口：显示网页的矩形区域称为可见视口（减去浏览器中的按钮、滚动条等）。</p><p>4、布局视口：约束整个页面时视口为布局视口。</p><h3 id="二、配置视口"><a href="#二、配置视口" class="headerlink" title="二、配置视口"></a>二、配置视口</h3><blockquote><p>让默认视口的设备都具有理想视口，需要进行声明 meta 标签。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用当前的设备的理想尺寸作为视口的宽度，以及与理想视口的缩放程度相匹配的缩放级别</span></span><br><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-with,initial-scale=1"</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="三、媒体类型和媒体查询"><a href="#三、媒体类型和媒体查询" class="headerlink" title="三、媒体类型和媒体查询"></a>三、媒体类型和媒体查询</h3><h4 id="3-1、媒体类型"><a href="#3-1、媒体类型" class="headerlink" title="3.1、媒体类型"></a>3.1、媒体类型</h4><blockquote><p>媒体类型分为 screen(屏幕显示) 和 print (打印机)。</p></blockquote><p><strong>应用方式：</strong></p><p>① HTML 方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta rel=<span class="string">"stylesheet"</span> href=<span class="string">"main.css"</span> media=<span class="string">"screen,print"</span>&gt;</span><br></pre></td></tr></table></figure><p>② CSS 方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> print&#123;</span><br><span class="line"><span class="selector-class">.smallprint</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">11pt</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2、媒体查询"><a href="#3-2、媒体查询" class="headerlink" title="3.2、媒体查询"></a>3.2、媒体查询</h4><blockquote><p>应用方式有两种，一种是标签的形式，另一种是 css 的形式。标签的形式由于可能有的浏览器会将外部文件下载影响性能，所以通常使用 css 的形式。</p><p>① 可以忽略媒体类型，相当于用 all 代替。</p><p>②  only 关键字为了避免旧版本浏览器的误解。所有旧版本的浏览器遇到 only 关键字。都会跳过媒题查询应用下的样式。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="comment">/* 这里写规则 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、响应式设计"><a href="#四、响应式设计" class="headerlink" title="四、响应式设计"></a>四、响应式设计</h3><h4 id="4-1-移动端优先"><a href="#4-1-移动端优先" class="headerlink" title="4.1 移动端优先"></a>4.1 移动端优先</h4><blockquote><p>我们通常设计响应式以移动端优先设计，因为移动端屏幕小、通常处理器和硬件配置比电脑要低，便于人们携带。之所以首先设计移动端，为了能够考虑到很多限制因素。如果开发桌面的程序，我们可以进行其扩展。如果我们相反，将已有的功能塞进一个有限的平台，难度会更大。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;响应式设计！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/12/数据结构与算法之递归系列/</id>
    <published>2019-05-12T00:38:25.297Z</published>
    <updated>2019-05-16T08:48:53.756Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数据结构与算法之递归系列"><a href="#数据结构与算法之递归系列" class="headerlink" title="数据结构与算法之递归系列"></a>数据结构与算法之递归系列</h2><p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几个月之前就想写这样一篇文章分享给大家，由于自己有心而力不足，没有把真正的学到的东西沉淀下来，所以一直在不断的自学。可能是因为在一所三流大学，资源也比较少，只能自己在网搜索相关资料，在互联网上遇到了一些朋友的帮助下去深入理解，然后自己抽出大量时间做题总结、归纳，才会把已有的知识概念所被自己吸收和理解，形成了自己的技术思想体系。</p><p>然后自己游泳了用了一个星期的时间去整理、分类，才有了这篇 7000 字有关递归的分享，希望能够帮助正在学习递归的小伙伴们。而且有了这篇文章的支撑和动力，往后还会写出关于数据结构与算法一些难懂的概念简单化。如果文章中有错误的地方，希望大家指正，能够为他人分享出更有质量的文章！</p><h2 id="为什么要写这篇递归文章"><a href="#为什么要写这篇递归文章" class="headerlink" title="为什么要写这篇递归文章"></a>为什么要写这篇递归文章</h2><p>看了很多关于递归的文章，也总结了很多递归的文章，也看了多篇文章下方读者的评论。有的读者评论到文章清晰易懂，有的却喷作者写的存在很多错误，埋怨作者写出来很垃圾，还不如不写。我想从理性的角度说一下，创作者写文章的最初好意是能够帮助别人对此知识点有进一步的了解，并不代表一定能够满足每个人的要求。</p><p>另一方面，每篇文章的作者可能理解的不够透彻，很多地方可能存在许多错误，包括理解上的错误，笔误等，这也是写文章的第二个目的，能够让别人挑出自己文章中的不足，能够达到与别人共同进步的目的，一举两得，两全其美。</p><p>接下来分享的文章是关于递归的，这篇文章不单单分享递归的一切，我觉得更重要的是向每位读者传递一个思想。思想？对的，没错！这篇文章不能说包含递归的边边角角，但是通过自己的理论上的学习和实践，有了自己的一套递归思想。</p><p>什么问题该用递归，什么问题用递归简洁，什么问题就不能使用递归解决，以及对于特定的问题用递归解决的陷阱，能不能进一步对递归进行二次优化，这些都是今天小鹿分享的内容。</p><h2 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h2><blockquote><p>递归，顾名思义，有递有归才叫递归，有递无归，有归无递那叫 “耍流氓” 。</p></blockquote><h2 id="为什么要学习递归？"><a href="#为什么要学习递归？" class="headerlink" title="为什么要学习递归？"></a>为什么要学习递归？</h2><p>我们学习一门技术也好，编程语言也好，首先学习之前我们知道它将能给我们带来什么，能帮助我们解决什么样的问题，这也是激励我们去学习它的动力所在。</p><p>从数组到链表、散列表，再到基本算法等，直到遇到递归之后，感觉非常的难理解。我相信每个人都有这种感觉，一开始觉得非常难，经历了九九八十一难之后，还是没有弄懂递归里边的猫腻，然后就自然而然的跳过了。</p><p>后来我就开始刷了一个月的 LeetCode 题，发现递归在数据结构与算法中有着一席之地，统治着江山。大部分的题都可以用递归去解决，如：二叉树的遍历、回溯算法、0-1 背包问题、深度优先遍历、回溯算法等等，我整理了至少二三十到关于递归的题，才发现递归的重要性，所以不得不重新深入递归学习，所有有了今天这篇文章。</p><h2 id="怎么理解递归的过程？"><a href="#怎么理解递归的过程？" class="headerlink" title="怎么理解递归的过程？"></a>怎么理解递归的过程？</h2><blockquote><p>上方我对递归“耍流氓”式的定义并不能让你准确的理解递归是什么，那么我们就来活生生的举个生活中的例子。</p></blockquote><h4 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h4><blockquote><p>比如你和小鹿我一样，在大学里喜欢插队打饭（作为一个三好学生，我怎么能干这种事呢？哈哈），那么队伍后边的同学本数着自己前边还有 5 个同学就改轮到自己了，由于前边同学不断的插队，这时他发现，怎么觉得自己离着打饭的窗口越来越远呢？这时如果他想知道自己在队队列中的的第几个（前提是前边不再有人插队），用递归思想来解决，我们怎么做呢？</p></blockquote><h4 id="2、“递”"><a href="#2、“递”" class="headerlink" title="2、“递”"></a>2、“递”</h4><blockquote><p>于是他问前边的同学是第几位，前边的同学也不只到呀，于是前边的同学问他前边的同学是第几位，直到前边第二个同学问到第一个正在打饭的同学是队伍的第几个（有点小尴尬）。打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？<strong>这个过程其实是就是一个递归中“递”的过程</strong>。</p></blockquote><h4 id="3、“归”"><a href="#3、“归”" class="headerlink" title="3、“归”"></a>3、“归”</h4><blockquote><p>然后前边打饭的第二个同学不耐烦的又告诉第三个同学，我是第二个，没看单我前边有个家伙正在打饭吗？然后第三个传给第四个，以后往后传，直到那位逐渐远离窗口的同学的前一个人告诉他是第几个之后，他知道了自己目前在队伍中的第几个位置。<strong>这个过程我们可以理解为递归中“归”的过程</strong>。</p></blockquote><h4 id="4、终止条件"><a href="#4、终止条件" class="headerlink" title="4、终止条件"></a>4、终止条件</h4><blockquote><p>“打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？”，在递归中，我们称为<strong>终止条件</strong>。</p></blockquote><h4 id="5、怎么理解递归？"><a href="#5、怎么理解递归？" class="headerlink" title="5、怎么理解递归？"></a>5、怎么理解递归？</h4><blockquote><p>1）问题虽然是层层递归的分析，但是用程序表示的时候，不要层层的在大脑中调用递归代码去想，这样可能会使你完全陷入到 “递” 的过程中去，“归” 的时候，归不出来了，这些都是我们交给计算机干的事情。</p><p>2）那我们在写程序的时候怎么理解递归呢？我们只找问题之间存在的关系，<strong>屏蔽掉递归的细节</strong>，具体看（五）分析。</p></blockquote><h2 id="满足递归的三个条件"><a href="#满足递归的三个条件" class="headerlink" title="满足递归的三个条件"></a>满足递归的三个条件</h2><blockquote><p>通过上方的例子，我们可以很容易的总结出满足递归的三个条件。</p></blockquote><h4 id="1、一个问题能不能分解成多个子问题来解决"><a href="#1、一个问题能不能分解成多个子问题来解决" class="headerlink" title="1、一个问题能不能分解成多个子问题来解决"></a>1、一个问题能不能分解成多个子问题来解决</h4><blockquote><p>想知道自己在队伍中的位置，将其问题分解为“每个人所处队伍中的位置”这样的多个子问题。</p></blockquote><h4 id="2、该问题是否和子问题的解决思路相同"><a href="#2、该问题是否和子问题的解决思路相同" class="headerlink" title="2、该问题是否和子问题的解决思路相同"></a>2、该问题是否和子问题的解决思路相同</h4><blockquote><p>想要知道自己当前的位置，就要问前边人所处的位置。那么前边人想要知道自己所处的位置，就要知道他前边人的位置。所以说，该问题和子问题的解决思路相同，满足第二个条件。</p></blockquote><h4 id="3、该问题是否有终止条件"><a href="#3、该问题是否有终止条件" class="headerlink" title="3、该问题是否有终止条件"></a>3、该问题是否有终止条件</h4><blockquote><p>第一个正在打饭的同学说自己是队伍中的第一人，这就是所谓的终止条件，找到终止条件之后就开始进行“归”的过程。</p></blockquote><h2 id="怎么编写递归代码？"><a href="#怎么编写递归代码？" class="headerlink" title="怎么编写递归代码？"></a>怎么编写递归代码？</h2><blockquote><p>如果你对递归有了一定的了解，上边的例子对你来说小菜一碟，下边还有更大的难度来进行挑战。那么问题分析清楚了，怎么根据问题编写出递归代码来呢？</p></blockquote><h4 id="1、写出递推公式"><a href="#1、写出递推公式" class="headerlink" title="1、写出递推公式"></a>1、写出递推公式</h4><blockquote><p>写递归公式最重要的一点就是找到该问题和子问题的关系，怎么找到之间存在的关系呢？这里我要强调注意的一点就是不要让大脑试图去想层层的递归过程，毕竟大脑的思考方式是顺势思考的（一开始学习递归总是把自己绕绕进去，归的时候，就完全乱套的）。那怎么找到每个子问题之间存在的某种关系呢？</p></blockquote><p>我们只想其中一层（第一层关系），以上述为例，如果我想知道当前队伍的位置，所以我要之前前一个人的位置，然后 <code>+1</code> 就是我的位置了。对于他在什么位置，我丝毫不用关系，而是让递归去解决他的位置。我们可以写出递推公式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(n) 代表当前我在队伍中的位置</span></span><br><span class="line"><span class="comment">// f(n-1) 代表我前边那个人的位置</span></span><br><span class="line"><span class="comment">// 递推公式</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>※ 注意：</strong>这个式子的含义就是 <code>f(n)</code> 求当前 n 这个人的位置， <code>f(n-1) + 1</code> 代表的就是前一个人的位置 <code>+ 1</code> 就是 <code>n</code> 的位置。</p></blockquote><h4 id="2、找到终止条件"><a href="#2、找到终止条件" class="headerlink" title="2、找到终止条件"></a>2、找到终止条件</h4><blockquote><p>递推公式我们很轻松的写出来了，但是没有终止条件的递推公式会永远的执行下去的，所以我们要有一个终止条件终止程序的运行。那么怎么找到终止条件呢？</p></blockquote><p>所谓的终止条件就是已知的条件，比如上述的排队打饭的例子中，第一个人正在窗口打饭，他的前边是没有人的，所以他是第一个。第一个人的位置为 1，我们应该怎么表示呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>※ 注意：</strong>有的问题终止条件不止一个哦，比如：斐波那契数列。具体问题具体分析。</p></blockquote><h4 id="3、转换递归代码"><a href="#3、转换递归代码" class="headerlink" title="3、转换递归代码"></a>3、转换递归代码</h4><blockquote><p>递推公式和终止条件我们分析出来了，那么将递推公式转化为递归代码非常容易了。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) retun <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line"><span class="keyword">return</span> f(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归的分类"><a href="#递归的分类" class="headerlink" title="递归的分类"></a>递归的分类</h2><blockquote><p>通过做大量的题，根据递归解决不同的问题，引申出来的几种解决和思考的方式。之所以将其分类，是为了能够更好的理解递归在不同的问题下起着什么作用，如：每层递归之间存在的关系、计算，以及递归枚举所有情况和面临选择性问题的递归。虽然分为了几类，但是递归的本质是一成不变的。</p></blockquote><h4 id="分类一：递归计算型"><a href="#分类一：递归计算型" class="headerlink" title="分类一：递归计算型"></a>分类一：递归计算型</h4><blockquote><p>将哪一类用递归解决的问题作为计算型呢？我简单总结了为两点，<strong>层层计算和并列计算</strong>。</p></blockquote><h5 id="1、层层计算"><a href="#1、层层计算" class="headerlink" title="1、层层计算"></a>1、层层计算</h5><blockquote><p>层层计算，顾名思义，能够用递归解决的问题都可以分为多个子问题，我们把每个子问题可以抽象成一层，子问题之间的关系可以表示为层与层之间的关系。我们通过层与层之间的计算关系用递推公式表达出来做计算，经过层层的递归，最终得到结果值。</p></blockquote><p><strong>▉ 例子：</strong></p><blockquote><p>我们再那上方排队打饭的例子来说明，我们的子问题已经分析出来了，就是我想知道当前在队伍中的位置，就是去问我前边人的位置加一就是我当前队伍的位置，这为一层。而前边这个人想知道当前自己的位置，需要用同样的解决思路，作为另一层。</p></blockquote><p>层与层之间的关系是什么（我当前队伍中的位置与前边人的位置存在什么样的关系）？这时你会说，当前是 <code>+1</code>。这个大部分人都很容易找出，既然关系确定了，然后通过递推公式很容易写出递归代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(n) 为我所在的当前层</span></span><br><span class="line"><span class="comment">// f(n-1) 为我前边的人所在的当前层</span></span><br><span class="line"><span class="comment">// + 1 是层与层之间的计算关系</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>▉ 总结：</strong></p><blockquote><p>我将以上一类递归问题命名为「递归计算型」的「层层计算类型」。</p></blockquote><p><strong>▉ 举一反三：</strong></p><blockquote><p>求年龄的问题也是层层计算类型的问题，自己尝试分析一下（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。</p><p><strong>问题一：</strong>有 5 个人坐在一起，问第 5 个人多少岁，他说比第 4 个人大 2 岁。问第 4 个人多少岁，他说比第 3 个人大2岁。问第 3 人多少岁，他说比第 2个 人大 2 岁。问第2个人多少岁，他说比第 1 个人大 2 岁。最后问第 1 个人，他说他是 10 岁。编写程序，当输入第几个人时求出其对应的年龄。</p><p><strong>问题二：</strong>单链表从尾到头一次输出结点值，用递归实现。</p></blockquote><h5 id="2、并列计算"><a href="#2、并列计算" class="headerlink" title="2、并列计算"></a>2、并列计算</h5><blockquote><p>并列计算，顾名思义，问题的解决方式是通过递归的并列计算来得到结果的。层与层之间并没有一定的计算关系，而只是简单的改变输入的参数值。</p></blockquote><p><strong>▉ 例子：</strong></p><blockquote><p>最经典的题型就是<strong>斐波那契数列</strong>。观察这样一组数据0、 1、1、2、3、5、8、13、21、34…，去除第一个和第二个数据外，其余的数据等于前两个数据之和（如：<code>2 = 1 + 1</code>，<code>8 = 3 + 5</code>，<code>34 = 21 + 13</code>）。你可以尝试着根据「满足递归的三个条件」以及「怎么写出递归代码」的步骤自己动手动脑亲自分析一下。</p></blockquote><p>我也在这里稍微做一个分析。</p><p>1）第一步：首先判断能不能将问题分解为多个子问题，上边我也分析过了，除了第一个和第二个数据，其他数据是前两个数据之和。那么前两个数据怎么知道呢？同样的解决方式，是他们前两个数之和。</p><p>2）第二步：找到终止条件，如果不断的找到前两个数之和，直到最前边三个数据 <code>0、1、1</code> 。如果递归求第一个 1 时，前边的数据不够，所以这也是我们找到的终止条件。</p><p>3）第三步：既然我们终止条件和关系找到了，递推公式也就不难写出 <code>f(n) = f(n-1) + f(n-2)</code>（n 为要求的第几个数字的值）。</p><p>4）转化为递归代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>▉ 总结：</strong></p><blockquote><p>我将上方的问题总结为并列计算型。也可以归属为层层计算的一种，只不过是 + 1 改成了加一个 f 函数自身的递归（说白了，递归的结果也是一个确切的数值）。之所谓并列计算 <code>f(n-1)</code> 和 <code>f(n-2)</code> 互不打扰，各自递归计算各的值。最后我们将其计算的结果值相加是我们最想要的结果。</p></blockquote><p><strong>▉ 举一反三：</strong></p><blockquote><p>青蛙跳台阶的问题也是一种并列计算的一种，自己尝试着根据上边的思路分析一下，实践出真知（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。</p><p><strong>问题：</strong></p><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。</p></blockquote><h4 id="分类二：递归枚举型"><a href="#分类二：递归枚举型" class="headerlink" title="分类二：递归枚举型"></a>分类二：递归枚举型</h4><blockquote><p>递归枚举型最多的应用就是回溯算法，枚举出所有可能的情况，怎么枚举所有情况呢？通过递归编程技巧进行枚举。那什么是回溯算法？比如走迷宫，从入口走到出口，如果遇到死胡同，需要回退，退回上一个路口，然后走另一岔路口，重复上述方式，直到找到出口。</p></blockquote><p>回溯算法最经典的问题又深度优先遍历、八皇后问题等，应用非常广泛，下边以八皇后问题为例子，展开分析，其他利用递归枚举型的回溯算法就很简单了。</p><h5 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h5><blockquote><p>在 8 X 8 的网格中，放入八个皇后（棋子），满足的条件是，任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，问有多少种摆放方式？</p></blockquote><p>【图片】</p><p><strong>▉ 问题分析：</strong></p><blockquote><p>要想满足任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，需要一一枚举皇后（棋子）的所有摆放情况，然后设定条件，筛选出满足条件的情况。</p></blockquote><p><strong>▉ 算法思路：</strong></p><blockquote><p>我们把问题分析清楚了之后，怎么通过递归实现回溯算法枚举八个皇后（棋子）出现的所有情况呢？</p><p>1）我们在 8 X 8 的网格中，先将第一枚皇后（棋子）摆放到第一行的第一列的位置（也就是坐标: (0,0)）。</p><p>2）然后我们在第二行安置第二个皇后（棋子），先放到第一列的位置，然后判断同一行、同一列、同一斜线是否存在另一个皇后？如果存在，则该位置不合适，然后放到下一列的位置，然后在判断是否满足我们设定的条件。</p><p>3）第二个皇后（棋子）找到合适的位置之后，然后在第三行放置第三枚棋子，依次将八个皇后放到合适的位置。</p><p>4）这只是一种可能，因为我设定的第一个皇后是固定位置的，在网格坐标的（0,0） 位置，那么怎么枚举所有的情况呢？然后我们不断的改变第一个皇后位置，第二个皇后位置…… ，就可以枚举出所有的情况。如果你和我一样，看了这个题之后，如果还有点懵懵懂懂，那么直接分析代码吧。</p></blockquote><p><strong>▉ 代码实现：</strong></p><blockquote><p>虽然是用 <code>javascript</code> 实现的代码，相信学过编程的小伙伴基本的代码逻辑都可以看懂。根据上方总结的递归分析满足的三个条件以及怎么写出递归代码的步骤，一步步来分析八皇后问题。</p></blockquote><p>1、将问题分解为多个子问题</p><blockquote><p>在上述的代码分析和算法思路分析中，我们可以大体知道怎么分解该问题了，枚举出八个皇后（棋子）所有的满足情况可以分解为，先寻找每一种满足的情况这种子问题。比如，每个子问题的算法思路就是上方列出的四个步骤。</p></blockquote><p>2、找出终止条件</p><blockquote><p>当遍历到第八行的时候，递归结束。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">if</span>(row === <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// 打印第 n 种满足的情况</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、写出递推公式</p><blockquote><p><code>isOkCulomn()</code> 函数判断找到的该位置是否满足条件（不能处于同一行、同一列或同一斜线上）。如果满足条件，我们返回 <code>true</code>，进入 <code>if</code> 判断，<code>row</code>行数加一传入进行递归下一行的皇后位置。直至递归遇到终止条件位置，<code>column ++</code>，将第一行的皇后放到下一位置，进行继续递归，枚举出所有可能的摆放情况。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一列的判断</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++)&#123;</span><br><span class="line">    <span class="comment">// 判断当前的列位置是否合适</span></span><br><span class="line">    <span class="keyword">if</span>(isOkCulomn(row,column))&#123;</span><br><span class="line">        <span class="comment">// 保存皇后的位置</span></span><br><span class="line">        result[row] = column;</span><br><span class="line">        <span class="comment">// 对下一行寻找数据</span></span><br><span class="line">        cal8queens(row + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前列是否合适</span></span><br><span class="line"><span class="keyword">const</span> isOkCulomn = <span class="function">(<span class="params">row,column</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 左上角列的位置</span></span><br><span class="line">    <span class="keyword">let</span> leftcolumn = column - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右上角列的位置</span></span><br><span class="line">    <span class="keyword">let</span> rightcolumn = column + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 判断当前格子正上方是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] === column) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格子左上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === leftcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格式右上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === rightcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历</span></span><br><span class="line">        leftcolumn --;</span><br><span class="line">        rightcolumn ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、转换为递归代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="comment">// result 为数组，下标为行，数组中存储的是每一行中皇后的存储的列的位置。</span></span><br><span class="line"><span class="comment">// row 行  </span></span><br><span class="line"><span class="comment">// column 列</span></span><br><span class="line"><span class="comment">// n 计数满足条件的多少种</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> cal8queens = <span class="function">(<span class="params">row</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(row === <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每一列的判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++)&#123;</span><br><span class="line">        <span class="comment">// 判断当前的列位置是否合适</span></span><br><span class="line">        <span class="keyword">if</span>(isOkCulomn(row,column))&#123;</span><br><span class="line">            <span class="comment">// 保存皇后的位置</span></span><br><span class="line">            result[row] = column;</span><br><span class="line">            <span class="comment">// 对下一行寻找数据</span></span><br><span class="line">            cal8queens(row + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前列是否合适</span></span><br><span class="line"><span class="keyword">const</span> isOkCulomn = <span class="function">(<span class="params">row,column</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 设置左上角</span></span><br><span class="line">    <span class="keyword">let</span> leftcolumn = column - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> rightcolumn = column + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 判断当前格子正上方是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] === column) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格子左上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === leftcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格式右上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === rightcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历</span></span><br><span class="line">        leftcolumn --;</span><br><span class="line">        rightcolumn ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归打印所有情况</span></span><br><span class="line"><span class="keyword">const</span> print = <span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === j)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'Q'</span> + <span class="string">' '</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'*'</span> + <span class="string">' '</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">cal8queens(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br></pre></td></tr></table></figure><p><strong>▉ 总结</strong></p><blockquote><p>上述八皇后的问题就是用递归来枚举所有情况，然后再从中设置条件，只筛选满足条件的选项。上述代码建议多看几遍，亲自动手实践一下。一开始解决八皇后问题，我自己看了好长时间才明白的，以及递归如何发挥技巧作用的。</p></blockquote><p><strong>▉ 举一反三：</strong></p><blockquote><p>如果你想练练手，可以自己实现以下图的深度优先遍历，这个理解起来并不难，可以自己动手尝试着写一写，我把代码传到我的 <code>Github</code> 上了。</p></blockquote><h4 id="分类三：递归选择型"><a href="#分类三：递归选择型" class="headerlink" title="分类三：递归选择型"></a>分类三：递归选择型</h4><blockquote><p>所谓的递归选择型，每个子问题都要面临选择，求最优解的情况。有的小伙伴会说，求最优解动态规划最适合，对的，没错，但是递归通过选择型枚举所有情况，设置条件，求得问题的最优解也是可以实现的，所有我呢将其这一类问题归为递归选择型问题。</p></blockquote><h5 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0 -1 背包问题"></a>0 -1 背包问题</h5><blockquote><p><code>0 - 1</code> 背包问题，了解过的小伙伴也是很熟悉的了。其实这个问题也属于回溯算法的一种，废话不多说，直接上问题。有一个背包，背包总的承载重量是 <code>Wkg</code>。现在我们有 <code>n</code> 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p></blockquote><p><strong>▉ 问题分析：</strong></p><blockquote><p>如果你对该问题看懵了，没关系，我们一点点的分析。假如每个物品我们有两种状态，总的装法就有 <code>2^n</code>种，怎么才能不重复的穷举这些可能呢？</p></blockquote><p><strong>▉ 算法思路：</strong></p><blockquote><p>我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p></blockquote><p>▉ <strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来存储背包中承受的最大重量</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Number</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">// i: 对第 i 个物品做出选择</span></span><br><span class="line"><span class="comment">// currentw: 当前背包的总重量</span></span><br><span class="line"><span class="comment">// goods：数组，存储每个物品的质量</span></span><br><span class="line"><span class="comment">// n: 物品的数量</span></span><br><span class="line"><span class="comment">// weight: 背包应承受的重量</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">i, currentw, goods, n, weight</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(currentw === weight || i === n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(currentw &gt; max)&#123;</span><br><span class="line">            max = currentw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择跳过当前物品不装入背包</span></span><br><span class="line">    f(i+<span class="number">1</span>, currentw, goods, n, weight)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前物品装入背包</span></span><br><span class="line">    <span class="comment">// 判断当前物品装入背包之前是否超过背包的重量,如果已经超过当前背包重量，就不要就继续装了</span></span><br><span class="line">    <span class="keyword">if</span>(currentw + goods[i] &lt;= weight)&#123;</span><br><span class="line">        f(i+<span class="number">1</span> ,currentw + goods[i], goods, n, weight)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">f(<span class="number">0</span>,<span class="number">0</span>,a,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(max)</span><br></pre></td></tr></table></figure><h2 id="递归的缺点"><a href="#递归的缺点" class="headerlink" title="递归的缺点"></a>递归的缺点</h2><blockquote><p>虽然递归的使用非常的简洁，但是也有很多缺点，也是我们在使用中需要额外注意的地方和优化的地方。</p></blockquote><h4 id="1、递归警惕堆栈溢出"><a href="#1、递归警惕堆栈溢出" class="headerlink" title="1、递归警惕堆栈溢出"></a>1、递归警惕堆栈溢出</h4><blockquote><p>你可能会问，递归和系统中的堆栈有什么关联？不要急，听我慢慢细说。</p></blockquote><h5 id="▉-理解堆栈溢出"><a href="#▉-理解堆栈溢出" class="headerlink" title="▉ 理解堆栈溢出"></a>▉ 理解堆栈溢出</h5><blockquote><p>1）递归的本质就是重复调用本身的过程，本身是什么？当然是一个函数，那好，函数中有参数以及一些局部的声明的变量，相信很多小伙伴只会用函数，而不知道函数中的变量是怎么存储的吧。没关系，等你听我分析完，你就会了。</p><p>2）函数中变量是存储到系统中的栈中的，栈数据结构的特点就是先进后出，后进先出。一个函数中的变量的使用情况就是随函数的声明周期变化的。当我们执行一个函数时，该函数的变量就会一直不断的压入栈中，当函数执行完毕销毁的时候，栈内的元素依次出栈。还是不懂，没关系，看下方示意图。</p><p>3）我们理解了上述过程之后，回到递归上来，我们的递归调用是在函数里调用自身，且当前函数并没有销毁，因为当前函数在执行自身层层递归进去了，所以递归的过程，函数中的变量一直不断的压栈，由于我们系统栈或虚拟机栈空间是非常小的，当栈压满之后，再压时，就会导致堆栈溢出。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【图】</p><h5 id="▉-解决办法"><a href="#▉-解决办法" class="headerlink" title="▉ 解决办法"></a>▉ 解决办法</h5><blockquote><p>那么遇到这种情况，我们怎么解决呢？</p></blockquote><p>通常我们设置递归深度，简单的理解就是，如果递归超过我们设置的深度，我们就退出，不再递归下去。</p><h4 id="2、递归警惕重复元素"><a href="#2、递归警惕重复元素" class="headerlink" title="2、递归警惕重复元素"></a>2、递归警惕重复元素</h4><blockquote><p>有些递归问题中，存在重复计算问题，比如求斐波那契数列，我们画一下递归树如下图，我们会发现有很多重复递归计算的值，重复计算会导致程序的时间复杂度很高，而且是指数级别的，导致我们的程序效率低下。</p></blockquote><p>【递归树图】</p><h5 id="▉-解决办法-1"><a href="#▉-解决办法-1" class="headerlink" title="▉ 解决办法"></a>▉ 解决办法</h5><blockquote><p>重复计算问题，我们应该怎么解决？有的小伙伴想到了，我们把已经计算过的值保存起来，每次递归计算之前先检查一下保存的数据有没有该数据，如果有，我们拿出来直接用。如果没有，我们计算出来保存起来。一般我们用散列表来保存。（所谓的散列表就是键值对的形式，如 map ）</p></blockquote><p>【代码实现】</p><h4 id="3、递归高空间复杂度"><a href="#3、递归高空间复杂度" class="headerlink" title="3、递归高空间复杂度"></a>3、递归高空间复杂度</h4><blockquote><p>因为递归时函数的变量的存储需要额外的栈空间，当递归深度很深时，需要额外的内存占空间就会很多，所以递归有非常高的空间复杂度。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Webpack成神之路之插件配置【处理CSS3属性前缀_11】</title>
    <link href="http://yoursite.com/2019/05/09/Webpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90%E5%A4%84%E7%90%86CSS3%E5%B1%9E%E6%80%A7%E5%89%8D%E7%BC%80_11%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/09/Webpack成神之路之插件配置【处理CSS3属性前缀_11】/</id>
    <published>2019-05-09T06:52:32.787Z</published>
    <updated>2019-05-09T07:44:00.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>处理 CSS3 属性前缀！</p><a id="more"></a><h2 id="CSS进阶：自动处理CSS3属性前缀"><a href="#CSS进阶：自动处理CSS3属性前缀" class="headerlink" title="CSS进阶：自动处理CSS3属性前缀"></a>CSS进阶：自动处理CSS3属性前缀</h2><blockquote><p>CSS3 是前段必会的技能，但是通常需要添加像 <code>-webkit,-ms,-o,-moz</code> 这些前缀，为了能够在不同浏览器上都可已顺利的运行。为了能够自动添加这些繁琐的前缀，我们借助插件来实现。</p></blockquote><p>1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;处理 CSS3 属性前缀！&lt;/p&gt;
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/webpack/"/>
    
    
      <category term="前端工具" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>吃透 javascript 之【完整篇】</title>
    <link href="http://yoursite.com/2019/05/08/%E5%90%83%E9%80%8F%20JavaScript%20%E4%B9%8B%E3%80%90%E5%AE%8C%E6%95%B4%E7%AF%87%E3%80%91%20/"/>
    <id>http://yoursite.com/2019/05/08/吃透 JavaScript 之【完整篇】 /</id>
    <published>2019-05-08T11:19:46.959Z</published>
    <updated>2019-05-08T11:19:46.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Javascript 的重点学习路线完整篇。</p><a id="more"></a><p>[TOC]</p><h3 id="一、JavaScript-简介"><a href="#一、JavaScript-简介" class="headerlink" title="一、JavaScript 简介"></a>一、JavaScript 简介</h3><h4 id="1、诞生"><a href="#1、诞生" class="headerlink" title="1、诞生"></a>1、诞生</h4><blockquote><p>最早期网景公司开启 web 时代的第一代互联网，早起网景公司只是做静态页面，为了能够在静态页面添加一些动态的效果，所以叫Brendan Eich 这两个人两星期之内设计出 javascript ，不出所料，这两人只用了短短的10天时间。为了使其能够借助 java 的盛行，所以起名 javascript。</p></blockquote><h4 id="2、ECMAScript"><a href="#2、ECMAScript" class="headerlink" title="2、ECMAScript"></a>2、ECMAScript</h4><blockquote><p>网景开发了 javascript 之后，微软也模仿开发了 Jscript，为了能够让 javascript 称为全球的开发标准，所以几个公司联合发布了 ECMA 标准。ECMAScript 是一种语言标准，而网景公司开发的 javascript 是这一标准的实现。</p></blockquote><h4 id="3、版本"><a href="#3、版本" class="headerlink" title="3、版本"></a>3、版本</h4><blockquote><p>因为 javascript 的标准在短时间实现的，其中存在很多的缺陷，所以 javascript 的标准 ECMAScript 不断发展，到目前的 ES6 版本 2015 年发布。这里的 javascript 版本一般说的就是实现了 ECMAScript 哪个版本。</p></blockquote><h3 id="二、数据类型和变量"><a href="#二、数据类型和变量" class="headerlink" title="二、数据类型和变量"></a>二、数据类型和变量</h3><h4 id="1、-和-的区别？"><a href="#1、-和-的区别？" class="headerlink" title="1、== 和 ===的区别？"></a>1、<code>==</code> 和 <code>===</code>的区别？</h4><blockquote><p>== 是 javascript 的设计缺陷，一般使用 === 来比较。</p><p><code>==</code> : 两种之间比较需要先进行转换，然后进行比较，有时候出现很奇怪的情况。</p><p><code>===</code> :  先比较类型，如果类型相等，然后在比较值。</p></blockquote><h4 id="2、NAN-是-Number-特殊的值"><a href="#2、NAN-是-Number-特殊的值" class="headerlink" title="2、NAN 是 Number 特殊的值"></a>2、NAN 是 Number 特殊的值</h4><blockquote><p>NAN 与任何值都不相等，包括它本身自己。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN === NaN; // false</span><br></pre></td></tr></table></figure><blockquote><p>唯一能判断 <code>NaN</code> 的方法是通过 <code>isNaN()</code> 函数 </p></blockquote><h4 id="3、浮点型之间的比较"><a href="#3、浮点型之间的比较" class="headerlink" title="3、浮点型之间的比较"></a>3、浮点型之间的比较</h4><blockquote><p><strong>问题</strong>：浮点型在运算会产生误差，导致计算机无法准确表示无限循环小数，所以导致比较不相等。</p><p><strong>解决：</strong>要比较浮点型之间的大小，要比较两个浮点型之差的绝对值是否小于某一个阈值。</p></blockquote><h4 id="4、null-和-undefined"><a href="#4、null-和-undefined" class="headerlink" title="4、null 和 undefined"></a>4、null 和 undefined</h4><blockquote><p><code>NULL</code> 表示“空”。<code>undefined</code> 表示未定义。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。 </p></blockquote><h4 id="5、严格模式是什么？"><a href="#5、严格模式是什么？" class="headerlink" title="5、严格模式是什么？"></a>5、严格模式是什么？</h4><blockquote><p><strong>缘由：</strong>初期，为了方便，不强制要求 var 声明变量，所以会导致未被 var 声明的变量自动声明为全局变量，如果同一页面不同 js 文件都用到了 js 文件的相同变量，导致变量之间相互影响，也就是我们所说的污染全局环境变量。</p><p><strong>strict模式：</strong>不用<code>var</code>申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。 </p></blockquote><h3 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h3><h4 id="1、多行字符串"><a href="#1、多行字符串" class="headerlink" title="1、多行字符串"></a>1、多行字符串</h4><blockquote><p>多行字符串用 <code></code> 反引号来表示，ES6 新增加语法。</p></blockquote><h4 id="2、字符串拼接"><a href="#2、字符串拼接" class="headerlink" title="2、字符串拼接"></a>2、字符串拼接</h4><blockquote><p>关于字符串拼接用 ${name} 引用，ES6 新增加语法。</p></blockquote><h3 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h3><h4 id="1、indexof"><a href="#1、indexof" class="headerlink" title="1、indexof"></a>1、indexof</h4><blockquote><p>搜索一个指定的元素的位置 。</p></blockquote><h4 id="2、slice"><a href="#2、slice" class="headerlink" title="2、slice"></a>2、slice</h4><blockquote><p>字符串截取。单参数为从参数起到结束，双参数为中间元素（不包括尾元素），返回新数组。</p></blockquote><h4 id="3、push-和-pop"><a href="#3、push-和-pop" class="headerlink" title="3、push 和 pop"></a>3、push 和 pop</h4><blockquote><p>末尾添加元素和末尾删除元素。</p></blockquote><h4 id="4、unshift-和-shift"><a href="#4、unshift-和-shift" class="headerlink" title="4、unshift 和 shift"></a>4、unshift 和 shift</h4><blockquote><p>头部添加元素和头部删除元素。</p></blockquote><h4 id="5、sort"><a href="#5、sort" class="headerlink" title="5、sort"></a>5、sort</h4><blockquote><p>对当前数组进行排序。</p></blockquote><h4 id="6、reverse"><a href="#6、reverse" class="headerlink" title="6、reverse"></a>6、reverse</h4><blockquote><p>将数组元素反转。</p></blockquote><h4 id="7、splice"><a href="#7、splice" class="headerlink" title="7、splice"></a>7、splice</h4><blockquote><p>可以删除元素也可以删除同时添加元素。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;);</span><br></pre></td></tr></table></figure><h4 id="8、concat"><a href="#8、concat" class="headerlink" title="8、concat"></a>8、concat</h4><blockquote><p>合并两个数组，返回新数组。</p></blockquote><h4 id="9、join"><a href="#9、join" class="headerlink" title="9、join"></a>9、join</h4><blockquote><p>指定字符连接数组中的元素。</p></blockquote><h3 id="五、Map-和-Set"><a href="#五、Map-和-Set" class="headerlink" title="五、Map 和 Set"></a>五、Map 和 Set</h3><h4 id="1、Map"><a href="#1、Map" class="headerlink" title="1、Map"></a>1、Map</h4><blockquote><p>一组键值对，键必须为字符串类型。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;);</span><br><span class="line">m.set(&apos;Bob&apos;,59)</span><br><span class="line">m.delete(&apos;Adam&apos;);</span><br></pre></td></tr></table></figure><h4 id="2、Set"><a href="#2、Set" class="headerlink" title="2、Set"></a>2、Set</h4><blockquote><p>一组 key 的集合，不存储 value。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set([1, 2, 3]);</span><br><span class="line">s.add(4);</span><br><span class="line">s.delete(3);</span><br></pre></td></tr></table></figure><h3 id="六、iterable"><a href="#六、iterable" class="headerlink" title="六、iterable"></a>六、iterable</h3><h6 id="▉-普通-for-循环"><a href="#▉-普通-for-循环" class="headerlink" title="▉ 普通 for 循环"></a>▉ 普通 for 循环</h6><blockquote><p>当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率 。</p></blockquote><h6 id="▉-foreach-循环"><a href="#▉-foreach-循环" class="headerlink" title="▉ foreach 循环"></a>▉ foreach 循环</h6><blockquote><p><strong>功能：</strong>可以获取到 key 和 value 数组的本身。</p><p><strong>缺点：</strong></p><ul><li>不能用 break，continue 语句跳出循环。</li><li>函数内不能使用 return 语句。</li></ul><p><strong>注意：</strong>在不同浏览器下测试的结果都是 forEach 的速度不如 for 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//item 为数组元素</span></span><br><span class="line"><span class="comment">//index 为索引下标</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item,index,arr)</span><br><span class="line">&#125;,<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h6 id="▉-for…in-循环"><a href="#▉-for…in-循环" class="headerlink" title="▉  for…in 循环"></a>▉  for…in 循环</h6><blockquote><p><strong>for-in 循环遍历的是对象的属性。</strong>而不是数组的索引 ，除了遍历数组也可以遍历对象。</p><p><strong>缺点：</strong></p><ul><li>for-in 遍历的顺序并不是确定的。</li><li>它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。 </li><li>for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性 （Array 中的 length 不能遍历到），for-in 不适合遍历 Array 。【链接】：<a href="https://juejin.im/entry/5a1654e951882554b8373622" target="_blank" rel="noopener">https://juejin.im/entry/5a1654e951882554b8373622</a></li></ul></blockquote><h6 id="▉-for…of-循环"><a href="#▉-for…of-循环" class="headerlink" title="▉  for…of 循环"></a>▉  for…of 循环</h6><blockquote><p>ES6 新增语法。</p><p><strong>优点：</strong></p><ul><li>以正确响应 break, continue, return。 </li><li>for-of 循环不仅支持数组，还支持大多数类数组对象。</li><li>for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。</li><li>for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历 </li></ul></blockquote><h3 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h3><blockquote><p>在函数中如果没有 <code>return</code> 语句，函数执行完返回 <code>undefined</code>。</p></blockquote><h4 id="1、arguments"><a href="#1、arguments" class="headerlink" title="1、arguments"></a>1、arguments</h4><blockquote><p>此关键字只在函数内部起作用，并且永远指向当前函数调用者传入的所有参数。</p><p>1、即使函数不定义参数，也是可以通过 arguments 对象拿到传入的参数的。</p><p>2、通常用来判断传入参数的个数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x = '</span> + x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'arg '</span> + i + <span class="string">' = '</span> + <span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><h4 id="2、reset-参数（ES6）"><a href="#2、reset-参数（ES6）" class="headerlink" title="2、reset 参数（ES6）"></a>2、reset 参数（ES6）</h4><blockquote><p>由于 arguments 获取额外的传参非常的别扭，所以 ES6 新增了 rest 参数用来处理额外的参数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b,...rest</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入多余两个参数</span></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// Array[3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传入少于定义参数的个数</span></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//Array[] 空数组</span></span><br></pre></td></tr></table></figure><h4 id="3、注意-return-语句"><a href="#3、注意-return-语句" class="headerlink" title="3、注意 return  语句"></a>3、注意 return  语句</h4><blockquote><p>javascript 引擎会有一个行末添加分号的机制。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为&#123;表示语句尚未结束</span></span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>   <span class="comment">//这一行会可能被引擎自动加分号</span></span><br><span class="line">       &#123; <span class="attr">name</span>: <span class="string">'foo'</span>&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、变量作用域和解构赋值"><a href="#4、变量作用域和解构赋值" class="headerlink" title="4、变量作用域和解构赋值"></a>4、变量作用域和解构赋值</h4><h6 id="▉-全局作用域"><a href="#▉-全局作用域" class="headerlink" title="▉ 全局作用域"></a>▉ 全局作用域</h6><blockquote><p>javascript 只有一个全局作用域，如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报<code>ReferenceError</code>错误。 </p></blockquote><h6 id="▉-命名空间"><a href="#▉-命名空间" class="headerlink" title="▉ 命名空间"></a>▉ 命名空间</h6><blockquote><p>全局变量会绑定到 windows 上，不同的 javascript 文件使用相同的全局变量会产生命名冲突，我们很难发现，所以一般减少冲突的方法就是所有变量和函数全部绑定到一个全局变量中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line">MYAPP.name = <span class="string">'myapp'</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>许多 js 库都是这么干的，jQuery，YUI等。</p></blockquote><h6 id="▉-局部作用域"><a href="#▉-局部作用域" class="headerlink" title="▉ 局部作用域"></a>▉ 局部作用域</h6><blockquote><p>所谓的 js 作用域是在函数内部的，for 循环等语句块中是无法定义具有局部作用域变量的。ES6 引用了 let 代替 var 声明块级作用域变量。</p></blockquote><h6 id="▉-对多个变量同时赋值"><a href="#▉-对多个变量同时赋值" class="headerlink" title="▉ 对多个变量同时赋值"></a>▉ 对多个变量同时赋值</h6><blockquote><p>使用 ES6 新增加的解构赋值。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>];</span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><p>1、交换两个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>,y = <span class="number">2</span>;</span><br><span class="line">[x,y] = [y,x]</span><br></pre></td></tr></table></figure><p>2、快速获取当前页面的域名和路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">hostname</span>:domain, <span class="attr">pathname</span>:path&#125; = location;</span><br></pre></td></tr></table></figure><p>3、函数接受对象的属性为参数</p><blockquote><p>用解构直接将对象的属性绑定到变量中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildDate</span>(<span class="params">&#123;year, month, day, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(year + <span class="string">'-'</span> + month + <span class="string">'-'</span> + day + <span class="string">' '</span> + hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second);</span><br><span class="line">&#125;</span><br><span class="line">buildDate(&#123; <span class="attr">year</span>: <span class="number">2017</span>, <span class="attr">month</span>: <span class="number">1</span>, <span class="attr">day</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="5、方法"><a href="#5、方法" class="headerlink" title="5、方法"></a>5、方法</h4><h6 id="▉-this-指针"><a href="#▉-this-指针" class="headerlink" title="▉ this 指针"></a>▉ this 指针</h6><blockquote><p>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>。如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向全局对象，也就是<code>window</code>。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25, 正常结果</span></span><br><span class="line">getAge(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></span><br><span class="line">fn(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><blockquote><p>以上是 js 的设计错误，ECMA决定，在 strict 模式下让函数的<code>this</code>指向<code>undefined</code> 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="keyword">this</span>.birth; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>报错了，<code>this</code>  指针只在 <code>age</code> 方法的函数内指向 <code>xiaoming</code> 在函数内部定义的函数 ，this 指针指向 undefined ，他重新指向全局变量。</p></blockquote><p>改进方法，用 that 进行捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h6 id="▉-apply-方法"><a href="#▉-apply-方法" class="headerlink" title="▉ apply() 方法"></a>▉ apply() 方法</h6><blockquote><p><strong>作用： </strong>指针函数的 this 指向哪个对象。</p><p><strong>使用：</strong></p><ul><li>参数一：需要绑定的 this 变量。</li><li>参数二：传入的是 Array，表示函数本身的参数。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure><h6 id="▉-call-方法"><a href="#▉-call-方法" class="headerlink" title="▉ call() 方法"></a>▉ call() 方法</h6><blockquote><p>把参数按照顺序传入。</p></blockquote><h6 id="▉-装饰器"><a href="#▉-装饰器" class="headerlink" title="▉ 装饰器"></a>▉ 装饰器</h6><blockquote><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6、高阶函数"><a href="#6、高阶函数" class="headerlink" title="6、高阶函数"></a>6、高阶函数</h4><blockquote><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为<strong>高阶函数 </strong>。 </p></blockquote><h6 id="▉-map-对元素自身进行计算"><a href="#▉-map-对元素自身进行计算" class="headerlink" title="▉ map 对元素自身进行计算"></a>▉ map 对元素自身进行计算</h6><blockquote><p><code>map()</code> 方法定义在 JavaScript 的 <code>Array</code> 中 ,对数组中的每个数据做处理。</p><p><code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"><span class="built_in">console</span>.log(results);</span><br></pre></td></tr></table></figure><h6 id="▉-reduce-所有元素进行累加计算"><a href="#▉-reduce-所有元素进行累加计算" class="headerlink" title="▉ reduce 所有元素进行累加计算"></a>▉ reduce 所有元素进行累加计算</h6><blockquote><p>Array的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h6 id="▉-filter-过滤元素"><a href="#▉-filter-过滤元素" class="headerlink" title="▉ filter 过滤元素"></a>▉ filter 过滤元素</h6><blockquote><p>用于把  <code>Array</code>的某些元素过滤掉，然后返回剩下的元素。 和 <code>map()</code> 不同的是，<code>filter()</code> <strong>把传入的函数依次作用于每个元素，然后根据返回值是 <code>true</code> 还是 <code>false</code> 决定保留还是丢弃该元素。</strong> </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个Array中，删掉偶数，只保留奇数</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure><p><strong>● 回调函数</strong></p><blockquote><p>filter 有多个参数。</p><p><strong>1、一个参数：</strong>仅使用一个表示 Array 的某个元素。</p><p><strong>2、三个参数：</strong>回调函数可以接受另外两个参数，表示元素的<strong>位置</strong>和<strong>数组本身</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除重复元素依靠的是 indexOf 总是返回第一个元素的位置，后续的重复元素位置与 indexOf 返回的位置不相等，因此被 filter 滤掉了。</span></span><br><span class="line"><span class="keyword">var</span> r,</span><br><span class="line">arr = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'orange'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="▉-sort-排序"><a href="#▉-sort-排序" class="headerlink" title="▉ sort 排序"></a>▉ sort 排序</h6><blockquote><p>1、比较字符或者字符串，根据 ASCLL 码进行排序的。</p><p>2、比较数字，先将数组中的数字转换成字符串，然后再进行排序。</p></blockquote><p>sort 是一个高阶函数，可以传入函数来进行自定义的比较：</p><ul><li>数字比较</li></ul><blockquote><p>传入一个比较函数，-返回值为 1，-1，0；</p><p><strong>注意：</strong>sort 直接对 Array 进行修改，结果返回 Array。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="comment">//经断点调试，更像是一种插入排序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//变</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不变</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure><h4 id="6、闭包"><a href="#6、闭包" class="headerlink" title="6、闭包"></a>6、闭包</h4><blockquote><p>将闭包和 Java 类中的 get 获取内部私有变量做对比。</p></blockquote><h6 id="▉-什么是闭包？"><a href="#▉-什么是闭包？" class="headerlink" title="▉ 什么是闭包？"></a>▉ 什么是闭包？</h6><blockquote><p>只有函数内部的子函数才能读取局部变量，定义在一个函数内部的函数 。</p></blockquote><h6 id="▉-作用"><a href="#▉-作用" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>1）在函数的外部也可以获取到函数内部的局部变量。</p><p>2）让这些局部变量值始终保存在内存中，保证不会被 js “垃圾回收机制”回收。</p></blockquote><h6 id="▉-使用闭包注意事项"><a href="#▉-使用闭包注意事项" class="headerlink" title="▉ 使用闭包注意事项"></a>▉ 使用闭包注意事项</h6><blockquote><p>1）闭包会被保存到内存中，内存消耗很大，会造成网页性能问题，在 IE 会导致内存泄漏。在退出函数之前，将不适用的局部变量全部删除。</p></blockquote><h4 id="7、垃圾回收机制"><a href="#7、垃圾回收机制" class="headerlink" title="7、垃圾回收机制"></a>7、垃圾回收机制</h4><h6 id="▉-生命周期"><a href="#▉-生命周期" class="headerlink" title="▉ 生命周期"></a>▉ 生命周期</h6><blockquote><p>1）分配内存： javascript 自动完成内存的分配</p><p>2）使用内存（读或写）：使用值的过程实际上是对分配内存进行读取与写入的操作 </p><p>3）释放内存：在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。所以高级语言潜入垃圾回收机制。</p></blockquote><h6 id="▉-垃圾回收机制"><a href="#▉-垃圾回收机制" class="headerlink" title="▉ 垃圾回收机制"></a>▉ 垃圾回收机制</h6><blockquote><p>主要工作是跟踪内存的<strong>分配</strong>和<strong>使用</strong>，以便当分配的内存不再使用时，自动释放它。</p></blockquote><p><strong>1）引用</strong></p><blockquote><p>垃圾回收算法主要依赖于引用的概念 ，一个对象访问另一个对象就叫做引用。</p></blockquote><p><strong>2）引用计数垃圾收集</strong></p><blockquote><p>初级的垃圾回收算法，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p></blockquote><p><strong>3）限制：循环引用</strong></p><blockquote><p>当该函数调用完成离开作用域之后，可以被回收了，但是两个对象相互引用，所以不会被回收。（IE 6, 7对 DOM 结点进行计数垃圾回收）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）标记—清除算法</strong></p><blockquote><p>针对于“对象是否不再需要”。</p><p>1）算法假设有一个根对象（全局对象），垃圾回收器从根开始找所有从根开始引用的对象。</p><p>2）垃圾回收器将找到所有<strong>可以获得的对象</strong>和收集所有<strong>不能获得的对象</strong>。 （零引用总不可获得的）</p></blockquote><p><strong>5）限制：那些无法从根对象查询到的对象都将被清除</strong></p><h4 id="8、箭头函数"><a href="#8、箭头函数" class="headerlink" title="8、箭头函数"></a>8、箭头函数</h4><h6 id="▉-箭头中的-this"><a href="#▉-箭头中的-this" class="headerlink" title="▉ 箭头中的 this"></a>▉ 箭头中的 this</h6><blockquote><p>由于之前的函数中 this 绑定的错误处理，this 在箭头函数中被修复了。<strong>this 总是与词法作用域绑定</strong>（函数的作用域在函数定义的时候就决定了 ），由上下文确定 ，外层调用者 <code>obj</code>.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向window 或 undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="▉-注意"><a href="#▉-注意" class="headerlink" title="▉ 注意"></a>▉ 注意</h6><blockquote><p>由于<code>this</code>在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>调用箭头函数时，无法对<code>this</code>进行绑定，即传入的第一个参数被忽略。</p></blockquote><h4 id="9、generator-生成器"><a href="#9、generator-生成器" class="headerlink" title="9、generator 生成器"></a>9、generator 生成器</h4><h6 id="▉-定义"><a href="#▉-定义" class="headerlink" title="▉ 定义"></a>▉ 定义</h6><blockquote><p>整个 Generator 函数封装了异步任务。 标注 yield 地方都是异步需要暂停的地方（yield 将任务分为几个阶段）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-过程"><a href="#▉-过程" class="headerlink" title="▉ 过程"></a>▉ 过程</h6><blockquote><p><strong>1）</strong>调用 Generator 会返回一个指针对象（<strong>遍历器对象</strong> ），调用指针对象的的 next 方法，会移动指针的位置（异步任务的第一阶段），也就是指向遇到第一个 yield  的位置。 </p><p><strong>2）</strong>next 方法会返回一个当前阶段的对象，表示当前阶段的信息（value:当前阶段的值，yield：布尔值 ）表示 generator 是否执行完毕。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h6 id="▉-数据交换"><a href="#▉-数据交换" class="headerlink" title="▉ 数据交换"></a>▉ 数据交换</h6><blockquote><p>除了能够暂停、恢复之外，还可以作为函数体内外的数据交换。</p><p>1、不带有参数的 next 方法可以输出返回值。</p><p>2、带有参数的方法可以将参数作为上一阶段异步任务的返回结果，也就是输入。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><h6 id="▉-错误处理"><a href="#▉-错误处理" class="headerlink" title="▉ 错误处理"></a>▉ 错误处理</h6><blockquote><p>Generator 内部可以部署错误处理代码，捕获函数体外抛出的错误。</p><p>1、在函数外用指针的throw抛出的错误，被函数体内的  try … catch  代码块进行捕获。</p><p>2、实现了出错代码和处理错误的代码时间和空间上的分离。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw（<span class="string">'出错了'</span>）;</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><h6 id="▉-作用-1"><a href="#▉-作用-1" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>异步回调代码变成“同步”代码。</p></blockquote><h3 id="八、标准对象"><a href="#八、标准对象" class="headerlink" title="八、标准对象"></a>八、标准对象</h3><blockquote><p>总结一下，有这么几条规则需要遵守：</p></blockquote><ul><li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li><li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li><li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li><li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li><li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li><li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li><li>判断<code>null</code>请使用<code>myVar === null</code>；</li><li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li><li>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code>。</li></ul><blockquote><p>任何对象都有<code>toString()</code>方法吗？<code>null</code>和<code>undefined</code>就没有！确实如此，这两个特殊值要除外，虽然<code>null</code>还伪装成了<code>object</code>类型。</p></blockquote><h4 id="1、Date"><a href="#1、Date" class="headerlink" title="1、Date"></a>1、Date</h4><blockquote><p> JavaScript的 Date 对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure><h3 id="九、面向对象编程"><a href="#九、面向对象编程" class="headerlink" title="九、面向对象编程"></a>九、面向对象编程</h3><h4 id="1、继承设计思想"><a href="#1、继承设计思想" class="headerlink" title="1、继承设计思想"></a>1、继承设计思想</h4><h6 id="▉-js-的诞生"><a href="#▉-js-的诞生" class="headerlink" title="▉ js 的诞生"></a>▉ js 的诞生</h6><blockquote><p>为了让静态页面进行交互，设计一种语言完成不需要借助服务器完成的操作，如：表单验证。</p></blockquote><h6 id="▉-模仿其他-oop-进行设计"><a href="#▉-模仿其他-oop-进行设计" class="headerlink" title="▉  模仿其他 oop 进行设计"></a>▉  模仿其他 oop 进行设计</h6><blockquote><p>js 不像其他语言是面向对象语言有类的概念，为了能够即不引入类又能实现继承，所以 js 设计者模仿 oop 语言进行设计。</p><p>1、其他语言通过 new 来生成实例，所以 js 也通过 new 生成实例。</p><p>2、其他语言有类可以通过 new 来实现，js 并没有类，所以借助 new 构造函数来生成实例。</p><p>3、不同对象有不同的属性，也有相同的属性，对于每个对象相同的属性都需要在内存中开辟多个空间存储。能否使相同的属性只存一个呢？然后拥有该属性的对象都去引用它。</p></blockquote><h6 id="▉-prototype-属性"><a href="#▉-prototype-属性" class="headerlink" title="▉  prototype 属性"></a>▉  <strong>prototype</strong> 属性</h6><blockquote><p>我们就给构造函数设计一个 prototype 属性，用来存储不同对象相同的属性，共享的属性都存到这里边，不共享的属性就存放到构造函数中。其实 prototype 属性存储的就是一个对象，构造函数里边存放的都是变量，具体看变量和对象在内存中的引用。</p></blockquote><h6 id="▉-继承"><a href="#▉-继承" class="headerlink" title="▉  继承"></a>▉  继承</h6><blockquote><p>所有构造函数生成的对象都具有 prototype 对象里边的共享属性，就像是所有实例对象继承了 prototype 对象一样。</p></blockquote><h4 id="2、封装"><a href="#2、封装" class="headerlink" title="2、封装"></a>2、封装</h4><blockquote><p>其他语言因为有类的概念，对对象的封装是非常方便的，那么 js 是怎么封装对象的呢？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//猫对象</span></span><br><span class="line"><span class="keyword">var</span> Cat = &#123;</span><br><span class="line">    name : <span class="string">''</span>,</span><br><span class="line">    color : <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-原始模式"><a href="#▉-原始模式" class="headerlink" title="▉  原始模式"></a>▉  原始模式</h6><blockquote><p>下面简单的进行两个不同对象的封装，就会有两个问题：</p><p><strong>问题：</strong></p><p>1）生成多个实例对象写起来非常麻烦。</p><p>2）实例对象和原型对象之间没什么联系。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = &#123;&#125;; <span class="comment">// 创建一个空对象</span></span><br><span class="line">cat1.name = <span class="string">"大毛"</span>; <span class="comment">// 按照原型对象的属性赋值</span></span><br><span class="line">cat1.color = <span class="string">"黄色"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat2 = &#123;&#125;;</span><br><span class="line">cat2.name = <span class="string">"二毛"</span>;</span><br><span class="line">cat2.color = <span class="string">"黑色"</span>;</span><br></pre></td></tr></table></figure><h6 id="▉-原始模式改进"><a href="#▉-原始模式改进" class="headerlink" title="▉  原始模式改进"></a>▉  原始模式改进</h6><blockquote><p>用函数来解决代码重复的问题。</p><p><strong>问题：</strong></p><p>1）但是不能反映他们来自于同一个原型对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name:name,</span><br><span class="line">        color:color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成实例对象</span></span><br><span class="line"><span class="keyword">var</span> cat1 = Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = Cat(<span class="string">"二毛"</span>,<span class="string">"黑色"</span>);</span><br></pre></td></tr></table></figure><h6 id="▉-构造函数模式"><a href="#▉-构造函数模式" class="headerlink" title="▉  构造函数模式"></a>▉  构造函数模式</h6><blockquote><p>为了解决原型对象生成实例的问题，引入构造函数模式。</p><p>1）构造函数就是一个普通函数。</p><p>2）内部使用 this 变量，对构造函数使用 new 就能生成实例对象，内部的 this 指针就会指向实例对象。</p><p>3）每个实例对象都有 constructor 属性，并指向他们的构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.color=color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2）</span></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>,<span class="string">"黑色"</span>);</span><br><span class="line"><span class="comment">//3)</span></span><br><span class="line">alert(cat1.constructor == Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>问题：</strong></p><p>1）对于每个实例共享的属性，存在浪费内存的问题。</p></blockquote><h6 id="▉-原型模式（prototype-模式）"><a href="#▉-原型模式（prototype-模式）" class="headerlink" title="▉  原型模式（prototype 模式）"></a>▉  原型模式（prototype 模式）</h6><blockquote><p>每个构造函数都有一个 prototype 属性指向原型对象，我们将共享的属性存放到原型对象上，所有实例的共享属性其实都是同一个内存地址，指向<code>prototype</code>对象，因此就提高了运行效率。</p><p><strong>验证方法：</strong></p><p><strong>1）isPrototypeOf()</strong> ：验证实例与原型对象之间的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(Cat.prototype.isPrototypeOf(cat1)); //true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>2）hasOwnProperty()</strong>：判断某个属性来自本地还是原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>3）in运算符</strong>：判断某个实例是否拥有某个属性。以及遍历某个实例的所有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(&quot;name&quot; in cat1); // true</span><br><span class="line">&gt; for(var prop in cat1) &#123; alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2、原型继承"><a href="#2、原型继承" class="headerlink" title="2、原型继承"></a>2、原型继承</h4><h4 id="3、构造函数继承（五种）"><a href="#3、构造函数继承（五种）" class="headerlink" title="3、构造函数继承（五种）"></a>3、构造函数继承（五种）</h4><blockquote><p>两个构造函数。怎么让猫继承动物？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动物构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//猫的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第一种：构造函数的绑定"><a href="#▉-第一种：构造函数的绑定" class="headerlink" title="▉  第一种：构造函数的绑定"></a>▉  第一种：构造函数的绑定</h6><blockquote><p>用 call 或 apply 方法将父对象的构造函数绑定到子对象的构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//改变 this 的绑定</span></span><br><span class="line">    Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第二种：原型模式"><a href="#▉-第二种：原型模式" class="headerlink" title="▉  第二种：原型模式"></a>▉  第二种：原型模式</h6><blockquote><p>让猫构造函数的 prototype 等于 Animal 的实例，Animal 的实例拥有 Animal  的所有属性，所以相当于猫构造函数的 prototype 指向 Animal 实例了， 所有的猫的实例共享 Animal  里的属性了。</p><p>1) 每个实例都有 construct 属性，每个 prototype 也都有 construct 属性。</p><p>2）实例中的 construct 指向与 prototype 对象中 construct 指向同一个构造函数。也就是说改变 Cat 的原型对象之后，Cat 的实例对象 construct 属性指向的是 Animal 实例对象的 construct 属性，也就是 Animal 原型对象的 construct 属性，也就是构造函数 Animal 。</p><p>3）猫的实例对象是由 Cat 生成的，怎么能指向 Animal 呢，所以手动修改过来。</p><p>4）如果更换了 prototype对象 ，一定将 construct 属性修改过来。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><h6 id="▉-第三种：直接继承原型"><a href="#▉-第三种：直接继承原型" class="headerlink" title="▉  第三种：直接继承原型"></a>▉  第三种：直接继承原型</h6><blockquote><p>第二种方式的改进，跳过 Animal 的实例，直接将 Animal 的原型对象赋值给 Cat.prototype;</p><p><strong>优点：</strong>效率更高（不用执行和建立Animal的实例了 ）</p><p><strong>缺点：</strong><code>Cat.prototype</code> 和 <code>Animal.prototype</code> 现在指向了同一个对象，那么任何对 <code>Cat.prototype</code> 的修改，都会反映到 <code>Animal.prototype</code>。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = Animal.prototype;</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><h6 id="▉-第四种：空对象作为中介"><a href="#▉-第四种：空对象作为中介" class="headerlink" title="▉  第四种：空对象作为中介"></a>▉  第四种：空对象作为中介</h6><blockquote><p>对于第三种的缺点，第四种作为改进。F是空对象，所以几乎不占内存。 </p><p><strong>优点：</strong>修改Cat的prototype对象，就不会影响到Animal的prototype对象。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = Animal.prototype;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> F();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><p>将其封装成方法:</p><blockquote><p>这个 extend 函数，就是 YUI 库如何实现继承的方法。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　<span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">　　　　F.prototype = Parent.prototype;</span><br><span class="line">　　　　Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">　　　　Child.prototype.constructor = Child;</span><br><span class="line">　　　　Child.uber = Parent.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第五种：拷贝继承"><a href="#▉-第五种：拷贝继承" class="headerlink" title="▉  第五种：拷贝继承"></a>▉  第五种：拷贝继承</h6><blockquote><p>如果把父对象的 prototype 所有属性和方法，拷贝进子对象的 prototype 中 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> p = Parent.prototype;</span><br><span class="line">　　　　<span class="keyword">var</span> c = Child.prototype;</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　　　c[i] = p[i];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　c.uber = p;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h4 id="4、非构造函数继承"><a href="#4、非构造函数继承" class="headerlink" title="4、非构造函数继承"></a>4、非构造函数继承</h4><blockquote><p>让医生继承中国。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//父对象</span><br><span class="line">var Chinese = &#123;</span><br><span class="line">nation:&apos;中国&apos;</span><br><span class="line">&#125;;</span><br><span class="line">//子对象</span><br><span class="line">var Doctor =&#123;</span><br><span class="line">career:&apos;医生&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第一种：object-方法"><a href="#▉-第一种：object-方法" class="headerlink" title="▉  第一种：object()方法"></a>▉  第一种：object()方法</h6><blockquote><p>让中国成为医生的原型对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="▉-第二种：浅拷贝"><a href="#▉-第二种：浅拷贝" class="headerlink" title="▉  第二种：浅拷贝"></a>▉  第二种：浅拷贝</h6><blockquote><p>把父对象的属性，全部拷贝给子对象，也能实现继承。 拷贝继承分为浅拷贝和深拷贝。</p><p><strong>问题：</strong></p><p>1）如果父对象的属性等于数组或另一个对象，子对象获得的只是一个内存地址 ，子对象改变，父对象的属性也将改变。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function extendCopy(p) &#123;</span><br><span class="line">    var c = &#123;&#125;;</span><br><span class="line">    for (var i in p) &#123; </span><br><span class="line">    c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.uber = p;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第二种：深拷贝"><a href="#▉-第二种：深拷贝" class="headerlink" title="▉  第二种：深拷贝"></a>▉  第二种：深拷贝</h6><blockquote><p>弥补浅拷贝出现的问题，真正的将对象和数组及逆行拷贝，只要递归调用”浅拷贝”就行了 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　　　<span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">　　　　　　　　c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">　　　　　　　　deepCopy(p[i], c[i]);</span><br><span class="line">　　　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　　　　c[i] = p[i];</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> c;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><blockquote><p>jQuery库使用的就是这种继承方法。 </p></blockquote><h4 id="5、class-继承"><a href="#5、class-继承" class="headerlink" title="5、class 继承"></a>5、class 继承</h4><blockquote><p>class 的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用 class 的好处就是极大地简化了原型链代码。</p></blockquote><h3 id="十、浏览器"><a href="#十、浏览器" class="headerlink" title="十、浏览器"></a>十、浏览器</h3><h4 id="1、浏览器对象"><a href="#1、浏览器对象" class="headerlink" title="1、浏览器对象"></a>1、浏览器对象</h4><h6 id="▉-window"><a href="#▉-window" class="headerlink" title="▉ window"></a>▉ window</h6><blockquote><p><code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'window inner size: '</span> + <span class="built_in">window</span>.innerWidth + <span class="string">' x '</span> + <span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure><h6 id="▉-navigator"><a href="#▉-navigator" class="headerlink" title="▉ navigator"></a>▉ navigator</h6><blockquote><p><code>navigator</code>对象表示浏览器的信息，最常用的属性包括： </p></blockquote><ul><li>navigator.appName：浏览器名称；</li><li>navigator.appVersion：浏览器版本；</li><li>navigator.language：浏览器设置的语言；</li><li>navigator.platform：操作系统类型；</li><li>navigator.userAgent：浏览器设定的<code>User-Agent</code>字符串。</li></ul><h6 id="▉-screen"><a href="#▉-screen" class="headerlink" title="▉ screen"></a>▉ screen</h6><blockquote><p><code>screen</code>对象表示屏幕的信息，常用的属性有： </p></blockquote><ul><li>screen.width：屏幕宽度，以像素为单位；</li><li>screen.height：屏幕高度，以像素为单位；</li><li>screen.colorDepth：返回颜色位数，如8、16、24。</li></ul><h6 id="▉-location"><a href="#▉-location" class="headerlink" title="▉ location"></a>▉ location</h6><blockquote><p><code>location</code>对象表示当前页面的URL信息。 </p><p><strong>加载新页面：</strong>location.assign() 。</p><p><strong>重新加载：</strong>location.reload() 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</span></span><br><span class="line"><span class="comment">//可以用location.href获取</span></span><br><span class="line">location.protocol; <span class="comment">// 'http'</span></span><br><span class="line">location.host; <span class="comment">// 'www.example.com'</span></span><br><span class="line">location.port; <span class="comment">// '8080'</span></span><br><span class="line">location.pathname; <span class="comment">// '/path/index.html'</span></span><br><span class="line">location.search; <span class="comment">// '?a=1&amp;b=2'</span></span><br><span class="line">location.hash; <span class="comment">// 'TOP'</span></span><br></pre></td></tr></table></figure><h6 id="▉-document"><a href="#▉-document" class="headerlink" title="▉ document"></a>▉ document</h6><blockquote><p><code>document</code> 对象表示当前页面。由于 HTML 在浏览器中以 DOM 形式表示为树形结构，<code>document</code> 对象就是整个 DOM 树的根节点。 </p></blockquote><p><strong>Cookie</strong></p><blockquote><p>1) Cookie 是由服务器发送的 key-value 标示符。因为 HTTP 协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用 Cookie 来区分 。</p><p>2) 当一个用户成功登录后，服务器发送一个 Cookie 给浏览器，例如 <code>user=ABC123XYZ(加密的字符串)...</code>，此后，浏览器访问该网站时，会在请求头附上这个 Cookie，服务器根据 Cookie 即可区分出用户。<em>**</em></p><p><strong>安全性：</strong> </p><p>如果引入的第三方库存在恶意代码，则被第三方直接获取到用户登录信息。为了解决这个问题，服务器在设置 Cookie 的时候使用 <strong>httpOnly</strong>，设置的 Cookie 不能被 Javascript 读取。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie; <span class="comment">// 'v=123; remember=true; prefer=zh'</span></span><br></pre></td></tr></table></figure><h6 id="▉-history"><a href="#▉-history" class="headerlink" title="▉ history"></a>▉ history</h6><blockquote><p><code>history</code>对象保存了浏览器的历史记录，JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。 </p></blockquote><h4 id="2、操作-DOM"><a href="#2、操作-DOM" class="headerlink" title="2、操作 DOM"></a>2、操作 DOM</h4><h6 id="▉-更新-DOM"><a href="#▉-更新-DOM" class="headerlink" title="▉ 更新 DOM"></a>▉ 更新 DOM</h6><p><strong>1）<code>innerHtml</code>属性</strong></p><blockquote><p>修改文本。用<code>innerHTML</code>时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，<strong>要注意对字符编码来避免XSS攻击。</strong> </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC'</span>; <span class="comment">// &lt;p id="p-id"&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ'</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure><p><strong>2) 修改 innerText 或 textContent 属性</strong></p><blockquote><p>可以自动对字符串进行HTML编码，保证无法设置任何HTML标签： </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.innerText = <span class="string">'&lt;script&gt;alert("Hi")&lt;/script&gt;'</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br></pre></td></tr></table></figure><p><strong>3) 两者区别 </strong></p><blockquote><p>读取属性，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本。另外注意 <strong>IE &lt; 9</strong> 支持<code>textContent</code>。 </p></blockquote><p><strong>4）设置 CSS 样式 </strong></p><blockquote><p>DOM节点的<code>style</code>属性对应所有的 CSS 。CSS允许<code>font-size</code>这样的名称使用驼峰命名法（fontSize）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.style.fontSize = &apos;20px&apos;;</span><br></pre></td></tr></table></figure><h6 id="▉-插入-DOM"><a href="#▉-插入-DOM" class="headerlink" title="▉ 插入 DOM"></a>▉ 插入 DOM</h6><p><strong>1）使用 <code>appendChild</code> 把一个子节点添加到父节点的最后一个子节点。 </strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">    haskell.id = <span class="string">'haskell'</span>;</span><br><span class="line">    haskell.innerText = <span class="string">'Haskell'</span>;</span><br><span class="line">    list.appendChild(haskell);</span><br></pre></td></tr></table></figure><p><strong>2) insertBefore 插入指定位置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将子节点插入到 referenceElement 之前</span><br><span class="line">parentElement.insertBefore(newElement, referenceElement);</span><br></pre></td></tr></table></figure><h6 id="▉-删除-DOM"><a href="#▉-删除-DOM" class="headerlink" title="▉ 删除 DOM"></a>▉ 删除 DOM</h6><blockquote><p>parentElement () 得到删除节点的父节点，然后 removeChild() 删除节点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">'to-be-removed'</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">var</span> parent = self.parentElement;</span><br><span class="line"><span class="comment">// 删除:</span></span><br><span class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>1、删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 </p><p>2、parent.children[0] 删除节点的时候注意下标。</p></blockquote><h4 id="3、操作表单"><a href="#3、操作表单" class="headerlink" title="3、操作表单"></a>3、操作表单</h4><p>HTML表单的输入控件主要有以下几种： </p><ul><li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li><li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li><li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li><li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li><li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li><li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li></ul><h6 id="▉-获取值"><a href="#▉-获取值" class="headerlink" title="▉ 获取值"></a>▉ 获取值</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type="text" id="email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>);</span><br><span class="line">input.value; <span class="comment">// '用户输入的值'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;</span></span><br><span class="line">mon.value; <span class="comment">// '1'</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure><h6 id="▉-提交表单"><a href="#▉-提交表单" class="headerlink" title="▉ 提交表单"></a>▉ 提交表单</h6><p><strong>方法一：</strong></p><blockquote><p>响应一个 button 方法。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"doSubmitForm()"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 提交form:</span></span></span><br><span class="line"><span class="undefined">    form.submit();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><blockquote><p>onsubmit 事件。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"input-password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"md5-password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'input-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'md5-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line"><span class="undefined">    md5_pwd.value = toMD5(input_pwd.value);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="4、操作文件"><a href="#4、操作文件" class="headerlink" title="4、操作文件"></a>4、操作文件</h4><blockquote><p>在表单提交文件时，from 表单的 enctype  属性应该使用 <code>multipart/form-data</code>  不对文件数据进行编码才能上传，其他数据默认 <code>application/x-www-form-urlencoded</code>  编码再提交。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//input 的 ID</span><br><span class="line">var f = document.getElementById(&apos;test-file-upload&apos;);</span><br><span class="line">var filename = f.value; // &apos;C:\fakepath\test.png&apos;</span><br><span class="line">if (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) &#123;</span><br><span class="line">    alert(&apos;Can only upload image file.&apos;);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-File-API-操作文件"><a href="#▉-File-API-操作文件" class="headerlink" title="▉ File API 操作文件"></a>▉ File API 操作文件</h6><blockquote><p>HTML5的File API提供了 <code>File</code> 和 <code>FileReader</code> 两个主要对象，可以获得文件信息并读取文件。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">            fileInput = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-file'</span>),</span><br><span class="line">            info = <span class="built_in">document</span>.getElementById(<span class="string">'test-file-info'</span>),</span><br><span class="line">            preview = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-preview'</span>);</span><br><span class="line">            <span class="comment">// 监听change事件:</span></span><br><span class="line">            fileInput.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 清除背景图片:</span></span><br><span class="line">                preview.style.backgroundImage = <span class="string">''</span>;</span><br><span class="line">                <span class="comment">// 检查文件是否选择:</span></span><br><span class="line">                <span class="keyword">if</span> (!fileInput.value) &#123;</span><br><span class="line">                    info.innerHTML = <span class="string">'没有选择文件'</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取File引用:</span></span><br><span class="line">                <span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 获取File信息:</span></span><br><span class="line">                info.innerHTML = <span class="string">'文件: '</span> + file.name + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                                <span class="string">'大小: '</span> + file.size + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                                <span class="string">'修改: '</span> + file.lastModifiedDate;</span><br><span class="line">                <span class="keyword">if</span> (file.type !== <span class="string">'image/jpeg'</span> &amp;&amp; file.type !== <span class="string">'image/png'</span> &amp;&amp; file.type !== <span class="string">'image/gif'</span>) &#123;</span><br><span class="line">                    alert(<span class="string">'不是有效的图片文件!'</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 读取文件:</span></span><br><span class="line">                <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">                <span class="comment">//异步操作的回调函数</span></span><br><span class="line">                reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span></span><br><span class="line">                        data = e.target.result; <span class="comment">// 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            </span></span><br><span class="line">                    preview.style.backgroundImage = <span class="string">'url('</span> + data + <span class="string">')'</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 以DataURL的形式读取文件:(异步操作)</span></span><br><span class="line">                reader.readAsDataURL(file);</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h4 id="5、AJAX"><a href="#5、AJAX" class="headerlink" title="5、AJAX"></a>5、AJAX</h4><blockquote><p>需要注意的几点：</p><p>1、通过检测<code>window</code>对象是否有<code>XMLHttpRequest</code>属性来确定浏览器是否支持标准的<code>XMLHttpRequest</code> </p><p>2、先设置<code>onreadystatechange</code>的回调函数。在回调函数中，通常我们只需通过<code>readyState === 4</code>判断请求是否完成 </p><p>3、<code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数，分别为请求方式、URL地址、是否使用异步。</p><p>4、send 发送，Get 不需要参数，Post 需要把 body 部分以字符串或者 FormData 对象传进去。</p><p>关于 FromData 请查看：<a href="https://wangdoc.com/javascript/bom/form.html#formdata-%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">FormData</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = <span class="string">'Error code: '</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">//现代浏览器</span></span><br><span class="line">    request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//低版本 IE 浏览器</span></span><br><span class="line">    request = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</span><br></pre></td></tr></table></figure><h4 id="6、Cookie"><a href="#6、Cookie" class="headerlink" title="6、Cookie"></a>6、Cookie</h4><h6 id="▉-定义-1"><a href="#▉-定义-1" class="headerlink" title="▉ 定义"></a>▉ 定义</h6><blockquote><p>1）概念：Cookie 小段文本信息，存储于计算机硬盘中，大小只有 4 k。</p><p>2）特点：每个 Cookie 文件都对应一个域名，同一域名下的所以页面可以共享 Cookie，不能跨域名访问。</p><p>3）使用：通常从 document 中提取 cookie 属性提供给 javascript，然后进行创建或发送 cookie 到服务器。</p></blockquote><h6 id="▉-作用-2"><a href="#▉-作用-2" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>cookie 是存在用户硬盘中，用户每次访问站点时，Web应用程序都可以读取 Cookie 包含的信息。当用户再次访问这个站点时，<strong>浏览器就会在本地硬盘上查找与该 URL 相关联的 <code>Cookie</code></strong>。如果该 Cookie 存在，浏览器就将它添加到 <code>request header</code> 的 <code>Cookie</code> 字段中，与 <code>http请求</code> 一起发送到该站点。 </p></blockquote><h6 id="▉-缺点"><a href="#▉-缺点" class="headerlink" title="▉ 缺点"></a>▉ 缺点</h6><ul><li>安全性：由于cookie在HTTP中是明文传递的，其中包含的数据都可以被他人访问，可能会被篡改、盗用。</li><li>大小限制：cookie的大小限制在4KB左右，若要做大量存储显然不是理想的选择。</li><li>增加流量：cookie每次请求都会被自动添加到Request Header中，无形中增加了流量。cookie信息越大，对服务器请求的时间也越长。</li></ul><h6 id="▉-用途"><a href="#▉-用途" class="headerlink" title="▉ 用途"></a>▉ 用途</h6><blockquote><p>Cookie 一般用于保存网页访问者的信息。</p><p>1）保存用户登录信息。在一些登录网站选择下次自动登录，登录成功后，后台对用户名和密码进行加密返回数据，客户端就会将数据存储到 Cookie 中。当用户下一次进行登录时，判断 Cookie 中否存在值，存在则将Cookie 信息加到 HTTP 头部发送到服务器，实现自动登录。</p><p>2）创建购物车。通常将选择的物品放入 Cookie 中，同一域名下页面实现 Cookie 共享，提交订单将 Cookie 传到后台。</p><p>3）跟踪用户。用 Cookie 记录用户的偏好信息，然后推广小广告，在侧边栏经常是我们之前搜索过的内容。</p></blockquote><h6 id="▉-其他存储机制"><a href="#▉-其他存储机制" class="headerlink" title="▉ 其他存储机制"></a>▉ 其他存储机制</h6><blockquote><p><strong>1）web存储机制 </strong> </p><ul><li>sessionStorage：用于一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除 </li><li>localStorage ：用于跨会话持久化地存储数据。</li></ul><p><strong>2）indexedDB </strong></p><ul><li>是 indexed Database API 的简称，是在浏览器中保存结构化数据的一种「数据库」，它类似SQL数据库的结构化数据存储机制 ， 它能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。 </li></ul></blockquote><h4 id="7、-同源跨域问题"><a href="#7、-同源跨域问题" class="headerlink" title="7、 同源跨域问题"></a>7、 同源跨域问题</h4><p>请查看另一篇：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript 的重点学习路线完整篇。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Webpack成神之路之插件配置【CSS 图片处理_08】</title>
    <link href="http://yoursite.com/2019/05/08/Webpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90CSS%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86_08%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/08/Webpack成神之路之插件配置【CSS图片处理_08】/</id>
    <published>2019-05-08T08:25:02.150Z</published>
    <updated>2019-05-09T06:52:09.523Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>webpack 处理 CSS 中的图片！</p><a id="more"></a> <h2 id="01-CSS-中的图片处理"><a href="#01-CSS-中的图片处理" class="headerlink" title="01|CSS 中的图片处理"></a>01|CSS 中的图片处理</h2><h4 id="1、图片准备"><a href="#1、图片准备" class="headerlink" title="1、图片准备"></a>1、图片准备</h4><blockquote><p>通常我们保存的图片早 <code>src</code> 中的 <code>images</code> 文件夹下。</p></blockquote><h4 id="2、安装解析图片的-loader"><a href="#2、安装解析图片的-loader" class="headerlink" title="2、安装解析图片的 loader"></a>2、安装解析图片的 loader</h4><blockquote><p>1）当我们直接用 <code>webpack</code> 命令时，就会报错，报错的原因就是无法解析 <code>CSS</code> 中的图片。之前解析 <code>CSS</code> 文件使用的 <code>loader</code> ，所以我们要添加专门解析图片用的 <code>loader</code>。</p><p>2）<code>webpack</code> 打包将各个模块打包成一个文件，所以我们的样式文件 <code>url</code> 是相对于 <code>CSS</code> 文件的，当我们打包成一个文件，<code>url</code>  的路径是相对于 <code>html</code> 而言的，导致原来的 <code>css</code> 文件引入的路径就会导致找不到原来的图片位置。</p><p>3）图片过多，导致有很多的 http 请求，降低页面的性能。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br></pre></td></tr></table></figure><ul><li><strong>file-loader：</strong>这个模块主要解决上述 （2）的问题。<code>file-loader</code> 可以解析项目中的 <code>ur</code> l引入（不仅限于 <code>css</code> ），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。</li><li><strong>url-loader：</strong>这个模块主要解决上述 （3）的问题。<code>url-loader</code> 会将引入的图片编码，生成 <code>dataURl</code>。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此 <code>url-loader</code> 提供了一个 <code>limit</code> 参数，小于 <code>limit</code> 字节的文件会被转为 <code>DataURl</code>，大于 <code>limit</code> 的还会使用 <code>file-loader</code> 进行 <code>copy</code>.。</li></ul><h4 id="3、配置-loader"><a href="#3、配置-loader" class="headerlink" title="3、配置 loader"></a>3、配置 loader</h4><blockquote><ul><li><code>test:/.(png|jpg|gif)/：</code>是匹配图片文件后缀名称。</li><li><code>use：</code>是指定使用的 <code>loader</code> 和 <code>loader</code> 的配置参数。</li><li><code>imit：</code>是把小于 <code>500000B</code> 的文件打成 <code>Base64</code> 的格式，写入JS。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpg|gif)/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        limit: <span class="number">500000</span>,</span><br><span class="line">                        outputPath:<span class="string">'images/'</span>, <span class="comment">// 将图片放到规定的目录下</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125; </span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="4、url-loader-和-file-loader-的关系"><a href="#4、url-loader-和-file-loader-的关系" class="headerlink" title="4、url-loader 和 file-loader 的关系"></a>4、url-loader 和 file-loader 的关系</h4><blockquote><p><code>url-loader</code>封装了 <code>file-loader</code>，配置中的 <code>limit</code> ，<code>url-loader</code> 会调用  <code>file-loader</code>进行处理。</p></blockquote><h2 id="02-CSS分离与图片路径处理"><a href="#02-CSS分离与图片路径处理" class="headerlink" title="02|CSS分离与图片路径处理"></a>02|CSS分离与图片路径处理</h2><blockquote><p>1）把 <code>CSS</code> 从J <code>avasScript</code> 代码中分离出来 。</p><p>2）如何处理分离出来后 <code>CSS</code> 中的图片路径不对问题 。</p></blockquote><h4 id="1、CSS-分离"><a href="#1、CSS-分离" class="headerlink" title="1、CSS 分离"></a>1、CSS 分离</h4><blockquote></blockquote><h4 id="2、安装插件（extract-text-webpack-plugin）"><a href="#2、安装插件（extract-text-webpack-plugin）" class="headerlink" title="2、安装插件（extract-text-webpack-plugin）"></a>2、安装插件（extract-text-webpack-plugin）</h4><blockquote><p>注意版本号，我 webpack3.0 使用的是 2.0.1 版本的插件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin@<span class="number">2.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h4 id="3、配置文件"><a href="#3、配置文件" class="headerlink" title="3、配置文件"></a>3、配置文件</h4><blockquote><p>1）引入插件。</p><p>2）new 出插件对象。</p><p>3）修改 <code>style-loader</code> 和 <code>css-loader</code>。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> extractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>); </span><br><span class="line"><span class="comment">// 此路径是分离的 CSS 文件路径</span></span><br><span class="line"><span class="keyword">new</span> extractTextPlugin(<span class="string">"/css/index.css"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">        use:extractTextPlugin.extract(&#123;</span><br><span class="line">            fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">            use: <span class="string">"css-loader"</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="4、路径失效问题"><a href="#4、路径失效问题" class="headerlink" title="4、路径失效问题"></a>4、路径失效问题</h4><h2 id="03-处理-HTML-中的图片"><a href="#03-处理-HTML-中的图片" class="headerlink" title="03|处理 HTML 中的图片"></a>03|处理 HTML 中的图片</h2><blockquote><p>通常我们会在 HTML 中引入图片，需要对 HTML 中的图片进行打包。</p></blockquote><h4 id="1、安装-Loader"><a href="#1、安装-Loader" class="headerlink" title="1、安装 Loader"></a>1、安装 Loader</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br></pre></td></tr></table></figure><h4 id="2、配置-Loader"><a href="#2、配置-Loader" class="headerlink" title="2、配置 Loader"></a>2、配置 Loader</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(htm|html)$/i</span>,</span><br><span class="line">     use:[ <span class="string">'html-withimg-loader'</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack 处理 CSS 中的图片！&lt;/p&gt;
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/webpack/"/>
    
    
      <category term="前端工具" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【CSS 常用布局】</title>
    <link href="http://yoursite.com/2019/05/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90CSS%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/06/前端面试之道【CSS常用布局】/</id>
    <published>2019-05-05T23:43:01.094Z</published>
    <updated>2019-05-06T00:09:13.321Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CSS 中常用的几种布局方式！</p><a id="more"></a><h2 id="三种最基本的布局方式"><a href="#三种最基本的布局方式" class="headerlink" title="三种最基本的布局方式"></a>三种最基本的布局方式</h2><h3 id="1、流式布局"><a href="#1、流式布局" class="headerlink" title="1、流式布局"></a>1、流式布局</h3><blockquote><p>流动布局模型就是<strong>默认的</strong>网页布局模式。</p></blockquote><ul><li><strong>块级元素</strong>都会在所处的最近父级容器元素内<strong>自上而下</strong>按顺序垂直顺延分布，块元素的宽度一般为 100%，也就是父元素的宽度。</li><li><strong>内联元素</strong>一般<strong>从左到右</strong>依次分布显示。</li></ul><h3 id="2、浮动布局"><a href="#2、浮动布局" class="headerlink" title="2、浮动布局"></a>2、浮动布局</h3><blockquote><p>流式布局的元素基本都是在整个文档流中的，如果使用浮动布局，需要给某一元素设置浮动属性，脱离当前文档流。</p></blockquote><h3 id="3、层级布局"><a href="#3、层级布局" class="headerlink" title="3、层级布局"></a>3、层级布局</h3><blockquote><p>层级布局指的是通过<strong>相对定位</strong>以及<strong>绝对定位</strong>以及<strong>固定定位</strong>的方式来进行布局。</p><p>1）通过设置 top、left、right、bottom 来记性定位元素。</p><p>2）缺点：对于相应式的布局，该布局方式还有很多不便之处。</p></blockquote><ul><li><strong>fixed 定位：</strong>固定定位，相对于浏览器窗口进行定位，不随窗口滚动，可以和其他元素重叠，不占据空间。</li><li><strong>relative 定位：</strong>相对定位，相对于正常位置进行定位，原本的空间不会改变。</li><li><strong>absolute 定位：</strong>绝对定位，是相对于已经定位的父元素进行定位，如果没有父元素，就相当于 <code>&lt;html&gt;</code> ，不占据任何空间，定位元素可以和其他元素进行重叠。</li></ul><h2 id="弹性布局（Flex）"><a href="#弹性布局（Flex）" class="headerlink" title="弹性布局（Flex）"></a>弹性布局（Flex）</h2><h2 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h2><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><h2 id="两种自适应布局"><a href="#两种自适应布局" class="headerlink" title="两种自适应布局"></a>两种自适应布局</h2><h3 id="1、双飞翼布局"><a href="#1、双飞翼布局" class="headerlink" title="1、双飞翼布局"></a>1、双飞翼布局</h3><h3 id="2、圣杯布局"><a href="#2、圣杯布局" class="headerlink" title="2、圣杯布局"></a>2、圣杯布局</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 中常用的几种布局方式！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【盒模型】</title>
    <link href="http://yoursite.com/2019/05/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E7%9B%92%E6%A8%A1%E5%9E%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/06/前端面试之道【盒模型】/</id>
    <published>2019-05-05T23:12:51.565Z</published>
    <updated>2019-05-05T23:42:55.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>盒模型相关知识点！</p><a id="more"></a><h2 id="css-盒模型"><a href="#css-盒模型" class="headerlink" title="css 盒模型"></a>css 盒模型</h2><h3 id="一、盒模型的分类"><a href="#一、盒模型的分类" class="headerlink" title="一、盒模型的分类"></a>一、盒模型的分类</h3><blockquote><p>IE 盒模型和 W3C 标准盒模型。</p></blockquote><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><blockquote><p>一个盒子模型是由 外边距（margin）、边框（border）、内边距（padding）、内容（content）四部分组成的。</p></blockquote><h4 id="IE-盒模型"><a href="#IE-盒模型" class="headerlink" title="IE 盒模型"></a>IE 盒模型</h4><blockquote><p>盒子的属性 <code>width</code>  和 <code>height</code> 指的是 <code>content + padding + border</code>。</p></blockquote><h4 id="W3C-标准盒模型"><a href="#W3C-标准盒模型" class="headerlink" title="W3C 标准盒模型"></a>W3C 标准盒模型</h4><blockquote><p>盒子的属性 <code>width</code>  和 <code>height</code> 指的是 <code>content</code>。</p></blockquote><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><blockquote><p>1）只有在 IE8 + 版本中可以通过 <code>box-sizing（centent-box 标准盒模型/border-sizing IE 盒模型）</code> 切换 IE 盒模型和 W3C 标准盒模型。其他浏览器需要加上前缀。</p><p>2）在 IE6、IE7、IE8 中添加 <code>&lt;!DOCTYPE&gt;</code> 就会使用 <code>W3C</code> 标准盒模型。否则出现不同浏览器兼容性问题（IE浏览器会将盒子模型解释为 IE 盒子模型，FireFox等会将其解释为 W3C 盒子模型）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;盒模型相关知识点！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【网络攻击】</title>
    <link href="http://yoursite.com/2019/05/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/02/前端面试之道【网络攻击】/</id>
    <published>2019-05-02T12:21:03.578Z</published>
    <updated>2019-05-04T03:09:38.879Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常见的网络攻击！</p><a id="more"></a><h2 id="一、XSS-攻击"><a href="#一、XSS-攻击" class="headerlink" title="一、XSS 攻击"></a>一、XSS 攻击</h2><h4 id="1、XSS-是什么"><a href="#1、XSS-是什么" class="headerlink" title="1、XSS 是什么"></a>1、XSS 是什么</h4><blockquote><p>XSS 攻击称为跨站脚本攻击，是一种代码注入的攻击。攻击者通过向目标网站注入恶意脚本，使之在浏览器中运行。利用脚本获取到用户的信息。</p></blockquote><p>XSS 常见几种注入方法：</p><ul><li>以 javascript 标签的形式注入。</li><li>在内联 javascript 中，拼接的数据突破了原本的限制（字符串、变量等）</li><li>在属性标签中，恶意内容包含引号，突破属性值的限制，注入其他属性。</li><li>在标签的 href、src 等属性中，包含 js 可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制的代码。</li></ul><h4 id="2、XSS-攻击的分类"><a href="#2、XSS-攻击的分类" class="headerlink" title="2、XSS 攻击的分类"></a>2、XSS 攻击的分类</h4><ul><li>存储型 XSS</li><li>反射型 XSS</li><li>DOM型 XSS</li></ul><h5 id="▉-存储型-XSS"><a href="#▉-存储型-XSS" class="headerlink" title="▉ 存储型 XSS"></a>▉ 存储型 XSS</h5><blockquote><p>最危险的一种跨站脚本攻击，危害比反射性和DOM型都要大，因为不需要用户手动触发。<strong>恶意代码存储在数据库中</strong>。</p></blockquote><p>1）攻击者将恶意代码提交至目标网站的数据库中。</p><p>2）用户打开网站，网站将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</p><p>3）浏览器将服务器返回的 HTML 进行解析，恶意代码被执行。</p><p>4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。</p><h5 id="▉-反射型-XSS"><a href="#▉-反射型-XSS" class="headerlink" title="▉ 反射型 XSS"></a>▉ 反射型 XSS</h5><blockquote><p>需要用户主动打开 URL 。<strong>恶意代码存储在 URL 中</strong>。常见的用于 URL 传递参数的功能，如：网站搜索、跳转等。</p></blockquote><p>1）攻击者伪造包含恶意代码的URL。</p><p>2）用户打开恶意的URL，服务端将恶意的 <code>URL</code> 代码取出拼接在<code>HTML</code> 后返回给浏览器。</p><p>3）用户浏览器解析请求，恶意代码得到执行。</p><p>4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。</p><h5 id="▉DOM-型-XSS"><a href="#▉DOM-型-XSS" class="headerlink" title="▉DOM 型 XSS"></a>▉DOM 型 XSS</h5><blockquote><p>DOM 型 XSS 攻击中，取出和执行<strong>恶意代码由浏览器端完成</strong>，属于前端 <code>JavaScript</code> 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 </p></blockquote><p>1）攻击者伪造包含恶意代码的 <code>URL</code>。</p><p>2）用户打开恶意的 <code>URL</code>。</p><p>3）前端 <code>Javascript</code> 取出 <code>URL</code> 中的恶意代码<strong>由浏览器完成</strong>，属于前端 <code>javascript</code> 自身的安全漏洞，触发XSS <strong>靠的是浏览器端的DOM解析</strong> 。</p><p>4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。</p><h4 id="3、防御-XSS"><a href="#3、防御-XSS" class="headerlink" title="3、防御 XSS"></a>3、防御 XSS</h4><h5 id="▉-常用的防御方法"><a href="#▉-常用的防御方法" class="headerlink" title="▉ 常用的防御方法"></a>▉ 常用的防御方法</h5><blockquote><p>一般页面输入的地方会存在 XSS 攻击的危险。</p></blockquote><ul><li><strong>httpOnly:</strong> 在 <code>cookie</code> 中设置 <code>HttpOnly</code> 属性后，js 脚本无法读取到 <code>Cookie</code> 信息。</li><li><strong>输入过滤：</strong>用于对输入格式的检查（邮箱、电话号码等）。前后台多要进行过滤检查，因为攻击者完全可以绕过前端直接利用接口对后端发送设置。</li><li><strong>白名单：</strong>名单控制允许的 <code>HTML</code>标签及各标签的属性 。</li><li><strong>转义 HTML：</strong>如果拼接 <code>HTML</code> 是必要的，对于引号，尖括号，斜杠进行转义（可以借助转义库）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">'&amp;#96;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2F;'</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="▉-预防存储型和反射性-XSS-攻击"><a href="#▉-预防存储型和反射性-XSS-攻击" class="headerlink" title="▉ 预防存储型和反射性 XSS 攻击"></a>▉ 预防存储型和反射性 XSS 攻击</h5><blockquote><p>这两种攻击一般在服务器端取出恶意代码，拼接到 <code>HTML</code> 中，然后被浏览器所执行。</p></blockquote><p><strong>1、改成纯前端渲染，使代码和数据分离。</strong></p><blockquote><p><strong>作用：</strong>明确告诉浏览器，要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了 。</p><p><strong>缺点：</strong>需要避免 DOM 型的 XSS 攻击。</p><p>1）浏览器先加载一个静态 <code>HTML</code>，此 <code>HTML</code> 中不包含任何跟业务相关的数据。</p><p>2）然后浏览器执行 <code>HTML</code> 中的 <code>JavaScript</code>。</p><p>3）<code>JavaScript</code> 通过 <code>Ajax</code> 加载业务数据，调用 <code>DOM API</code> 更新到页面上 </p></blockquote><p><strong>2、对 HTML 做充分的转义。</strong></p><blockquote><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题,这时就需要对HTML进行充分的转义。 </p></blockquote><h5 id="▉-预防-DOM-型-XSS-攻击"><a href="#▉-预防-DOM-型-XSS-攻击" class="headerlink" title="▉ 预防 DOM 型 XSS 攻击"></a>▉ 预防 DOM 型 XSS 攻击</h5><blockquote><p>由于前端的 javascript 代码本身不够严谨，把不可信的数据当做代码执行了。</p></blockquote><p><strong>1、HTML 插入数据</strong></p><blockquote><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等 </p></blockquote><p><strong>2、DOM 内联监听</strong></p><blockquote><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;</span><br><span class="line">&lt;img onclick=<span class="string">"UNTRUSTED"</span> onerror=<span class="string">"UNTRUSTED"</span> src=<span class="string">"data:image/png,"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 链接内包含恶意代码 --&gt;</span><br><span class="line">&lt;a href=<span class="string">"UNTRUSTED"</span>&gt;<span class="number">1</span>&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ setTimeout()/</span>setInterval() 中调用恶意代码</span><br><span class="line">setTimeout(<span class="string">"UNTRUSTED"</span>)</span><br><span class="line">setInterval(<span class="string">"UNTRUSTED"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// location 调用恶意代码</span></span><br><span class="line">location.href = <span class="string">'UNTRUSTED'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eval() 中调用恶意代码</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"UNTRUSTED"</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、CSRF-跨站请求伪造"><a href="#二、CSRF-跨站请求伪造" class="headerlink" title="二、CSRF 跨站请求伪造"></a>二、CSRF 跨站请求伪造</h2><h3 id="2-1-跨站请求伪造（CSRF）"><a href="#2-1-跨站请求伪造（CSRF）" class="headerlink" title="2.1 跨站请求伪造（CSRF）"></a>2.1 跨站请求伪造（CSRF）</h3><blockquote><p>跨站伪造请求（Cross-site request forgery ），缩写为 CSRF。冒充用户发起请求（在用户不知情的情况下）， 完成一些违背用户意愿的事情（如修改用户信息，删初评论等）。 </p></blockquote><h4 id="1、攻击原理"><a href="#1、攻击原理" class="headerlink" title="1、攻击原理"></a>1、攻击原理</h4><blockquote><p>攻击者通过技术手段欺骗用户的浏览器去访问一个曾经认证过的网站，所以用户不用进行重新认证，这是一个用户身份验证的一个漏洞：<strong>简单身份认证只保证请求来自某个用户的浏览器，确不能保证请求的本身是用户自愿发出的。</strong>攻击者诱导用户在刚访问不久的网站中点击设定的链接（本页的论坛、博客等自动生成的链接内容）。</p></blockquote><h4 id="2、防御措施"><a href="#2、防御措施" class="headerlink" title="2、防御措施"></a>2、防御措施</h4><h6 id="▉-检查-Referer-字段"><a href="#▉-检查-Referer-字段" class="headerlink" title="▉ 检查 Referer 字段"></a>▉ 检查 Referer 字段</h6><blockquote><p>HTTP 头有一个 <code>Referer</code> 字段，用来标记请求来源于哪个地址。<code>Referer</code> 字段应和请求的地址位于同一域名下。 服务器在处理请求的时候，可以判断该字段是否位于正确的源地址下发送的请求。如果是 CSRF 攻击，该字段会包含恶意的网址。</p><p><strong>局限性：</strong>设置 <code>Referer</code> 有本身的局限性，攻击者可以篡改 <code>Referer</code> 字段来达到攻击的目的。</p></blockquote><h6 id="▉-Token-验证"><a href="#▉-Token-验证" class="headerlink" title="▉  Token 验证"></a>▉  Token 验证</h6><blockquote><p>CSRF 的本质是在于攻击者欺骗自己去访问设置的地址，如果在请求数据的时候，用户不把信息保存到浏览器的 <code>Cookie</code> 中，那么攻击者无法获取数据校验，从而不能进行 CSRF 攻击。</p></blockquote><ul><li><strong>第一步：</strong>后端随机产生一个 <code>token</code>，把这个 <code>token</code> 保存到 <code>session</code> 状态中；同时后端把这个 <code>token</code> 交给前端页面；</li><li><strong>第二步：</strong>前端页面提交请求时，把 <code>token</code> 加入到请求数据或者头信息中，一起传给后端；</li><li><strong>第三步：</strong>端验证前端传来的 <code>token</code> 与 <code>session</code> 是否一致，一致则合法，否则是非法请求。</li></ul><h2 id="四、DNS-攻击"><a href="#四、DNS-攻击" class="headerlink" title="四、DNS 攻击"></a>四、DNS 攻击</h2><h4 id="1、什么是-DNS-攻击？"><a href="#1、什么是-DNS-攻击？" class="headerlink" title="1、什么是 DNS 攻击？"></a>1、什么是 DNS 攻击？</h4><blockquote><p>利用 DNS（域名系统）中的漏洞，发起 DNS 攻击。</p></blockquote><h6 id="▉-DNS-的工作原理"><a href="#▉-DNS-的工作原理" class="headerlink" title="▉ DNS 的工作原理"></a>▉ DNS 的工作原理</h6><blockquote><p>将用户输入的域名转换成相对应的 IP 地址。</p></blockquote><ul><li>DNS 首先搜索缓存中是否存在该域名的 IP 地址。</li><li>如果找不到该域名的地址，就到 DNS 服务器查找该域名准确的 IP 地址。</li><li>DNS 一直循环工作，DNS 服务器之间可以相互查询到域名的 IP 地址的DNS 服务器。</li><li>DNS 一旦找到 IP 地址，就将当前的 IP 地址返回给请求的程序，将其存储缓存中。</li></ul><h6 id="▉-如何利用-DNS-攻击"><a href="#▉-如何利用-DNS-攻击" class="headerlink" title="▉ 如何利用 DNS 攻击"></a>▉ 如何利用 DNS 攻击</h6><blockquote><p>1）DNS 不太注重安全问题，所以容易被攻击者发起 DNS 攻击。攻击者利用一种方式来用恶意的 IP 地址替换 DNS 解析的域名的 IP 地址，那么用户发送的数据发送到这个攻击者替换的 IP 假地址中去。</p><p>2）DNS 服务器配置不记得它的默认配置，所以利用这一漏洞进行攻击。</p></blockquote><h6 id="▉-DNS-的攻击类型"><a href="#▉-DNS-的攻击类型" class="headerlink" title="▉ DNS 的攻击类型"></a>▉ DNS 的攻击类型</h6><ul><li><strong>零日攻击：</strong>利用 DNS 服务器软件和协议堆栈中未知的漏洞。</li><li><strong>Fast Flux DNS ： </strong>以高频率交换 DNS 记录以重定向 DNS 请求，也有利于攻击者避免检测。</li><li><strong>DNS 欺骗：</strong>攻击者通过用服务器缓存中的伪造 IP 地址替换授权的 IP 地址来破坏整个DNS服务器。通过这种方式，他们将整个流量重定向到恶意网站并收集重要信息。 </li></ul><h2 id="五、DDOS-攻击"><a href="#五、DDOS-攻击" class="headerlink" title="五、DDOS 攻击"></a>五、DDOS 攻击</h2><blockquote><p>DDoS 攻击称为<strong>分布式拒绝服务攻击</strong>。 通过多台计算机对 DNS 服务器发送大量的请求，达到目标的 DNS 服务器无法进行正常队请求进行解析回应的目的。DDoS 攻击可能导致整个 DNS 服务器崩溃并使用户无法访问 Web。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的网络攻击！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之题型篇【查找和排序】</title>
    <link href="http://yoursite.com/2019/05/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A2%98%E5%9E%8B%E7%AF%87%E3%80%90%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/02/数据结构与算法之题型篇【查找和排序】/</id>
    <published>2019-05-02T10:57:10.751Z</published>
    <updated>2019-05-04T08:37:35.439Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据结构与算法中所必会的查找和排序算法。</p><a id="more"></a><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><h2 id="一、查找和排序的基础练习（阶段一）"><a href="#一、查找和排序的基础练习（阶段一）" class="headerlink" title="一、查找和排序的基础练习（阶段一）"></a>一、查找和排序的基础练习（阶段一）</h2><h2 id="二、查找和排序的进阶练习（阶段二）"><a href="#二、查找和排序的进阶练习（阶段二）" class="headerlink" title="二、查找和排序的进阶练习（阶段二）"></a>二、查找和排序的进阶练习（阶段二）</h2><h3 id="1、旋转数组的最小数字"><a href="#1、旋转数组的最小数字" class="headerlink" title="1、旋转数组的最小数字"></a>1、旋转数组的最小数字</h3><blockquote><p>题目：把一个数组最开始的若干个元素搬移到数组的尾部，称为旋转数组。输入一个递增排序的数组的一个旋转，输出旋转数组中最小的值。</p></blockquote><h4 id="1-1-问题分析与解决"><a href="#1-1-问题分析与解决" class="headerlink" title="1.1 问题分析与解决"></a>1.1 问题分析与解决</h4><h6 id="▉-问题分析"><a href="#▉-问题分析" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><blockquote><p>1）最先想到的方法是暴力破解法，能否遍历整个数组，得出最小值呢？</p><p>2）暴力破解法时间复杂度太高，是否还有其他方法减少时间复杂度呢？查找一个数据，我们想到的方法是二分查找，但是二分查找是查找一个给定值的数据。能够自己改进一下，借助二分查找的思想呢？</p><p>我们发现旋转数组是由两个升序的数组组成的，最小值的位置是在第一个升序数组的后边，第二个数组的最大值小于第一个升序数组中最小值的，我们发现是有规律可循的。</p></blockquote><h6 id="▉-算法思路"><a href="#▉-算法思路" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote><p>暴力破解法：</p><p>1）遍历整个数组，找出数组中的最小值。</p><p>二分查找法：</p><p>1）首先声明两个指针分别指向数组的起始位置和终止位置，取中间元素 mid。</p><p>2）判断当前数据 mid 和起始指针的大小，如果大于<strong>起始指针</strong>（或等于），说明这个中间数据一定是第一个数组中的值。那数组中的最小值一定在该数字的后边。</p><p>3）判断当前数据 mid 和起始指针的大小，如果小于<strong>终止指针</strong>（或等于），说明这个中间数据一定是第二个数组中的值。那数组中的最小值一定在该数字的前边。</p><p>4）我们把指针指向中间元素，将搜索范围缩小到原来的一半了，循环以上过程。</p><p>5）那么终止条件是什么呢？我们不断的缩小范围，我们会发现，起始指针和终止指针最终相邻，起始指针会指向数组的最后一个元素，终止指针会指向第二个数组的起始元素。那么终止指针指向的就是我们要查找的最小值。（之所以两个指针最后相邻，是因为我们不断你的在第一个或第二个数组中移动起始或终止指针，该指针永远不会越界指向超出本身数组的值）</p></blockquote><h6 id="▉-边界条件"><a href="#▉-边界条件" class="headerlink" title="▉ 边界条件"></a>▉ 边界条件</h6><blockquote><p>虽然我们上述的算法思路可以实现，但是有几个特殊情况需要处理一下：</p><p>1）如果数组中有重复的值，上述的方法不再适用。假如三个数组{11101} 是 {01111}的旋转数组，那么起始指针与终止指针以及中间元素相等，无法再用之前的判断，此时遇到这种情况需要遍历当前数组。</p><p>2）向后移动 0 个元素也算是一个旋转数组呀，相当于数组本身。此时需要判断数组的最后一个元素是否大于第一个元素，如果是这种情况，那就说明旋转数组就是本身。</p></blockquote><h6 id="▉-测试用例"><a href="#▉-测试用例" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote><p>1）空数组</p><p>2）原数组</p><p>3）重复元素的数组</p><p>4）正常旋转数组（升序数组，为一个值的数组）</p></blockquote><h6 id="▉-代码实现"><a href="#▉-代码实现" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="▉-性能分析"><a href="#▉-性能分析" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><blockquote><p>暴力破解法</p><ul><li>时间复杂度：O(n)。遍历整个数组。</li><li>空间复杂度：O(1)。不需要额外的内存空间。</li></ul><p>二分查找法</p><ul><li>时间复杂度：log(n)。二分查找，每次都缩小范围的 1/2 。</li><li>空间复杂度：不需要额外的内存空间 O(1)。</li></ul></blockquote><h4 id="1-2-小结"><a href="#1-2-小结" class="headerlink" title="1.2 小结"></a>1.2 小结</h4><h6 id="▉-考查内容"><a href="#▉-考查内容" class="headerlink" title="▉ 考查内容"></a>▉ 考查内容</h6><blockquote><p>1）对二分查找的充分理解。</p><p>2）能在短时间内了解旋转数组这种新的概念。</p><p>3）问题的全面性。（重复元素以及向后移动 0 个元素）</p></blockquote><h6 id="▉-扩展思考"><a href="#▉-扩展思考" class="headerlink" title="▉ 扩展思考"></a>▉ 扩展思考</h6><blockquote><p>1）对二分查找条件的变换，使得问题可以举一反三。</p></blockquote><h3 id="2、二叉查找树的后续序列"><a href="#2、二叉查找树的后续序列" class="headerlink" title="2、二叉查找树的后续序列"></a>2、二叉查找树的后续序列</h3><blockquote><p>题目：给你一个整型数组，判断该数组是否为二叉查找树的后序遍历。如果是返回 true，如果不是返回 false。</p></blockquote><h4 id="2-1-问题分析与解决"><a href="#2-1-问题分析与解决" class="headerlink" title="2.1 问题分析与解决"></a>2.1 问题分析与解决</h4><h6 id="▉-问题分析-1"><a href="#▉-问题分析-1" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><blockquote><p>1）根据二叉查找树后续遍历的特点，先遍历左子树，然后遍历右子树，最后遍历根节点。存储在数组中的二叉查找树是有规律的，所以观察数组中的数据，与后序遍历是否存在一些规律和关系呢？</p><p>2）二叉查找树的后序遍可以用递归实现遍历的，如果判断一组数据是否为后序遍历是否也可以通过递归来进行判断呢？</p></blockquote><h6 id="▉-算法思路-1"><a href="#▉-算法思路-1" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote><p>1）数组中的数据最后一个数据一定是树的根节点。</p><p>2）如果为一棵二叉查找树，除最后一个根节结点外，数组分为两份数据，我们发现前一份数据小于根节点，后一份数据大于根节点。也就是说，前一半数据为树的左子节点，后一半数据为树的右子节点。</p><p>3）然后对左右两部分的数据分别递归按照上述的方法进行判断。</p></blockquote><h6 id="▉-测试用例-1"><a href="#▉-测试用例-1" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote><p>1）空树</p><p>2）非二叉查找树</p><p>3）只有一个结点的二叉查找树。</p><p>4）只有右/左子树的二叉查找树。</p></blockquote><h6 id="▉-代码实现-1"><a href="#▉-代码实现-1" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><blockquote></blockquote><h6 id="▉-性能分析-1"><a href="#▉-性能分析-1" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><blockquote></blockquote><h4 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><h6 id="▉-考查内容-1"><a href="#▉-考查内容-1" class="headerlink" title="▉ 考查内容"></a>▉ 考查内容</h6><blockquote><p>1）对问题的分析能力，能否找到解题问题的规律。</p><p>2）对二叉查找树遍历的理解。</p><p>3）递归的灵活运用。</p></blockquote><h6 id="▉-扩展思考-1"><a href="#▉-扩展思考-1" class="headerlink" title="▉ 扩展思考"></a>▉ 扩展思考</h6><blockquote><p>1）判断一个数组是否为树的前序遍历或中序遍历？</p><p>2）”重建二叉树“ 也是同样的解题思路。</p></blockquote><h2 id="三、查找和排序的高级练习（阶段三）"><a href="#三、查找和排序的高级练习（阶段三）" class="headerlink" title="三、查找和排序的高级练习（阶段三）"></a>三、查找和排序的高级练习（阶段三）</h2><h2 id="四、查找和排序的总结"><a href="#四、查找和排序的总结" class="headerlink" title="四、查找和排序的总结"></a>四、查找和排序的总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中所必会的查找和排序算法。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【事件流与委托】</title>
    <link href="http://yoursite.com/2019/05/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%8E%E5%A7%94%E6%89%98%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/02/前端面试之道【事件流与委托】/</id>
    <published>2019-05-01T23:18:56.655Z</published>
    <updated>2019-05-10T07:43:40.822Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>事件流与委托是前端重点内容之一！</p><a id="more"></a><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><blockquote><p>浏览器开发团队遇到的问题是，当点击页面的某一元素的时候，不仅点击了当前源苏苏，而且也点击了包含当前元素的容器，也相当于点击了整个页面。然而为了规范页面中的事件的接收顺序，两个浏览器团队提出了完全相反的想法。</p></blockquote><h3 id="一、事件流"><a href="#一、事件流" class="headerlink" title="一、事件流"></a>一、事件流</h3><blockquote><p>所谓的事件流描述的是从页面中接收事件的顺序。</p><p>1）IE 提出的是<strong>事件冒泡流</strong>。</p><p>2）NC 提出的是<strong>事件捕获流</strong>。</p></blockquote><h4 id="1、事件冒泡"><a href="#1、事件冒泡" class="headerlink" title="1、事件冒泡"></a>1、事件冒泡</h4><blockquote><p>IE 的事件流叫做事件冒泡。事件是从具体的元素接收，向上传播到不具体的结点。</p><p>1）所有的浏览器都支持事件冒泡。</p><p>2）IE 5 之前事件冒泡会跳过<code>&lt;html&gt;</code> 元素，从 <code>body</code> 到 <code>document</code>。</p><p>3）<code>IE 9</code>、<code>Firefox</code>、<code>Safari</code>、<code>Chrome</code> 等浏览器事件一直冒泡到 <code>window</code> 对象。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 例子</span><br><span class="line">div &gt; body &gt; html &gt; document &gt; window // 当点击页面的 div 元素时，事件的传播顺序</span><br></pre></td></tr></table></figure><h4 id="2、事件捕获"><a href="#2、事件捕获" class="headerlink" title="2、事件捕获"></a>2、事件捕获</h4><blockquote><p>NC 提出的另一个事件流叫做事件捕获。事件从不具体的结点到具体的元素。用意是事件到达预定的目标结点之前捕获它。</p><p>1）老版本的浏览器只支持事件冒泡，不支持事件捕获。</p><p>2）一般没有特殊要求，都是用事件冒泡。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 例子</span><br><span class="line">window &gt; document &gt; html &gt; body &gt; div // 当点击页面的 div 元素时，事件的传播顺序</span><br></pre></td></tr></table></figure><h4 id="3、DOM-事件流"><a href="#3、DOM-事件流" class="headerlink" title="3、DOM 事件流"></a>3、DOM 事件流</h4><blockquote><p>“DOM2” 的事件流包括三个阶段，<strong>事件捕获、处于目标阶段、事件冒泡阶段</strong>。</p><p>1）一般「处于目标阶段」属于事件「冒泡阶段」的一部分。</p><p>1）<code>IE 9</code>、<code>Firefox</code>、<code>Safari</code>、<code>Chrome</code> 等浏览器会在事件捕获阶段触发事件对象上的目标。相当于有两个机会在目标对象上操作事件。</p><p>2）<code>IE 8</code> 更早的版本不支持 <code>DOM</code> 事件流。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 事件捕获</span><br><span class="line">window &gt; document &gt; html &gt; body</span><br><span class="line">// 处于目标阶段</span><br><span class="line">body &gt; div </span><br><span class="line">// 事件冒泡阶段</span><br><span class="line">div &gt; body &gt; html &gt; document &gt; window</span><br></pre></td></tr></table></figure><h3 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h3><p>链接：<a href="http://luxiangqiang.xn--6qq986b3xl/2019/04/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%91/" target="_blank" rel="noopener">事件绑定和事件对象</a></p><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><blockquote><p>事件处理程序的数量直接关系到页面的性能问题，主要分为两个方面：</p><p>1）每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。</p><p>2）事先指定所有事件处理程序而导致的 <code>DOM</code> 访问次数过多，会延迟整个页面的交互就绪时间。</p></blockquote><h3 id="一、事件委托"><a href="#一、事件委托" class="headerlink" title="一、事件委托"></a>一、事件委托</h3><blockquote><p>为了解决“事件绑定”过多的问题，解决方案是<strong>事件委托</strong>。利用事件冒泡，只需绑定一个事件处理程序，就可以管理页面所有的事件。</p></blockquote><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><blockquote><p>1）事件委托，只需将事件处理程序绑定到 <code>DOM</code> 树最高的层次上。</p><p>2）一般考虑绑定到页面的 <code>document</code> 对象上。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定到 document 对象上</span></span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"click"</span>, handler);</span><br><span class="line"><span class="keyword">const</span> handler = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent();</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.getTarget(event);</span><br><span class="line">    <span class="keyword">if</span> (target.name &amp;&amp; target.id) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (target.name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'delete'</span>:   </span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'edit'</span>:</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'selectImg'</span>:</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'updataImg'</span>:</span><br><span class="line">               </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'modifyStaffInfo'</span>:</span><br><span class="line">               </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'modelYes'</span>:   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h4><blockquote><p>1）<code>document</code> 很快就可以访问，页面呈现的元素立即具备了绑定的功能。</p><p>2）页面设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的 <code>DOM</code> <strong>引用更少</strong>，<strong>时间就越少</strong>。</p><p>3）整个页面占用的<strong>内存空间少</strong>，提升了整体的性能。</p></blockquote><h3 id="二、移除事件绑定"><a href="#二、移除事件绑定" class="headerlink" title="二、移除事件绑定"></a>二、移除事件绑定</h3><blockquote><p>页面元素在绑定事件处理程序的时候，浏览器中的代码就会和 javascript 代码之间建立一个链接。这种链接越多，页面就会越慢。</p><p>1）事件委托减少事件绑定，限制连接的数量。</p><p>2）在不需要时移除时间绑定程序（内存中留有不用的处理程序）。</p></blockquote><h4 id="1、两种情况"><a href="#1、两种情况" class="headerlink" title="1、两种情况"></a>1、两种情况</h4><blockquote><p>造成以上问题的两种情况：</p><p><strong>1）文档中移除绑定事件的元素。</strong>虽然元素被移除，但是事件处理程序还在内存中，无法当做垃圾被回收,因为虽然元素被移除了，但是在内存中与元素保持的引用的关系。</p><p>例如：<code>removeChild()</code> 和 <code>replaceChild()</code> 方法，更多的是使用 <code>innerHtml</code> 替换页面的一部分。</p><p><strong>2）卸载页面的时候。</strong>如果在页面卸载之前没有清理干净事件处理程序，还会存储在内存中。不断的刷新、卸载页面使得内存中事件处理程序的数量越来越多，因为事件处理程序占用的内存空间有没释放掉。</p></blockquote><h4 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h4><blockquote><p>通过 onunload 事件处理在页面卸载的时候，将页面中绑定的事件处理程序全部移除掉。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件流与委托是前端重点内容之一！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端功能之【Datatables插件】</title>
    <link href="http://yoursite.com/2019/04/28/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E4%B9%8B%E3%80%90Datatables%E6%8F%92%E4%BB%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/28/前端功能之【Datatables插件】/</id>
    <published>2019-04-28T14:43:59.565Z</published>
    <updated>2019-04-28T15:44:37.722Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Datatables 功能插件的使用详细讲解！</p><a id="more"></a><h3 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h3><h4 id="1、引用插件"><a href="#1、引用插件" class="headerlink" title="1、引用插件"></a>1、引用插件</h4><blockquote><p>首先引入 Datatables 插件、Bootstrap、jQuery 插件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--DataTables js--&gt;</span><br><span class="line">&lt;script src=<span class="string">"assets/plugins/Datatable/js/jquery.dataTables.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"assets/plugins/Datatable/js/dataTables.bootstrap4.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2、HTML-表格"><a href="#2、HTML-表格" class="headerlink" title="2、HTML 表格"></a>2、HTML 表格</h4><blockquote><p>在界面添加 HTML 表格代码。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 行标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每列的标题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-15p"</span>&gt;</span>权限<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-15p"</span>&gt;</span>登陆号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-20p"</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-15p"</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表格内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bella<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Chloe<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>System Developer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>2018/03/12<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、Datatables-语言设置"><a href="#3、Datatables-语言设置" class="headerlink" title="3、Datatables 语言设置"></a>3、Datatables 语言设置</h4><blockquote><p>Datatables 默认的语言设置是英文，我们要将其设置为中文。在 <code>$(document).render(function(){})</code> <code>HTML</code> 结构渲染完进行设置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">let</span> table = $(<span class="string">'#example'</span>).DataTable(&#123;</span><br><span class="line">        <span class="comment">// Datatable 语言设置</span></span><br><span class="line">        <span class="string">'language'</span>: &#123;</span><br><span class="line">            <span class="comment">// 左上角的显示数量设置</span></span><br><span class="line">            <span class="string">"lengthMenu"</span>: <span class="string">'每页显示&lt;select class="form-control"&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="10"&gt;10&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="20"&gt;20&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="30"&gt;30&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="40"&gt;40&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="50"&gt;50&lt;/option&gt;'</span> + <span class="string">'&lt;/select&gt;条'</span>,</span><br><span class="line">            <span class="comment">// 右下角的翻页设置</span></span><br><span class="line">            <span class="string">"paginate"</span>: &#123;</span><br><span class="line">                <span class="string">"first"</span>: <span class="string">"首页"</span>,</span><br><span class="line">                <span class="string">"last"</span>: <span class="string">"尾页"</span>,</span><br><span class="line">                <span class="string">"previous"</span>: <span class="string">"上一页"</span>,</span><br><span class="line">                <span class="string">"next"</span>: <span class="string">"下一页"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"processing"</span>: <span class="string">"加载中..."</span>,  <span class="comment">// DataTables载入数据时，是否显示进度条 </span></span><br><span class="line">            <span class="string">"emptyTable"</span>: <span class="string">"暂无数据"</span>,   <span class="comment">// 表格无数据时显示情况</span></span><br><span class="line">            <span class="string">"info"</span>: <span class="string">"共 _PAGES_ 页  _TOTAL_ 条数据  "</span>,</span><br><span class="line">            <span class="string">"infoEmpty"</span>: <span class="string">"暂无数据"</span>,</span><br><span class="line">            <span class="string">"emptyTable"</span>: <span class="string">"暂无要处理的数据..."</span>,  <span class="comment">//表格中无数据</span></span><br><span class="line">            <span class="string">"search"</span>: <span class="string">"搜索:"</span>,</span><br><span class="line">            <span class="string">"infoFiltered"</span>: <span class="string">" —— 从  _MAX_ 条数据中筛选"</span>,</span><br><span class="line">            <span class="string">"zeroRecords"</span>: <span class="string">"没有找到记录"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// datatables 自带的 ajax 请求数据</span></span><br><span class="line">        <span class="string">"ajax"</span>: &#123;</span><br><span class="line">            url: <span class="string">''</span>, <span class="comment">// 请求的 url</span></span><br><span class="line">            method: <span class="string">'post'</span>, <span class="comment">// 请求方式</span></span><br><span class="line">            timeout: <span class="number">5000</span>,  <span class="comment">// 请求延迟</span></span><br><span class="line">            dataType: <span class="string">'JSON'</span>, <span class="comment">// 数据类型</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">let</span> alldata = [<span class="string">'role'</span>, <span class="string">'name'</span>, <span class="string">'password'</span>];</span><br><span class="line">        <span class="comment">// 设置后台返回的字段名，Datatable 会自动填充</span></span><br><span class="line"><span class="string">'columns'</span>: [</span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'role'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'name'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'password'</span> &#125;,</span><br><span class="line"><span class="comment">// name 为每一行传入的 data 字段</span></span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'name'</span>,</span><br><span class="line"><span class="string">'render'</span>:<span class="function"><span class="keyword">function</span>(<span class="params">data,type,row,meta</span>)</span>&#123;</span><br><span class="line">                                <span class="comment">// 自定义代码（一般添加增、删、改按钮），data 为传入的 name 值</span></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">`&lt;button name="add" id="add_<span class="subst">$&#123;data&#125;</span>"&gt;添加&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;button name="delete" id="delete_<span class="subst">$&#123;data&#125;</span>"&gt;删除&lt;/button&gt;`</span> </span><br><span class="line"><span class="keyword">return</span> html;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">         <span class="comment">// cells 存储着所有行对象（通过 . 可获取属性）</span></span><br><span class="line">         createdRow: <span class="function"><span class="keyword">function</span> (<span class="params">row, data, dataIndex, cells</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; alldata.length; i++) &#123;</span><br><span class="line">             <span class="comment">// 为每一行元素添加唯一标识 ID</span></span><br><span class="line">             cells[i].id = alldata[i]</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、为-Table-添加点击事件"><a href="#4、为-Table-添加点击事件" class="headerlink" title="4、为 Table 添加点击事件"></a>4、为 Table 添加点击事件</h4><blockquote><p>通过事件委托的方式添加事件监听。</p><p>1）虽然监听事件添加到 <code>table</code> 上，但是可以通过  <code>event</code> 事件对象判断点击了哪一个 <code>id</code> 或 <code>name</code> 的控件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#example'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每一行数据中每个字段的 name 值和 id 值</span></span><br><span class="line">    <span class="keyword">if</span> (event.target.name &amp;&amp; event.target.id) &#123;</span><br><span class="line">        <span class="comment">// 通过判断 name 值来确定删除/添加</span></span><br><span class="line">        <span class="keyword">switch</span> (event.target.name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">                <span class="comment">// 对表格做添加数据</span></span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'delete'</span>:</span><br><span class="line">                <span class="comment">// 对该行做删除处理</span></span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5、获取同行的所有数据"><a href="#5、获取同行的所有数据" class="headerlink" title="5、获取同行的所有数据"></a>5、获取同行的所有数据</h4><blockquote><p>通过点击某按钮的 id 获取父节点，从而达到获取同行的数据。</p><p>1）得到同一行数据之后，我们可以进行传值编辑或者删除一行数据。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同行某点击事件的 id</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSameValue</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取该 id 父节点的所有兄弟节点（存储所有数据的结点）</span></span><br><span class="line">    <span class="keyword">let</span> values = $(<span class="string">'#'</span> + id).parent().parent().siblings();</span><br><span class="line">    <span class="comment">// 以键值对的方式存储到 map 中</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 将同一行的数据 name:value 遍历出来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> obj <span class="keyword">of</span> values) &#123;</span><br><span class="line">        <span class="comment">// 通过结点得到想要的属性存储起来</span></span><br><span class="line">        result.set(obj.id, obj.outerText);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 map</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、删除一行数据"><a href="#6、删除一行数据" class="headerlink" title="6、删除一行数据"></a>6、删除一行数据</h4><blockquote><p>得到同一行数据之后，进行删除操作。</p><p>1）删除一行需要的到该行的 DOM 对象，可以通过目标值的父节点获取</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> row = event.target.parentNode.（...）.parentNode;</span><br><span class="line"><span class="comment">// 进行删除更新</span></span><br><span class="line">table.row(row).remove().draw(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h4 id="7、添加一行数据"><a href="#7、添加一行数据" class="headerlink" title="7、添加一行数据"></a>7、添加一行数据</h4><blockquote></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> table = $(<span class="string">'#example'</span>).DataTable(&#123;&#125;)</span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line">table.ajax.reload(<span class="literal">null</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Datatables 功能插件的使用详细讲解！&lt;/p&gt;
    
    </summary>
    
      <category term="前端功能实现" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="前端功能实现" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【事件绑定】</title>
    <link href="http://yoursite.com/2019/04/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/28/前端面试之道【事件绑定】/</id>
    <published>2019-04-28T02:12:55.467Z</published>
    <updated>2019-05-10T08:42:25.643Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>js 事件的处理程序！</p><a id="more"></a><p>[TOC]</p><h2 id="事件绑定（事件处理程序）"><a href="#事件绑定（事件处理程序）" class="headerlink" title="事件绑定（事件处理程序）"></a>事件绑定（事件处理程序）</h2><h3 id="一、HTML-事件绑定"><a href="#一、HTML-事件绑定" class="headerlink" title="一、HTML 事件绑定"></a>一、HTML 事件绑定</h3><blockquote><p>最直接的事件绑定就是在 <code>HTML</code> 上做处理，显式的为按钮绑定 <code>click</code> 事件，用户点击按钮就会触发事件。</p></blockquote><h4 id="1、事件绑定定义"><a href="#1、事件绑定定义" class="headerlink" title="1、事件绑定定义"></a>1、事件绑定定义</h4><p>1）<code>onClick</code> 特性的值是 <code>javascript</code> ，所以不能在内使用未转义的 <code>HTML</code> 语法字符。</p><p>2）<code>onClick</code> 也可以调用页面定义的脚本（函数名）。也可以是外部文件，事件处理程序有权访问全局变量。</p><p>3）<code>onClick</code> 内定义的函数自带的一个 <code>event</code>变量存储事件对象，通过 <code>event</code> 变量可以访问事件对象的属性值（也可以使用 <code>this</code> ，<code>this</code> 指向事件对象本身）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、onClick 内不能使用未转义的 HTML 语法字符（单引号）</span></span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"alert(&amp;quot;Clicked&amp;quot;)"</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、调用页面其他地方的脚本</span></span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"showMessage()"</span> /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">showMessage = ()=&#123;</span><br><span class="line">        alert(<span class="string">"Hello Word"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、event 事件对象</span></span><br><span class="line">&lt;!--两个都输出‘点击我’--&gt;</span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"alert('event.value')"</span> /&gt; </span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"alert(this.value)"</span> /&gt;</span><br></pre></td></tr></table></figure><h4 id="2、存在的缺点"><a href="#2、存在的缺点" class="headerlink" title="2、存在的缺点"></a>2、存在的缺点</h4><h6 id="▉-缺点"><a href="#▉-缺点" class="headerlink" title="▉ 缺点"></a>▉ 缺点</h6><blockquote><p>1）用户在 <code>HTML</code> 元素一出现就点击元素触发相应的事件，但可能改事件还没有初始化（尚未具备执行的条件），导致报错。</p><p>2）<code>HTML</code> 和 <code>Javascript</code> 紧密耦合。修改事件时，会修改两处，所以一般不使用 <code>HTML</code> 事件绑定。</p></blockquote><h6 id="▉-解决"><a href="#▉-解决" class="headerlink" title="▉ 解决"></a>▉ 解决</h6><blockquote><p>1）加入 <code>try catch</code> 语句，在脚本函数没有被解析之前就点击了元素，就会引出错误。该错误不会让用户看见，而是被捕获。</p><p>2）不使用 <code>HTML</code> 事件绑定，而是转向使用 <code>javascript</code> 执行事件处理程序。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"try&#123;showMessage();&#125;catch(ex)&#123;&#125;"</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="二、DOM0-级事件绑定"><a href="#二、DOM0-级事件绑定" class="headerlink" title="二、DOM0 级事件绑定"></a>二、DOM0 级事件绑定</h3><blockquote><p>通过将一个函数的值赋值给事件处理程序的属性来绑定事件。</p><p>1）简单</p><p>2）跨浏览器</p></blockquote><h3 id="1、事件绑定定义-1"><a href="#1、事件绑定定义-1" class="headerlink" title="1、事件绑定定义"></a>1、事件绑定定义</h3><blockquote><p>1）先获取某个拥有事件处理程序属性的对象（属性一般都是小写，如 <code>onclick</code>），然后将该属性指向一个事件处理函数。</p><p>2）该方法被认为定义了元素的方法，处理事件是在该元素的作用域执行的，所以 <code>this</code>  指向该元素（可以通过 <code>this</code> 访问该元素的任何属性和方法）。</p><p>3）DOM0 级事件处理是在事件的<strong>冒泡阶段</strong>进行绑定的。</p><p>4）删除元素的绑定事件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = documentElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.ElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id) <span class="comment">// 输出 myBtn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="三、DOM2级事件绑定"><a href="#三、DOM2级事件绑定" class="headerlink" title="三、DOM2级事件绑定"></a>三、DOM2级事件绑定</h3><blockquote><p>DOM2 级事件处理程序定义了两个方法，分别是处理事件和删除事件的两个操作：<code>addEventListener()</code> 和 <code>removeEventListener()</code> 。</p></blockquote><h4 id="1、事件绑定定义-2"><a href="#1、事件绑定定义-2" class="headerlink" title="1、事件绑定定义"></a>1、事件绑定定义</h4><blockquote><p>1）可以添加多个事件处理函数。</p><p>2）移除函数必须和移除函数相同的参数。并且 <code>addEventListener()</code> 函数必须使用 <code>removeEventListener()</code> 才能移除。</p></blockquote><p>该函数接受三个参数：</p><ul><li>要处理的事件名；</li><li>绑定的函数；</li><li>布尔值（<code>true</code>：表示<strong>捕获阶段</strong>调用事件程序，<code>false</code>：表示<strong>冒泡阶段</strong>调用事件程序）；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为 btn 绑定了两个事件处理函数，按顺序执行</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>) <span class="comment">// 先执行 HelloWord</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)  <span class="comment">// 再执行 ID</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这里的 function 和上方不是同一个函数，所以移除失败</span></span><br><span class="line"><span class="comment">// 通过将同一个函数赋值给统一的变量，就可以视作为统一参数</span></span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h4 id="2、兼容性"><a href="#2、兼容性" class="headerlink" title="2、兼容性"></a>2、兼容性</h4><blockquote><p>1）DOM2 级事件处理程序兼容的浏览器有 <code>IE9、Firefox、Safari、Chrome</code> 和 <code>Opera</code>。</p><p>2）大多情况下，都将事件处理程序添加到<strong>冒泡阶段，为了最大限度的兼容各种浏览器</strong>。</p></blockquote><h3 id="四、IE-事件绑定"><a href="#四、IE-事件绑定" class="headerlink" title="四、IE 事件绑定"></a>四、IE 事件绑定</h3><blockquote><p>1）IE 实现了与 DOM 类中的两个方法：<code>attachEvent()</code> 和 <code>detachEvent()</code> 。</p><p>2）IE8 版本之前所有的事件绑定都是在冒泡阶段。</p><p>3）IE 与 <code>DOM0</code> 级绑定事件的区别在于事件的作用域是「<strong>全局变量</strong>」（ <code>this</code> 指向 <code>window</code> 作用域）。</p><p>4）可以通过 <code>attach</code> 添加多个事件，且「<strong>执行顺序和 <code>DOM2</code> 级相反</strong>」。</p><p>5）<code>detachEvent</code> 删除事件也必须提供相同的参数，匿名函数无效。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.attach(<span class="string">'onclick'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.attach(<span class="string">'onclick'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>) <span class="comment">// 再执行 HelloWord</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">btn.attach(<span class="string">'onclick'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)  <span class="comment">// 先执行 ID</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除无效</span></span><br><span class="line">btn.detachEvent(<span class="string">'onclick'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="五、跨浏览器的事件绑定"><a href="#五、跨浏览器的事件绑定" class="headerlink" title="五、跨浏览器的事件绑定"></a>五、跨浏览器的事件绑定</h3><blockquote><p>为了能够保证事件绑定能在大多数的浏览器下运行，一般有两种方式：</p><p>1）使用能够隔离浏览器差异的 javascript 库。</p><p>2）自己开发合适的功能，使用能力检测，保证能够在大多数的浏览器下运行。</p><p>3）该程序没有考虑到浏览器的所有问题。如：在 IE 中的作用域问题。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    <span class="comment">// 绑定事件</span></span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 解除绑定</span></span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.detachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="1、IE-与-DOM0-DOM2-之间的区别"><a href="#1、IE-与-DOM0-DOM2-之间的区别" class="headerlink" title="1、IE 与 DOM0/DOM2 之间的区别"></a>1、<code>IE</code> 与 <code>DOM0/DOM2</code> 之间的区别</h4><blockquote><p>1）<code>IE</code> 与 <code>DOM0</code> 比较：<code>IE</code> 事件绑定时，<code>this</code> 指向全局变量 <code>window</code>，而 DOM0 的 <code>this</code> 却指向事件本身。</p><p>2）<code>IE</code> 与 <code>DOM2</code> 比较：<code>IE</code> 与 <code>DOM2</code> 相比，<code>DOM2</code> 中的添加多个事件执行的顺序（正序）与 <code>IE</code> 绑定多个事件执行的顺序相反（逆序）。</p></blockquote><h4 id="2、兼容性-1"><a href="#2、兼容性-1" class="headerlink" title="2、兼容性"></a>2、兼容性</h4><blockquote><p>1）<code>IE8</code> 之前的只有冒泡阶段，所以  <code>IE8</code> 之前的事件绑定都是在冒泡阶段完成的（<code>DOM0</code> 级以及 IE 事件绑定）。</p><p>2）<code>DOM2</code> 事件第三个参数可以选择绑定阶段（冒泡还是捕获），因为 IE8 之前只有冒泡阶段，所以 <code>DOM2</code>级别的事件绑定只适用于 <code>IE9+</code> 。</p></blockquote><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><blockquote><p>当触发 DOM 的某个事件时，就会产生一个 <code>event</code> 对象，对象中包含着与事件相关信息。</p></blockquote><h3 id="一、DOM-中的事件对象"><a href="#一、DOM-中的事件对象" class="headerlink" title="一、DOM 中的事件对象"></a>一、DOM 中的事件对象</h3><h4 id="1、this、currentTarget、target"><a href="#1、this、currentTarget、target" class="headerlink" title="1、this、currentTarget、target"></a>1、this、currentTarget、target</h4><blockquote><p>1）当事件直接绑定到目标事件时，三者的值相同。</p><p>2）当事件绑定到目标事件的父节点上，<code>this</code>  与<code>currentTarget</code> 的值与 <code>target</code> 的值不相同。</p><p>当点击该按钮时，事件的绑定是按钮的父节点，所以目标对象 <code>target</code> 是指向按钮元素的（<code>click</code> 的真正目标），由于按钮没有绑定事件处理程序，所以 <code>click</code> 事件冒泡到 <code>document.body</code> 事件才得到处理 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将事件绑定 btn 按钮的父节点上</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    alert(event.target === <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、处理多个事件"><a href="#2、处理多个事件" class="headerlink" title="2、处理多个事件"></a>2、处理多个事件</h4><blockquote><p>为了能够减少代码量，通过 <code>event.type</code> 来确定一个函数处理多个事件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">handler = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">            <span class="comment">//要处理的点击事件</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">            <span class="comment">// 要处理的鼠标进入事件</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">            <span class="comment">// 要处理的鼠标滑出事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.mouseover = handler;</span><br><span class="line">btn.mouseout = handler;</span><br></pre></td></tr></table></figure><h4 id="3、阻止默认的事件行为"><a href="#3、阻止默认的事件行为" class="headerlink" title="3、阻止默认的事件行为"></a>3、阻止默认的事件行为</h4><blockquote><p>可以通过使用 <code>preventDefault()</code> 方法来取消默认的行为（必须设置属性 <code>cancelable</code> 为 <code>true</code>），如 <code>a</code>标签的链接事件，阻止了跳转 <code>href</code> 的链接。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">link.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event.cancelable = <span class="literal">true</span>;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、立即停止事件的传播"><a href="#4、立即停止事件的传播" class="headerlink" title="4、立即停止事件的传播"></a>4、立即停止事件的传播</h4><blockquote><p>通过设置 <code>stopPropagation()</code> 方法立即停止在 DOM 层次中的传播（停止事件的捕获或冒泡）。</p><p>1）通过这种方式可以避免发生在父节点绑定的事件处理程序。</p></blockquote><h3 id="二、IE-中的事件对象"><a href="#二、IE-中的事件对象" class="headerlink" title="二、IE 中的事件对象"></a>二、IE 中的事件对象</h3><blockquote><p>IE 中事件对象 <code>event</code> 有一种不同的方式。</p><p>1）DOM0 级：<code>event</code> 作为 <code>window</code> 的一个属性。</p><p>2）attatach 添加的：传入一个 event 对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">    alert(event.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、srcElement"><a href="#1、srcElement" class="headerlink" title="1、srcElement"></a>1、srcElement</h4><blockquote><p><code>srcElement</code> 属性相当于 <code>DOM</code> 中的 <code>target</code> 属性，用来确定事件目标对象的。</p><p>1）因为事件处理程序的作用域是根据指定它的方式来确定，所以 <code>this</code> 不一定指向目标对象。因此我们通常用 <code>srcElement</code> 来替换。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>,(event)=&gt;&#123;</span><br><span class="line">    alert(event.srcElement === <span class="keyword">this</span>) <span class="comment">// false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2、阻止默认的事件行为"><a href="#2、阻止默认的事件行为" class="headerlink" title="2、阻止默认的事件行为"></a>2、阻止默认的事件行为</h4><blockquote><p>只要将 <code>returnValue</code> 设置为 <code>false</code> 就可以阻止默认的行为。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">link.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、立即停止事件的传播"><a href="#3、立即停止事件的传播" class="headerlink" title="3、立即停止事件的传播"></a>3、立即停止事件的传播</h4><blockquote><p>设置 <code>cancelBubble</code> 属性即可停止事件的传播。由于 IE 中只有冒泡阶段，所以也只能阻止冒泡阶段在 DOM 层次中的传播。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble  = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、跨浏览器的事件对象"><a href="#三、跨浏览器的事件对象" class="headerlink" title="三、跨浏览器的事件对象"></a>三、跨浏览器的事件对象</h3><blockquote><p>不同浏览器中的 Event 对象是不同的，所以要写一个跨浏览器的事件对象。</p></blockquote><h4 id="1、定义-Event-事件"><a href="#1、定义-Event-事件" class="headerlink" title="1、定义 Event 事件"></a>1、定义 Event 事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> EventUtil = &#123;</span><br><span class="line">    <span class="comment">// 绑定事件</span></span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 解除绑定</span></span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.detachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取事件对象</span></span><br><span class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取事件目标对象</span></span><br><span class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 阻止事件</span></span><br><span class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event.preventDefault)&#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            event.returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 立即停止事件传播</span></span><br><span class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event.stopPropagation)&#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、调用-Event-对象事件"><a href="#2、调用-Event-对象事件" class="headerlink" title="2、调用 Event 对象事件"></a>2、调用 Event 对象事件</h4><blockquote><p>1）<code>getEvent()</code></p><p>2）<code>getTarget()</code></p><p>3）<code>preventDefault（）</code></p><p>4）<code>stopPropagation（）</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IE 不存在 event (undefined)就返回 window.event</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标对象</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.getTarget(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻止事件</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.preventDefault(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即停止事件传播</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.stopPropagation(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><blockquote><p>1）<code>DOM0</code> 级别的 <code>Event</code> 存在 <code>window</code> 对象中，而 <code>DOM2</code> 和 <code>IE</code> 处理事件程序中的 <code>Event</code> 对象是当做参数传入的。</p><p>2）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js 事件的处理程序！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【异步编程】</title>
    <link href="http://yoursite.com/2019/04/25/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/25/前端面试之道【异步编程】/</id>
    <published>2019-04-25T09:17:54.497Z</published>
    <updated>2019-04-27T12:55:53.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>js 异步常考面试题！</p><a id="more"></a><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><blockquote><p>面试题一：并发和并行的区别？</p></blockquote><p><strong>※ 答✔：</strong></p><ul><li>并发：宏观概念。两个任务在一段时间内同时完成切换。</li><li>并行：微观概念。同时完成两个任务。</li></ul><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><blockquote><p>面试题二：什么是回调函数？回调函数有什么缺点？如何理解回调地狱的问题？</p></blockquote><p><strong>※ 答✔：什么是回调函数</strong></p><blockquote><p>回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该<strong>事件</strong>或<strong>条件</strong>进行响应 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>※ 答✔：回调函数有什么缺点？</strong></p><blockquote><p>容易写成回调地狱问题。也就是多个请求存在依赖性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>※ 答✔：如何理解回调地狱问题？</strong></p><blockquote><p>回调地狱存在几个问题如下：</p><p>1）嵌套函数存在耦合性，一旦有所改动，牵一发而动全身。</p><p>2）嵌套函数一多，就很难处理错误。</p><p>3）回调函数不能使用 <code>try catch</code>  捕获异常(异常的捕获只能在函数执行的时候才能捕获到)。</p><p>4）回调函数不能直接 <code>return</code> 。</p></blockquote><p><strong>※ 答✔：如何解决回调地狱问题？</strong></p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote><p>面试三：你理解的 Generator 是什么？</p></blockquote><blockquote><p>1）一般 <code>generator</code> 配合 co 库（用于 <code>generator</code> 函数的自动执行 ）去使用。</p><p><code>Generator</code> 最大的特点就是可以控制函数的执行，下面是最容易困惑的点也是难点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span> (y + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = foo(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.next()); =&gt; &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="number">4</span>));=&gt; &#123;<span class="attr">value</span>: <span class="number">10</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="number">1</span>));=&gt; &#123;<span class="attr">value</span>: <span class="number">9</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><p>执行过程分析：</p><p>1）<code>generator</code> 函数的调用会返回一个迭代器。</p><p>2）执行第一次 <code>next</code> ，传入的 <code>next</code> 参数会被忽略，执行会停止在第一个 <code>yield</code> 处，返回其值。</p><p>3）执行第二次 <code>next</code> ，传入的参数代表第一个 <code>yield</code> 的返回值，<code>let y = 2 * 4</code> ，所以返回 <code>y + 2 = 8 + 2 = 10</code>  。如果不传入参数，就返回 <code>undefined</code>，打印的值为 <code>NAN</code> 。</p><p>4）执行第三个 <code>next</code>，传入的参数会代表第二个 <code>yield</code> 的返回值，<code>y + z = 8 + 1 = 9</code> 。</p><blockquote><p>我们可以通过 <code>generator</code> 解决回调地狱问题。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> ajax(url, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url1, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url2, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch()</span><br><span class="line"><span class="keyword">let</span> result1 = it.next()</span><br><span class="line"><span class="keyword">let</span> result2 = it.next()</span><br><span class="line"><span class="keyword">let</span> result3 = it.next()</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote><p>面试四：Promise 的特点是什么？分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？</p></blockquote><p>1、了解 Promise 吗？</p><p>2、Promise 解决的痛点是什么？</p><p>3、Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。</p><p>4、Promise 如何使用？</p><p>5、Promise 常用的方法有哪些？它们的作用是什么？</p><p>6、Promise 在事件循环中的执行过程是怎样的？</p><p>7、Promise 的业界实现都有哪些？</p><p>8、能不能手写一个 Promise 的 polyfill。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js 异步常考面试题！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端功能之【选取图片并显示】</title>
    <link href="http://yoursite.com/2019/04/21/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E4%B9%8B%E3%80%90%E9%80%89%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/21/前端功能之【选取图片并显示】/</id>
    <published>2019-04-21T00:33:00.035Z</published>
    <updated>2019-04-21T01:33:49.516Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本地选取图片并显示！</p><a id="more"></a><h3 id="一、选取本地图片"><a href="#一、选取本地图片" class="headerlink" title="一、选取本地图片"></a>一、选取本地图片</h3><h4 id="1、HTML"><a href="#1、HTML" class="headerlink" title="1、HTML"></a>1、HTML</h4><h6 id="▉-accept-属性"><a href="#▉-accept-属性" class="headerlink" title="▉ accept 属性"></a>▉ accept 属性</h6><blockquote><p>控制选取照片的类型。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 建议只选择照片使用这种写法</span><br><span class="line">accept=&quot;image/png, image/jpeg, image/gif, image/jpg&quot;</span><br><span class="line">// 其次这种写法</span><br><span class="line">accept=&quot;image/*&quot;</span><br></pre></td></tr></table></figure><h6 id="▉-multiple-属性"><a href="#▉-multiple-属性" class="headerlink" title="▉ multiple 属性"></a>▉ multiple 属性</h6><blockquote><p>用来选择多个文件上传。</p></blockquote><h6 id="▉-改变样式"><a href="#▉-改变样式" class="headerlink" title="▉ 改变样式"></a>▉ 改变样式</h6><blockquote><p>通过使用 <code>lable</code>  <code>for</code> 的联动改变上传按钮的样式。</p><p>1）<code>input</code> 需要设置 <code>display:none</code> 属性进行隐藏。</p><p>2）然后通过 <code>lable</code> 的 <code>for</code> 的值为<code>input</code> 的<code>ID</code> 属性值。</p></blockquote><h6 id="▉-实例"><a href="#▉-实例" class="headerlink" title="▉ 实例"></a>▉ 实例</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// input 选取</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"user_icon"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">onchange</span>=<span class="string">"preImg(this.id,'image_icon',this)"</span> <span class="attr">style</span>=<span class="string">"display: none"</span> /&gt;</span></span><br><span class="line">// 按钮</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"choose_icon"</span>&gt;</span>选择照片<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">// 显示图片</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"image_icon"</span> <span class="attr">width</span>=<span class="string">"138"</span> <span class="attr">height</span>=<span class="string">"150"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、javascript"><a href="#2、javascript" class="headerlink" title="2、javascript"></a>2、javascript</h4><h6 id="▉-限制照片大小"><a href="#▉-限制照片大小" class="headerlink" title="▉ 限制照片大小"></a>▉ 限制照片大小</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加内容：图片大小限制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">limitFileSize</span>(<span class="params">sourceId</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//图片大小限制</span></span><br><span class="line">    <span class="keyword">var</span> fileSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> fileMaxSize = <span class="number">1024</span>;<span class="comment">//1024k</span></span><br><span class="line">    <span class="comment">// 通过 input ID 获取到图片的大小</span></span><br><span class="line">    fileSize = <span class="built_in">document</span>.getElementById(sourceId).files.item(<span class="number">0</span>).size;</span><br><span class="line">    <span class="keyword">var</span> size = fileSize / <span class="number">1024</span>; <span class="comment">//转换成 KB</span></span><br><span class="line">    <span class="keyword">if</span>(size &gt;= fileMaxSize)&#123;</span><br><span class="line">        alert(<span class="string">"文件大小不能大于 1 M！"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        alert(<span class="string">"文件大小不能小于 0 M！"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-显示图片"><a href="#▉-显示图片" class="headerlink" title="▉ 显示图片"></a>▉ 显示图片</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示图片</span></span><br><span class="line"><span class="comment">// sourceId: ipnput id,sourceId: image id file: input object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preImg</span>(<span class="params">sourceId, targetId,file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = getFileUrl(sourceId);</span><br><span class="line">    <span class="keyword">var</span> imgPre = <span class="built_in">document</span>.getElementById(targetId);</span><br><span class="line">    <span class="comment">// 获取到的图片本地 url 设置 img 的 src 属性就 ok 了</span></span><br><span class="line">    imgPre.src = url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-判断浏览器类型"><a href="#▉-判断浏览器类型" class="headerlink" title="▉ 判断浏览器类型"></a>▉ 判断浏览器类型</h6><blockquote><p>不同的浏览器，选取图片 URL 的路径方式不相同。</p><p>1） 照片的路径就是 input 的 value 的值</p><p>2）选择 url 之前，要判断图片的大小。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择图片按钮监听</span></span><br><span class="line">$(<span class="string">"#choose_icon"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"#user_icon"</span>).click();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选取本地文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileUrl</span>(<span class="params">sourceId</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url;</span><br><span class="line">    <span class="keyword">if</span> (navigator.userAgent.indexOf(<span class="string">"MSIE"</span>)&gt;=<span class="number">1</span>) &#123; <span class="comment">// IE</span></span><br><span class="line">        <span class="comment">//限制文件大小</span></span><br><span class="line">        <span class="keyword">if</span>(limitFileSize(sourceId))&#123;</span><br><span class="line">            <span class="comment">// 照片的路径就是 input 的 value 的值</span></span><br><span class="line">            url = <span class="built_in">document</span>.getElementById(sourceId).value;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(navigator.userAgent.indexOf(<span class="string">"Firefox"</span>)&gt;<span class="number">0</span>) &#123; <span class="comment">// Firefox</span></span><br><span class="line">        <span class="comment">//限制文件大小</span></span><br><span class="line">        <span class="keyword">if</span>(limitFileSize(sourceId))&#123;</span><br><span class="line">            url = <span class="built_in">window</span>.URL.createObjectURL(<span class="built_in">document</span>.getElementById(sourceId).files.item(<span class="number">0</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(navigator.userAgent.indexOf(<span class="string">"Chrome"</span>)&gt;<span class="number">0</span>) &#123; <span class="comment">// Chrome</span></span><br><span class="line">        <span class="comment">//限制文件大小</span></span><br><span class="line">        <span class="keyword">if</span>(limitFileSize(sourceId))&#123;</span><br><span class="line">            url = <span class="built_in">window</span>.URL.createObjectURL(<span class="built_in">document</span>.getElementById(sourceId).files.item(<span class="number">0</span>)); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、上传本地图片"><a href="#二、上传本地图片" class="headerlink" title="二、上传本地图片"></a>二、上传本地图片</h3><blockquote><p><code>enctype</code> 属性规定在发送到服务器之前应该如何对表单数据进行编码，默认的编码是：” <code>application/x-www-form-urlencoded</code> “。对于普通数据是挺适用的，对于文件，就不能乱编码了，该什么就是什么，只能使用 <code>multipart/form-data</code> 作为 <code>enctype</code> 属性值。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地选取图片并显示！&lt;/p&gt;
    
    </summary>
    
      <category term="前端功能实现" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="前端功能实现" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>小学生都能学会的 Git 之【Github 提交篇】</title>
    <link href="http://yoursite.com/2019/04/18/%E5%B0%8F%E5%AD%A6%E7%94%9F%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%20Git%20%E4%B9%8B%E3%80%90Github%E6%8F%90%E4%BA%A4%E7%AF%87%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/18/小学生都能学会的 Git 之【Github提交篇】/</id>
    <published>2019-04-18T14:42:23.921Z</published>
    <updated>2019-04-30T02:41:45.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Git 版本控制完整使用流程！</p><a id="more"></a><p>[TOC]</p><h3 id="一、创建版本库"><a href="#一、创建版本库" class="headerlink" title="一、创建版本库"></a>一、创建版本库</h3><h4 id="1、初始化仓库"><a href="#1、初始化仓库" class="headerlink" title="1、初始化仓库"></a>1、初始化仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h4 id="2、添加文件到版本库的缓存区"><a href="#2、添加文件到版本库的缓存区" class="headerlink" title="2、添加文件到版本库的缓存区"></a>2、添加文件到版本库的缓存区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xiaolu.txt</span><br></pre></td></tr></table></figure><h4 id="3、将缓存区文件提交到本地正式仓库"><a href="#3、将缓存区文件提交到本地正式仓库" class="headerlink" title="3、将缓存区文件提交到本地正式仓库"></a>3、将缓存区文件提交到本地正式仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;wrote a file&quot;</span><br></pre></td></tr></table></figure><h4 id="4、当前版本库的状态"><a href="#4、当前版本库的状态" class="headerlink" title="4、当前版本库的状态"></a>4、当前版本库的状态</h4><blockquote><p>比如修改了内容。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h4 id="5、查看修改的内容"><a href="#5、查看修改的内容" class="headerlink" title="5、查看修改的内容"></a>5、查看修改的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 文件名</span><br></pre></td></tr></table></figure><h4 id="6、查看提交记录"><a href="#6、查看提交记录" class="headerlink" title="6、查看提交记录"></a>6、查看提交记录</h4><blockquote><p><code>--pretty=oneline</code> 用于格式化。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure><h3 id="二、时光穿梭"><a href="#二、时光穿梭" class="headerlink" title="二、时光穿梭"></a>二、时光穿梭</h3><h4 id="1、版本回退"><a href="#1、版本回退" class="headerlink" title="1、版本回退"></a>1、版本回退</h4><blockquote><p>回到上一个版本 <code>HEAD^</code>，上上版本就是 <code>HEAD^^</code> ，100 个之前的版本 <code>HEAD~100</code> </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><h4 id="2、向后回滚"><a href="#2、向后回滚" class="headerlink" title="2、向后回滚"></a>2、向后回滚</h4><blockquote><p>1）如果窗口不关闭的情况下可以找到 <code>commit id</code> 。</p><p>2)  如果窗口关闭了，需要使用 <code>git reflog</code> 命令找到 <code>commit id</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1094a // 提供的提交 ID</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查看命令历史记录</span><br><span class="line">git reflog</span><br><span class="line">//878eae2 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 878ea</span><br><span class="line">//ad3b64b HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">//878eae2 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: 第二次提交</span><br><span class="line">//ad3b64b HEAD@&#123;3&#125;: commit (initial): xiaolu.txt</span><br></pre></td></tr></table></figure><h4 id="3、管理修改"><a href="#3、管理修改" class="headerlink" title="3、管理修改"></a>3、管理修改</h4><blockquote><p>查看工作区和版本区最新版本的区别。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD -- xiaolu.txt</span><br><span class="line"></span><br><span class="line">diff --git a/xiaolu.txt b/xiaolu.txt</span><br><span class="line">index fda2ac1..4832c20 100644</span><br><span class="line">--- a/xiaolu.txt</span><br><span class="line">+++ b/xiaolu.txt</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> 1111</span><br><span class="line"> 2222</span><br><span class="line">-333    // 版本区</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+333^M</span><br><span class="line">+444               // 工作区</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><h4 id="4、撤销修改"><a href="#4、撤销修改" class="headerlink" title="4、撤销修改"></a>4、撤销修改</h4><ul><li><strong>丢弃工作区的修改。</strong></li><li><strong>丢弃缓存区的添加</strong></li></ul><blockquote><p>让这个文件回到最近一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p><p>1）文件修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； </p><p>2）文件经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态 ；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- xiaolu.txt</span><br></pre></td></tr></table></figure><blockquote><p><strong>丢弃缓存区的添加</strong>，就是撤销 <code>git add</code> 命令操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD xiaolu.txt // HEAD 代表最新版本</span><br></pre></td></tr></table></figure><h4 id="5、删除文件"><a href="#5、删除文件" class="headerlink" title="5、删除文件"></a>5、删除文件</h4><blockquote><p>工作区删除了文件，导致工作区和版本库中的版本不一致所以杰西莱有两种选择。</p><p>1）将版本库中的该文件进行删除，然后提交。</p><p>2）不小心误删了工作区的文件，要回复工作区误删除的文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将版本库中的该文件进行删除</span><br><span class="line">git rm test.md</span><br><span class="line">git commit -m &apos;删除test&apos;</span><br><span class="line">// 恢复误删除的文件</span><br><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure><h3 id="三、远程仓库"><a href="#三、远程仓库" class="headerlink" title="三、远程仓库"></a>三、远程仓库</h3><blockquote><p>本地仓库和远程的仓库通信需要 SSH 加密的，需要设计一样的秘钥才可以进行通信。</p></blockquote><h6 id="▉-创建秘钥"><a href="#▉-创建秘钥" class="headerlink" title="▉ 创建秘钥"></a>▉ 创建秘钥</h6><p>本地仓库设置密钥需要和远程仓库及逆行加密通信。</p><blockquote><p>在 window 下创建 SSH Key，一路回车。在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><h6 id="▉-Github设置-key"><a href="#▉-Github设置-key" class="headerlink" title="▉ Github设置 key"></a>▉ Github设置 key</h6><p>在远程仓库设置一个或多个公钥知道有哪里的本地仓库要通信。</p><blockquote><p>登陆GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容，点“Add Key”，你就应该看到已经添加的Key 。</p></blockquote><h4 id="1、添加远程仓库"><a href="#1、添加远程仓库" class="headerlink" title="1、添加远程仓库"></a>1、添加远程仓库</h4><blockquote><p>1）将本地仓库和远程仓库进行关联之后才可以推送信息。</p><p>2）将本地所有内容推送到远程仓库。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 关联远程仓库</span><br><span class="line">git remote add origin 远程仓库地址</span><br><span class="line"></span><br><span class="line">//-u 参数不但会把 master 分支推上去，还会将关联两个分支</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h4 id="2、克隆仓库"><a href="#2、克隆仓库" class="headerlink" title="2、克隆仓库"></a>2、克隆仓库</h4><blockquote><p>从远程克隆下仓库。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 仓库地址</span><br></pre></td></tr></table></figure><h3 id="四、创建与合并分支"><a href="#四、创建与合并分支" class="headerlink" title="四、创建与合并分支"></a>四、创建与合并分支</h3><blockquote><p>HEAD 指针是指向 master 的，master 是指向提交的，通过切换 HEAD 指针来切换指针。</p></blockquote><h4 id="1、创建分支"><a href="#1、创建分支" class="headerlink" title="1、创建分支"></a>1、创建分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建分支</span><br><span class="line">git branch dev</span><br><span class="line">//切换分支</span><br><span class="line">git checkout dev</span><br><span class="line">// 创建并切换分支</span><br><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><h4 id="2、查看当前分支"><a href="#2、查看当前分支" class="headerlink" title="2、查看当前分支"></a>2、查看当前分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><h4 id="3、合并分支"><a href="#3、合并分支" class="headerlink" title="3、合并分支"></a>3、合并分支</h4><blockquote><p>Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 合并分支</span><br><span class="line">git merge dev</span><br><span class="line">Updating 9220589..b12c1f2</span><br><span class="line">Fast-forward</span><br><span class="line"> xiaolu.txt | 4 +++-</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><h4 id="4、删除分支"><a href="#4、删除分支" class="headerlink" title="4、删除分支"></a>4、删除分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><h3 id="五、解决冲突"><a href="#五、解决冲突" class="headerlink" title="五、解决冲突"></a>五、解决冲突</h3><blockquote><p>创建的新分支与主分支 master 都进行修改了，分支进行了分叉，出现合并冲突，不能正常合并。必须手动解决冲突。</p></blockquote><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909115478645b93e2b5ae4dc78da049a0d1704a41000/0" alt="git-br-feature1"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 尝试合并,产生冲突</span><br><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging xiaolu.txt</span><br><span class="line">CONFLICT (content): Merge conflict in xiaolu.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 冲突信息</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:   xiaolu.txt</span><br></pre></td></tr></table></figure><blockquote><p>查看文件内容 <code>vi xiaolu.txt</code> 可以查看不同分值冲突的内容。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 查看文件内容</span><br><span class="line">vi xiaolu.txt</span><br><span class="line"></span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">333</span><br><span class="line">444</span><br><span class="line">dev·ÖÖ§¸üÐÂ</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">featrue ·ÖÖ§</span><br><span class="line">master ·ÖÖ§ÐÞ¸Ä</span><br><span class="line">=======</span><br><span class="line">featrue ·ÖÖ§</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/00138490913052149c4b2cd9702422aa387ac024943921b000/0" alt="git-br-conflict-merged"> </p><blockquote><p>用 <code>git log</code> 带参数的情况看到分治合并情况。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 带参查看合并分支情况</span><br><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">*   34b90d1 (HEAD -&gt; master) 解决冲突后提交</span><br><span class="line">|\</span><br><span class="line">| * e890412 (feature1) featrue提交</span><br><span class="line">* | 775427c master提交</span><br><span class="line">|/</span><br><span class="line">* b12c1f2 在dev分支提交</span><br><span class="line">* 9220589 删除test文件</span><br><span class="line">* 89bd80c 添加新文件</span><br><span class="line">* 5564077 第三次提交</span><br><span class="line">* 878eae2 第二次提交</span><br><span class="line">* ad3b64b xiaolu.txt</span><br></pre></td></tr></table></figure><h3 id="六、分支管理策略"><a href="#六、分支管理策略" class="headerlink" title="六、分支管理策略"></a>六、分支管理策略</h3><blockquote><p>合并分支时，如果可能，Git会用 <code>Fast forward</code> 模式，但这种模式下，删除分支后，会丢掉分支信息 。要强制关闭该模式，git 就会在 merge 时生成一个新的 commit。</p></blockquote><h4 id="1、合并分支强制禁用-ff-模式"><a href="#1、合并分支强制禁用-ff-模式" class="headerlink" title="1、合并分支强制禁用 ff 模式"></a>1、合并分支强制禁用 ff 模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git merge --no-ff -m &apos;merge with no-ff&apos; dev</span><br><span class="line"></span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> xiaolu.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><h4 id="2、查看合并记录"><a href="#2、查看合并记录" class="headerlink" title="2、查看合并记录"></a>2、查看合并记录</h4><blockquote><p>不使用 Fast forward 模式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">*   9885e46 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * d303c02 (dev) dev分支提交修改</span><br><span class="line">|/</span><br><span class="line">*   34b90d1 解决冲突后提交</span><br><span class="line">|\</span><br><span class="line">| * e890412 featrue提交</span><br><span class="line">* | 775427c master提交</span><br><span class="line">|/</span><br><span class="line">* b12c1f2 在dev分支提交</span><br><span class="line">* 9220589 删除test文件</span><br><span class="line">* 89bd80c 添加新文件</span><br><span class="line">* 5564077 第三次提交</span><br><span class="line">* 878eae2 第二次提交</span><br><span class="line">* ad3b64b xiaolu.txt</span><br></pre></td></tr></table></figure><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909222841acf964ec9e6a4629a35a7a30588281bb000/0" alt="git-no-ff-mode"> </p><h4 id="3、分支策略"><a href="#3、分支策略" class="headerlink" title="3、分支策略"></a>3、分支策略</h4><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909239390d355eb07d9d64305b6322aaf4edac1e3000/0" alt="git-br-policy"> </p><blockquote><p>实际开发，按照这几个基本原则进行分支管理。</p><p>1）master 主分治，只用于发布新的版本，平时开发不能在此分支。</p><p>2）开发都在 dev 分支开发。每到一个阶段就要合并 master 分支进行版本发布。</p><p>3）多人合作，创建自己的分支，时不时的向 dev 分支合并。</p></blockquote><h3 id="七、Bug-分支"><a href="#七、Bug-分支" class="headerlink" title="七、Bug 分支"></a>七、Bug 分支</h3><blockquote><p>每当开发中有 Bug 时，需要通过新的临时分支来修复，修复后合并分支，然后临时分支删除。</p></blockquote><p>如果接到修改 Bug ，当前在 dev 分支工作还没提交，又不想提交，一天后才能开发完毕。只能将现场保护起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   test.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   xiaolu.txt</span><br></pre></td></tr></table></figure><h4 id="1、存储当前开发进度"><a href="#1、存储当前开发进度" class="headerlink" title="1、存储当前开发进度"></a>1、存储当前开发进度</h4><blockquote><p>当前的进度存储起来之后，回到主分支，然后创建 <code>bug</code> 分支，修改 <code>bug</code> 后提交，然后合并到 <code>master</code>分支，然后恢复现场进度。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 存储当前开发进度</span><br><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on master: 9885e46 merge with no-ff</span><br></pre></td></tr></table></figure><h4 id="2、查看进度存储列表"><a href="#2、查看进度存储列表" class="headerlink" title="2、查看进度存储列表"></a>2、查看进度存储列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 9885e46 merge with no-ff</span><br></pre></td></tr></table></figure><h4 id="3、恢复开发进度"><a href="#3、恢复开发进度" class="headerlink" title="3、恢复开发进度"></a>3、恢复开发进度</h4><blockquote><p>两种方法：</p><p>1）<code>git stash apply</code> 恢复后的 stash 并不删除；通过 <code>git stash drop</code> 删除。</p><p>2）<code>git stash pop</code> 进行删除，stash 存储的开发进度被删除了。</p></blockquote><h4 id="4、恢复指定存储"><a href="#4、恢复指定存储" class="headerlink" title="4、恢复指定存储"></a>4、恢复指定存储</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><h3 id="八、Feature-分支"><a href="#八、Feature-分支" class="headerlink" title="八、Feature 分支"></a>八、Feature 分支</h3><blockquote><p>软件开发出现新功能，需要单独创建 <code>feature</code> 分支进行开发。</p></blockquote><p>如果开发增加一个功能，需要在新分支进行开发，但是中途取消了开发，就地需要删除已经开发的。回到主分支，删除该分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch &apos;feature-vulcan&apos; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;.</span><br></pre></td></tr></table></figure><blockquote><p>分支还没有进行合并，不能删除分支，所以我们要进行强制删除分支。</p></blockquote><h4 id="1、强制删除分支"><a href="#1、强制删除分支" class="headerlink" title="1、强制删除分支"></a>1、强制删除分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D feature-vulcan</span><br></pre></td></tr></table></figure><h3 id="九、多人合作"><a href="#九、多人合作" class="headerlink" title="九、多人合作"></a>九、多人合作</h3><blockquote><p>从远程仓库进行克隆，Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code> </p></blockquote><h4 id="1、远程仓库信息"><a href="#1、远程仓库信息" class="headerlink" title="1、远程仓库信息"></a>1、远程仓库信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remove -v</span><br></pre></td></tr></table></figure><h4 id="2、推送分支"><a href="#2、推送分支" class="headerlink" title="2、推送分支"></a>2、推送分支</h4><blockquote><p>把该分支上的所有<strong>本地提交</strong>推送到<strong>远程库</strong>。推送时，要指定本地分支。Git就会把该分支推送到远程库对应的远程分支上 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h4 id="3、抓取分支"><a href="#3、抓取分支" class="headerlink" title="3、抓取分支"></a>3、抓取分支</h4><blockquote><p>1）多人合作，克隆远程仓库，只能看到本地 <code>master</code> 分支。</p><p>2）要在 dev 开发，就必须创建远程 <code>origin</code> 的 <code>dev</code> 分支到本地，于是他用这个命令创建本地<code>dev</code>分支： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将本地 git 的头指针指向 origin 库的 dev 分支</span><br><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><h4 id="4、创建远程仓库分支"><a href="#4、创建远程仓库分支" class="headerlink" title="4、创建远程仓库分支"></a>4、创建远程仓库分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b my-test  //在当前分支下创建my-test的本地分支分支</span><br><span class="line">git push origin my-test  //将my-test分支推送到远程</span><br><span class="line">git branch --set-upstream-to=origin/my-test //将本地分支my-test关联到远程分支my-test上   </span><br><span class="line">git branch -a //查看远程分支</span><br></pre></td></tr></table></figure><h4 id="5、推送失败"><a href="#5、推送失败" class="headerlink" title="5、推送失败"></a>5、推送失败</h4><blockquote><p>1）如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并。</p><p>2）如果合并有冲突，则解决冲突，并在本地提交； </p><p>3）如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 版本控制完整使用流程！&lt;/p&gt;
    
    </summary>
    
      <category term="Git版本控制" scheme="http://yoursite.com/categories/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="Git版本控制" scheme="http://yoursite.com/tags/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【原型】</title>
    <link href="http://yoursite.com/2019/04/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8E%9F%E5%9E%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/18/前端进阶深入系列之【原型】/</id>
    <published>2019-04-18T11:56:07.738Z</published>
    <updated>2019-04-21T08:08:48.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小鹿把自己想象成 js 的设计者，这一篇就让你搞明白是什么 js 中的原型！</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>小鹿，程序员一名，来自某大型公司，在这个兵荒马乱的年代，人人都盛行 java ，这时公司给小鹿下达任务，说小鹿呀，现今 java 那么盛行，咱们公司也没什么前景了，都让那个什么 java 公司把便宜占去了，如果咱们还不能有点创新或者说比无法超过现在流行的 java 的话 ，公司迟早要破产。</p><p>这样吧，给你个任务，这个任务关系重大，公司的生死存亡就掌握到你手中了 。你要在两星期内给我设计一款语言，并且在短时间内把现在流行的 java 超过去，事后给你 300 万美金，给你放个假可以去旅游。</p><p>小鹿一听，既兴奋又困惑。困惑的是，现在 java 那么盛行，用的人如此之多，设计一款什么样的语言才能脱颖而出，让大家真正的喜欢上这款语言呢？小鹿的内心还是很困惑的。</p><p>半夜，小鹿躺在床上怎么也不能入眠，想着要想真正的设计出一门出色的语言，一定要与众不同。</p><ul><li>设计结构一定要和 java 不同。</li><li>java 针对于后台服务器语言设计的，那么这门语言设计为前端交互性语言吧。</li><li>为了能够在两星期之内设计出来，有必要模仿一下 java 里边的设计。</li></ul><p>小鹿又想，设计的这门语言一定要起一个好名字，等这门语言发布了，名字都没听过说，怎么能让别人接受呢？这时，小鹿一机灵，可否语言名字中带有 java 的名字，这样一来，当人们新接触到这门语言时，就会对其产生好奇心，误认为是 java 的升级版，只能借此机会赌一把了！就叫做 javascript 吧！</p><h4 id="一、遇到的第一个问题（语言类型）"><a href="#一、遇到的第一个问题（语言类型）" class="headerlink" title="一、遇到的第一个问题（语言类型）"></a>一、遇到的第一个问题（语言类型）</h4><blockquote><p>面对现在盛行的 java ，是一款面向对象的设计语言，小鹿想了想，不想也在设计一款完全面向对象的语言，但是为了能够可以做到 java 能做到的一些操作，就将 java 拿来进行分析和模仿了。</p></blockquote><h4 id="1、原型模式"><a href="#1、原型模式" class="headerlink" title="1、原型模式"></a>1、原型模式</h4><blockquote><p><code>Java</code>：<code>Java</code> 中有类的概念，类中有一个构造器，通过构造器可以通过 new 生成一个实例。</p></blockquote><p>※ <code>Javascript</code> 的设计：</p><p><code>JavaScript</code> 起初没有引进类的概念，所以继承以及共享数据就成为了 <code>JavaScript</code>  设计的一个问题，后来，小鹿想，要想实现数据共享以及继承，要设计成没有类的概念也能完成这些操作，于是有了下面的原型模式。</p><h6 id="▉-实例对象"><a href="#▉-实例对象" class="headerlink" title="▉ 实例对象"></a>▉ 实例对象</h6><blockquote><p>在 java 中生成一个对象，直接通过 <code>new 类名()</code> 就可以生成对象，但是在 js 中并没有类的概念，小鹿是怎么设计的呢？</p></blockquote><p>在 <code>java</code> 中虽然  <code>new</code> 了一个类，但是这个过程中调用了构造函数；<code>javascript</code> 中虽然没有类的概念，那就直接 <code>new</code> 构造函数生成一个对象实例吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 猴子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monkey</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huanhuan = <span class="keyword">new</span> Monkey(<span class="string">'欢欢'</span>);</span><br><span class="line"><span class="keyword">let</span> lele = <span class="keyword">new</span> Dog(<span class="string">'乐乐'</span>);</span><br></pre></td></tr></table></figure><h6 id="▉-原型对象"><a href="#▉-原型对象" class="headerlink" title="▉ 原型对象"></a>▉ 原型对象</h6><blockquote><p>虽然可以通过 new 构造函数的的方式生成一个实例对象，但是存在一个问题就是生成的两个实例对象共享一个属性和方法应该怎么办？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monkey</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">'动物'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huanhuan = <span class="keyword">new</span> Monkey(<span class="string">'欢欢'</span>);</span><br><span class="line"><span class="keyword">let</span> lele = <span class="keyword">new</span> Monkey(<span class="string">'乐乐'</span>);</span><br><span class="line">alert(huanhuan.species === lele.species) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>虽然这种方式可行，但是这两个 <code>species</code> 是两个不同的属性，这样的话在内存比较浪费空间，那应该怎么设计才能共享这一个公共的属性呢？ </p><p>这时，小鹿想到，如果设计一个” 容器 “专门才存放公共的属性和方法就好了，然后让不同构造函数生成的对象公共的属性都指向这个“ 容器 ”里的属性和方法不就可以了吗？</p><p>【图】</p><p>那么问题又来了，用什么来充当这个容器呢？然后小鹿专门对象来存储公共的属性和方法，又因为这个对象非常的特别，所以起名叫 “ 原型对象 ”。</p><p>为了能够让构造函数和原型对象产生关联，就为构造函数设计了一个默认的属性叫做 <code>prototype</code> ，这个属性专门指向原型对象的，那么原型对象又要指向构造函数，怎么办呢？所以小鹿又给每个原型对象指定了一个属性叫做 <code>constructor</code> ，原型对象的这个属性专门指向构造函数。</p><p>【图】</p><blockquote><p><strong>注意：</strong></p><p>1）最后又为构造函数生成的实例对象设置了一个属性 <code>_proto_</code> 用于指向原型对象。其实就是指向了 <code>prototype</code> 所指向的。</p><p>2）每个实例对象也是有一个属性指向自己的构造函数的（可以知道自己是由哪个构造函数生成的），也就是 <code>constructor</code> 属性，其实这个属性就是原型对象中 <code>constructor</code> 所指向的构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Monkey</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Monkey.prototype.species = <span class="string">'动物'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> huanhuan = <span class="keyword">new</span> Monkey(<span class="string">'欢欢'</span>);</span><br><span class="line"><span class="keyword">let</span> lele = <span class="keyword">new</span> Monkey(<span class="string">'乐乐'</span>);</span><br><span class="line">alert(huanhuan.species === lele.species) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小鹿把自己想象成 js 的设计者，这一篇就让你搞明白是什么 js 中的原型！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【原型链和继承】</title>
    <link href="http://yoursite.com/2019/04/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/18/前端进阶深入系列之【原型链和继承】/</id>
    <published>2019-04-18T11:50:51.788Z</published>
    <updated>2019-04-23T06:04:21.642Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一篇让你完全明白 js 中原型链和继承！</p><a id="more"></a><h3 id="一、原型链"><a href="#一、原型链" class="headerlink" title="一、原型链"></a>一、原型链</h3><blockquote><p>回顾上一节的内容《原型》，我们知道了构造函数与实例以及原型对象之间的关系，下面我们来看原型链。</p></blockquote><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><blockquote><p>所谓的原型链就是，一个构造函数的原型对象是另一个构造函数的实例。·</p></blockquote><h4 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h4><blockquote><p>要在引用的对象（实例 instance）中引用某个属性，首先在对象内部查找，然后再到原型对象中查找（instance.__proto__ (constructor1.prototype)）,如果这个原型对象是另一构造函数的实例的话，就会继续沿着这个实例的原型对象继续查找。</p></blockquote><h4 id="3、原型链"><a href="#3、原型链" class="headerlink" title="3、原型链"></a>3、原型链</h4><blockquote><p>这种实例与原型的链条叫做原型链。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索轨迹: instance1--&gt; instance2 --&gt; （instance2.__proto__ ）constructor2.prototype…--&gt;Object.prototype</span><br></pre></td></tr></table></figure><blockquote><p><strong>补充：</strong>所有的对象都继承与 Object 对象。</p></blockquote><h4 id="4、原型和实例的关系"><a href="#4、原型和实例的关系" class="headerlink" title="4、原型和实例的关系"></a>4、原型和实例的关系</h4><h6 id="▉-instanceof-（实例-—-gt-原型）"><a href="#▉-instanceof-（实例-—-gt-原型）" class="headerlink" title="▉ instanceof （实例 —&gt; 原型）"></a>▉ instanceof （实例 —&gt; 原型）</h6><blockquote><p>用于测试实例（instance）在原型链中出现的构造函数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(instance instanceof Object);//true</span><br><span class="line">alert(instance instanceof Father);//true</span><br></pre></td></tr></table></figure><h6 id="▉-isPrototypeOf-（原型-—-gt-实例）"><a href="#▉-isPrototypeOf-（原型-—-gt-实例）" class="headerlink" title="▉ isPrototypeOf()（原型 —&gt; 实例）"></a>▉ isPrototypeOf()（原型 —&gt; 实例）</h6><blockquote><p>只要该实例出现在原型链中，就会返回 true。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(Object.prototype.isPrototypeOf(instance));//true</span><br></pre></td></tr></table></figure><h4 id="5、原型链的问题"><a href="#5、原型链的问题" class="headerlink" title="5、原型链的问题"></a>5、原型链的问题</h4><blockquote><p>问题一：当原型链中包含引用类型值的原型（实例）时,该引用类型值会被所有实例共享; </p><p>问题二：在创建子类型(例如创建 Son 的实例) ,不能向超类型(例如 Father )的构造函数中传递参数. </p></blockquote><h3 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h3><blockquote><p>为了能够解决上面的问题，所以使用一下几种继承的方式。</p></blockquote><h4 id="1、经典继承（构造函数）"><a href="#1、经典继承（构造函数）" class="headerlink" title="1、经典继承（构造函数）"></a>1、经典继承（构造函数）</h4><h6 id="▉-基本思想"><a href="#▉-基本思想" class="headerlink" title="▉ 基本思想"></a>▉ 基本思想</h6><blockquote><p>在子类型构造函数的内部调用超类型构造函数. </p></blockquote><h6 id="▉-代码实现"><a href="#▉-代码实现" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><blockquote><p>1）保证了原型链中引用类型值（实例）的独立，不被所有实例共享。</p><p>2）子类创建的时候可以向父类进行传参。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 详细解析</span></span><br><span class="line"><span class="comment">//1、当用调用 call 方法时，this 带边 son 。</span></span><br><span class="line"><span class="comment">//2、此时 Father 构造函数中的 this 指向 son。</span></span><br><span class="line"><span class="comment">//3、也就是说 son 有了 colors 的属性。</span></span><br><span class="line"><span class="comment">//4、每 new 一个 son ，都会产生不同的对象，每个对象的属性都是相互独立的。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Father.call(<span class="keyword">this</span>);<span class="comment">//继承了Father,且向父类型传递参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red,blue,green" 可见引用类型值是独立的</span></span><br></pre></td></tr></table></figure><h6 id="▉-缺陷"><a href="#▉-缺陷" class="headerlink" title="▉ 缺陷"></a>▉ 缺陷</h6><blockquote><p>1）继承的方法都在构造函数中定义，构造函数不能够复用了（Father 的 this 已经绑定到 son，this 只能用于 son ，所以说 Father 构造函数不能复用了 ）</p><p>2）父类中定义的方法对于子类型而言是不可见的。</p></blockquote><h4 id="2、组合继承（最常见的继承模式）"><a href="#2、组合继承（最常见的继承模式）" class="headerlink" title="2、组合继承（最常见的继承模式）"></a>2、组合继承（最常见的继承模式）</h4><blockquote><p>上述的构造函数模式因为存在的两个缺点，所以不经常被使用。组合继承是将<strong>原型链技术</strong>和<strong>构造函数</strong>来实现堆实例属性的继承。</p></blockquote><h6 id="▉-基本思想-1"><a href="#▉-基本思想-1" class="headerlink" title="▉ 基本思想"></a>▉ 基本思想</h6><blockquote><p>使用<strong>原型链</strong>实现对<strong>「原型属性和方法」</strong>的继承,通过借用<strong>构造函数</strong>来实现对<strong>「实例属性」</strong>的继承. </p></blockquote><h6 id="▉-代码实现-1"><a href="#▉-代码实现-1" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><blockquote><p>1）在原型对象上定义的方法实现了函数的复用。</p><p>2）每个实例都有属于自己的属性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法定义在原型对象上（共享）</span></span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 子类继承父类的属性  </span></span><br><span class="line">Father.call(<span class="keyword">this</span>,name);     <span class="comment">//继承实例属性，第一次调用 Father()</span></span><br><span class="line">    <span class="comment">// 每个实例都有自己的属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将父类的实例变为子类的原型对象                                 </span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();   <span class="comment">//继承父类方法,第二次调用 Father()</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();  <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();  <span class="comment">//10</span></span><br></pre></td></tr></table></figure><h6 id="▉-缺陷-1"><a href="#▉-缺陷-1" class="headerlink" title="▉ 缺陷"></a>▉ 缺陷</h6><blockquote><p>1）组合继承调用了两次父类的构造函数，造成了不必要的消耗。</p></blockquote><h6 id="▉-改进"><a href="#▉-改进" class="headerlink" title="▉ 改进"></a>▉ 改进</h6><blockquote><p>也就是寄生组合式继承。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">Father.call(<span class="keyword">this</span>,name);<span class="comment">//继承实例属性，第一次调用Father()</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">extend(Son,Father)<span class="comment">//继承父类方法,此处并不会第二次调用Father()</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();<span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName();<span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();<span class="comment">//10</span></span><br></pre></td></tr></table></figure><h4 id="3、原型继承"><a href="#3、原型继承" class="headerlink" title="3、原型继承"></a>3、原型继承</h4><h6 id="▉-基本思想-2"><a href="#▉-基本思想-2" class="headerlink" title="▉ 基本思想"></a>▉ 基本思想</h6><blockquote><p>创建临时性的构造函数（无任何属性），将传入的对象作为该构造函数的原型对象，然后返回这个新构造函数的实例。</p></blockquote><h6 id="▉-代码实现-2"><a href="#▉-代码实现-2" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><blockquote><p>对传入的 o 对象进行了一次浅拷贝。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">F.prototype = o;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>浅拷贝。</p><p>1）object 所产生的对象是不相同的，但是原型对象都是 person 对象，所改变存在原型对象的属性所有生成的实例所共享，不仅被 Person 所拥有，而且被子类生成的实例所共享。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例 1</span></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="comment">// 实例 2</span></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line"><span class="comment">// 都添加至原型对象的属性(所共享)</span></span><br><span class="line">alert(person.friends); <span class="comment">// "Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure><h6 id="▉-object-create"><a href="#▉-object-create" class="headerlink" title="▉ object.create()"></a>▉ <strong>object.create()</strong></h6><blockquote><p>在 ECMAScript5 中,通过新增 <strong>object.create()</strong> 方法规范化了上面的原型式继承.。</p><p>两个参数：</p><p>1）参数一：新对象的原型的对象。</p><p>2）参数二：先对象定义额外的属性（可选）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line">alert(person.friends);<span class="comment">//"Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">"Van"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">name : &#123;</span><br><span class="line">value : <span class="string">"Louis"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);<span class="comment">//"Louis"</span></span><br></pre></td></tr></table></figure><h4 id="4、寄生式继承"><a href="#4、寄生式继承" class="headerlink" title="4、寄生式继承"></a>4、寄生式继承</h4><blockquote><p>寄生继承对原型继承的改进，原型继承生成的子类实例是通过 create 的第二个参数设定的；而寄生式继承是靠函数的封装，将封装好的对象实例进行返回。</p></blockquote><h6 id="▉-基本思想-3"><a href="#▉-基本思想-3" class="headerlink" title="▉ 基本思想"></a>▉ 基本思想</h6><blockquote><p>同样调用 object 函数，将返回的对象和对象的额外的方法和属性封装成一个函数进行返回。</p></blockquote><h6 id="▉-代码实现-3"><a href="#▉-代码实现-3" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用object函数创建一个新对象</span></span><br><span class="line">clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-缺陷-2"><a href="#▉-缺陷-2" class="headerlink" title="▉ 缺陷"></a>▉ 缺陷</h6><blockquote><p>寄生式继承将对象封装起来，导致不能做到函数的复用，使得效率降低。</p></blockquote><h4 id="5、寄生组合式继承"><a href="#5、寄生组合式继承" class="headerlink" title="5、寄生组合式继承"></a>5、寄生组合式继承</h4><blockquote><p>寄生组合式继承就是为了解决组合继承中两次调用构造函数的开销。</p></blockquote><h6 id="▉-基本思想-4"><a href="#▉-基本思想-4" class="headerlink" title="▉ 基本思想"></a>▉ 基本思想</h6><blockquote><p>不必为了指定子类型的原型而调用超类型的构造函数（避免第二次调用的构造函数）。</p></blockquote><h6 id="▉-代码实现-4"><a href="#▉-代码实现-4" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><blockquote><p>F 的构造函数指向父类的原型对象，让 F 的实例的 constructor 指向子类构造函数，子类的构造函数的原型指向 F 的实例对象。</p><p>1）这样做避免了在 F 的实例上创建不必要的属性，也没有调用 superClass 构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subClass:子类构造函数</span></span><br><span class="line"><span class="comment">// superClass:父类构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass,superClass</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> prototype = object(superClass.prototype);<span class="comment">//创建对象</span></span><br><span class="line">prototype.constructor = subClass;<span class="comment">//增强对象</span></span><br><span class="line">subClass.prototype = prototype;<span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype = superClass.prototype;<span class="comment">//直接指向超类型prototype</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>之所以没有进行如上操作，就是因为如上操作只不过是子类和父类共享原型对象，并没有实现继承。</p></blockquote><h6 id="▉-extend-有效扩展"><a href="#▉-extend-有效扩展" class="headerlink" title="▉ extend 有效扩展"></a>▉ extend 有效扩展</h6><blockquote><p>将 object() 里边的内容扩展开，将整体封装成函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = superClass.prototype;</span><br><span class="line">  subClass.prototype = <span class="keyword">new</span> F(); </span><br><span class="line">  subClass.prototype.constructor = subClass;</span><br><span class="line"></span><br><span class="line">  subClass.superclass = superClass.prototype;</span><br><span class="line">  <span class="keyword">if</span>(superClass.prototype.constructor == <span class="built_in">Object</span>.prototype.constructor) &#123;</span><br><span class="line">    superClass.prototype.constructor = superClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、new-运算符"><a href="#三、new-运算符" class="headerlink" title="三、new 运算符"></a>三、new 运算符</h3><blockquote><p>new 运算符创建对象的过程中，新创建一个对象，然后对对象进行一系列的关联。</p></blockquote><ul><li>创建一个空对象。</li><li>将空对象的原型指向构造函数的原型对象。</li><li>对构造函数的属性和方法进行浅拷贝到新对象中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = F.prototype;</span><br><span class="line">F.call(obj);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇让你完全明白 js 中原型链和继承！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【ES6 常考点】</title>
    <link href="http://yoursite.com/2019/04/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90ES6%E5%B8%B8%E8%80%83%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/17/前端面试之道【ES6常考点】/</id>
    <published>2019-04-17T12:07:23.423Z</published>
    <updated>2019-05-07T00:46:20.975Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ES6 面试常考的知识点！</p><a id="more"></a><h2 id="一、var、let、const区别"><a href="#一、var、let、const区别" class="headerlink" title="一、var、let、const区别"></a>一、var、let、const区别</h2><blockquote><p>面试题一：1、什么是提升？2、什么是暂时性死区？3、var、let 及 const 区别？ </p></blockquote><p><strong>※ 答✔：什么是提升？</strong></p><p>1）所谓的提升就是虽然变量没有声明，但是可以使用这个未声明的变量。</p><p>2）函数也有提升并且优先于变量的提升。函数提升会把整个函数挪到作用域顶部。</p><p>3）<code>var</code> 的变量会被提升到作用域的顶部。</p><p><strong>※ 答✔：什么是暂时性死区？</strong></p><p>1）如果使用 <code>let</code>、<code>const</code> 声明变量，在声明之前就是用了变量就会报错，报错的原因就是暂时性死区。这里的提升和 <code>var</code> 是有区别的，，虽然变量在编译的环节中被告知在这块作用域中可以访问，但是访问是受限制的。 </p><p><strong>※ 答✔：var、let 及 const 区别？</strong></p><p>1）<code>var</code> 在全局作用域下声明变量会导致变量挂载在 <code>window</code> 上，其他两者不会</p><p>2）<code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值。</p><p><strong>※ 扩展✔：为什么或存在提升？</strong></p><p>1）根本原因就是为了解决函数间互相调用的情况。</p><h2 id="二、原型继承和-Class-继承"><a href="#二、原型继承和-Class-继承" class="headerlink" title="二、原型继承和 Class 继承"></a>二、原型继承和 Class 继承</h2><blockquote><p>面试题二：原型如何实现继承？Class 如何实现继承？Class 本质是什么？ </p></blockquote><p><strong>※ 答✔：原型如何实现继承？</strong></p><p>1）组合继承、寄生组合继承、Class 继承  原文链接：<a href="http://luxiangqiang.xn--6qq986b3xl/2019/04/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF%E3%80%91/" target="_blank" rel="noopener">JavaScript 中的原型链和继承</a></p><p><strong>※ 答✔：Class 如何实现继承？</strong></p><p>1）<code>Class</code> 实现继承主要使用 <code>extends</code> 来明确继承自哪个父类，并且再子类中调用 <code>super</code>，可以将这段代码看做 <code>Parent.call(this,value)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>※ 答✔：Class 本质是什么？</strong></p><p>1）js 中并不存在类，Class 只是语法糖，Class 的本质还是函数。</p><h2 id="三、模块化"><a href="#三、模块化" class="headerlink" title="三、模块化"></a>三、模块化</h2><blockquote><p>面试题三：为什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</p></blockquote><p><strong>※ 答✔：为什么使用模块化？</strong></p><blockquote><p>通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。 </p></blockquote><ul><li>解决命名冲突</li><li>提供复用性</li><li>提高代码可维护性</li></ul><p><strong>※ 答✔：都有哪几种方式可以实现模块化？</strong></p><p><strong>1）立即执行函数（IIFE）</strong></p><blockquote><p>立即执行函数中的匿名函数中有独立的 词法作用域，避免了外界访问此作用域的变量。<strong>通过函数作用域解决了命名冲突、污染全局作用域的问题</strong> 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Barry"</span>; </span><br><span class="line">    <span class="keyword">return</span> name; </span><br><span class="line">&#125;)(); </span><br><span class="line"><span class="comment">// IIFE 执行后返回的结果：</span></span><br><span class="line">result; <span class="comment">// "Barry"</span></span><br></pre></td></tr></table></figure><p><strong>2）AMD 和 CMD</strong></p><blockquote><p>目前很少见，只需了解即可。</p></blockquote><ul><li><p><strong>AMD </strong></p><blockquote><p>AMD 采用异步的加载方式，加载之后不影响它后面语句的运行。require.js 实现 AMD 规范的模块化 ， <code>require.config()</code> 指定引用路径等，用 <code>define()</code> 定义模块，用 <code>require()</code> 加载模块。 </p></blockquote></li></ul><ul><li><p><strong>CMD </strong></p><blockquote><p>CMD 的不同点在于推崇依赖前置、提前执行，CDM 推崇依赖就近、延迟执行。</p></blockquote></li></ul><p><strong>3）CommonJS</strong></p><blockquote><p>① <code>CommonJS</code> 的规范主要用在 <code>Node.js</code> 中，为模块提供了四个接口：<code>module、exports、require、global</code>。</p><p>② <code>CommonJS</code> 用同步的方式加载模块（服务器端），在浏览器端使用的是异步加载模块。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对外暴露接口</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载外部模块</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="comment">// 原始类型的值被缓存，所以就没有被改变（commonJS 不会随着执行而去模块随时调用）</span></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>4）ES6 Module</strong></p><blockquote><p>ES6 实现的模块非常简单，用于浏览器和服务器端。<code>mport</code>命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码 .主要有两个命令组成：<code>export</code>和<code>import</code>:</p><ul><li><code>export</code>命令用于规定模块的<strong>对外接口</strong>。</li><li><code>import</code>命令引入其他模块的功能。 </li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定指定的值暴露对外的接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块中的某个值</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="comment">// ES6 模块不同的是，静态加载完毕之后，每执行到模块中的方法，就去模块内调用（外部的变量总是与模块进行绑定的），而且值不会被缓存。</span></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong>5）ES6 模块与 CommonJS 模块的区别</strong></p><blockquote><p><strong>1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong></p><ul><li>所谓值的拷贝，原始类型的值被缓存，不随模块内部的改变而改变。</li><li>ES6 模块是<strong>动态引用</strong>，<strong>不缓存值</strong>，模块内外是<strong>绑定</strong>的，而且是<strong>只读引用</strong>，不能修改值。ES6 的 js 引擎对脚本静态分析的时候，遇到加载命令模块 <code>import</code> ，就会生成一个只读引用，当真正用到模块里边的值的时候，就会去模块内部去取。</li></ul><p><strong>2、CommonJS 模块是运行时加载，ES6 模块是编译时加载输出接口。</strong></p><ul><li><strong>运行时加载</strong>：<code>CommonJS</code> 模块就是对象；是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 </li><li><strong>编译时加载：</strong>ES6 模块不是对象，而是通过 <code>export</code> 命令「显式指定输出的代码」。<code>import</code> 时采用静态命令的形式，即在<code>import</code>指定「加载某个输出值」，而「不是加载整个模块」，这种加载称为“编译时加载”。 </li></ul></blockquote><p><strong>6）总结</strong></p><blockquote><ul><li>CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li><li>AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li><li>CMD 规范与 AMD  规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重。</li><li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li></ul></blockquote><h2 id="四、Proxy"><a href="#四、Proxy" class="headerlink" title="四、Proxy"></a>四、Proxy</h2><h2 id="五、map-filter-reduce"><a href="#五、map-filter-reduce" class="headerlink" title="五、map,filter,reduce"></a>五、map,filter,reduce</h2><blockquote><p>面试题：map,filter,reduce 各自有什么作用？</p></blockquote><p><strong>※ map 有什么作用？</strong> </p><blockquote><p>map 的作用是 map 中传入一个函数，该函数会遍历该数组，对每一个元素做变换之后返回新数组。</p></blockquote><h6 id="1）该函数存在三个参数："><a href="#1）该函数存在三个参数：" class="headerlink" title="1）该函数存在三个参数："></a>1）该函数存在三个参数：</h6><ul><li>element :  对应数组的每个元素。</li><li>index : 数组元素的下标。</li><li>arr : 原数组。</li></ul><h6 id="2）代码实现"><a href="#2）代码实现" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">arr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">element,index,arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index]+<span class="number">1</span>;</span><br><span class="line">&#125;) <span class="comment">// [3,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>※ filter 有什么作用？</strong> </p><blockquote><p><code>filter</code> 的作用是也是生成一个数组，传入的函数返回值确实布尔类型，返回值为 true 的元素放入新数组，通常来筛选删除不需要的元素。</p></blockquote><h6 id="1）该函数存在三个参数：-1"><a href="#1）该函数存在三个参数：-1" class="headerlink" title="1）该函数存在三个参数："></a>1）该函数存在三个参数：</h6><ul><li>element :  对应数组的每个元素。</li><li>index : 数组元素的下标。</li><li>arr : 原数组。</li></ul><h6 id="2）代码实现-1"><a href="#2）代码实现-1" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr = array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> element != <span class="number">6</span>;</span><br><span class="line">&#125;)<span class="comment">// [1,2,4]</span></span><br></pre></td></tr></table></figure><p><strong>※ reduce 有什么作用？</strong> </p><blockquote><p>reduce 可以将数组中的元素通过回调函数最终转换为一个值。</p></blockquote><h6 id="1）传入-reduce-两个参数："><a href="#1）传入-reduce-两个参数：" class="headerlink" title="1）传入 reduce 两个参数："></a>1）传入 reduce 两个参数：</h6><ul><li>回调函数<ul><li>accum：累计值(第一次的值代表初始化的值)。</li><li>element：当前元素。</li><li>index：当前索引。</li><li>arr：原数组。</li></ul></li><li>初始值</li></ul><h6 id="2）代码实现-2"><a href="#2）代码实现-2" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">acc,element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> acc + element;</span><br><span class="line">&#125;,<span class="number">0</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h6 id="2）reduce-的执行过程"><a href="#2）reduce-的执行过程" class="headerlink" title="2）reduce 的执行过程"></a>2）reduce 的执行过程</h6><ul><li>初始值为 0 ，该值会传入第一次回调函数。</li><li>回到函数接收四个值，第一个值是累计值。</li><li>第一次执行回调函数将「初始值」和「当前值」做运算。</li><li>然后将结果值传入第二次执行的回调函数。</li><li>第二次回调函数会和当前值再做运算。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 面试常考的知识点！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/ES6/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/ES6/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据分析之爬虫【基本流程】</title>
    <link href="http://yoursite.com/2019/04/15/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E7%88%AC%E8%99%AB%E3%80%90%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/15/数据分析之爬虫【基本流程】/</id>
    <published>2019-04-14T16:11:36.357Z</published>
    <updated>2019-04-17T00:20:42.456Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/images/爬虫基本流程.png" alt=""></p><p>本篇文章教你数据分析爬虫的基本流程！</p><a id="more"></a><h3 id="一、爬虫的基本流程"><a href="#一、爬虫的基本流程" class="headerlink" title="一、爬虫的基本流程"></a>一、爬虫的基本流程</h3><blockquote><p>三个基本流程：</p><ul><li>打开网页: Request 访问网页，得到服务器返回的数据，包括 HTML 和 JSON 数据。</li><li>提取数据: 针对 HTML 使用 XPath 元素定位；针对 JSON 使用 JSON 进行解析。</li><li>保存数据：使用 Pandas 保存数据，最后导出 XSL 或 CSV 文件。</li></ul></blockquote><h4 id="1、Request-访问页面"><a href="#1、Request-访问页面" class="headerlink" title="1、Request 访问页面"></a>1、Request 访问页面</h4><blockquote><p>Request 是 Python 的 HTTP 的客户端库，两种访问方式 GET 和 POST 。请求回来的数据可以通过 <code>text</code> 或 <code>content</code> 来获取 HTML 的正文。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// get 方式</span><br><span class="line">r = requests.get(<span class="string">'http://www.douban.com'</span>)</span><br><span class="line">// post 方式</span><br><span class="line">r = requests.post(<span class="string">'http://xxx.com'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="2、XPath-定位"><a href="#2、XPath-定位" class="headerlink" title="2、XPath 定位"></a>2、XPath 定位</h4><blockquote><p>XPath 是 XML 的路径语言，通过元素和属性进行导航，定位位置。</p><p>1）XPath 有 100 多个内置函数进行快速的定位。</p><p>2）XPath 需要借助一个解析库 lxml 。例如:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 得到 HTML 的所有列表项目</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">html = etree.HTML(html)</span><br><span class="line">result = html.xpath(<span class="string">'//li'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://static001.geekbang.org/resource/image/3b/ea/3bcb311361c76bfbeb90d360b21195ea.jpg" alt="img"></p><h4 id="3、JSON-对象"><a href="#3、JSON-对象" class="headerlink" title="3、JSON 对象"></a>3、JSON 对象</h4><blockquote><p>Python 中有 JSON 库，可以将 Python 对象和 JSON 对象相互转换。</p></blockquote><p><img src="https://static001.geekbang.org/resource/image/9a/43/9a6d6564a64cf2b1c256265eea78c543.png" alt="img"></p><h4 id="4、使用-JSON-数据爬取实战"><a href="#4、使用-JSON-数据爬取实战" class="headerlink" title="4、使用 JSON 数据爬取实战"></a>4、使用 JSON 数据爬取实战</h4><blockquote><p>抓取的页面时动态页面，需要关注 XHR 数据，动态页面是通过原生的 XHR 数据对象发送 HTTP 请求，得到服务器返回的值，在进行处理。（使用谷歌开发工具可以查看）</p></blockquote><h6 id="▉-导包"><a href="#▉-导包" class="headerlink" title="▉ 导包"></a>▉ 导包</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><h6 id="▉-查看-XHR-请求的页数"><a href="#▉-查看-XHR-请求的页数" class="headerlink" title="▉ 查看 XHR 请求的页数"></a>▉ 查看 XHR 请求的页数</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range(开始，结束，步长)  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">23287</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="comment"># XHR 请求的路径</span></span><br><span class="line">    url = <span class="string">'https://www.douban.com/j/search_photo?q='</span> + query + <span class="string">'&amp;limit=20&amp;start='</span> + str(i)</span><br></pre></td></tr></table></figure><h6 id="▉-进行-XHR-请求"><a href="#▉-进行-XHR-请求" class="headerlink" title="▉ 进行 XHR 请求"></a>▉ 进行 XHR 请求</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取服务器返回的文本</span></span><br><span class="line">html = requests.get(url).text</span><br></pre></td></tr></table></figure><h6 id="▉-将-JSON-对象转化为-Python-对象进行解析"><a href="#▉-将-JSON-对象转化为-Python-对象进行解析" class="headerlink" title="▉ 将 JSON 对象转化为 Python 对象进行解析"></a>▉ 将 JSON 对象转化为 Python 对象进行解析</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 JSON 转化为 Python 对象</span></span><br><span class="line">response = json.loads(html,encoding=<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><h6 id="▉-循环遍历出内容"><a href="#▉-循环遍历出内容" class="headerlink" title="▉ 循环遍历出内容"></a>▉ 循环遍历出内容</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># images: [&#123;src: "https://img3.doubanio.com/view/photo/thumb/public/p637714342.jpg", author: "華生",…&#125;,…]</span></span><br><span class="line"><span class="comment"># 获取内容数组</span></span><br><span class="line">response[<span class="string">'images'</span>]</span><br><span class="line"><span class="comment"># 获取数组中的每个对象</span></span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> response[<span class="string">'images'</span>]</span><br><span class="line"><span class="comment"># 获取每个对象中的值</span></span><br><span class="line">image[<span class="string">'src'</span>]</span><br></pre></td></tr></table></figure><h6 id="▉-下载图片"><a href="#▉-下载图片" class="headerlink" title="▉ 下载图片"></a>▉ 下载图片</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(src,id)</span>:</span></span><br><span class="line">    <span class="comment"># 设置路径和图片命名</span></span><br><span class="line">    dir = <span class="string">'./'</span> + str(id) + <span class="string">'.jpg'</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># timeout 设置爬虫超时操作</span></span><br><span class="line">        pic = requests.get(src,timeout = <span class="number">10</span>)</span><br><span class="line">        <span class="comment"># 内置函数 open 用于打开文件(wb 二进制文件只写入)</span></span><br><span class="line">        fp = open(dir,<span class="string">'wb'</span>)</span><br><span class="line">        <span class="comment"># 以二进制方式写入本地文件</span></span><br><span class="line">        fp.write(pic.content)</span><br><span class="line">        fp.close()</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.ConnectionError:</span><br><span class="line">        print(<span class="string">'图片无法下载'</span>)</span><br></pre></td></tr></table></figure><h4 id="5、使用-XPath-爬取数据"><a href="#5、使用-XPath-爬取数据" class="headerlink" title="5、使用 XPath 爬取数据"></a>5、使用 XPath 爬取数据</h4><blockquote><p>网页除了用  XHR 做请求，也会用 JS 做请求，如果用到 JS 做请求，那么我们就用 XPath 做解析。用 XPath 做解析必须 JS 请求后接受到整个页面之后，才能进行解析。</p><p>1）快速定位 XPath 的方法就是使用谷歌插件 XPath Helper 使用快捷键 Ctrl + Shift + X ,直接定位你想要的元素。</p><p>2）使用 lxml 库来进行对获取的网页进行解析。</p></blockquote><h5 id="1、Selenium-模拟测试工具"><a href="#1、Selenium-模拟测试工具" class="headerlink" title="1、Selenium 模拟测试工具"></a>1、Selenium 模拟测试工具</h5><blockquote><p>因为 XPath 的使用必须在页面加载完成才可以，所以使用 Request 获取页面的 HTML 时候，发现 XPath 并不存在，所以必须借助 Selenium 模拟工具（模拟用户操作页面的工具）。</p><p>1）必须下载 Driver 执行程序才能正常打开浏览器。</p></blockquote><h5 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h5><h6 id="▉-加载浏览器程序"><a href="#▉-加载浏览器程序" class="headerlink" title="▉ 加载浏览器程序"></a>▉ 加载浏览器程序</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Chrome(<span class="string">'C:/Program Files (x86)/Google/Chrome/Application/chromedriver.exe'</span>)</span><br></pre></td></tr></table></figure><h6 id="▉-打开指定网址"><a href="#▉-打开指定网址" class="headerlink" title="▉ 打开指定网址"></a>▉ 打开指定网址</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 尽情请求</span><br><span class="line">browser.get(url)</span><br></pre></td></tr></table></figure><h6 id="▉-获取网页源代码"><a href="#▉-获取网页源代码" class="headerlink" title="▉  获取网页源代码"></a>▉  获取网页源代码</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取打开网页的源代码</span><br><span class="line">browser.page_source</span><br><span class="line">// 转化为可以被 lxml 解析的对象</span><br><span class="line">html = etree.HTML(browser.page_source)</span><br></pre></td></tr></table></figure><h6 id="▉-获取到-XPath-匹配的元素"><a href="#▉-获取到-XPath-匹配的元素" class="headerlink" title="▉  获取到 XPath 匹配的元素"></a>▉  获取到 XPath 匹配的元素</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src_xpath = <span class="string">"//div[@class='result']/div[@class='pic']/a[@class='nbg']/img/@src"</span></span><br><span class="line">srcs = html.xpath(src_xpath)</span><br></pre></td></tr></table></figure><h6 id="▉-遍历获取数据"><a href="#▉-遍历获取数据" class="headerlink" title="▉  遍历获取数据"></a>▉  遍历获取数据</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zip 将对象中对应的元素打包成元组</span></span><br><span class="line"><span class="keyword">for</span> src,title <span class="keyword">in</span> zip(srcs,titles):</span><br><span class="line">    print(src)</span><br><span class="line">    download(src,title.text)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/爬虫基本流程.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇文章教你数据分析爬虫的基本流程！&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/python/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="数据分析" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>吃透 JQuery 之【完整篇】</title>
    <link href="http://yoursite.com/2019/04/13/%E5%90%83%E9%80%8F%20JQuery%20%E4%B9%8B%E3%80%90%E5%AE%8C%E6%95%B4%E7%AF%87%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/13/吃透 JQuery 之【完整篇】/</id>
    <published>2019-04-13T05:17:23.146Z</published>
    <updated>2019-04-23T00:05:13.323Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一篇 JQuery 核心内容文章！</p><a id="more"></a><p>[TOC]</p><h2 id="一、选择器"><a href="#一、选择器" class="headerlink" title="一、选择器"></a>一、选择器</h2><h3 id="1、基本选择器"><a href="#1、基本选择器" class="headerlink" title="1、基本选择器"></a>1、基本选择器</h3><h4 id="1-1-按-ID-查找"><a href="#1-1-按-ID-查找" class="headerlink" title="1.1 按 ID 查找"></a>1.1 按 ID 查找</h4><blockquote><p>返回 jQuery 对象，jQuery 对象类似数组，每个元素都是引用了 DOM 节点的对象。<code>[&lt;div id=&quot;abc&quot;&gt;...&lt;/div&gt;]</code>，如果找不到该对象，返回 <code>[]</code> 空对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照 ID 查找</span></span><br><span class="line">&lt;div id=<span class="string">"abc"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>jQuery 对象与 DOM 对象之间的转化：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>);    <span class="comment">// 获取 jQuery 对象 ‘#abc’ 执行了 document.getElementById('#abc');</span></span><br><span class="line"><span class="keyword">var</span> divDOM = div.get(<span class="number">0</span>);<span class="comment">// 获取第一个 DOM 对象</span></span><br><span class="line"><span class="keyword">var</span> anthor = $(divDOM); <span class="comment">// 重新把 DOM 封装为 jQuery 对象</span></span><br></pre></td></tr></table></figure><h4 id="1-2-按-tag-查找"><a href="#1-2-按-tag-查找" class="headerlink" title="1.2 按 tag 查找"></a>1.2 按 tag 查找</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ps = $(<span class="string">'p'</span>);<span class="comment">//获取所有的 &lt;p&gt; 节点</span></span><br><span class="line">ps.length;      <span class="comment">//统计 &lt;p&gt; 节点的个数</span></span><br></pre></td></tr></table></figure><h4 id="1-3-按-class-查找"><a href="#1-3-按-class-查找" class="headerlink" title="1.3 按 class 查找"></a>1.3 按 class 查找</h4><blockquote><p>查找之前要加一个 ‘.’；</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ps = $(<span class="string">'.red'</span>);<span class="comment">// 所有节点包含`class="red"`都将返回</span></span><br></pre></td></tr></table></figure><h4 id="1-4-按属性查找"><a href="#1-4-按属性查找" class="headerlink" title="1.4 按属性查找"></a>1.4 按属性查找</h4><blockquote><p>DOM 节点很多属性，可以根据属性来快速定位节点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出属性为 [name=email] 的节点</span></span><br><span class="line"><span class="keyword">var</span> email = $(<span class="string">'[name^=email]'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按属性查找使用前缀或后缀查找</span></span><br><span class="line"><span class="keyword">var</span> icons = $(<span class="string">'name^= icon'</span>)       <span class="comment">// 找出所有 name 属性值以 icon 开头的 DOM</span></span><br><span class="line"><span class="keyword">var</span> names = $(<span class="string">'[name$=with]'</span>);     <span class="comment">// 找出所有 name 属性值以 with 结尾的 DOM</span></span><br><span class="line"><span class="keyword">var</span> icons = $(<span class="string">'[class^="icon-"]'</span>); <span class="comment">// class 经常使用到</span></span><br></pre></td></tr></table></figure><h4 id="1-5-组合查找"><a href="#1-5-组合查找" class="headerlink" title="1.5 组合查找"></a>1.5 组合查找</h4><blockquote><p>通常选择会选择所有的属性，但是有时我们只选择某标签里的属性进行使用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标签和属性组合</span></span><br><span class="line"><span class="keyword">var</span> emilInput = $(<span class="string">'input[name = email]'</span>);</span><br><span class="line"><span class="comment">// 标签和 Class 组合</span></span><br><span class="line"><span class="keyword">var</span> tr = $(<span class="string">'tr.red'</span>);</span><br></pre></td></tr></table></figure><h4 id="1-6-多项选择器"><a href="#1-6-多项选择器" class="headerlink" title="1.6 多项选择器"></a>1.6 多项选择器</h4><blockquote><p>多个选择器用 <code>，</code> 组合起来一块选。选出来的元素是按照它们在 HTML 中出现的顺序排列的，而且不会有重复元素。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 &lt;p&gt; 和 &lt;div&gt; 都选出来</span></span><br><span class="line">$(<span class="string">'p,div'</span>)</span><br><span class="line"><span class="comment">// 把 &lt;p class="red"&gt; 和 &lt;p class="green"&gt; 都选出来</span></span><br><span class="line">$(<span class="string">'p.red,p.green'</span>)</span><br></pre></td></tr></table></figure><h3 id="2、层级选择器"><a href="#2、层级选择器" class="headerlink" title="2、层级选择器"></a>2、层级选择器</h3><blockquote><p>由于 DOM 的结构是层级结构，经常需要根据层级来进行选择，所以 jQuery 层级选择器更加灵活。</p><p><strong>优点： </strong>层级选择器的好处就是在于缩小了选择的范围，定位父元素后再定位子元素，避免了不相干页面的干扰。</p></blockquote><h4 id="2-1-层级选择器"><a href="#2-1-层级选择器" class="headerlink" title="2.1 层级选择器"></a>2.1 层级选择器</h4><blockquote><p>如果两个 DOM 元素有层级结构，可以使用 <code>$(&#39;ancestor descendant&#39;)</code> 来选择，层级之间需要用空格隔开。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'form[name=upload] input'</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-子选择器（Child-Selector）"><a href="#2-2-子选择器（Child-Selector）" class="headerlink" title="2.2 子选择器（Child Selector）"></a>2.2 子选择器（Child Selector）</h4><blockquote><p>类似层级选择器，但是限定了只能选择父元素的子元素。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul &gt; li'</span>) <span class="comment">//选择 &lt;ul&gt; 父节点下的子节点 &lt;li&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-过滤器（Filter）"><a href="#2-3-过滤器（Filter）" class="headerlink" title="2.3 过滤器（Filter）"></a>2.3 过滤器（Filter）</h4><blockquote><p>过滤器通常不单独使用，附加到选择器中使用，更精确的定位元素。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'ul.lang li'</span>); <span class="comment">// 选出 JavaScript、Python 和 Lua 3个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择节点的第一个节点</span></span><br><span class="line">$(<span class="string">'ul.lang li:first-child'</span>);     <span class="comment">// 仅选出 JavaScript</span></span><br><span class="line"><span class="comment">// 选择最后一个元素</span></span><br><span class="line">$(<span class="string">'ul.lang li:last-child'</span>);      <span class="comment">// 仅选出 Lua</span></span><br><span class="line"><span class="comment">// 选出第 n 的元素，n 从 1 开始</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(2)'</span>);  </span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(even)'</span>); <span class="comment">// 选出序号为偶数的元素</span></span><br><span class="line">$(<span class="string">'ul.lang li:nth-child(odd)'</span>);  <span class="comment">// 选出序号为奇数的元素</span></span><br></pre></td></tr></table></figure><h4 id="2-4-表单相关"><a href="#2-4-表单相关" class="headerlink" title="2.4 表单相关"></a>2.4 表单相关</h4><blockquote><p>针对表单，jQuery 有一组特殊的选择器。</p></blockquote><ul><li><code>:input</code>：可以选择 <code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code> 和 <code>&lt;button&gt;</code>；</li><li><code>:file</code>：可以选择 <code>&lt;input type=&quot;file&quot;&gt;</code> 和 <code>input[type=file]</code> 一样；</li><li><code>:checkbox</code>：可以选择复选框，和 <code>input[type=checkbox]</code> 一样；</li><li><code>:radio</code>：可以选择单选框和 <code>input[type=radio]</code> 一样；</li><li><code>:focus</code>：可以选择当前输入焦点的元素，例如把光标放到一个 <code>&lt;input&gt;</code> 上，用 <code>$(&#39;input:focus&#39;)</code> 就可以选出；</li><li><code>:checked</code>：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如<code>$(&#39;input[type=radio]:checked&#39;)</code>；</li><li><code>:enabled</code>：可以选择可以正常输入的 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>  等，也就是没有灰掉的输入；</li><li><code>:disabled</code>：和 <code>:enabled</code> 正好相反，选择那些不能输入的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div:visible'</span>); <span class="comment">// 所有可见的div</span></span><br><span class="line">$(<span class="string">'div:hidden'</span>); <span class="comment">// 所有隐藏的div</span></span><br></pre></td></tr></table></figure><h3 id="3、查找和过滤"><a href="#3、查找和过滤" class="headerlink" title="3、查找和过滤"></a>3、查找和过滤</h3><blockquote><p>最常用的是在某个节点的所有子节点中查找，使用 find 方法，接受一个选择器进行选择。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"lang"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"js dy"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dy"</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"swift"</span>&gt;</span>Swift<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"dy"</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">name</span>=<span class="string">"haskell"</span>&gt;</span>Haskell<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'ul.lang'</span>);               <span class="comment">// 获得 &lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> dy = ul.find(<span class="string">'.dy'</span>);             <span class="comment">// 获得 JavaScript, Python, Scheme</span></span><br><span class="line"><span class="keyword">var</span> swf = ul.find(<span class="string">'#swift'</span>);         <span class="comment">// 获得 Swift</span></span><br><span class="line"><span class="keyword">var</span> hsk = ul.find(<span class="string">'[name=haskell]'</span>); <span class="comment">// 获得 Haskell</span></span><br></pre></td></tr></table></figure><p>向上查找使用 <code>parent()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swf = $(<span class="string">'#swift'</span>); <span class="comment">// 获得Swift</span></span><br><span class="line"><span class="keyword">var</span> parent = swf.parent(); <span class="comment">// 获得 Swift 的上层节点 &lt;ul&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = swf.parent(<span class="string">'.red'</span>); <span class="comment">// 获得 Swift 的上层节点 &lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空 jQuery 对象</span></span><br></pre></td></tr></table></figure><p>同级元素使用 <code>next（）</code> 和 <code>prev（）</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> swift = $(<span class="string">'#swift'</span>);</span><br><span class="line"></span><br><span class="line">swift.next(); <span class="comment">// Scheme</span></span><br><span class="line">swift.next(<span class="string">'[name=haskell]'</span>); <span class="comment">// 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]</span></span><br><span class="line"></span><br><span class="line">swift.prev(); <span class="comment">// Python</span></span><br><span class="line">swift.prev(<span class="string">'.dy'</span>); <span class="comment">// Python，因为 Python 同时符合过滤器条件.dy</span></span><br></pre></td></tr></table></figure><h4 id="3-1-过滤"><a href="#3-1-过滤" class="headerlink" title="3.1 过滤"></a>3.1 过滤</h4><blockquote><p>函数式编程中的 map、filter类似，jQuery 也有自己类似的方法。</p></blockquote><p>filter() 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>);<span class="comment">// 拿到 JavaScript, Python, Swift, Scheme 和 Haskell</span></span><br><span class="line"><span class="keyword">var</span> a = langs.filter(<span class="string">'.dy'</span>) <span class="comment">// 拿到 JavaScript, Python, Scheme</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个函数</span></span><br><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到 JavaScript, Python, Swift, Scheme 和 Haskell</span></span><br><span class="line">langs.filter(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 函数内部的 this 被绑定为 DOM 对象，不是 jQuery 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML.indexOf(<span class="string">'S'</span>) === <span class="number">0</span>; <span class="comment">// 检查每个子节点，返回 S 开头的节点</span></span><br><span class="line">&#125;</span><br><span class="line">); <span class="comment">// 拿到Swift, Scheme</span></span><br></pre></td></tr></table></figure><p>map() 方法：把一个  jQuery 对象包含的若干 DOM 节点转化为其他对象 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>); <span class="comment">// 拿到 JavaScript, Python, Swift, Scheme 和 Haskell</span></span><br><span class="line"><span class="keyword">var</span> arr = langs.map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML;</span><br><span class="line">&#125;).get(); </span><br><span class="line"><span class="comment">// 用 get() 拿到包含 string 的 Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell']</span></span><br></pre></td></tr></table></figure><p>一个jQuery对象如果包含了不止一个DOM节点，<code>first()</code>、<code>last()</code>和<code>slice()</code>方法可以返回一个新的 jQuery对象，把不需要的 DOM 节点去掉： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> langs = $(<span class="string">'ul.lang li'</span>);  <span class="comment">// 拿到 JavaScript, Python, Swift, Scheme 和 Haskell</span></span><br><span class="line"><span class="keyword">var</span> js = langs.first();       <span class="comment">// JavaScript，相当于 $('ul.lang li:first-child')</span></span><br><span class="line"><span class="keyword">var</span> haskell = langs.last();   <span class="comment">// Haskell, 相当于 $('ul.lang li:last-child')</span></span><br><span class="line"><span class="keyword">var</span> sub = langs.slice(<span class="number">2</span>, <span class="number">4</span>);  <span class="comment">// Swift, Scheme 参数和数组的 slice() 方法一致</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var inputs = $(&apos;#test-form :input&apos;).not(&apos;button&apos;);</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">inputs.filter(function()&#123;</span><br><span class="line"> if(this.type !== &quot;radio&quot; || this.checked);</span><br><span class="line"> obj[this.name] = this.value;</span><br><span class="line">&#125;)</span><br><span class="line">json = JSON.stringify(obj);</span><br></pre></td></tr></table></figure><h2 id="二、操作-DOM"><a href="#二、操作-DOM" class="headerlink" title="二、操作 DOM"></a>二、操作 DOM</h2><h3 id="1-操作-DOM"><a href="#1-操作-DOM" class="headerlink" title="1. 操作 DOM"></a>1. 操作 DOM</h3><h4 id="1-1-修改-Text-和-HTML"><a href="#1-1-修改-Text-和-HTML" class="headerlink" title="1.1 修改 Text 和 HTML"></a>1.1 修改 Text 和 HTML</h4><blockquote><p>jQuery 对象的 text() 和 html() 方法分别获取节点文本和原始的 HTML 文本。</p><p>1）jQuery 可以获取一组数据进行统一设置文本。</p><p>2）jQuery 如果不存在结点对象，将不会报错。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"test-ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"js"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">name</span>=<span class="string">"book"</span>&gt;</span>Java &amp;amp; JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文本</span></span><br><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).text(); <span class="comment">// 'Java &amp; JavaScript'</span></span><br><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).html(); <span class="comment">// 'Java &amp;amp; JavaScript'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文本</span></span><br><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).text(<span class="string">'JavaScript &amp; ECMAScript'</span>); </span><br><span class="line">$(<span class="string">'#test-ul li[name=book]'</span>).html(<span class="string">'&lt;span style="color: red"&gt;JavaScript&lt;/span&gt;'</span>);</span><br></pre></td></tr></table></figure><h4 id="1-2-修改-CSS"><a href="#1-2-修改-CSS" class="headerlink" title="1.2 修改 CSS"></a>1.2 修改 CSS</h4><blockquote><p>调用 jQuery 对象的 <code>css(&quot;name&quot;,&quot;value&quot;)</code> 方法。</p><p>1）CSS 属性可以使用 <code>&#39;background-color&#39;</code> 和  <code>&#39;backgroundColor&#39;</code>两种格式。</p><p>2）css() 方法将作用于 DOM 节点的 style 属性，具有最高的优先级。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：jQuery 的所有方法返回的是对象，可以链式调用。</span></span><br><span class="line">$(<span class="string">'#test-css li.dy&gt;span'</span>).css(<span class="string">'background-color'</span>, <span class="string">'#ffd351'</span>).css(<span class="string">'color'</span>, <span class="string">'red'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>修改 <code>class</code> 属性，jQuery 提供一下方法：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test'</span>);</span><br><span class="line">div.hasClass(<span class="string">'container'</span>);<span class="comment">// 判断该结点 class 是否包含 container 属性</span></span><br><span class="line">div.addClass(<span class="string">'container'</span>);<span class="comment">// 添加 container 这个 Class</span></span><br><span class="line">div.removeClass(<span class="string">'container'</span>); <span class="comment">// 删除 container 这个 Class</span></span><br></pre></td></tr></table></figure><h4 id="1-3-显示和隐藏-DOM"><a href="#1-3-显示和隐藏-DOM" class="headerlink" title="1.3 显示和隐藏 DOM"></a>1.3 显示和隐藏 DOM</h4><blockquote><p>显示或隐藏 DOM 需要设置 CSS 属性的 display 属性。</p><p>1）隐藏 DOM 需要设置 CSS 的 display 属性为 none。</p><p>2）显示 DOM 需要知道 display 之前的属性（block,inline）。</p><p>3）jQuery 对象提供的 show() 和 hide() 方法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">'div'</span>);</span><br><span class="line">a.hide(); <span class="comment">// 隐藏</span></span><br><span class="line">a.show(); <span class="comment">// 显示(并没有删除 DOM 结点，影响了 DOM 结点的显示)</span></span><br></pre></td></tr></table></figure><h4 id="1-4-获取-DOM-信息"><a href="#1-4-获取-DOM-信息" class="headerlink" title="1.4 获取 DOM 信息"></a>1.4 获取 DOM 信息</h4><blockquote><p>无序针对特定的浏览器编写特定的代码，jQuery 对象的方法直接获取。</p><p>1）操作 DOM 节点的属性：<code>attr()</code> 和 <code>removeAttr()</code> 方法。</p><p>2）操作 H5 中无值属性：<code>prop()</code> 但会 <code>boolean</code> 值，也可以用 <code>is</code> 判断。  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器可视窗口大小:</span></span><br><span class="line">$(<span class="built_in">window</span>).width(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="built_in">window</span>).height(); <span class="comment">// 600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML文档大小:</span></span><br><span class="line">$(<span class="built_in">document</span>).width(); <span class="comment">// 800</span></span><br><span class="line">$(<span class="built_in">document</span>).height(); <span class="comment">// 3500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个div的大小:</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.width(); <span class="comment">// 600</span></span><br><span class="line">div.height(); <span class="comment">// 300</span></span><br><span class="line">div.width(<span class="number">400</span>); <span class="comment">// 设置CSS属性 width: 400px，是否生效要看CSS是否有效</span></span><br><span class="line">div.height(<span class="string">'200px'</span>); <span class="comment">// 设置CSS属性 height: 200px，是否生效要看CSS是否有效</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-div'</span>);</span><br><span class="line">div.attr(<span class="string">'data'</span>);<span class="comment">// undefined 属性值不存在</span></span><br><span class="line">div.attr(<span class="string">'name'</span>);<span class="comment">// test 获取属性值</span></span><br><span class="line">div.attr(<span class="string">'name'</span>,<span class="string">'Hello'</span>); <span class="comment">// 设置属性值</span></span><br><span class="line">div.removeAttr(<span class="string">'name'</span>); <span class="comment">//删除 name 属性</span></span><br><span class="line">div.attr(<span class="string">'name'</span>);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"test-radio"</span> type=<span class="string">"radio"</span> name=<span class="string">"test"</span> checked value=<span class="string">"1"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> radio = $(<span class="string">'#test-radio'</span>);</span><br><span class="line">radio.prop(<span class="string">'checked'</span>); <span class="comment">// true</span></span><br><span class="line">radio.is(<span class="string">':checked'</span>); <span class="comment">// true</span></span><br><span class="line">is(<span class="string">':selected'</span>);<span class="comment">// 下拉属性判断</span></span><br></pre></td></tr></table></figure><h4 id="1-5-操作表单"><a href="#1-5-操作表单" class="headerlink" title="1.5 操作表单"></a>1.5 操作表单</h4><blockquote><p>对于 jQuery 操作表单，统一使用 <code>val()</code> 方法获取和设置对应的 <code>value</code> 属性：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    &lt;input id="test-input" name="email" value=""&gt;</span></span><br><span class="line"><span class="comment">    &lt;select id="test-select" name="city"&gt;</span></span><br><span class="line"><span class="comment">        &lt;option value="BJ" selected&gt;Beijing&lt;/option&gt;</span></span><br><span class="line"><span class="comment">        &lt;option value="SH"&gt;Shanghai&lt;/option&gt;</span></span><br><span class="line"><span class="comment">        &lt;option value="SZ"&gt;Shenzhen&lt;/option&gt;</span></span><br><span class="line"><span class="comment">    &lt;/select&gt;</span></span><br><span class="line"><span class="comment">    &lt;textarea id="test-textarea"&gt;Hello&lt;/textarea&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    input = $(<span class="string">'#test-input'</span>),</span><br><span class="line">    select = $(<span class="string">'#test-select'</span>),</span><br><span class="line">    textarea = $(<span class="string">'#test-textarea'</span>);</span><br><span class="line"></span><br><span class="line">input.val(); <span class="comment">// 'test'</span></span><br><span class="line">input.val(<span class="string">'abc@example.com'</span>); <span class="comment">// 文本框的内容已变为abc@example.com</span></span><br><span class="line"></span><br><span class="line">select.val(); <span class="comment">// 'BJ'</span></span><br><span class="line">select.val(<span class="string">'SH'</span>); <span class="comment">// 选择框已变为Shanghai</span></span><br><span class="line"></span><br><span class="line">textarea.val(); <span class="comment">// 'Hello'</span></span><br><span class="line">textarea.val(<span class="string">'Hi'</span>); <span class="comment">// 文本区域已更新为'Hi'</span></span><br></pre></td></tr></table></figure><h3 id="2、修改-DOM"><a href="#2、修改-DOM" class="headerlink" title="2、修改 DOM"></a>2、修改 DOM</h3><blockquote><p>原生的浏览器 API 修改 DOM 需要根据不同的浏览器进行写不同的代码。</p></blockquote><h4 id="2-1-添加-DOM"><a href="#2-1-添加-DOM" class="headerlink" title="2.1 添加 DOM"></a>2.1 添加 DOM</h4><blockquote><p>添加 DOM 结点除了使用 <code>html()</code> 方法外还可以使用 <code>append()</code> 方法。</p><p>1) append() 方法可以接收一下几个参数：</p><ul><li>DOM 对象</li><li>jQuery 对象</li><li>函数对象(该函数要返回一个字符串、DOM 对象、jQuery对象)</li></ul><p>2）<code>append()</code> 把DOM添加到最后，<code>prepend()</code> 则把 DOM 添加到最前。 </p><p>3）<code>after()</code> 方法和 <code>before()</code> 方法将 DOM 插入指定位置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*&lt;div id="test-div"&gt;</span></span><br><span class="line"><span class="comment">    &lt;ul&gt;</span></span><br><span class="line"><span class="comment">        &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">        &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">        &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">    &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt;*/</span></span><br><span class="line"><span class="keyword">var</span> ul = $(<span class="string">'#test-div&gt;ul'</span>);</span><br><span class="line">ul.append(<span class="string">'&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建DOM对象:</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">ps.innerHTML = <span class="string">'&lt;span&gt;Pascal&lt;/span&gt;'</span>;</span><br><span class="line"><span class="comment">// 添加DOM对象:</span></span><br><span class="line">ul.append(ps);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加jQuery对象:</span></span><br><span class="line">ul.append($(<span class="string">'#scheme'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加函数对象:</span></span><br><span class="line">ul.append(<span class="function"><span class="keyword">function</span> (<span class="params">index, html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;li&gt;&lt;span&gt;Language - '</span> + index + <span class="string">'&lt;/span&gt;&lt;/li&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注意：jQuery的 <code>append()</code> 可能作用于一组 DOM 节点，只有传入函数才能针对每个 DOM 生成不同的子节点。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = $(<span class="string">'#test-div&gt;ul&gt;li:first-child'</span>);</span><br><span class="line">js.after(<span class="string">'&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-删除节点"><a href="#2-2-删除节点" class="headerlink" title="2.2 删除节点"></a>2.2 删除节点</h4><blockquote><p>拿到 jQuery 对象之后，直接执行 <code>remove()</code> 方法可以删除一组或单个节点。</p></blockquote><h3 id="3、事件"><a href="#3、事件" class="headerlink" title="3、事件"></a>3、事件</h3><blockquote><p>1) 浏览器获取到鼠标事件，自动在对应的 DOM 结点上触发响应的时间，如果该结点绑定了函数，函数就触发响应的事件，然后调用绑定了对应的 javascript 处理函数，该函数就会自动调用。</p><p>2) 不同浏览器的代码是不一样的，jQuery 屏蔽了不同浏览器的差异。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-1-鼠标事件"><a href="#3-1-鼠标事件" class="headerlink" title="3.1 鼠标事件"></a>3.1 鼠标事件</h4><ul><li>click : 单击事件</li><li>dbclick: 双击事件</li><li>mouseenter: 鼠标进入时触发</li><li>mouseleace: 鼠标离开时触发</li><li>mousemove: 鼠标在 DOM 内部移动时触发</li><li>hover: 鼠标进入和退出时触发两个函数，相当于 mouseenter 加上 mouseleave。</li></ul><h4 id="3-2-键盘事件"><a href="#3-2-键盘事件" class="headerlink" title="3.2 键盘事件"></a>3.2 键盘事件</h4><blockquote><p>键盘事件仅作用在当前焦点 DOM 上，通常是 <code>&lt;imput&gt;</code> 和 <code>&lt;textarea&gt;</code>。</p></blockquote><ul><li>keydown：键盘按下时触发</li><li>keyup：键盘松开时触发</li><li>keypress：按一次键后触发</li></ul><h4 id="3-3-其他事件"><a href="#3-3-其他事件" class="headerlink" title="3.3 其他事件"></a>3.3 其他事件</h4><ul><li>focus：当 DOM 获取焦点时触发；</li><li>blur：当 DOM 失去焦点时触发；</li><li>change：当 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 或 <code>&lt;textarea&gt;</code> 的内容改变时触发；</li><li>submit：当 <code>&lt;form&gt;</code> 提交时触发；</li><li>ready：当页面被载入并且 DOM 树完成初始化后触发（仅作用于 document 对象）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-4-事件参数"><a href="#3-4-事件参数" class="headerlink" title="3.4 事件参数"></a>3.4 事件参数</h4><blockquote><p>有些事件需要传入参数，获取到按键的值和鼠标的位置。所有事件都传入 Event 对象作为参数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#testMouseMoveDiv'</span>).mousemove(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#testMouseMoveSpan'</span>).text(<span class="string">'pageX = '</span> + e.pageX + <span class="string">', pageY = '</span> + e.pageY);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-5-取消绑定"><a href="#3-5-取消绑定" class="headerlink" title="3.5  取消绑定"></a>3.5  取消绑定</h4><blockquote><p>一个绑定的事件可以被解除，通过 <code>off（‘click’, function）</code> 实现：</p><p>1) off 无参会一次性移除已绑定的所有类型的事件处理函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.click(hello); <span class="comment">// 绑定事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10秒钟后解除绑定:</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a.off(<span class="string">'click'</span>, hello);</span><br><span class="line">&#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h4 id="3-6-事件触发条件"><a href="#3-6-事件触发条件" class="headerlink" title="3.6 事件触发条件"></a>3.6 事件触发条件</h4><blockquote><p>事件的触发是由用户操作引发的。</p><p>1）change 事件的触发是由用户改变文本框内容触发的，在 js 修改文本框内容则不会触发。</p><p>2）用代码触发 change 事件，可以直接调用无参数的 change() 方法来触发事件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.change(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'changed...'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = $(<span class="string">'#test-input'</span>);</span><br><span class="line">input.val(<span class="string">'change it!'</span>);</span><br><span class="line">input.change(); <span class="comment">// 触发change事件,相当于 input.trigger('change')</span></span><br></pre></td></tr></table></figure><h4 id="3-7-浏览器安全限制"><a href="#3-7-浏览器安全限制" class="headerlink" title="3.7 浏览器安全限制"></a>3.7 浏览器安全限制</h4><blockquote><p>有些 javascript 代码只有用户触发才能执行，如 <code>window.open()</code> 函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法弹出新窗口，将被浏览器屏蔽:</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.open(<span class="string">'/'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4、AJAX"><a href="#4、AJAX" class="headerlink" title="4、AJAX"></a>4、AJAX</h3><blockquote><p>jQuery 的 AJAX 不用针对不同浏览器写不同代码，代码也得到很大的简化。</p></blockquote><h4 id="4-1-ajax"><a href="#4-1-ajax" class="headerlink" title="4.1 ajax"></a>4.1 ajax</h4><blockquote><p>jQuery 在全局对象中（$）绑定了 ajax() 函数。</p><p>1）<code>ajax(url,settings)</code> 函数需要接收一个 URL 和一个可选的 settings 对象</p></blockquote><ul><li><p><strong>async </strong>：默认 true</p></li><li><p><strong>method： </strong>发送的 Method ，默认为 <code>GET</code>。</p></li><li><p><strong>contentType： </strong>发送的 POST 格式，默认值为 <code>&#39;application/x-www-form-urlencoded; charset=UTF-8&#39;</code></p><p>其余格式为 <code>text/plain</code>、<code>application/json</code>；</p></li><li><p><strong>data： </strong>发送的数据，可以是字符串、数组或 object。如果是 GET 请求，data 转换为 query 附加到 URL 上。如果是 POST 根据 contentType 将数据序列化成合适的格式；</p></li><li><p><strong>headers： </strong>发送额外的 HTTP 头，必须是一个 object;</p></li><li><p><strong>dataType：</strong>接受的数据格，<code>html</code> 、<code>xml</code>、<code>json</code> 、<code>text</code> 等，没有设置的情况下根据 contentType 来定义。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(<span class="string">'/api/categories'</span>,&#123;</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>响应方式：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(<span class="string">'/api/categories'</span>, &#123;</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'成功, 收到的数据: '</span> + <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;).fail(<span class="function"><span class="keyword">function</span> (<span class="params">xhr, status</span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'失败: '</span> + xhr.status + <span class="string">', 原因: '</span> + status);</span><br><span class="line">&#125;).always(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ajaxLog(<span class="string">'请求完成: 无论成功或失败都会调用'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-2-get-方法"><a href="#4-2-get-方法" class="headerlink" title="4.2 get 方法"></a>4.2 get 方法</h4><blockquote><p>最常见的写法；第二个参数会被拼接到 url 后边</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.get(url, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url?name=Bob%<span class="number">20</span>Lee&amp;check=<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="4-3-post-方法"><a href="#4-3-post-方法" class="headerlink" title="4.3 post 方法"></a>4.3 post 方法</h4><blockquote><p>虽然写法和 GET 类似，但是第二个参数被序列化了为 <code>application/x-www-form-urlencoded</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.post(<span class="string">'/path/to/resource'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-4-getJSON-对象"><a href="#4-4-getJSON-对象" class="headerlink" title="4.4 getJSON 对象"></a>4.4 getJSON 对象</h4><blockquote><p>通过 <code>getJSON()</code> 方法来快速通过 GET 获取一个 JSON 对象：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.getJSON(<span class="string">'/path/to/resource'</span>, &#123;</span><br><span class="line">    name: <span class="string">'Bob Lee'</span>,</span><br><span class="line">    check: <span class="number">1</span></span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// data已经被解析为JSON对象了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="4-5-安全限制"><a href="#4-5-安全限制" class="headerlink" title="4.5 安全限制"></a>4.5 安全限制</h4><blockquote><p>关于跨域，jQuery 也是有限制的，和 JavaScript 一样。如果跨域加载数据，设置 <code>jsonp：‘callback’</code> ，这样就可以实现 jQuery 加载跨域数据了。</p></blockquote><h3 id="5、动画"><a href="#5、动画" class="headerlink" title="5、动画"></a>5、动画</h3><blockquote><p>jQuery 封装的动画非常简单，只需要一行代码就可以搞定。</p></blockquote><h4 id="5-1-show-hide"><a href="#5-1-show-hide" class="headerlink" title="5.1 show/hide"></a>5.1 show/hide</h4><blockquote><p>无参的<code>show()</code> <code>hide()</code> 方法用于隐藏、显示元素，传入一个时间参数就会变成动画。</p><p>1）参数可以是<code>&#39;slow&#39;</code>，<code>&#39;fast&#39;</code> 。</p><p>2）<code>toggle()</code> 根据当前的状态来决定显示还是隐藏。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#id'</span>);</span><br><span class="line">div.hide(<span class="number">3000</span>); <span class="comment">// 在 3 秒钟内逐渐消失</span></span><br></pre></td></tr></table></figure><h4 id="5-2-slideUp-slideDown"><a href="#5-2-slideUp-slideDown" class="headerlink" title="5.2 slideUp / slideDown"></a>5.2 slideUp / slideDown</h4><blockquote><p>这两个方法是垂直方向消失和隐藏的。</p><p>1) <code>slideToggle()</code> 根据状态来决定。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#id'</span>);</span><br><span class="line">div.slideUp(<span class="number">3000</span>); <span class="comment">// 在3秒钟内逐渐向上消失</span></span><br></pre></td></tr></table></figure><h4 id="5-3-fadeIn-fadeOut"><a href="#5-3-fadeIn-fadeOut" class="headerlink" title="5.3 fadeIn/fadeOut"></a>5.3 fadeIn/fadeOut</h4><blockquote><p>这两个方法的动画就是淡入淡出，通过设置 <code>opacity</code> 来实现的。</p><p>1）<code>fadeToggle()</code> 决定是否状态是否改变。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#id'</span>);</span><br><span class="line">div.fadeOut(<span class="string">'slow'</span>); <span class="comment">// 在 0.6 秒内淡出</span></span><br></pre></td></tr></table></figure><h4 id="5-4-自定义动画"><a href="#5-4-自定义动画" class="headerlink" title="5.4 自定义动画"></a>5.4 自定义动画</h4><blockquote><p><code>animate()</code> 可以实现自定义动画，传入的参数就是 DOM 元素最终的 CSS 状态和时间。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#id'</span>);</span><br><span class="line">div.animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.25</span>,</span><br><span class="line">    width: <span class="string">'256px'</span>,</span><br><span class="line">    height: <span class="string">'256px'</span></span><br><span class="line">&#125;, <span class="number">3000</span>); <span class="comment">// 在 3 秒钟内 CSS 过渡到设定值</span></span><br></pre></td></tr></table></figure><blockquote><p>第三个参数就是传入一个函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#test-animate'</span>);</span><br><span class="line">div.animate(&#123;</span><br><span class="line">    opacity: <span class="number">0.25</span>,</span><br><span class="line">    width: <span class="string">'256px'</span>,</span><br><span class="line">    height: <span class="string">'256px'</span></span><br><span class="line">&#125;, <span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'动画已结束'</span>);</span><br><span class="line">    <span class="comment">// 恢复至初始状态:</span></span><br><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">'opacity'</span>, <span class="string">'1.0'</span>).css(<span class="string">'width'</span>, <span class="string">'128px'</span>).css(<span class="string">'height'</span>, <span class="string">'128px'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5-5-串行动画"><a href="#5-5-串行动画" class="headerlink" title="5.5 串行动画"></a>5.5 串行动画</h4><blockquote><p>动画可以串行执行，通过 <code>delay（）</code>  方法可以实现暂停，可以实现更复杂的动画效果。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">'#id'</span>);</span><br><span class="line"><span class="comment">// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小</span></span><br><span class="line">div.slideDown(<span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'256px'</span>,</span><br><span class="line">       height: <span class="string">'256px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>)</span><br><span class="line">   .delay(<span class="number">1000</span>)</span><br><span class="line">   .animate(&#123;</span><br><span class="line">       width: <span class="string">'128px'</span>,</span><br><span class="line">       height: <span class="string">'128px'</span></span><br><span class="line">   &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-动画设置失败"><a href="#5-6-动画设置失败" class="headerlink" title="5.6 动画设置失败"></a>5.6 动画设置失败</h4><blockquote><p>1）有的动画没有效果，jQuery 动画的原理是逐渐改变 CSS 的值。很多元素不是 block 性质的 DOM 元素，对它们设置有的属性不起作用，所以没有动画效果。</p><p>2）jQuery也没有实现对<code>background-color</code>的动画效果，用<code>animate()</code>设置<code>background-color</code>也没有效果 。只能借助 CSS3 动画。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇 JQuery 核心内容文章！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JQuery" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/JQuery/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JQuery" scheme="http://yoursite.com/tags/JQuery/"/>
    
  </entry>
  
</feed>
