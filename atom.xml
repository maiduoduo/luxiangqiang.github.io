<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小鹿的博客</title>
  
  <subtitle>Ordinary life , Unwilling to be ordinary code farmers</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-09T13:01:54.097Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小鹿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>玩转 ES6 之【Generator生成器】</title>
    <link href="http://yoursite.com/2019/06/09/%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90Generator%E7%94%9F%E6%88%90%E5%99%A8%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/09/玩转 ES6 之【Generator生成器】/</id>
    <published>2019-06-09T11:46:25.468Z</published>
    <updated>2019-06-09T13:01:54.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用 ES6 的生成器可以优雅的实现异步操作！</p><a id="more"></a><h3 id="一、生成器函数"><a href="#一、生成器函数" class="headerlink" title="一、生成器函数"></a>一、生成器函数</h3><blockquote><p>1、使用生成器函数可以生成一组值的序列，每个值的生成是基于每次请求的，并不同于标准函数立即生成。</p><p>2、调用生成器不会直接执行，而是通过叫做<strong>迭代器</strong>的对象控制生成器执行。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"3"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> WeaponGenerator())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><h3 id="二、使用迭代器控制生成器"><a href="#二、使用迭代器控制生成器" class="headerlink" title="二、使用迭代器控制生成器"></a>二、使用迭代器控制生成器</h3><h4 id="2-1-迭代器的使用"><a href="#2-1-迭代器的使用" class="headerlink" title="2.1 迭代器的使用"></a>2.1 迭代器的使用</h4><p>1、通过调用生成器返回一个迭代器对象，用来控制生成器的执行。</p><p>2、调用迭代器的 next 方法向生成器请求一个值。</p><p>3、请求的结果返回一个对象，对象中包含一个 value 值和 done 布尔值，告诉我们生成器是否还会生成值。</p><p>4、如果没有可执行的代码，生成器就会返回一个 undefined 值，表示整个生成器已经完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"3"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = WeaponGenerator();</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br></pre></td></tr></table></figure><h4 id="2-2-生成器的状态"><a href="#2-2-生成器的状态" class="headerlink" title="2.2 生成器的状态"></a>2.2 生成器的状态</h4><p>1、每当代码执行到 yield 属性，就会生成一个中间值，返回一个对象。</p><p>2、每当生成一个值后，生成器就会非阻塞的挂起执行，等待下一次值的请求。</p><p>3、再次调用 next 方法，将生成器从挂起状态唤醒，中断执行的生成器从上次离开的位置继续执行。</p><p>4、直到遇到下一个 yield ，生成器挂起。</p><p>5、 当执行到没有可执行代码了，就会返回一个结果对象，value 的值为 undefined , done 的值为 true，生成器执行完成。</p><h4 id="2-3-将执行权交给下一个生成器"><a href="#2-3-将执行权交给下一个生成器" class="headerlink" title="2.3 将执行权交给下一个生成器"></a>2.3 将执行权交给下一个生成器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"4"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"5"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"6"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"3"</span>;</span><br><span class="line">    <span class="keyword">yield</span> *XiaoLuGenerator(); <span class="comment">// 将执行权交给另一个生成器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> WeaponGenerator())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、生成器的应用"><a href="#三、生成器的应用" class="headerlink" title="三、生成器的应用"></a>三、生成器的应用</h3><h4 id="1、为对象赋唯一-ID-标识"><a href="#1、为对象赋唯一-ID-标识" class="headerlink" title="1、为对象赋唯一 ID 标识"></a>1、为对象赋唯一 ID 标识</h4><blockquote><p>当创建某些对象时，需要为对象赋一个唯一的 ID 值。通常使用一个全局计时器变量，但是这种写法很容易使代码变的混乱。所以使用生成器可以实现这个功能。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span>* <span class="title">IdGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">yield</span> ++id;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> idIterator = IdGenerator();</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj4 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj5 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br></pre></td></tr></table></figure><h4 id="2、遍历-DOM-树"><a href="#2、遍历-DOM-树" class="headerlink" title="2、遍历 DOM 树"></a>2、遍历 DOM 树</h4><blockquote><p>通常遍历 DOM 树最简单的方法是使用递归，但是使用生成器也可以进行遍历代码。很多情况下，使用迭代器比使用递归更要自然。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"xiaolu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Spam<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">DomTraversal</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1、打印当前元素</span></span><br><span class="line">    <span class="keyword">yield</span> element;</span><br><span class="line">    <span class="comment">// 2、寻找当前元素的子元素</span></span><br><span class="line">    element = element.firstElementChild;</span><br><span class="line">    <span class="comment">// 3、循环遍历子元素（子元素可能多个）</span></span><br><span class="line">    <span class="keyword">while</span> (element) &#123;</span><br><span class="line">        <span class="comment">// 4、子元素可能还有子元素（递归）</span></span><br><span class="line">        <span class="keyword">yield</span>* DomTraversal(element);</span><br><span class="line">        <span class="comment">// 5、遍历兄弟元素的子元素</span></span><br><span class="line">        element = element.nextElementSibling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subTree = <span class="built_in">document</span>.getElementById(<span class="string">"xiaolu"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> node <span class="keyword">of</span> DomTraversal(subTree))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、生成器数据交互"><a href="#四、生成器数据交互" class="headerlink" title="四、生成器数据交互"></a>四、生成器数据交互</h3><blockquote><p>生成器中可以进行双向通信，通过 yield 可以返回值，也可以通过 next 传入值。</p><p><strong>注意：</strong>如果没有等待的 yield 表达式，也就是没有值可以应用，所以第一次的 yield 无法传值。</p></blockquote><h4 id="1、构造函数的初始化"><a href="#1、构造函数的初始化" class="headerlink" title="1、构造函数的初始化"></a>1、构造函数的初始化</h4><blockquote><p>生成器可以像其他函数一样接受标准的参数，并在生成器内使用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="keyword">yield</span> (<span class="string">"4"</span>+action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = XiaoLuGenerator(<span class="string">"3333"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br></pre></td></tr></table></figure><h4 id="2、next-方法传递值"><a href="#2、next-方法传递值" class="headerlink" title="2、next 方法传递值"></a>2、next 方法传递值</h4><blockquote><p>next 传递的参数是作为上一执行的结果返回。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="keyword">yield</span> (<span class="string">"4"</span>+action);</span><br><span class="line">    <span class="keyword">yield</span> (<span class="string">"next"</span> + n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = XiaoLuGenerator(<span class="string">"3333"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next(<span class="string">"嘿嘿"</span>));</span><br><span class="line"><span class="comment">// &#123;value: "43333", done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: "next嘿嘿", done: false&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3、抛出异常"><a href="#3、抛出异常" class="headerlink" title="3、抛出异常"></a>3、抛出异常</h4><blockquote><p>生成器除了有一个 next 方法，还有一个 throw 方法来抛出异常，当生成器内部发生错误时，我们可以通过抛出异常来抛出错误。抛出的错误就会被 try-catch 捕获。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> n = <span class="keyword">yield</span> <span class="string">"4"</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"抛出错误！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = XiaoLuGenerator(<span class="string">"3333"</span>);</span><br><span class="line">weapon.next()</span><br><span class="line">weapon.throw(<span class="string">"错误!"</span>)</span><br></pre></td></tr></table></figure><h3 id="五、生成器的内部结构"><a href="#五、生成器的内部结构" class="headerlink" title="五、生成器的内部结构"></a>五、生成器的内部结构</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 ES6 的生成器可以优雅的实现异步操作！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/ES6/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【闭包和作用域】</title>
    <link href="http://yoursite.com/2019/06/09/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E9%97%AD%E5%8C%85%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/09/前端进阶深入系列之【闭包和作用域】/</id>
    <published>2019-06-09T00:55:28.201Z</published>
    <updated>2019-06-09T02:30:56.506Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深入闭包以及闭包的应用！</p><a id="more"></a><h3 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h3><p><strong>1、作用域：</strong>限定变量和函数的可用性的范围叫做<strong>作用域</strong>。</p><p><strong>2、作用域链：</strong>保证对<strong>执行函数</strong>有权访问的所有变量和函数的<strong>有序访问</strong>。</p><h3 id="二、理解闭包？"><a href="#二、理解闭包？" class="headerlink" title="二、理解闭包？"></a>二、理解闭包？</h3><h4 id="1、什么是闭包？"><a href="#1、什么是闭包？" class="headerlink" title="1、什么是闭包？"></a>1、什么是闭包？</h4><blockquote><p>闭包是在函数内可以访问并操作函数外部的变量。只要变量或函数存在于声明的函数的作用域内，闭包就可以使用函数访问到这些变量。</p></blockquote><h4 id="2、如何理解闭包？"><a href="#2、如何理解闭包？" class="headerlink" title="2、如何理解闭包？"></a>2、如何理解闭包？</h4><blockquote><p> 在外部函数声明内部函数的时候，就创建了一个闭包。闭包包含了当前声明的函数作用域中所有的函数和变量。只要声明的函数存在，当前闭包就会存在。</p></blockquote><h6 id="▉-注意一："><a href="#▉-注意一：" class="headerlink" title="▉ 注意一："></a>▉ 注意一：</h6><blockquote><p>每一个通过闭包访问变量的函数都具有一个作用域链，作用域链包含闭包的全部信息。</p></blockquote><h6 id="▉-注意二："><a href="#▉-注意二：" class="headerlink" title="▉ 注意二："></a>▉ 注意二：</h6><blockquote><p>闭包不能过度使用，因为闭包所有的变量都存在内存中，直到不会被使用到（页面卸载）时才会被垃圾回收，多度的使用闭包会影响性能。</p></blockquote><h3 id="三、闭包的应用"><a href="#三、闭包的应用" class="headerlink" title="三、闭包的应用"></a>三、闭包的应用</h3><h4 id="1、应用一：封装私有变量"><a href="#1、应用一：封装私有变量" class="headerlink" title="1、应用一：封装私有变量"></a>1、应用一：封装私有变量</h4><blockquote><p>由于原生的 JavaScript 不支持私有变量，所以只能通过闭包的方式来实现。</p></blockquote><ul><li><p>在构造函数中的外部是无法访问到函数内部的变量的，只能通过闭包的形式访问内部的变量。</p></li><li><p>通过 new 的方式创建一个新对象，改变函数内 this 的指向，为实例对象添加新属性，返回一个新对象，通过对象的方式可以访问到构造函数内部的属性。</p></li><li>通过闭包内部的方法获取到私有变量的值，但是不能直接进行访问私有变量，有效的阻止了对变量不可控的修改。</li></ul><h4 id="2、应用二：回调函数"><a href="#2、应用二：回调函数" class="headerlink" title="2、应用二：回调函数"></a>2、应用二：回调函数</h4><blockquote><p>由于处理回调函数是一种异步的调用函数，需要在回调函数中频繁的访问外部的数据，所以用闭包来解决这个问题。</p></blockquote><ul><li><p>闭包解决问题回调可以有效的防止污染全局变量。当不使用闭包的时候，所有的变量全部都在全局作用域下，多个异步操作同时对变量进行读或取，那么就会发生冲突，就污染到了全局的作用域。</p></li><li><p>如果没有闭包，一次性做许多事情就会变得非常的困难，例如：事件绑定、动画甚至服务器请求。</p></li><li><p>闭包不是存在于创建的那一时刻，而是一个真实状态的封装，只要闭包存在，就可以对变量就行修改。</p></li></ul><h3 id="四、闭包与作用域的关系"><a href="#四、闭包与作用域的关系" class="headerlink" title="四、闭包与作用域的关系"></a>四、闭包与作用域的关系</h3><blockquote><p>闭包和作用域是强相关的，JavaScript 的作用域有一定的规则以及 javaScript 的内部运行机制。</p><p>1）javascript 引擎是如何跟踪函数执行又回到函数的位置？</p><p>2）</p></blockquote><h4 id="1、javaScript-的执行上下文跟踪函数"><a href="#1、javaScript-的执行上下文跟踪函数" class="headerlink" title="1、javaScript 的执行上下文跟踪函数"></a>1、javaScript 的执行上下文跟踪函数</h4><blockquote><p>因为 JavaScript 的运行机制是基于单线程的，某个特定的时刻只能执行特定的代码，所以要通过执行上下文栈来确定函数的执行顺序。</p></blockquote><h6 id="▉-基本概念"><a href="#▉-基本概念" class="headerlink" title="▉ 基本概念"></a>▉ 基本概念</h6><ul><li><p>js 代码类型分为两种：<strong>全局代码</strong>，在所有函数的外部定义；<strong>局部代码</strong>，在函数的内部定义。</p></li><li><p>每个函数的执行都会在一个特定的执行上下文中。<strong>全局执行上下文</strong>只有一个（每个页面只有一个）；而<strong>函数执行上下文</strong>是每当执行一个函数时，就会先创建一个函数执行上下文。</p></li><li><strong>注意：</strong>this 访问函数上下文和函数执行上下文是两个不同的概念。</li></ul><h6 id="▉-跟踪过程"><a href="#▉-跟踪过程" class="headerlink" title="▉ 跟踪过程"></a>▉ 跟踪过程</h6><blockquote><p>1）程序开始运行只有执行上下文栈中只有全局执行上下文。</p><p>2）当调用函数的时候，当前函数就会创建一个新的执行上下文入栈，就说明当前的函数正在执行。</p><p>3）如果当前的函数执行完毕，所创建的执行上下文就会出栈，将控制权教给上一级。</p><p>4）直到所有有执行上下文出栈，全局执行上下文恢复执行。</p></blockquote><h4 id="2、javascript-引擎跟踪词法环境"><a href="#2、javascript-引擎跟踪词法环境" class="headerlink" title="2、javascript 引擎跟踪词法环境"></a>2、javascript 引擎跟踪词法环境</h4><blockquote><p>词法环境是每个（函数）执行上下文中所有变量和函数存储的环境。词法环境是 JavaScript 内部的实现机制，通常称为作用域。</p></blockquote><h6 id="▉-词法环境的作用"><a href="#▉-词法环境的作用" class="headerlink" title="▉ 词法环境的作用"></a>▉ 词法环境的作用</h6><blockquote><p>词法环境主要是 JavaScript 引擎用来<strong>如何跟踪变量</strong>以及如果<strong>判断变量的可访问性</strong>。</p></blockquote><h6 id="▉-关联性"><a href="#▉-关联性" class="headerlink" title="▉ 关联性"></a>▉ 关联性</h6><blockquote><p>词法环境与 JavaScript 的代码就够进行关联，如：函数、代码片段等是相互关联的。</p></blockquote><h4 id="2-1-代码嵌套"><a href="#2-1-代码嵌套" class="headerlink" title="2.1 代码嵌套"></a>2.1 代码嵌套</h4><blockquote><p>词法环境主要与代码嵌套（代码嵌套的结构）相关联的，每执行代码，代码结构就会获取与之相关联的词法环境，用来确保内部环境可访问外部环境。</p></blockquote><h4 id="2-2-代码嵌套与词法环境的关系"><a href="#2-2-代码嵌套与词法环境的关系" class="headerlink" title="2.2 代码嵌套与词法环境的关系"></a>2.2 代码嵌套与词法环境的关系</h4><blockquote><p>词法环境查询变量时，根据执行上下文对应的词法环境由内而外依次进行查找，直到查找到最外层的全局作用域。</p></blockquote><h6 id="▉-函数-执行上下文-词法环境的关系"><a href="#▉-函数-执行上下文-词法环境的关系" class="headerlink" title="▉ 函数 - 执行上下文 - 词法环境的关系"></a>▉ 函数 - 执行上下文 - 词法环境的关系</h6><p>1、每个执行上下文都对应一个词法环境（函数的局部作用域）；</p><p>2、每个局部函数中的内部属性 [[Environment]] 与创建的执行上下文相关联（所在当前函数的执行上下文）；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入闭包以及闭包的应用！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【异步编程】</title>
    <link href="http://yoursite.com/2019/06/05/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/05/前端进阶深入系列之【异步编程】/</id>
    <published>2019-06-05T09:00:41.299Z</published>
    <updated>2019-06-07T11:37:51.246Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JavaScript 所有的异步编程知识点都在这里！</p><a id="more"></a><h3 id="一、为什么-js-会有异步编程？"><a href="#一、为什么-js-会有异步编程？" class="headerlink" title="一、为什么 js 会有异步编程？"></a>一、为什么 js 会有异步编程？</h3><blockquote><p><strong>原因：</strong>由于  <code>JavaScript</code> 语言的执行环境是“单线程”的，一次只能执行一个任务，多余的任务需要在后边排队等候。</p><p><strong>发展：</strong>异步编程的语法目标，就是怎样让它更像同步编程。</p></blockquote><h4 id="1、单线程的优点"><a href="#1、单线程的优点" class="headerlink" title="1、单线程的优点"></a>1、单线程的优点</h4><blockquote><p>JavaScript 单线程的优点在于实现起来简单，环境相对单纯。</p></blockquote><h4 id="2、单线程的缺点"><a href="#2、单线程的缺点" class="headerlink" title="2、单线程的缺点"></a>2、单线程的缺点</h4><blockquote><p>其中一个任务一旦时间耗时很长，后边的任务必须排队等候，会导致整个程序的执行，会出现浏览器无响应，出现卡死状态，其他任务无法执行。</p></blockquote><h4 id="3、新模式（同步-异步）"><a href="#3、新模式（同步-异步）" class="headerlink" title="3、新模式（同步+异步）"></a>3、新模式（同步+异步）</h4><blockquote><p>为了弥补上边的缺点，JavaScript 决定将执行模式分为两种：<strong>同步（Synchronous）和异步（Asynchronous）。</strong></p></blockquote><h6 id="▉-同步模式"><a href="#▉-同步模式" class="headerlink" title="▉ 同步模式"></a>▉ 同步模式</h6><blockquote><p>同步的模式为许多任务需要排队、顺序处理。</p></blockquote><h6 id="▉-异步模式"><a href="#▉-异步模式" class="headerlink" title="▉ 异步模式"></a>▉ 异步模式</h6><p>1、每个任务有一个或多个回调函数（callback）「，每当任务执行完毕，都会执行任务的回调函数，任务的开始和结束互不影响。</p><p>2、在浏览器端，耗时的操作都应该异步执行，避免浏览器失去响应（如：AJAX）。</p><h3 id="二、四种异步编程模式"><a href="#二、四种异步编程模式" class="headerlink" title="二、四种异步编程模式"></a>二、四种异步编程模式</h3><h4 id="1、回调函数"><a href="#1、回调函数" class="headerlink" title="1、回调函数"></a>1、回调函数</h4><blockquote><p>将一个函数作为另一个函数的参数传入，传入的函数就是回调函数，当前函数执行完之后，就会调用回调函数。</p></blockquote><h6 id="▉-优点"><a href="#▉-优点" class="headerlink" title="▉ 优点"></a>▉ 优点</h6><blockquote><p>简单、容易理解和部署。</p></blockquote><h6 id="▉-缺点"><a href="#▉-缺点" class="headerlink" title="▉ 缺点"></a>▉ 缺点</h6><p><strong>1、不利于代码的阅读和维护，各部分之间的耦合度高，流程混乱，每个任务只能指定一个回调函数。</strong></p><p><strong>2、不能使用 <code>try-catch</code> 捕获错误。</strong></p><blockquote><p>这跟浏览器的执行机制相关，异步任务由 EventLoop 加入任务队列，取出并入栈执行，当异步任务执行的时候，捕获异常的函数已经在栈内退出了，所以异常无法被捕获。</p></blockquote><p><strong>3、不能直接 <code>return</code>。</strong></p><p><strong>4、容易产生回调地狱问题。</strong></p><ul><li><strong>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身。</strong></li><li><strong>嵌套函数一多，就很难处理错误</strong></li></ul><blockquote><p>回调地狱问题就是我们想要通过异步请求得到数据做某些事情的话，需要将代码写到回调中去，如果涉及到多个这样的异步操作，就会形成回调地狱问题。</p></blockquote><h4 id="2、事件监听"><a href="#2、事件监听" class="headerlink" title="2、事件监听"></a>2、事件监听</h4><blockquote><p>还可以使用<strong>事件驱动模式</strong>，任务的执行不取决于代码的顺序，而是取决于某个事件是否发生。</p></blockquote><h6 id="▉-思路"><a href="#▉-思路" class="headerlink" title="▉ 思路"></a>▉ 思路</h6><blockquote><p>为某一程序绑定一个事件，当程序运行到此时，就会触发事件的执行。</p></blockquote><h6 id="▉-优点-1"><a href="#▉-优点-1" class="headerlink" title="▉ 优点"></a>▉ 优点</h6><blockquote><p>容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，可以去耦合，实现模块化。</p></blockquote><h6 id="▉-缺点-1"><a href="#▉-缺点-1" class="headerlink" title="▉ 缺点"></a>▉ 缺点</h6><blockquote><p>整个程序就会变成事件驱动型，运行的流程会变得不清晰。</p></blockquote><h4 id="3、Generator"><a href="#3、Generator" class="headerlink" title="3、Generator"></a>3、Generator</h4><blockquote><p>ES6 的新语法，特点就是可以交出函数的执行权（可以暂停再执行）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="comment">// next 传入的参数会作为上阶段异步任务的返回结果，被函数体 y 所接收。</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">2</span>)) <span class="comment">// &#123;value: 2, done: true&#125;</span></span><br></pre></td></tr></table></figure><h6 id="▉-调用过程"><a href="#▉-调用过程" class="headerlink" title="▉ 调用过程"></a>▉ 调用过程</h6><p>1、调用 Generator 函数不会返回执行结果，而是会返回一个内部指针对象 g。</p><p>2、调用内部指针的对象 g 的 next 方法，就会移动内部的指针（执行异步的第一段），执行第一个 yield 语句。</p><p>3、next 方法主要是分段执行函数，每次调用 next 都会返回一个对象，显示当前信息（value,done）。</p><p>4、value 代表的是 yield 语句后边表达式的值，表示当前阶段的值；done 代表 Generator 是否执行完毕，返回一个布尔值。</p><h6 id="▉-数据交换"><a href="#▉-数据交换" class="headerlink" title="▉ 数据交换"></a>▉ 数据交换</h6><p>1、next 方法返回的值 vaule，是 Generator 函数向外输出的数据；next 的方法还可以接受参数，向 Generator 传递数据。</p><p>2、next 传入的参数会作为上阶段异步任务的返回结果。</p><h6 id="▉-捕获异常"><a href="#▉-捕获异常" class="headerlink" title="▉ 捕获异常"></a>▉ 捕获异常</h6><blockquote><p>Generator 函数内部可以部署错误处理代码，捕获函数体外抛出的错误。出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw（<span class="string">'出错了'</span>）; <span class="comment">// 出错了 将会被捕获 e 的值</span></span><br></pre></td></tr></table></figure><h6 id="▉-实际回调"><a href="#▉-实际回调" class="headerlink" title="▉ 实际回调"></a>▉ 实际回调</h6><blockquote><p>下面的三个都是异步请求，而且每次请求的的结果作为下一请求的参数使用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">const</span> n = <span class="keyword">yield</span> getJson(<span class="string">"n.json"</span>);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">yield</span> getJson(n[<span class="number">0</span>].mUrl);</span><br><span class="line">        <span class="keyword">const</span> w = <span class="keyword">yield</span> getJson(m[<span class="number">0</span>].wUrl);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、promise"><a href="#3、promise" class="headerlink" title="3、promise"></a>3、promise</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 所有的异步编程知识点都在这里！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【Event Loop】</title>
    <link href="http://yoursite.com/2019/06/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E4%B9%8B%E3%80%90Event%20Loop%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/05/前端面试之道之【Event Loop】/</id>
    <published>2019-06-05T06:52:28.237Z</published>
    <updated>2019-06-05T08:53:15.408Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>了解前端事件循环！</p><a id="more"></a><h4 id="一、进程与线程区别？"><a href="#一、进程与线程区别？" class="headerlink" title="一、进程与线程区别？"></a>一、进程与线程区别？</h4><ul><li><strong>进程：</strong>进程是 CPU <strong>资源分配</strong>的最小单位，系统会为每个进程进行分配内存空间。比如一个 Tab 页面就是一个进程。</li><li><strong>线程：</strong>线程是 CPU <strong>调度</strong>的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程由多个线程组成，比如：渲染线程、Js 引擎线程、HTTP 请求线程等）。</li></ul><h4 id="二、JS-单线程带来的好处？"><a href="#二、JS-单线程带来的好处？" class="headerlink" title="二、JS 单线程带来的好处？"></a>二、JS 单线程带来的好处？</h4><p>1、对于 js 引擎线程和渲染线程来说，在 js 运行的时候可能会阻止 UI 渲染，可以得出两个线程是互斥的。</p><p>2、如果在 js 修改 DOM 的时候，UI 线程还在渲染，会导致不能安全的渲染 UI。</p><p>3、JS 单线程的好处可以达到节省内存空间，节约上下文切换时间，没有锁的问题。</p><h4 id="三、什么是执行栈？"><a href="#三、什么是执行栈？" class="headerlink" title="三、什么是执行栈？"></a>三、什么是执行栈？</h4><blockquote><p>执行栈就是一个存储函数调用的栈结构，具有先进后出的特点。根据这个特定，函数之间的调用会遵循后执行的函数先弹出栈。</p></blockquote><h4 id="四、异步代码执行顺序？"><a href="#四、异步代码执行顺序？" class="headerlink" title="四、异步代码执行顺序？"></a>四、异步代码执行顺序？</h4><p>1、我们知道 js 代码的调用是在执行栈中的同步执行的，如果遇到了异步代码时，此时就将异步代码挂起加入到 <code>Task</code> 的队列中。</p><p>2、当执行栈为空时，<code>Event Loop</code> 就会从 Task 队列中拿出需要执行的异步代码放入到执行栈中，我认为本质上 js 异步还算是一种同步的行为。</p><p>3、不同的任务源分配到不同的 <code>Task</code> 队列中，任务源分为微任务（<code>microtask</code>）和宏任务（<code>macrotask</code>），在 ES6 规范中分别叫 <code>jobs，task</code>。</p><h4 id="五、解释一下什么是-Event-Loop-？"><a href="#五、解释一下什么是-Event-Loop-？" class="headerlink" title="五、解释一下什么是 Event Loop ？"></a>五、解释一下什么是 Event Loop ？</h4><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解前端事件循环！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【浏览器的运行机制】</title>
    <link href="http://yoursite.com/2019/06/02/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/02/前端进阶深入系列之【浏览器的运行机制】/</id>
    <published>2019-06-02T06:02:01.187Z</published>
    <updated>2019-06-05T06:51:52.376Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深入浅出 JS 的运行机制！</p><a id="more"></a><h3 id="一、区分进程和线程"><a href="#一、区分进程和线程" class="headerlink" title="一、区分进程和线程"></a>一、区分进程和线程</h3><blockquote><p>CPU 的作用是主要是解释计算机的指令以及处理计算机软件中的数据。</p></blockquote><ul><li><p><strong>进程：</strong>进程是 CPU <strong>资源分配</strong>的最小单位，系统会为每个进行分配内存空间。</p></li><li><p><strong>线程：</strong>线程是 CPU <strong>调度</strong>的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程由多个线程组成）。</p></li></ul><h3 id="二、浏览器是多进程的"><a href="#二、浏览器是多进程的" class="headerlink" title="二、浏览器是多进程的"></a>二、浏览器是多进程的</h3><blockquote><p>1、浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）。</p><p>2、浏览器是多进程的，每打开一个 Tab 页，相当于创建了一个独立的浏览器进程。</p><p>3、浏览器有时可以将多个进程合并，比如打开多个空白页，将这些空白页合成一个进程。</p></blockquote><h4 id="1、浏览器有哪些进程？"><a href="#1、浏览器有哪些进程？" class="headerlink" title="1、浏览器有哪些进程？"></a>1、浏览器有哪些进程？</h4><ul><li><p><strong>Browser 进程：</strong></p><blockquote><p>浏览器的主进程（负责协调、主控），只有一个</p></blockquote><ul><li>负责浏览器界面显示，与用户交互。如前进，后退等；</li><li>负责各个页面的管理，创建和销毁其他进程；</li><li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；</li><li>网络资源的管理，下载等</li></ul></li><li><p><strong>第三方插件进程：</strong></p><blockquote><p>每种类型的插件对应一个进程，仅当使用该插件时才创建。</p></blockquote></li><li><p><strong>GPU 进程：</strong></p><blockquote><p>用于 3D 绘制等；</p></blockquote></li><li><p><strong>浏览器渲染进程（浏览器内核）：</strong></p><blockquote><p>默认每个Tab页面一个进程，互不影响。</p></blockquote><ul><li>页面渲染，脚本执行，事件处理等</li></ul></li></ul><h4 id="2、浏览器多进程的优势？"><a href="#2、浏览器多进程的优势？" class="headerlink" title="2、浏览器多进程的优势？"></a>2、浏览器多进程的优势？</h4><blockquote><p>多进程的浏览器资源消耗有点大，难道空间换时间思想。<strong>如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；</strong></p></blockquote><ul><li>避免单个页面崩溃影响整个浏览器；</li><li>避免第三方插件崩溃影响整个浏览器；</li><li>多进程利用多核优势；</li><li>……</li></ul><h4 id="3、重点：浏览器的内核（渲染进程）"><a href="#3、重点：浏览器的内核（渲染进程）" class="headerlink" title="3、重点：浏览器的内核（渲染进程）"></a>3、重点：浏览器的内核（渲染进程）</h4><blockquote><p>前端浏览器最重要的点就是<strong>渲染进程</strong>，而且渲染进程是是多线程的。页面的渲染、js 的执行、时间的想都会在这个进程内进行。</p></blockquote><p>渲染进程包括哪些线程：</p><h5 id="①-GUI-渲染线程"><a href="#①-GUI-渲染线程" class="headerlink" title="① GUI 渲染线程"></a>① GUI 渲染线程</h5><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。</li><li>GUI渲染线程与JS引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</li></ul><h5 id="②-JS-引擎线程"><a href="#②-JS-引擎线程" class="headerlink" title="② JS 引擎线程"></a>② JS 引擎线程</h5><ul><li>也称为 JS 内核，负责处理 Javascript 脚本程序（V8 引擎）。</li><li>JS 引擎线程负责解析 Javascript 脚本，运行代码。</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。</li><li>GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><h5 id="③-事件触发线程"><a href="#③-事件触发线程" class="headerlink" title="③ 事件触发线程"></a>③ 事件触发线程</h5><ul><li>属于浏览器的线程而不是 js 引擎，用来控制事件循环。</li><li>当 JS 引擎执行代码块如 setTimeOut 时，会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。</li><li>由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。</li></ul><h5 id="④-定时触发器线程"><a href="#④-定时触发器线程" class="headerlink" title="④ 定时触发器线程"></a>④ 定时触发器线程</h5><ul><li><code>setInterval</code>与<code>setTimeout</code>所在线程。</li><li>浏览器定时计数器并不是由 JavaScript 引擎计数的（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）。</li><li>通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）。</li><li>W3C在HTML标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</li></ul><h5 id="⑤-异步-http-请求线程"><a href="#⑤-异步-http-请求线程" class="headerlink" title="⑤ 异步 http 请求线程"></a>⑤ 异步 http 请求线程</h5><ul><li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入浅出 JS 的运行机制！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>浏览器如何工作的之【工作流程】</title>
    <link href="http://yoursite.com/2019/05/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B9%8B%E3%80%90%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/22/浏览器是如何工作的之【工作流程】/</id>
    <published>2019-05-22T09:09:59.814Z</published>
    <updated>2019-06-03T12:28:49.996Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浏览器是如何工作的？</p><a id="more"></a><p>[TOC]</p><h2 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="headerlink" title="浏览器的工作原理"></a>浏览器的工作原理</h2><h3 id="一、整个浏览器的工作流程"><a href="#一、整个浏览器的工作流程" class="headerlink" title="一、整个浏览器的工作流程"></a>一、整个浏览器的工作流程</h3><blockquote><p>整个过程都是流式处理，同步进行。</p></blockquote><p>1、DNS 查询。</p><p>2、浏览器通过 HTTP 请求服务器。（HTTP 请求的过程是怎么样的？）</p><p>3、构建 DOM 树。（解析 HTML 代码，构建 DOM 树）</p><p>4、计算 CSS属性。（如何将 CSS 属性挂载在 DOM 树）</p><p>5、排版 。（浏览器确定每个元素的位置）</p><p>6、渲染 。（模型变成位图的过程，将在内存每个元素渲染成图形）</p><p>7、合成 。</p><p>8、绘制。（位图绘制到图像上）</p><h3 id="二、DNS-查询"><a href="#二、DNS-查询" class="headerlink" title="二、DNS 查询"></a>二、DNS 查询</h3><blockquote><p>DNS 查询主要是通过访问的域名查询出它的 IP 地址。</p></blockquote><h4 id="2-1-查询内容"><a href="#2-1-查询内容" class="headerlink" title="2.1 查询内容"></a>2.1 查询内容</h4><p>通过 DNS 查询工具得出的一下六段内容:</p><p>1、第一段：查询参数和统计。</p><p>2、第二段：查询内容。</p><p>3、第三段：DNS服务器的答复。</p><blockquote><p>显示 A (adress) 记录，即域名对应的所有 IP 地址。<code>math.stackexchange.com</code>有四个<code>A</code>记录，即四个 IP 地址。<code>600</code>是 TTL 值（Time to live 的缩写），表示缓存时间，即 600 秒之内不用重新查询。</p></blockquote><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061504.png" alt="img"></p><p>4、第四段：显示域名的 NS 记录（Name Server），即哪些服务器负责管理该域名的 DNS 记录。</p><blockquote><p><code>stackexchange.com</code>共有四条 NS 记录，即四个域名服务器，向其中任一台查询就能知道<code>math.stackexchange.com</code> 的 IP 地址是什么。</p></blockquote><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061505.png" alt="img"></p><p>5、第五段：管理域名的服务器的 IP 地址跟随着返回。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061506.png" alt="img"></p><p>6、第六段：DNS 服务器的一些传输信息。</p><h4 id="2-2-DNS-服务器"><a href="#2-2-DNS-服务器" class="headerlink" title="2.2 DNS 服务器"></a>2.2 DNS 服务器</h4><p>1、本机知道 DNS 服务器的 IP 地址，通过请求 DNS 服务器才可以查询到该域名的 IP 地址。</p><p>2、DNS 服务器的 IP 地址，有可能是动态的，每次上网时由网关分配，这叫做 <strong>DHCP 机制</strong>；也有可能是事先指定的固定地址</p><h4 id="2-3-域名的层级"><a href="#2-3-域名的层级" class="headerlink" title="2.3 域名的层级"></a>2.3 域名的层级</h4><blockquote><p>DNS 服务器通过<strong>分级查询</strong>得到每个域名的 IP 地址。</p></blockquote><h6 id="▉-域名的层级结构"><a href="#▉-域名的层级结构" class="headerlink" title="▉ 域名的层级结构"></a>▉ 域名的层级结构</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机名.次级域名.顶级域名.根域名</span><br></pre></td></tr></table></figure><ul><li>根域名 (root) ：所有域名是一样的。</li><li>顶级域名（.com .net）。</li><li>次级域名 ：用户可以注册的。 </li><li>主机名（host）：如 www，又称三级域名。用户在自己域里为服务器任意分配的名称。</li></ul><h4 id="2-4-根域名服务器"><a href="#2-4-根域名服务器" class="headerlink" title="2.4 根域名服务器"></a>2.4 根域名服务器</h4><blockquote><p> 每一集域名都有自己的 NS 记录，NS 记录是指向该级域名服务器，该服务器知道下一级域名的各种记录。</p></blockquote><h6 id="▉-分级查询"><a href="#▉-分级查询" class="headerlink" title="▉ 分级查询"></a>▉ 分级查询</h6><blockquote><p>从根域名开始查询每一级的 NS 记录，直到查到最终的 IP 地址。”根域名服务器”的 NS 记录和IP地址一般是不会变化的，它是<strong>内置在 DNS 服务器里面的</strong>。</p></blockquote><ul><li><p>从”根域名服务器”查到”顶级域名服务器”的 NS 记录和 A 记录（IP 地址）。</p></li><li><p>从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（IP 地址）。</p></li><li><p>从”次级域名服务器”查出”主机名”的 IP 地址。</p></li></ul><h4 id="2-5-DNS-整个查询过程"><a href="#2-5-DNS-整个查询过程" class="headerlink" title="2.5 DNS 整个查询过程"></a>2.5 DNS 整个查询过程</h4><p>1、本机通过本地设置的 DNS 服务器请求域名的 IP 地址。</p><p>2、DNS 服务器开始进行分层查询。</p><p>3、先是通过内置的根域名（.root）服务器查到顶级域名服务器” 的 NS 记录和 A 记录。</p><p>4、然后从 “顶级域名服务器（com.）” 查到 “次级域名服务器” 的 NS 记录和 A 记录。</p><p>5、再通过从 “次级域名服务器（用户注册的域名）” 查出 “主机名（www.）” 的 IP 地址。</p><h4 id="三、浏览器通过-HTTP-请求服务器。"><a href="#三、浏览器通过-HTTP-请求服务器。" class="headerlink" title="三、浏览器通过 HTTP 请求服务器。"></a>三、浏览器通过 HTTP 请求服务器。</h4><blockquote><p>浏览器使用 HTTP 协议或者 HTTPS 协议，向服务器发送请求。</p></blockquote><h4 id="四、构建-DOM-树。"><a href="#四、构建-DOM-树。" class="headerlink" title="四、构建 DOM 树。"></a>四、构建 DOM 树。</h4><blockquote><p>获取 HTTP 的 Request 的 body 中字符串（字符流）的 HTML 文本，进行解析并构建 DOM 树。</p></blockquote><p><img src="C:\Users\10405\AppData\Roaming\Typora\typora-user-images\1559028002988.png" alt="1559028002988"></p><h5 id="1、状态机解析代码"><a href="#1、状态机解析代码" class="headerlink" title="1、状态机解析代码"></a>1、状态机解析代码</h5><blockquote><p>HTML 词法状态机的作用就是将字符流解析成词（token)。状态机每读入一个字符就要做一次决策，这些决策和当前的状态有关。</p></blockquote><p>① 字符流进入状态机对每个字符进行解析，每判断一个字符，就为一个状态。根据当前状态来确定下一字符确定的下一个状态。</p><p>② 用状态机做词法分析，将每个词的 “特征状态” 逐个拆开成独立状态，然后把所有的特征字符链合并起来，形成一个联通图结构。</p><p>③ 状态机涉及到编译原理，用 <code>javascript</code> 来讲解。可以设计函数，每个函数为一个状态，参数接受字符串，返回的是下一个状态函数。</p><h5 id="2、构建-DOM-树"><a href="#2、构建-DOM-树" class="headerlink" title="2、构建 DOM 树"></a>2、构建 DOM 树</h5><blockquote><p>要把上边状态机解析的词通过栈这种结构来构建 DOM 树。</p></blockquote><p>① 在接收状态机解析的词的同时，就开始通过构建 DOM 树算法构建 DOM 树，当接受完所有输入的时候，栈顶就是最后的根节点，DOM 树的产出，就是 stack 的第一项，</p><p>② 构建 DOM 树，需要一个 Node 类，构建 DOM 树的所有结点都是这个 Node 类的实例。不一样的 HTML 结点对应不一样的 Node 子类（如 Element、Text等，如果基于 OOP 的话，需要抽象工厂来创建类）。</p><p>③ 在词中，开始标签和结束标签需要成对匹配的（在编译原理中，正是利用了栈匹配开始和结束标签的方案）。</p><p>④ 如果遇到 Text 结点，把相邻的 Text 结点合并起来。入栈，检查栈顶，若栈顶为 Text 结点，就合并 Text 结点。</p><p>⑤ 构建 DOM 的全过程</p><ul><li>栈顶为当前元素；</li><li>遇到属性就添加当前节点；</li><li>遇到文本点，如果当前节点是文本节点，则跟文本节点合并，否则入栈为当前的子节点；</li><li>遇到注释节点，作为节点的子节点；</li><li>遇到开始标签就入栈一个节点，当前节点就是这个节点的父节点；</li><li>遇到结束标签就出栈一个节点（检查是否匹配）。</li></ul><h4 id="五、计算-CSS-属性"><a href="#五、计算-CSS-属性" class="headerlink" title="五、计算 CSS 属性"></a>五、计算 CSS 属性</h4><blockquote><p>上阶段构造的 DOM 树只有节点和属性，没有包含任何的 CSS 样式。这一节点将 CSS 规则应用到样式中去，为 DOM 树添加 CSS 属性。DOM 树构造到父节点的时候，还不知道它有没有子节点，所以算不出来 CSS。</p></blockquote><h5 id="1、选择器的出现顺序"><a href="#1、选择器的出现顺序" class="headerlink" title="1、选择器的出现顺序"></a>1、选择器的出现顺序</h5><blockquote><p>选择器出现的顺序必定跟 DOM 树的顺序一致，这是 CSS 设计的一个原则。即保证选择器在 DOM 构建到当前节点时，已经可以准确判断是否匹配了，不需要后续节点信息。</p></blockquote><h5 id="2、CSS-分析"><a href="#2、CSS-分析" class="headerlink" title="2、CSS 分析"></a>2、CSS 分析</h5><blockquote><p>① CSS 需经过词法分析和语法分析，变成计算机可以理解的结构（属于编译原理的知识），解析之后变成一颗可用的抽象语法树。</p><p>② 一个 complex-selector 是检查一个元素的规则，一个复合选择器是由数个 complex-selector 通过连接符（combinator）组成。</p></blockquote><h5 id="3、连接符的匹配规则"><a href="#3、连接符的匹配规则" class="headerlink" title="3、连接符的匹配规则"></a>3、连接符的匹配规则</h5><h6 id="▉-后代选择器-——-“空格”"><a href="#▉-后代选择器-——-“空格”" class="headerlink" title="▉ 后代选择器 —— “空格”"></a>▉ 后代选择器 —— “空格”</h6><blockquote><p>① 匹配到 a#b 元素时，开始检查所有的子代是否匹配 .cls。 </p><p>② 当遇到 \ 时，使规则退一步，才会时第三个不会被匹配到。</p><p><strong>※ 总结：</strong>后代选择器的作用范围是父节点的所有子节点，一次规则是在匹配到本地标签的结束时回退的。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-id">#b</span> <span class="selector-class">.cls</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">cls</span>&gt;</span>2<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">cls</span>&gt;</span>3<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="▉-后继选择器-——-“-”"><a href="#▉-后继选择器-——-“-”" class="headerlink" title="▉ 后继选择器 —— “~”"></a>▉ 后继选择器 —— “~”</h6><blockquote><p>后继选择器的匹配规则是不能再使用闭合标签规则，而是带父元素的规则。（带父元素规则，就不会匹配后继的子节点了）</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.cls~* &#123;</span><br><span class="line">    border:solid 1px green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">cls</span>&gt;</span>2<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    3</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="▉-子代选择器-——-“-gt-”"><a href="#▉-子代选择器-——-“-gt-”" class="headerlink" title="▉ 子代选择器 —— “&gt;”"></a>▉ 子代选择器 —— “&gt;”</h6><blockquote><p>也是使用父元素作为约束条件进行匹配。</p></blockquote><h6 id="▉-其他"><a href="#▉-其他" class="headerlink" title="▉ 其他"></a>▉ 其他</h6><blockquote><p>其他选择器包括逗号，表示“或”的关系。编译器当做两条规则来处理。</p></blockquote><h5 id="3、计算-css-完成"><a href="#3、计算-css-完成" class="headerlink" title="3、计算 css 完成"></a>3、计算 css 完成</h5><blockquote><p>CSS 计算把 CSS 规则应用到 DOM 树上，为 DOM 树添加了相关的属性过程，最后得到了一个带有 CSS 属性的树。</p></blockquote><h4 id="六、排版"><a href="#六、排版" class="headerlink" title="六、排版"></a>六、排版</h4><blockquote><p>上一阶段确定了 CSS 属性得到一颗带有 CSS 属性的 DOM 树，而且构建 DOM 树和计算 CSS 属性两个节点产出的是一个一个的元素，那么这一阶段是浏览器确定每个元素的位置。</p></blockquote><h5 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h5><p>① 浏览器最基本的排版方案是正常流排版，浏览器的正常流是唯一<strong>文字和盒模型</strong>混排的排版方式，并遵循公认的文字排版规范。</p><p>② 文字排版规定了行模型和文字在行模型中的排布（行模型规定了行顶、行底、行高、文字区域、基线等对齐方式）。</p><p>③ 浏览器还支持元素和文字混排，元素是一个长方形区域，也就是所谓的盒模型。</p><h5 id="2、正常流文字排版"><a href="#2、正常流文字排版" class="headerlink" title="2、正常流文字排版"></a>2、正常流文字排版</h5><p>① 浏览器中的环境和显示中书写文字的环境差不多相同，但是浏览器支持改变排版的方向。我们把文字书写的方向叫做主方向，换行延伸的方向叫做交叉轴方向。</p><p>② 从字体中获取相关信息，其中一个重要属性为主轴的前后距离。文字排版还会受到一些 CSS 属性的影响，line-height、letter-spacing等。</p><p>③ 正常流中多数元素都是以盒来排版； <code>display</code> 为 <code>inline</code> 属性的元素，是拆成文本来排版的，会直接排入文档流中，主轴方向的 <code>margin</code> 属性和 border 属性也会计算进排版前进举例当中。</p><blockquote><p>可以根据 display 属性可分为两类：</p></blockquote><ul><li><p>内部排版（文本排版）</p></li><li><p>是否为 <code>inline</code>（带有 <code>inline-</code> 前缀的盒子，称为行内级盒子）</p></li></ul><p>④ 当没有指定文字书写方向的时候，从左到右文字中插入从右到左文字，会形成一个双向文字盒。</p><p>⑤ 即使没有元素包裹，混合书写方向也会形成盒结构。在排版时，遇到这样双向文字盒，会先排完盒内再排盒外。</p><h5 id="3、正常流中的盒"><a href="#3、正常流中的盒" class="headerlink" title="3、正常流中的盒"></a>3、正常流中的盒</h5><blockquote><p>正常流中 <code>display</code> 不为 <code>inline</code> 的元素，以盒的形式跟文字一起进行排版。</p></blockquote><p>① 主轴方向上的占据的空间是由 margin、border、padding、with/height 等属性和决定的，交叉轴方向是由 vertical-align 决定的，也会影响实际的行高。</p><p>② 浏览器对行的排版，先行内布局， 然后再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。</p><p>③ 块级盒子单独占据一整行，计算出交叉轴方向的高度即可。</p><h5 id="4、绝对定位元素"><a href="#4、绝对定位元素" class="headerlink" title="4、绝对定位元素"></a>4、绝对定位元素</h5><blockquote><p><code>position</code> 属性为 <code>absolute</code> 的元素，根据包含它块来确定元素。因为这是跟正常流无关的一种独立排版模式，逐级找到父级的 <code>position</code> 非 <code>static</code> 即可。</p></blockquote><h5 id="5、浮动元素排版"><a href="#5、浮动元素排版" class="headerlink" title="5、浮动元素排版"></a>5、浮动元素排版</h5><p>① 浏览器对 float 的处理事先排入正常流，在移动到排版宽度的最左/最右（主轴方向）。</p><p>② 移动后，float 元素占据一块空间，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。</p><p>③ float 元素排布完成后，float 元素所在的行需要重新确定位置。 </p><h5 id="6、其它排版"><a href="#6、其它排版" class="headerlink" title="6、其它排版"></a>6、其它排版</h5><blockquote><p>CSS 每个排版都有复杂的规定，实现形式各不同。如 Flex 排版，支持 flex 属性，将每一行后的剩余空间平均分配给主轴方向的 width/height 属性。</p></blockquote><h4 id="七、渲染"><a href="#七、渲染" class="headerlink" title="七、渲染"></a>七、渲染</h4><blockquote><p>确定了每个元素的位置之后，根据样式信息和大小信息，为内存中的每个元素渲染出它的图形。在图形学中的意思是将模型变成位图的过程称为渲染。</p></blockquote><h5 id="1、位图"><a href="#1、位图" class="headerlink" title="1、位图"></a>1、位图</h5><blockquote><p>位图就是内存中的一个二维表格，把每张图片的像素对应的颜色保存进去。（位图信息是DOM树中占据浏览器中内存最多的信息，内存优化主要考虑这点）</p></blockquote><h5 id="2、渲染过程"><a href="#2、渲染过程" class="headerlink" title="2、渲染过程"></a>2、渲染过程</h5><blockquote><p>浏览器渲染过程主要是将每个元素（Html元素/伪元素）的盒模型变成位图，inline 元素可能占据多行，每个盒对应一张位图。渲染过程分为两大类：</p></blockquote><ul><li>图形渲染 </li><li>文字渲染 </li></ul><h6 id="▉-图形渲染"><a href="#▉-图形渲染" class="headerlink" title="▉ 图形渲染"></a>▉ 图形渲染</h6><blockquote><p>盒的背景、边框、SVG元素、阴影等特性，都为绘制的图形类，需要一个底层库的支持。</p></blockquote><h6 id="▉-文字渲染"><a href="#▉-文字渲染" class="headerlink" title="▉ 文字渲染"></a>▉ 文字渲染</h6><blockquote><p>盒中的文字的绘制也会要一个底层库来支持，叫做字体库（目前常见的字体库为 Freetype）。字体库提供读取文字文件的基本能力，它会根据字符的码点抽取出字形。字形分为两种：</p></blockquote><ul><li>像素字形</li><li>矢量字形</li></ul><p>通常字体会在小字体（小于6px、8px）提供像素字形，比较大的尺寸提供矢量字形（本身需要经过渲染才能继续渲染到元素的位图上去）。</p><h6 id="▉-渲染过程"><a href="#▉-渲染过程" class="headerlink" title="▉ 渲染过程"></a>▉ 渲染过程</h6><p>① 渲染过程生成的位图跟排版中占据的尺寸是相同的，但是现实中确有很大的差距，因为很多属性会影响渲染位图的大小，如阴影。为了优化，将阴影作为一个单独的盒子来处理。</p><p>② 渲染过程不会把子元素会知道渲染的位图上，当父元素和子元素发生相对位置变化时，可以保证渲染的结果最大程度被缓存，减少重新渲染。</p><h4 id="八、合成"><a href="#八、合成" class="headerlink" title="八、合成"></a>八、合成</h4><blockquote><p>合成并非浏览器必要执行的一环，实际上是一个性能的考量。</p></blockquote><p><strong>合成可以这样理解：</strong>合成的元素的意思是合成之后，通过 js 动态改变其他元素，合成的这部分元素，就不会重新渲染从而提高了性能。</p><h5 id="1、合成的过程"><a href="#1、合成的过程" class="headerlink" title="1、合成的过程"></a>1、合成的过程</h5><p>① 渲染过程不会把子元素渲染到位图上面，合成的过程，就是要创建一个合成层，把一部分子元素渲染到合成的位图上面。 </p><h5 id="2、为哪些元素创建合成后的位图，哪些元素应该渲染到合成层上？"><a href="#2、为哪些元素创建合成后的位图，哪些元素应该渲染到合成层上？" class="headerlink" title="2、为哪些元素创建合成后的位图，哪些元素应该渲染到合成层上？"></a>2、为哪些元素创建合成后的位图，哪些元素应该渲染到合成层上？</h5><blockquote><p>合成的目标是提高性能，建立的原则就是最大限度减少绘制次数原则。好的合成策略是“猜测”可能变化的元素，把他排除到合成之外。</p></blockquote><p>①    主流的浏览器一般根据 position、transform 等属性来决定合成策略，来猜测这些元素未来的变化。</p><p>②    以上猜测的准确性有限，所以新的 CSS 标准中，规定了 will-width 属性，可以由业务代码来提示浏览器的合成策略。</p><h4 id="九、绘制"><a href="#九、绘制" class="headerlink" title="九、绘制"></a>九、绘制</h4><blockquote><p>绘制是把位图绘制到屏幕上，变成肉眼可见的图像的过程。一般最终显示的位图位于显存中，，有的情况只需把内存中的一张位图交给显示驱动或操作系统就 ok，这个将位图合成最终的位图叫做绘制。</p></blockquote><h5 id="1、重排和重绘"><a href="#1、重排和重绘" class="headerlink" title="1、重排和重绘"></a>1、重排和重绘</h5><blockquote><p>所说的“重排”和“重绘”，所谓的重排是排版，重绘则是绘制过程。实际上，“绘制”过程发生的频率非常高，比如：鼠标滑过浏览器的显示区域，鼠标每次移动，都要造成重新绘制，如果不重新绘制，就会产生大量的鼠标残影。</p></blockquote><h5 id="2、怎样减少重绘？"><a href="#2、怎样减少重绘？" class="headerlink" title="2、怎样减少重绘？"></a>2、怎样减少重绘？</h5><blockquote><p>限制绘制面积可以提高性能，如果鼠标只在某个覆盖的区域滑动，我们只需重新绘制这个区域就可以了。</p></blockquote><h5 id="3、解决办法"><a href="#3、解决办法" class="headerlink" title="3、解决办法"></a>3、解决办法</h5><blockquote><p>“脏矩形”算法，把屏幕分成若干个矩形区域。</p></blockquote><p>① 当鼠标移动导致绘制时，只重绘它影响到的几个矩形区域就够了。最小的影响区域只会涉及 4 个矩形，大型元素则覆盖多个矩形。</p><p>② 设置合适的矩形区域大小，可以很好的控制绘制时的消耗。设置过大会造成绘制面积增大，设置过小的矩形会造成计算复杂。</p><p>③ 重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交际部分绘制即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器是如何工作的？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端 CSS 之【响应式】</title>
    <link href="http://yoursite.com/2019/05/20/%E5%89%8D%E7%AB%AF%20CSS%20%E4%B9%8B%E3%80%90%E5%93%8D%E5%BA%94%E5%BC%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/20/前端 CSS 之【响应式】/</id>
    <published>2019-05-20T11:37:12.064Z</published>
    <updated>2019-05-20T12:37:02.809Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>响应式设计！</p><a id="more"></a><h3 id="一、浏览器视口"><a href="#一、浏览器视口" class="headerlink" title="一、浏览器视口"></a>一、浏览器视口</h3><blockquote><p>通过 CSS 像素（不等于无力像素，和物理像素成比例）来合理利用视口空间。</p></blockquote><p>1、理想视口：与设备自身尺寸接近的视口称为理想视口。</p><p>2、默认视口：模拟一个大的视口，然后缩小页面进行显示，称为默认视口。</p><p>3、可见视口：显示网页的矩形区域称为可见视口（减去浏览器中的按钮、滚动条等）。</p><p>4、布局视口：约束整个页面时视口为布局视口。</p><h3 id="二、配置视口"><a href="#二、配置视口" class="headerlink" title="二、配置视口"></a>二、配置视口</h3><blockquote><p>让默认视口的设备都具有理想视口，需要进行声明 meta 标签。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用当前的设备的理想尺寸作为视口的宽度，以及与理想视口的缩放程度相匹配的缩放级别</span></span><br><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-with,initial-scale=1"</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="三、媒体类型和媒体查询"><a href="#三、媒体类型和媒体查询" class="headerlink" title="三、媒体类型和媒体查询"></a>三、媒体类型和媒体查询</h3><h4 id="3-1、媒体类型"><a href="#3-1、媒体类型" class="headerlink" title="3.1、媒体类型"></a>3.1、媒体类型</h4><blockquote><p>媒体类型分为 screen(屏幕显示) 和 print (打印机)。</p></blockquote><p><strong>应用方式：</strong></p><p>① HTML 方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta rel=<span class="string">"stylesheet"</span> href=<span class="string">"main.css"</span> media=<span class="string">"screen,print"</span>&gt;</span><br></pre></td></tr></table></figure><p>② CSS 方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> print&#123;</span><br><span class="line"><span class="selector-class">.smallprint</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">11pt</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2、媒体查询"><a href="#3-2、媒体查询" class="headerlink" title="3.2、媒体查询"></a>3.2、媒体查询</h4><blockquote><p>应用方式有两种，一种是标签的形式，另一种是 css 的形式。标签的形式由于可能有的浏览器会将外部文件下载影响性能，所以通常使用 css 的形式。</p><p>① 可以忽略媒体类型，相当于用 all 代替。</p><p>②  only 关键字为了避免旧版本浏览器的误解。所有旧版本的浏览器遇到 only 关键字。都会跳过媒题查询应用下的样式。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="comment">/* 这里写规则 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、响应式设计"><a href="#四、响应式设计" class="headerlink" title="四、响应式设计"></a>四、响应式设计</h3><h4 id="4-1-移动端优先"><a href="#4-1-移动端优先" class="headerlink" title="4.1 移动端优先"></a>4.1 移动端优先</h4><blockquote><p>我们通常设计响应式以移动端优先设计，因为移动端屏幕小、通常处理器和硬件配置比电脑要低，便于人们携带。之所以首先设计移动端，为了能够考虑到很多限制因素。如果开发桌面的程序，我们可以进行其扩展。如果我们相反，将已有的功能塞进一个有限的平台，难度会更大。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;响应式设计！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道之【面试汇总】</title>
    <link href="http://yoursite.com/2019/05/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E4%B9%8B%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/20/前端面试之道之【面试题汇总】/</id>
    <published>2019-05-20T08:36:20.851Z</published>
    <updated>2019-06-05T01:06:11.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端 js、css、vue等面试题解答汇总。</p><a id="more"></a><p>[TOC]</p><h2 id="一、CSS-篇"><a href="#一、CSS-篇" class="headerlink" title="一、CSS 篇"></a>一、CSS 篇</h2><h4 id="1、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？"><a href="#1、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？" class="headerlink" title="1、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？"></a>1、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？</h4><blockquote><p>① 标准盒子模型：宽度 = 内容的宽度<code>（content）+ border + padding + margin</code><br>② 低版本 IE 盒子模型：宽度 = 内容宽度<code>（content+border+padding）+ margin</code></p></blockquote><h4 id="2、-box-sizing属性？"><a href="#2、-box-sizing属性？" class="headerlink" title="2、 box-sizing属性？"></a>2、 box-sizing属性？</h4><blockquote><p>用来控制元素的盒子模型的解析模式，默认为 <code>content-box</code>。</p></blockquote><p>① <code>context-box：</code> W3C 的标准盒子模型，设置元素的 <code>height/width</code> 属性指的是 <code>content</code> 部分的高/宽<br>② <code>border-box：</code> IE 传统盒子模型。设置元素的 <code>height/width</code> 属性指的是 <code>border + padding + content</code> 部分的高/宽</p><h4 id="3、-CSS-选择器有哪些？哪些属性可以继承？"><a href="#3、-CSS-选择器有哪些？哪些属性可以继承？" class="headerlink" title="3、 CSS 选择器有哪些？哪些属性可以继承？"></a>3、 CSS 选择器有哪些？哪些属性可以继承？</h4><p><strong>① 选择器：</strong></p><ul><li><p>ID 选择器、类选择器、标签选择器；</p></li><li><p>相邻选择器（+）、子元素选择器（&gt;）、兄弟选择器（~）、后代选择器（ul li）、通配符选择器（*）；</p></li><li>属性选择器（a[href=”…l”]）；</li><li>伪类选择器（a:hover, li:nth-child）</li></ul><p><strong>② 可继承属性：</strong>font-size、font-family、color。</p><p><strong>③ 不可继承属性：</strong>border、padding、 margin、 width、height</p><p><strong>④ 优先级：</strong>important &gt; 内嵌样式 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪元素 &gt; 继承 &gt; 通配符</p><blockquote><p>注意：important 提高 css 样式的权重，在 IE 中失效。</p></blockquote><h4 id="4、说说你对伪类和伪元素的了解，分别举出五个例子。"><a href="#4、说说你对伪类和伪元素的了解，分别举出五个例子。" class="headerlink" title="4、说说你对伪类和伪元素的了解，分别举出五个例子。"></a>4、说说你对伪类和伪元素的了解，分别举出五个例子。</h4><p><strong>① 伪类和伪元素</strong></p><p>伪类：伪类用于某些<strong>选择器</strong>添加特殊效果。</p><p>伪元素：为某些<strong>元素</strong>添加特殊效果。</p><p><strong>② 两者区别：</strong></p><ul><li>伪元素相当于添加元素设置元素，而伪类是在元素添加效果。两者都不存在于 dom 树中，是文档流之外的东西。</li><li>伪类没有数量上的限制，只要两个伪类不相互排斥，可同时使用在同一元素上。</li></ul><p><strong>③ 伪元素</strong></p><ul><li>:: before</li><li><p>:: after</p></li><li><p>:: first-line</p></li><li>:: first-letter</li><li>:: last-letter</li></ul><p><strong>④ 伪类</strong></p><ul><li>: first-child</li><li>: visitive</li><li>: hover</li><li>: active</li><li>: focus</li><li>: lang</li></ul><p><strong>⑤ CSS3 新增伪类</strong></p><ul><li>p:first-of-type: 选择父元素的首个元素。</li><li>p:last-of-type: 选择属于其父元素的最后一个元素。</li><li>p:nth-child(2): 选择其父元素的第二个子元素。</li><li>p:only-of-type: 选择属于其父元素没有兄弟节点唯一元素。</li><li>p:first-child: p:last-child 选择父元素的第一个元素或最后一个元素</li><li>div:not(div2)  除 div2 的所有元素（否定伪类选择器）。</li><li>:enabled  disabled 表单控件的禁用状态。</li><li>:checkd 单选框或复选框被选中。</li></ul><h4 id="5、-CSS-优先级怎么计算？"><a href="#5、-CSS-优先级怎么计算？" class="headerlink" title="5、 CSS 优先级怎么计算？"></a>5、 CSS 优先级怎么计算？</h4><blockquote><p><strong>特指度：</strong>表示一个 css 选择器表达式的重要程度，<strong>哪个的计算结果大，浏览器就会以哪个为优先。</strong></p></blockquote><p><strong>① 计算方法</strong></p><ul><li><p>通用选择器（*）、子元素选择器（&gt;）、相邻兄弟选择器（+）  +0</p></li><li><p>element 元素选择器：+1；</p></li><li>class 选择器、伪类选择器、属性选择器：+10；</li><li>id 选择器：+100；</li><li>内联样式 +1000</li></ul><p><strong>② 计算规则</strong></p><ul><li>!important 声明的样式优先级最高，如果冲突再进行计算。</li><li>如果优先级相同，则选择最后出现的样式。</li><li>继承得到的样式优先级最低。</li></ul><h4 id="6、-display有哪些值？说明他们的作用"><a href="#6、-display有哪些值？说明他们的作用" class="headerlink" title="6、 display有哪些值？说明他们的作用?"></a>6、 display有哪些值？说明他们的作用?</h4><ul><li><p>inline：内联（默认值）；</p></li><li><p>none：隐藏（不占空间）；</p></li><li><p>block：块显示；</p></li><li><p>block-inline：内联块级元素呈现；</p></li><li><p>table：表格显示。</p></li></ul><h4 id="7、position的值？"><a href="#7、position的值？" class="headerlink" title="7、position的值？"></a>7、position的值？</h4><ul><li>static：（默认）按正常文档流排序；</li><li>relative：相对定位。不脱离文档流，通过静态位置top、left、right、bottom定位；</li><li><p>absolute：绝对定位。参考距其最近一个不为 static 的父级元素通过 top、bottom、left、right 定位。</p></li><li><p>fixed：固定定位。所固定的参照对象是<strong>可视窗口</strong>。</p></li></ul><h4 id="8、纯CSS实现三角形原理"><a href="#8、纯CSS实现三角形原理" class="headerlink" title="8、纯CSS实现三角形原理"></a>8、纯CSS实现三角形原理</h4><blockquote><p>均分原理。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.triangle&#123;</span><br><span class="line">    width: <span class="number">0</span>;</span><br><span class="line">    height: <span class="number">0</span>;</span><br><span class="line">    border-top: <span class="number">40</span>px solid transparent;</span><br><span class="line">    border-left: <span class="number">40</span>px solid transparent;</span><br><span class="line">    border-right: <span class="number">40</span>px solid transparent;</span><br><span class="line">    border-bottom: 40px solid #ff0000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"><a href="#9、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？" class="headerlink" title="9、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"></a>9、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h4><p>① 如何居中一个 div？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">margin:<span class="number">0</span> auto;</span><br></pre></td></tr></table></figure><p>② 如何居中一个浮动元素？</p><blockquote><p>flexbox 居中</p></blockquote><p>③ 如何让绝对定位的 div 居中？</p><blockquote><p>flexbox 居中</p></blockquote><h4 id="10、谈一下你对-Flexbox-的了解，以及适用场景？"><a href="#10、谈一下你对-Flexbox-的了解，以及适用场景？" class="headerlink" title="10、谈一下你对 Flexbox 的了解，以及适用场景？"></a>10、谈一下你对 Flexbox 的了解，以及适用场景？</h4><blockquote><p>Flex 布局提供了更高效的对容器进行布局、对齐和分配空间。传统的布局，block 垂直从上到下布局；而 inline 布局则是水平方向排列。Flex 没有在方向上的限制，可自由操作。</p></blockquote><h4 id="11、为什么要初始化CSS样式？"><a href="#11、为什么要初始化CSS样式？" class="headerlink" title="11、为什么要初始化CSS样式？"></a>11、为什么要初始化CSS样式？</h4><blockquote><p>由于浏览器的兼容性问题，不同浏览器的某些标签的默认值是不相同的，如果没有对 CSS 初始化，往往会出现浏览器之间的页面显示差异。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 淘宝初始化统一规范</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">hr</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">li</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">legend</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125; </span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span>tahoma, arial, \<span class="number">5</span>b8b\<span class="number">4</span>f53; &#125; </span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>&#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125; </span><br><span class="line"><span class="selector-tag">address</span>, <span class="selector-tag">cite</span>, <span class="selector-tag">dfn</span>, <span class="selector-tag">em</span>, <span class="selector-tag">var</span> &#123; <span class="attribute">font-style</span>:normal; &#125; </span><br><span class="line"><span class="selector-tag">code</span>, <span class="selector-tag">kbd</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">samp</span> &#123; <span class="attribute">font-family</span>:couriernew, courier, monospace; &#125; </span><br><span class="line"><span class="selector-tag">small</span>&#123; <span class="attribute">font-size</span>:<span class="number">12px</span>; &#125; </span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123; <span class="attribute">list-style</span>:none; &#125; </span><br><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">text-decoration</span>:none; &#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>:underline; &#125; </span><br><span class="line"><span class="selector-tag">sup</span> &#123; <span class="attribute">vertical-align</span>:text-top; &#125; </span><br><span class="line"><span class="selector-tag">sub</span>&#123; <span class="attribute">vertical-align</span>:text-bottom; &#125; </span><br><span class="line"><span class="selector-tag">legend</span> &#123; <span class="attribute">color</span>:<span class="number">#000</span>; &#125; </span><br><span class="line"><span class="selector-tag">fieldset</span>, <span class="selector-tag">img</span> &#123; <span class="attribute">border</span>:<span class="number">0</span>; &#125; </span><br><span class="line"><span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125; </span><br><span class="line"><span class="selector-tag">table</span> &#123; <span class="attribute">border-collapse</span>:collapse; <span class="attribute">border-spacing</span>:<span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="12、CSS-里的-visibility-属性有个-collapse-属性值？在不同浏览器下以后什么区别？"><a href="#12、CSS-里的-visibility-属性有个-collapse-属性值？在不同浏览器下以后什么区别？" class="headerlink" title="12、CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？"></a>12、CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？</h4><p>① 在谷歌浏览器中，使用 collapse 属性值和使用 hidden 没有区别。</p><p>② 在火狐以及 opera 和  IE 中，使用 collapse 的值和使用 display：none 没有什么区别。 </p><h4 id="13、display-none-与-visibility：hidden-的区别？"><a href="#13、display-none-与-visibility：hidden-的区别？" class="headerlink" title="13、display:none 与 visibility：hidden 的区别？"></a>13、display:none 与 visibility：hidden 的区别？</h4><ul><li>display: none 不显示对应的元素，在文档流中<strong>不分配空间</strong>。（回流+重绘）</li><li>visibility: hidden 隐藏对应元素，在文档中仍然<strong>保留原来的空间</strong>。（重绘）</li></ul><h4 id="14、对-BFC-的理解？"><a href="#14、对-BFC-的理解？" class="headerlink" title="14、对 BFC 的理解？"></a>14、对 BFC 的理解？</h4><blockquote><p>BFC 称为块级格式化上下文，是一个独立的容器，容器里边的内容不会影响到外边的内容，这个隐藏的属性需要被触发。    </p></blockquote><p><strong>①  触发 BFC 的条件：</strong></p><ul><li>根元素（html）;</li><li>float 的值不为 none ;</li><li>overflow 的值不为默认的 visible ;</li><li>display 的值为 inline-block、table-cell、table-caption ;</li><li>position 的值为 absolute 或 fixed。</li></ul><p><strong>② BFC 的规则</strong>‘</p><blockquote><p>1）在一个块级排版上下文中，盒子是从包含块顶部开始，垂直的一个接一个的排列的。每个盒子的左外边是触碰到包含块的左边的（对于从右向左的排版，则相反）。</p><p>2）相邻两个盒子之间的垂直的间距是被 margin属性所决定的，在一个块级排版上下文中相邻的两个块级盒之间的垂直 margin 是折叠的。—— margin 上下折叠问题</p><p>3）BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。—— margin 高度塌陷</p></blockquote><h4 id="15、浮动带来的问题？以及清除浮动的方式？"><a href="#15、浮动带来的问题？以及清除浮动的方式？" class="headerlink" title="15、浮动带来的问题？以及清除浮动的方式？"></a>15、浮动带来的问题？以及清除浮动的方式？</h4><p><strong>① 浮动问题：</strong></p><ul><li>父容器的高度无法撑开。</li><li>覆盖后边跟随的元素。</li></ul><p><strong>② 清理浮动：</strong></p><ul><li>overflow:hiddle(当子元素超出父元素，就会出现问题)</li><li>clear: both 属性解决。</li><li>利用伪元素（::after）的方法。</li></ul><h4 id="16、上下-margin-重叠问题？margin-塌陷问题？以及怎么解决？"><a href="#16、上下-margin-重叠问题？margin-塌陷问题？以及怎么解决？" class="headerlink" title="16、上下 margin 重叠问题？margin 塌陷问题？以及怎么解决？"></a>16、上下 margin 重叠问题？margin 塌陷问题？以及怎么解决？</h4><p><strong>① margin 折叠问题：</strong></p><blockquote><p>当两个盒子的垂直外边距 margin 是邻接的（相接触的），两个盒子就会使用一个外边距，外边距以高度最大值为准。（同一 BFC 中）</p><ul><li>兄弟元素折叠</li><li>父子元素折叠</li></ul></blockquote><p><strong>解决：</strong>处在不同的 BFC 中。</p><p><strong>1、 兄弟元素折叠解决办法</strong></p><ul><li>将元素设置为浮动 float:left;。 </li><li>在设置 margin-top/bottom 值时统一设置上或下。</li><li>元素的 position 的值为 absolute/fixed。</li></ul><p><strong>2、父子折叠解决办法：将两个 margin 隔离开，不直接相接触。</strong></p><ul><li>父元素设置 border；</li><li>父元素设置 padding；</li><li>父元素设置 overflow（父元素就为BFC，BFC 特性之一为内外不相互影响）；</li></ul><p><strong>② margin 塌陷问题：</strong></p><blockquote><p><strong>高度塌陷：</strong>浮动的子元素无法撑开父元素的高度，导致父元素高度塌陷（浮动元素为一个 BFC ，所以不影响其他 BFC 外元素）。</p><p><strong>嵌套塌陷：</strong>父盒子和子盒子存在嵌套关系的时候，子盒子和父盒子共用一个 margin。</p></blockquote><p><strong>解决：</strong></p><p>1、高度塌陷解决办法：</p><ul><li>清除浮动的方法。</li><li>父元素设置 overflow 属性（此时父元素也为 BFC，让浮动的元素正常溜排列，不能脱离文档流）</li></ul><h4 id="17、移动端的布局用过媒体查询吗？"><a href="#17、移动端的布局用过媒体查询吗？" class="headerlink" title="17、移动端的布局用过媒体查询吗？"></a>17、移动端的布局用过媒体查询吗？</h4><blockquote><p>通过媒介查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应设备上的显示。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、在 head 标签中</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"xx.css"</span> <span class="attr">media</span>=<span class="string">"only screen and (max-device-width:480px)"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、在 <span class="selector-tag">css</span> 中设置</span><br><span class="line">@<span class="keyword">media</span> only screen and (max-device-width:<span class="number">480px</span>)&#123;</span><br><span class="line">    // css样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18、css-预处理器"><a href="#18、css-预处理器" class="headerlink" title="18、css 预处理器"></a>18、css 预处理器</h4><ul><li>Less 是一个动态 CSS 语言框架，Less 扩展了 CSS 的动态特性。（变量、混入、嵌套、函数）。</li><li>SASS 是一种 CSS 的开发工具，提供了许多便利的写法。</li></ul><h4 id="19、margin-和-padding-分别适合什么场景使用？"><a href="#19、margin-和-padding-分别适合什么场景使用？" class="headerlink" title="19、margin 和 padding 分别适合什么场景使用？"></a>19、margin 和 padding 分别适合什么场景使用？</h4><p>① 什么时候使用 margin?</p><ul><li>需要在 border 外侧添加空白；</li><li>空白处不需要背景颜色；</li><li>上下相连的两个盒子之间的空白，需要相互抵消时。</li></ul><p>② 什么时候使用 padding？</p><ul><li>需要在 border 内侧添加空白</li><li>空白处需要背景颜色</li><li>上下相连的两个盒子的空白，希望为两者之和</li></ul><h4 id="20、display-inline-block-什么时候会显示间隙？"><a href="#20、display-inline-block-什么时候会显示间隙？" class="headerlink" title="20、display:inline-block 什么时候会显示间隙？"></a>20、display:inline-block 什么时候会显示间隙？</h4><ul><li>有空格时候会有间隙解决：移除空格</li><li>margin 正值的时候 解决：margin使用负值</li></ul><h4 id="21、-CSS属性overflow属性定义溢出元素内容区的内容会如何处理"><a href="#21、-CSS属性overflow属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="21、 CSS属性overflow属性定义溢出元素内容区的内容会如何处理?"></a>21、 CSS属性overflow属性定义溢出元素内容区的内容会如何处理?</h4><ul><li>scroll：出现滚动条。</li><li>auto：子元素内容大于父元素内容出现滚动条。</li><li>visible：溢出内容出现在父元素之外。</li><li>hidden：溢出隐藏。</li></ul><h4 id="22、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#22、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="22、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>22、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h4><p>① 响应式设计网站是一个网站能够兼容多个终端。</p><p>② 基本原理：通过媒介查询检测不同设备屏幕尺寸做处理。</p><p>③ 兼容 IE：头部必须有 meta 声明的 viewport。</p><h2 id="JavaScript-篇"><a href="#JavaScript-篇" class="headerlink" title="JavaScript 篇"></a>JavaScript 篇</h2><h4 id="1、原始类型"><a href="#1、原始类型" class="headerlink" title="1、原始类型"></a>1、原始类型</h4><blockquote><p>定义：原始类型都是存储的值，没有函数可以调用，共有六种原始类型。</p></blockquote><ul><li>string</li><li>number</li><li>boolean</li><li>undefined</li><li>null</li><li>symbol</li></ul><h4 id="2、关于-null-和-undefined-的区别？"><a href="#2、关于-null-和-undefined-的区别？" class="headerlink" title="2、关于 null 和 undefined 的区别？"></a>2、关于 null 和 undefined 的区别？</h4><p>① <code>null</code> 表示”没有对象”，即该处不应该有值。</p><p>② <code>undefined</code> 表示”缺少值”，就是此处应该有一个值</p><h4 id="3、对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？"><a href="#3、对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？" class="headerlink" title="3、对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？"></a>3、对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？</h4><p>① 原始类型存储的是指针，对象类型存储的是地址。</p><p>② 对象之间的赋值，是地址的赋值，改变对象的值，导致两个变量的值都会发生改变。</p><h4 id="4、typeof-是否能正确判断类型？instanceof-能正确判断对象的原理是什么？"><a href="#4、typeof-是否能正确判断类型？instanceof-能正确判断对象的原理是什么？" class="headerlink" title="4、typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？"></a>4、typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？</h4><p><strong>①  <code>typeof</code></strong></p><blockquote><p> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>         <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span>       <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>      <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()  <span class="comment">// 'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>      <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;        <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log()<span class="comment">// 'fuction'</span></span><br></pre></td></tr></table></figure><p><strong>②  <code>instanceof</code></strong></p><blockquote><p>判断一个对象的正确类型，可以使用 <code>intanceof</code> ，因为内部机制是<strong>通过原型链来判断的</strong>。<strong><code>instanceof</code></strong> 检测左侧的 <code>__proto__</code> 原型链上，是否存在右侧的 <code>prototype</code> 原型。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// p1._proto_._proto_ 原型链上是否存在 Person.prototype</span></span><br><span class="line">p1 <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="5、类型转换"><a href="#5、类型转换" class="headerlink" title="5、类型转换"></a>5、类型转换</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16716dec14421e47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h4 id="①-转换-Boolean-类型"><a href="#①-转换-Boolean-类型" class="headerlink" title="① 转换 Boolean 类型"></a>① 转换 Boolean 类型</h4><blockquote><p><code>undefined</code>、<code>null</code>、<code>false</code>、<code>NAN</code>、<code>‘ ’</code>、<code>0</code>、<code>-0</code> 值为 false，其他值都为 true。</p></blockquote><h4 id="②-对象转原始类型"><a href="#②-对象转原始类型" class="headerlink" title="② 对象转原始类型"></a>② 对象转原始类型</h4><blockquote><p>对象转换类型的时候，会调用内置的  [[ToPrimitive]]  函数，该函数的逻辑为：</p></blockquote><ul><li>如果为原始类型，就不转换；</li><li><p>需要转字符串，调用  <code>x.toString()</code>  方法。不是字符串类型就用 <code>x.valueOf()</code> 方法。</p></li><li><p>如果都没有返回原始类型，就会报错;</p></li></ul><blockquote><p><strong>补充：</strong>x.toString 和 x.valueOf() 的区别？</p></blockquote><ul><li>x.toString：将转化的类型用字符串表示。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'3'</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> d = &#123;<span class="attr">test</span>:<span class="string">'123'</span>,<span class="attr">example</span>:<span class="number">123</span>&#125;</span><br><span class="line"><span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'example'</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> f = [<span class="string">'test'</span>,<span class="string">'example'</span>];</span><br><span class="line"></span><br><span class="line">a.toString();<span class="comment">// "3"</span></span><br><span class="line">b.toString();<span class="comment">// "3"</span></span><br><span class="line">c.toString();<span class="comment">// "true"</span></span><br><span class="line">d.toString();<span class="comment">// "[object Object]"</span></span><br><span class="line">e.toString();<span class="comment">// "function ()&#123;console.log('example');&#125;"</span></span><br><span class="line">f.toString();<span class="comment">// "test,example"</span></span><br></pre></td></tr></table></figure><ul><li>x.valueOf：将返回自身的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'3'</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> d = &#123;<span class="attr">test</span>:<span class="string">'123'</span>,<span class="attr">example</span>:<span class="number">123</span>&#125;</span><br><span class="line"><span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'example'</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> f = [<span class="string">'test'</span>,<span class="string">'example'</span>];</span><br><span class="line"></span><br><span class="line">a.valueOf();<span class="comment">// 3</span></span><br><span class="line">b.valueOf();<span class="comment">// "3"</span></span><br><span class="line">c.valueOf();<span class="comment">// true</span></span><br><span class="line">d.valueOf();<span class="comment">// &#123;test:'123',example:123&#125;</span></span><br><span class="line">e.valueOf();<span class="comment">// function()&#123;console.log('example');&#125;</span></span><br><span class="line">f.valueOf();<span class="comment">// ['test','example']</span></span><br></pre></td></tr></table></figure><h4 id="6、四则运算符"><a href="#6、四则运算符" class="headerlink" title="6、四则运算符"></a>6、四则运算符</h4><ul><li>其中一个为字符串，另一个就会转化为字符串。</li><li>其中一方不是数字，就会转换字符串。</li><li>除了加法运算外，只要一方为数字，另一方也会转换为数字。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> * [] <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li><code>+ &#39;b&#39;</code> 等于 <code>NaN</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span> + + <span class="string">'b'</span> <span class="comment">// -&gt; "aNaN"</span></span><br></pre></td></tr></table></figure><h4 id="7、比较运算符"><a href="#7、比较运算符" class="headerlink" title="7、比较运算符"></a>7、比较运算符</h4><ul><li><p>如果是对象，就通过 valueOf 转化原始类型再比较。</p></li><li><p>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a &gt; <span class="number">-1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="8、逻辑运算符（-amp-amp-与-）"><a href="#8、逻辑运算符（-amp-amp-与-）" class="headerlink" title="8、逻辑运算符（&amp;&amp; 与 ||）"></a>8、逻辑运算符（&amp;&amp; 与 ||）</h4><blockquote><p>默认情况下返回布尔类型，但是也可以返回一个操作数。</p></blockquote><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">语法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">逻辑与（<code>&amp;&amp;</code>）</td><td style="text-align:left"><code>expr1 &amp;&amp; expr2</code></td><td style="text-align:left">若 <code>expr1</code> 可转换为 <code>true</code>，则返回 <code>expr2</code>；否则，返回 <code>expr1</code>。</td></tr><tr><td style="text-align:left">逻辑或（`</td><td style="text-align:left"></td><td style="text-align:left">`）</td><td>`expr1</td><td></td><td>expr2`</td><td>若 <code>expr1</code> 可转换为 <code>true</code>，则返回 <code>expr1</code>；否则，返回 <code>expr2</code>。</td></tr><tr><td style="text-align:left">逻辑非（<code>!</code>）</td><td style="text-align:left"><code>!expr</code></td><td style="text-align:left">若 <code>expr</code> 可转换为 <code>true</code>，则返回 <code>false</code>；否则，返回 <code>true</code>。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a5 = <span class="string">"Cat"</span> &amp;&amp; <span class="string">"Dog"</span>     <span class="comment">// t &amp;&amp; t 返回 "Dog"</span></span><br><span class="line">a6 = <span class="literal">false</span> &amp;&amp; <span class="string">"Cat"</span>     <span class="comment">// f &amp;&amp; t 返回 false</span></span><br><span class="line">a7 = <span class="string">"Cat"</span> &amp;&amp; <span class="literal">false</span>     <span class="comment">// t &amp;&amp; f 返回 false</span></span><br><span class="line">a8 = <span class="string">''</span>    &amp;&amp; <span class="literal">false</span>     <span class="comment">// f &amp;&amp; f 返回 ""</span></span><br><span class="line">a9 = <span class="literal">false</span> &amp;&amp; <span class="string">''</span>        <span class="comment">// f &amp;&amp; f 返回 false</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o5 = <span class="string">"Cat"</span> || <span class="string">"Dog"</span>     <span class="comment">// t || t 返回 "Cat"</span></span><br><span class="line">o6 = <span class="literal">false</span> || <span class="string">"Cat"</span>     <span class="comment">// f || t 返回 "Cat"</span></span><br><span class="line">o7 = <span class="string">"Cat"</span> || <span class="literal">false</span>     <span class="comment">// t || f 返回 "Cat"</span></span><br><span class="line">o8 = <span class="string">''</span>    || <span class="literal">false</span>     <span class="comment">// f || f 返回 false</span></span><br><span class="line">o9 = <span class="literal">false</span> || <span class="string">''</span>        <span class="comment">// f || f 返回 ""</span></span><br></pre></td></tr></table></figure><h4 id="8、运算符的优先级"><a href="#8、运算符的优先级" class="headerlink" title="8、运算符的优先级"></a>8、运算符的优先级</h4><table><thead><tr><th style="text-align:center">操作符分类</th><th style="text-align:center">操作符</th></tr></thead><tbody><tr><td style="text-align:center">算 术 操 作 符</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">++</td><td style="text-align:center">(自增)</td></tr><tr><td style="text-align:center">––</td><td style="text-align:center">(自减)</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">(乘法)</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">(除法)</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">(求余)</td></tr><tr><td style="text-align:center"><strong>&amp;&amp;</strong></td><td style="text-align:center"><strong>（逻辑与）</strong></td></tr><tr><td style="text-align:center">**\</td><td style="text-align:center">\</td><td>**</td><td><strong>(逻辑或)</strong></td></tr><tr><td style="text-align:center"><strong>!</strong></td><td style="text-align:center"><strong>(逻辑非)</strong></td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">(左移) 将第一操作数的二进制形式的每一位向左移位，所移位的数目由第二操作数指定。右面的空位补零。</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">(算术右移) 将第一操作数的二进制形式的每一位向右移位，所移位的数目由第二操作数指定。忽略被移出的位。</td></tr><tr><td style="text-align:center">&gt;&gt;&gt;</td><td style="text-align:center">(逻辑右移) 将第一操作数的二进制形式的每一位向右移位，所移位的数目由第二操作数指定。忽略被移出的位，左面的空位补零。</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">赋值操作符</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">相等的话返回真</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">如果操作数不相等的话则返回真。</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">如果左操作数大于右操作数的话则返回真。</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">如果左操作数大于等于右操作数的话则返回真。</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">如果左操作数小于右操作数的话则返回真。</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">如果左操作数小于等于右操作数的话则返回真。</td></tr></tbody></table><h4 id="8、如何正确判断-this？箭头函数的-this-是什么？"><a href="#8、如何正确判断-this？箭头函数的-this-是什么？" class="headerlink" title="8、如何正确判断 this？箭头函数的 this 是什么？"></a>8、如何正确判断 this？箭头函数的 this 是什么？</h4><p>① 三种 this 场景：</p><ul><li>全局调用函数，内部的 this 永远指向 windows 。</li><li>对象调用函数，谁调用 this ，this 就指向谁。</li><li>new 的方式，this 永远绑定在 new 出的对象。</li></ul><p>② 箭头函数中的 this：</p><ul><li>箭头函数中是没有 this 的。</li><li>箭头函数中的 this 是指向包裹箭头函数的第一个函数的。</li></ul><p>③ bind 中的 this：</p><ul><li><code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.bind(a) <span class="comment">// 函数.bind(参数)</span></span><br></pre></td></tr></table></figure><p>④ 多种规则出现的优先级</p><blockquote><p>箭头函数一旦绑定了 this，就不会被人和方式所改变。</p></blockquote><p>new ——&gt; bind ——&gt; obj.foo() ——&gt; 全局调用。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16717eaf3383aae8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h4 id="8、call-、apply、bind-的区别"><a href="#8、call-、apply、bind-的区别" class="headerlink" title="8、call 、apply、bind 的区别"></a>8、call 、apply、bind 的区别</h4><blockquote><p>三者可以方便理解为：第一个参数调用了该方法，并将第二个参数作为该方法的参数传入。</p></blockquote><p><strong>共同点：</strong></p><p>① apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的；</p><p>② apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；</p><p>③ apply 、 call 、bind 三者都可以利用后续参数传参；</p><p><strong>不同点：</strong></p><p>①  call 顺序传参，而 apply 是数组传参。</p><p>② bind 的 <code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</p><p>③ bind 是返回对应函数（<strong>需要加一对花括号进行调用</strong>），便于稍后调用；apply 、call 则是立即调用 。</p><h4 id="9、call、apply-及-bind-函数内部实现是怎么样的？"><a href="#9、call、apply-及-bind-函数内部实现是怎么样的？" class="headerlink" title="9、call、apply 及 bind 函数内部实现是怎么样的？"></a>9、call、apply 及 bind 函数内部实现是怎么样的？</h4><h6 id="▉-Call-的内部实现"><a href="#▉-Call-的内部实现" class="headerlink" title="▉ Call 的内部实现"></a>▉ Call 的内部实现</h6><ul><li>首先 <code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></li><li>接下来给 <code>context</code> 创建一个 <code>fn</code> 属性，并将值设置为需要调用的函数</li><li>因为 <code>call</code> 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来</li><li>然后调用函数并将对象上的函数删除</li></ul><blockquote><p><strong>※ 手写一个 call 方法：</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this 为调用的函数</span></span><br><span class="line"><span class="comment">// context 是参数对象</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断调用者是否为函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不传参默认为 window</span></span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">// 新增 fn 属性,将值设置为需要调用的函数</span></span><br><span class="line">    context.fn = <span class="keyword">this</span> </span><br><span class="line">    <span class="comment">// 将 arguments 转化为数组将 call 的传参提取出来  [...arguments]</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 传参调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">    <span class="comment">// 删除函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">" "</span>+age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'小鹿'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数的 call 方法</span></span><br><span class="line">print.myCall(obj,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h6 id="▉-apply-的内部实现"><a href="#▉-apply-的内部实现" class="headerlink" title="▉ apply 的内部实现"></a>▉ apply 的内部实现</h6><ul><li>首先 <code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></li><li>接下来给 <code>context</code> 创建一个 <code>fn</code> 属性，并将值设置为需要调用的函数</li><li>因为 <code>apply</code> 传参是数组传参，所以取得数组，将其剥离为顺序参数进行函数调用</li><li>然后调用函数并将对象上的函数删除</li></ul><blockquote><p><strong>※ 手写一个 apply 方法：</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写一个 apply 方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断调用者是否为函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不传参默认为 window</span></span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">// 新增 fn 属性,将值设置为需要调用的函数</span></span><br><span class="line">    context.fn = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="comment">// 判断是否有参数传入</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">        result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = context.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">age,age2,age3</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">" "</span>+ age + <span class="string">" "</span>+ age2+<span class="string">" "</span>+age3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'小鹿'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数的 call 方法</span></span><br><span class="line">print.myApply(obj,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h6 id="▉-apply-的内部实现-1"><a href="#▉-apply-的内部实现-1" class="headerlink" title="▉ apply 的内部实现"></a>▉ apply 的内部实现</h6><ul><li>判断调用者是否为函数。</li><li>截取参数，注意：这里有两种形式传参。</li><li>返回一个函数，判断外部哪种方式调用了该函数（new | 直接调用）</li></ul><blockquote><p> <strong>※ 手写一个 bind方法：</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写一个 bind 函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断调用者是否为函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 截取传递的参数</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// _this 指向调用的函数</span></span><br><span class="line">    <span class="keyword">const</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">        <span class="comment">// 对于 new 的情况来说，不会被任何方式改变 this</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args,...arguments)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _this.apply(context,args.concat(...arguments))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// new 的方式调用 bind 参数输出换做 [...arguments]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'小鹿'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数的 call 方法</span></span><br><span class="line"><span class="keyword">let</span> F = print.myBind(obj,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 返回对象</span></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> F();</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br></pre></td></tr></table></figure><h4 id="10、-和-有什么区别？"><a href="#10、-和-有什么区别？" class="headerlink" title="10、== 和 === 有什么区别？"></a>10、== 和 === 有什么区别？</h4><blockquote><p>== 如果类型不相同，则先进行类型转换。=== 判断两者的<strong>类型和值</strong>是否相同。</p></blockquote><p><strong>① == 比较规则</strong></p><ul><li>若类型相同，则直接比较大小；类型不同，先进行转换。</li><li>判断 null == undefined 返回 true。</li><li>判断 string 和 number 时，将字符换转化为 number。</li><li>判断其中一方为 boolean 值时，将 boolean 转化为 number。</li><li>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/19/167c4a2627fe55f1?imageslim" alt="img"></p><h4 id="11、闭包有关面试题？"><a href="#11、闭包有关面试题？" class="headerlink" title="11、闭包有关面试题？"></a>11、闭包有关面试题？</h4><blockquote><p>要想完全掌握闭包，一定要清楚函数作用域、内存回收机制、作用域继承</p></blockquote><p><strong>① 什么是闭包？</strong></p><blockquote><p><strong>闭包</strong>是有权限访问其他函数作用域内的变量的一个函数。</p></blockquote><p><strong>② 闭包为什么可以有权访问到？</strong></p><blockquote><p>在 js 中，变量的作用域属于函数域，当函数执行完毕时，作用域就会被清理，内存被回收。但是闭包是建立在一个函数的内部的子函数，可以访问上级作用域，上级函数执行完后，作用域不会销毁，所以闭包可以访问上级作用域的权限，上级函数执行完后作用域内的值也不会销毁。</p></blockquote><p><strong>③ 闭包解决了什么？</strong></p><blockquote><p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的 Ajax 成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p></blockquote><p><strong>④ 闭包有哪些应用场景？</strong></p><blockquote><p>闭包随处可见，一个 Ajax 请求的成功回调，一个事件绑定的回调方法，一个 setTimeout 的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p></blockquote><p><strong>⑤ 经典面试题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(j)&#125;,j*<span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、立即执行函数"><a href="#12、立即执行函数" class="headerlink" title="12、立即执行函数"></a>12、立即执行函数</h4><p><strong>① 什么是立即执行函数</strong></p><blockquote><p>声明一个匿名函数，并立即执行。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一：</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'我是匿名函数'</span>)&#125;)()</span><br><span class="line"><span class="comment">// 写法二：</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'我是匿名函数'</span>)&#125;())</span><br></pre></td></tr></table></figure><p><strong>② 立即执行函数有什么作用？</strong></p><blockquote><p>js 没有块级作用域，创建一个独立的作用域，用来隔离作用域避免污染。</p></blockquote><p><strong>③ 经典面试题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13、什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？"><a href="#13、什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？" class="headerlink" title="13、什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？"></a>13、什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？</h4><blockquote><p>对象赋值其实复制了地址，一方改动会导致另一方的值也改动。可以通过浅拷贝来解决这个问题。</p></blockquote><p><strong>① 浅拷贝 </strong></p><h6 id="▉-Object-assign"><a href="#▉-Object-assign" class="headerlink" title="▉ Object.assign()"></a>▉ Object.assign()</h6><blockquote><p>Object.assign()  可以实现一个浅拷贝，将 <code>source</code> 的所有属性值拷贝到 <code>target</code> 新对象中。如果属性是对象的话，拷贝的是地址。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="▉-扩展运算符"><a href="#▉-扩展运算符" class="headerlink" title="▉ ... 扩展运算符"></a>▉ <code>...</code> 扩展运算符</h6><blockquote><p>扩展运算符也可以实现一个浅拷贝。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123; ...a &#125;</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="▉实现一个浅克隆"><a href="#▉实现一个浅克隆" class="headerlink" title="▉实现一个浅克隆"></a>▉<strong>实现一个浅克隆</strong></h6><blockquote><p>自己实现一个浅拷贝，和上边的两种实现没什么差别。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 实现浅克隆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> o)&#123;</span><br><span class="line">        obj[i] = o[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② 深克隆</strong></p><blockquote><p>对于多层嵌套的对象，浅克隆就是失去了作用。</p></blockquote><h6 id="▉-序列-反序列化（parse-stringify）"><a href="#▉-序列-反序列化（parse-stringify）" class="headerlink" title="▉ 序列/反序列化（parse/stringify）"></a>▉ 序列/反序列化（parse/stringify）</h6><p><strong>序列化：</strong>把变量从内存中变成可存储或传输的过程称之为序列化。stringify 方法可以将 JS 对象序列化成 JSON 字符串。</p><p><strong>反序列化：</strong>把变量内容从序列化的对象重新读到内存里称之为反序列化。JSON对象parse 方法可以将 JSON 字符串反序列化成 JS 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><p>1、无法实现对函数、RegExp 等特殊对象的克隆。</p><p>2、会抛弃对象的 constructor，所有的构造函数会指向 Object。</p><p>3、对象有循环引用，会报错。</p><h6 id="▉-实现一个深克隆函数"><a href="#▉-实现一个深克隆函数" class="headerlink" title="▉ 实现一个深克隆函数"></a>▉ 实现一个深克隆函数</h6><blockquote><p>序列/反序列化不可能实现了，所以实现一个对象类型判断函数。要面对不同的对象(正则、数组、Date等)要采用不同的处理方式。推荐使用 lodash 函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isType = <span class="function">(<span class="params">obj, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> typeString = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line">  <span class="keyword">let</span> flag;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Array'</span>:</span><br><span class="line">      flag = typeString === <span class="string">'[object Array]'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Date'</span>:</span><br><span class="line">      flag = typeString === <span class="string">'[object Date]'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'RegExp'</span>:</span><br><span class="line">      flag = typeString === <span class="string">'[object RegExp]'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(isType(arr, <span class="string">'Array'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="14、Object-和-Function-的关系"><a href="#14、Object-和-Function-的关系" class="headerlink" title="14、Object 和 Function 的关系"></a>14、Object 和 Function 的关系</h4><blockquote><p>① 所有的构造函数的 <code>_proto_</code>  包括 <code>Object</code> 和 <code>Function</code> 本身都指向 <code>Function.prototype</code>。（可以理解为所有的构造函数都是 <code>Function</code> 的实例）。</p><p>② 因为所有的对象实例的 <code>_proto_</code> 都指向 <code>Object.prototype</code> ，又因为所有的原型对象都是 Object 的实例，包括 <code>Function</code> 的原型 <code>Function.prototype</code> ，所以 <code>Function.prototype</code> 也指向 <code>Object.prototype</code>。</p><p>③ <code>Object.prototype</code> 的 <code>_proto_</code> 最终指向 <code>null</code>。</p></blockquote><p>er<img src="https://img-blog.csdn.net/20151118103413727?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="JavascriptçPrototype,Function,Object,__proto__å³ç³»ç¤ºæå¾"></p><h4 id="15、你理解的原型是什么？"><a href="#15、你理解的原型是什么？" class="headerlink" title="15、你理解的原型是什么？"></a>15、你理解的原型是什么？</h4><blockquote><p>每个 JS 对象都有一个 _proto_ 属性，这个属性指向了原型。原型中定义了很多属性和函数，其中的 <code>constructor</code> 属性指向构造函数，构造函数又通过 <code>prototype</code> 属性指回原型，这个属性和  <code>_proto_</code> 属性指向是同一原型。并不是所有的函数都具有 <code>prototype</code> 的属性，<code>bind</code>函数就没有。</p></blockquote><h4 id="16、如何理解原型链？"><a href="#16、如何理解原型链？" class="headerlink" title="16、如何理解原型链？"></a>16、如何理解原型链？</h4><blockquote><p>所谓的原型链就是多个对象通过  <code>__proto__</code> 的方式连接了起来形成一条链。</p></blockquote><h4 id="17、说说-js-中的继承？"><a href="#17、说说-js-中的继承？" class="headerlink" title="17、说说 js 中的继承？"></a>17、说说 js 中的继承？</h4><blockquote><h6 id="ES5-中的继承："><a href="#ES5-中的继承：" class="headerlink" title="ES5 中的继承："></a>ES5 中的继承：</h6></blockquote><h5 id="1、经典继承（构造函数）"><a href="#1、经典继承（构造函数）" class="headerlink" title="1、经典继承（构造函数）"></a>1、经典继承（构造函数）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/ 详细解析</span><br><span class="line"><span class="comment">//1、当用调用 call 方法时，this 带边 son 。</span></span><br><span class="line"><span class="comment">//2、此时 Father 构造函数中的 this 指向 son。</span></span><br><span class="line"><span class="comment">//3、也就是说 son 有了 colors 的属性。</span></span><br><span class="line"><span class="comment">//4、每 new 一个 son ，都会产生不同的对象，每个对象的属性都是相互独立的。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// this 是通过 new 操作内部的新对象 &#123;&#125; ，</span></span><br><span class="line">    <span class="comment">// 此时 Father 中的 this 就是为 Son 中的新对象&#123;&#125;</span></span><br><span class="line">    <span class="comment">// 新对象就有了新的属性，并返回得到 new 的新对象实例</span></span><br><span class="line">    <span class="comment">// 继承了Father,且向父类型传递参数</span></span><br><span class="line">Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(s.color)</span><br></pre></td></tr></table></figure><p>① 基本思想：在子类的构造函数的内部调用父类的构造函数。</p><p>② 优点：</p><ul><li><p>保证了原型链中引用类型的独立，不被所有实例共享。</p></li><li><p>子类创建的时候可以向父类进行传参。</p></li></ul><p>③ 缺点:</p><ul><li>继承的方法都在构造函数中定义，构造函数不能够复用了（因为构造函数中存在子类的特殊属性，所以构造函数中复用的属性不能复用了）。</li><li>父类中定义的方法对于子类型而言是不可见的（子类所有的属性都定义在父类的构造函数当中）。</li></ul><h5 id="2、组合继承"><a href="#2、组合继承" class="headerlink" title="2、组合继承"></a>2、组合继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法定义在原型对象上（共享）</span></span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 子类继承父类的属性  </span></span><br><span class="line">Father.call(<span class="keyword">this</span>,name);     <span class="comment">//继承实例属性，第一次调用 Father()</span></span><br><span class="line">    <span class="comment">// 每个实例都有自己的属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类和父类共享的方法（实现了父类属性和方法的复用）                              </span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();   <span class="comment">//继承父类方法,第二次调用 Father()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类实例对象共享的方法</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();<span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName();<span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();<span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>① 基本思想：</p><ul><li>使用<strong>原型链</strong>实现对<strong>「原型对象属性和方法」</strong>的继承。</li><li>通过借用<strong>构造函数</strong>来实现对<strong>「实例属性」</strong>的继承。</li></ul><p>② 优点：</p><ul><li>在原型对象上定义的方法实现了函数的复用。</li><li>每个实例都有属于自己的属性。</li></ul><p>③ 缺点：</p><ul><li>组合继承调用了两次父类的构造函数，造成了不必要的消耗。</li></ul><h5 id="3、原型继承"><a href="#3、原型继承" class="headerlink" title="3、原型继承"></a>3、原型继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">F.prototype = o;</span><br><span class="line">    <span class="comment">// 每次返回的 new 是不同的</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例 1</span></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例 2</span></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都添加至原型对象的属性(所共享)</span></span><br><span class="line">alert(person.friends); <span class="comment">// "Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure><p><strong>① 基本思想：</strong>创建临时性的构造函数（无任何属性），将传入的对象作为该构造函数的原型对象，然后返回这个新构造函数的实例。</p><p><strong>② 浅拷贝：</strong></p><blockquote><p><code>object</code> 所产生的对象是不相同的，但是原型对象都是 <code>person</code> 对象，所改变存在原型对象的属性所有生成的实例所共享，不仅被 <code>Person</code> 所拥有，而且被子类生成的实例所共享。</p></blockquote><p>③ <strong>object.create()：</strong>在 ECMAScript5 中,通过新增 <strong>object.create()</strong> 方法规范化了上面的原型式继承.。</p><ul><li>参数一：新对象的原型的对象。</li><li>参数二：先对象定义额外的属性（可选）。</li></ul><h5 id="4、寄生式继承"><a href="#4、寄生式继承" class="headerlink" title="4、寄生式继承"></a>4、寄生式继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用object函数创建一个新对象</span></span><br><span class="line">clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>① 基本思想：</strong>同样调用 object 函数，将返回的对象和对象的额外的方法和属性封装成一个函数进行返回。</p><p><strong>② 缺点：</strong>寄生式继承将对象封装起来，导致不能做到函数的复用，使得效率降低。</p><h5 id="5、寄生组合式继承"><a href="#5、寄生组合式继承" class="headerlink" title="5、寄生组合式继承"></a>5、寄生组合式继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数分别为子类和父类的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass,superClass</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> prototype = object(superClass.prototype);<span class="comment">//创建对象</span></span><br><span class="line">    <span class="comment">// 下面这两部为子类的构造函数指定原型对象</span></span><br><span class="line">    <span class="comment">// 让原型对象的 constructor 指向子类</span></span><br><span class="line">prototype.constructor = subClass;</span><br><span class="line">    <span class="comment">// 为子类构造函数指定原型对象</span></span><br><span class="line">subClass.prototype = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 基本思想：不必为了指定子类型的原型而调用超类型的构造函数（避免第二次调用的构造函数）。</p><p>② 优点：寄生组合式继承就是为了解决组合继承中两次调用构造函数的开销。</p><h4 id="19、new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？以及-new-和-Object-create-null-创建对象的区别？"><a href="#19、new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？以及-new-和-Object-create-null-创建对象的区别？" class="headerlink" title="19、new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？以及 new 和 Object.create(null) 创建对象的区别？"></a>19、new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？以及 new 和 Object.create(null) 创建对象的区别？</h4><blockquote><p>new 操作符的过程其实就是一个创建空对象，为空对象添加属性，为对象链接原型链，返回对象。</p></blockquote><h6 id="▉-new-的原理："><a href="#▉-new-的原理：" class="headerlink" title="▉ new 的原理："></a>▉ new 的原理：</h6><p>① 新生成一个对象；</p><p>② 链接到原型；</p><p>③ 绑定 this；</p><p>④ 返回新对象。</p><h6 id="▉-new-创建对象和字面量创建对象的区别"><a href="#▉-new-创建对象和字面量创建对象的区别" class="headerlink" title="▉  new 创建对象和字面量创建对象的区别"></a>▉  new 创建对象和字面量创建对象的区别</h6><p><strong>共同点：</strong></p><ul><li>对于对象，其实都是通过 <code>new Object()</code> 产生的。</li></ul><p><strong>不同点：</strong></p><blockquote><p>推荐使用字面量的方式创建对象，简单，方便。</p></blockquote><ul><li>通过 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层的找到 <code>Object</code> 。</li><li>字面量的方式创建对象就没有以上问题。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// function 就是个语法糖</span></span><br><span class="line"><span class="comment">// 内部等同于 new Function()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 这个字面量内部也是使用了 new Object()</span></span><br></pre></td></tr></table></figure><h6 id="▉-Object-create-null-创建对象"><a href="#▉-Object-create-null-创建对象" class="headerlink" title="▉ Object.create(null) 创建对象"></a>▉ Object.create(null) 创建对象</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(proto, [propertiesObject]);</span><br></pre></td></tr></table></figure><ul><li>proto：新创建对象的原型对象。</li><li>propertiesObject：（可选）可为创建的新对象设置属性和值。</li></ul><h6 id="▉-Object-create-一般用于继承"><a href="#▉-Object-create-一般用于继承" class="headerlink" title="▉  Object.create() 一般用于继承"></a>▉  Object.create() 一般用于继承</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> People = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">People.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  People.call(<span class="keyword">this</span>, name);  <span class="comment">// 使用call，实现了People属性的继承</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.create()方法，实现People原型方法的继承，并且修改了constructor指向</span></span><br><span class="line">Person.prototype = <span class="built_in">Object</span>.create(People.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: Person,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Person.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'person1'</span>, <span class="number">25</span>);</span><br><span class="line"> </span><br><span class="line">p1.sayName();  <span class="comment">//'person1'</span></span><br><span class="line">p1.sayAge();   <span class="comment">//25</span></span><br></pre></td></tr></table></figure><h6 id="▉-new-字面量-与-Object-create-创建对象的区别"><a href="#▉-new-字面量-与-Object-create-创建对象的区别" class="headerlink" title="▉  new/字面量 与 Object.create() 创建对象的区别"></a>▉  new/字面量 与 Object.create() 创建对象的区别</h6><ul><li>new  和 字面量创建的对象的原型指向 Object.prototype，会继承Object的属性和方法。</li><li>而通过 Object.create(null) 创建的对象，其原型指向 null，null作为原型链的顶端，没有也不会继承任何属性和方法。</li></ul><h6 id="▉-手写实现一个-new-操作符"><a href="#▉-手写实现一个-new-操作符" class="headerlink" title="▉  手写实现一个 new 操作符"></a>▉  手写实现一个 new 操作符</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 生成对象的过程</span></span><br><span class="line"><span class="comment">// 1、生成新对象</span></span><br><span class="line"><span class="comment">// 2、链接到原型</span></span><br><span class="line"><span class="comment">// 3、绑定 this</span></span><br><span class="line"><span class="comment">// 4、返回新对象</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 1、Con: 接收一个构造函数</span></span><br><span class="line"><span class="comment">// 2、args：传入构造函数的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">Con, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建空对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 设置空对象的原型(链接对象的原型)</span></span><br><span class="line">    obj._proto_ = Con.prototype;</span><br><span class="line">    <span class="comment">// 绑定 this 并执行构造函数(为对象设置属性)</span></span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj,args)</span><br><span class="line">    <span class="comment">// 如果 result 没有其他选择的对象，就返回 obj 对象</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ?  result : obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个 new 操作符</span></span><br><span class="line"><span class="keyword">const</span> a = create(Test,<span class="string">'小鹿'</span>,<span class="string">'23'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.age)</span><br></pre></td></tr></table></figure><h4 id="20、instanceof-的原理是什么？"><a href="#20、instanceof-的原理是什么？" class="headerlink" title="20、instanceof 的原理是什么？"></a>20、instanceof 的原理是什么？</h4><blockquote><p><code>instanceof</code> 可以正确的判断<strong>对象的类型</strong>，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p></blockquote><h6 id="▉-手写实现一个-instanceof"><a href="#▉-手写实现一个-instanceof" class="headerlink" title="▉ 手写实现一个 instanceof"></a>▉ 手写实现一个 instanceof</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span> || left === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (prototype === left)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="21、为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#21、为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="21、为什么 0.1 + 0.2 != 0.3？如何解决这个问题？"></a>21、为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</h4><h6 id="▉-原因"><a href="#▉-原因" class="headerlink" title="▉ 原因"></a>▉ 原因</h6><p>① 因为 JS 采用的是 IEEE 754 双精度版本（64）位，采用该版本的语言都存在问题。</p><p>② 计算机是通过二进制来存储东西的，那么 0.1 会在二进制内表示的是无限循环的一些数，不只是 0.1 。还有很多的十进制小数用二进制表示的是无限循环的。</p><p>③ 但是 js 采用的是浮点数标准却会裁减掉循环的数据而失去精度。也就造成了 <code>0.1</code> 不再是 <code>0.1</code> 了。而是变成了 <code>0.100000000000000002</code>。</p><p>④ 那么同样的，<code>0.2</code> 在二进制也是无限循环的，被裁剪后也失去了精度变成了 <code>0.200000000000000002</code>。</p><p>⑤ 所以这两者相加不等于 <code>0.3</code> 而是 <code>0.300000000000000004</code>。</p><p>⑥ 既然 <code>0.1</code> 不是 <code>0.1</code>，那为什么 <code>console.log(0.1)</code> 却是正确的呢？在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// (0011) 表示循环</span><br><span class="line">0.1 = 2^-4 * 1.10011(0011)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.100000000000000002</span> === <span class="number">0.1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h6 id="▉-解决问题"><a href="#▉-解决问题" class="headerlink" title="▉ 解决问题"></a>▉ 解决问题</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).toFixed(<span class="number">10</span>)) === <span class="number">0.3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="ES6-知识点总结"><a href="#ES6-知识点总结" class="headerlink" title="ES6 知识点总结"></a>ES6 知识点总结</h2><h4 id="1、什么是提升？什么是暂时性死区？var、let-及-const-区别？"><a href="#1、什么是提升？什么是暂时性死区？var、let-及-const-区别？" class="headerlink" title="1、什么是提升？什么是暂时性死区？var、let 及 const 区别？"></a>1、什么是提升？什么是暂时性死区？var、let 及 const 区别？</h4><p><strong>※ 答✔：什么是提升？</strong></p><p>1）所谓的提升就是虽然变量没有声明，但是可以使用这个未声明的变量。</p><p>2）函数也有提升并且优先于变量的提升。函数提升会把整个函数挪到作用域顶部。</p><p>3）<code>var</code> 的变量会被提升到作用域的顶部。</p><p><strong>※ 答✔：什么是暂时性死区？</strong></p><p>1）如果使用 <code>let</code>、<code>const</code> 声明变量，在声明之前就是用了变量就会报错，报错的原因就是暂时性死区。这里的提升和 <code>var</code> 是有区别的，虽然变量在编译的环节中被告知在这块作用域中可以访问，但是访问是受限制的。</p><p><strong>※ 答✔：var、let 及 const 区别？</strong></p><p>1）<code>var</code> 在全局作用域下声明变量会导致变量挂载在 <code>window</code> 上，其他两者不会</p><p>2）<code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值。</p><p><strong>※ 扩展✔：为什么或存在提升？</strong></p><p>1）根本原因就是为了解决函数间互相调用的情况。</p><h4 id="2、原型如何实现继承？Class-如何实现继承？Class-本质是什么？"><a href="#2、原型如何实现继承？Class-如何实现继承？Class-本质是什么？" class="headerlink" title="2、原型如何实现继承？Class 如何实现继承？Class 本质是什么？"></a>2、原型如何实现继承？Class 如何实现继承？Class 本质是什么？</h4><p><strong>※ 答✔：原型如何实现继承？</strong></p><p>1）组合继承、寄生组合继承、Class 继承  原文链接：<a href="http://luxiangqiang.xn--6qq986b3xl/2019/04/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF%E3%80%91/" target="_blank" rel="noopener">JavaScript 中的原型链和继承</a></p><p><strong>※ 答✔：Class 如何实现继承？</strong></p><p>1）<code>Class</code> 实现继承主要使用 <code>extends</code> 来明确继承自哪个父类，并且再子类中调用 <code>super</code>，可以将这段代码看做 <code>Parent.call(this,value)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>※ 答✔：Class 本质是什么？</strong></p><p>1）js 中并不存在类，Class 只是语法糖，Class 的本质还是函数。</p><h4 id="3、什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？"><a href="#3、什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？" class="headerlink" title="3、什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？"></a>3、什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</h4><p><strong>※ 答✔：为什么使用模块化？</strong></p><blockquote><p>通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。 </p></blockquote><ul><li>解决命名冲突</li><li>提供复用性</li><li>提高代码可维护性</li></ul><p><strong>※ 答✔：都有哪几种方式可以实现模块化？</strong></p><p><strong>① 立即执行函数（IIFE）</strong></p><blockquote><p>立即执行函数中的匿名函数中有独立的 词法作用域，避免了外界访问此作用域的变量。<strong>通过函数作用域解决了命名冲突、污染全局作用域的问题</strong> 。</p></blockquote><p><strong>② AMD 和 CMD</strong></p><ul><li><p><strong>AMD</strong> </p><blockquote><p>AMD 采用异步的加载方式，加载之后不影响它后面语句的运行。require.js 实现 AMD 规范的模块化 ， <code>require.config()</code> 指定引用路径等，用 <code>define()</code> 定义模块，用 <code>require()</code> 加载模块。</p></blockquote></li><li><p><strong>CMD </strong></p><blockquote><p>CMD 的不同点在于推崇依赖前置、提前执行，CDM 推崇依赖就近、延迟执行。</p></blockquote></li></ul><p><strong>③ CommonJS</strong></p><ul><li><p><code>CommonJS</code> 的规范主要用在 <code>Node.js</code> 中，为模块提供了四个接口：<code>module、exports、require、global</code>。</p></li><li><p><code>CommonJS</code> 用同步的方式加载模块（服务器端），在浏览器端使用的是异步加载模块。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对外暴露接口</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载外部模块</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="comment">// 原始类型的值被缓存，所以就没有被改变（commonJS 不会随着执行而去模块随时调用）</span></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>④ ES6 模块</strong></p><blockquote><p>ES6 实现的模块非常简单，用于浏览器和服务器端。<code>mport</code>命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码 .主要有两个命令组成：<code>export</code>和<code>import</code>:</p></blockquote><ul><li><code>export</code>命令用于规定模块的<strong>对外接口</strong>。</li><li><code>import</code>命令引入其他模块的功能。 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定指定的值暴露对外的接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块中的某个值</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="comment">// ES6 模块不同的是，静态加载完毕之后，每执行到模块中的方法，就去模块内调用（外部的变量总是与模块进行绑定的），而且值不会被缓存。</span></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong>⑤ ES6 模块与 CommonJS 模块的区别</strong></p><p><strong>1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong></p><ul><li>所谓值的拷贝，原始类型的值被缓存，不随模块内部的改变而改变。</li><li>ES6 模块是<strong>动态引用</strong>，<strong>不缓存值</strong>，模块内外是<strong>绑定</strong>的，而且是<strong>只读引用</strong>，不能修改值。ES6 的 js 引擎对脚本静态分析的时候，遇到加载命令模块 <code>import</code> ，就会生成一个只读引用，当真正用到模块里边的值的时候，就会去模块内部去取。</li></ul><p><strong>2、CommonJS 模块是运行时加载，ES6 模块是编译时加载输出接口。</strong></p><ul><li><strong>运行时加载</strong>：<code>CommonJS</code> 模块就是对象；是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 </li><li><strong>编译时加载：</strong>ES6 模块不是对象，而是通过 <code>export</code> 命令「显式指定输出的代码」。<code>import</code> 时采用静态命令的形式，即在<code>import</code>指定「加载某个输出值」，而「不是加载整个模块」，这种加载称为“编译时加载”。 </li></ul><p><strong>⑥ 总结</strong></p><ul><li>CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li><li>AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li><li>CMD 规范与 AMD  规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重。</li><li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li></ul><h4 id="4、map、filter、reduce-各自有什么作用？"><a href="#4、map、filter、reduce-各自有什么作用？" class="headerlink" title="4、map、filter、reduce 各自有什么作用？"></a>4、map、filter、reduce 各自有什么作用？</h4><p><strong>※ map 有什么作用？</strong> </p><blockquote><p>map 的作用是 map 中传入一个函数，该函数会遍历该数组，对每一个元素做变换之后返回新数组。</p></blockquote><h6 id="1）该函数存在三个参数："><a href="#1）该函数存在三个参数：" class="headerlink" title="1）该函数存在三个参数："></a>1）该函数存在三个参数：</h6><ul><li>element :  对应数组的每个元素。</li><li>index : 数组元素的下标。</li><li>arr : 原数组。</li></ul><h6 id="2）代码实现"><a href="#2）代码实现" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">arr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">element,index,arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index]+<span class="number">1</span>;</span><br><span class="line">&#125;) <span class="comment">// [3,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>※ filter 有什么作用？</strong> </p><blockquote><p><code>filter</code> 的作用是也是生成一个数组，传入的函数返回值确实布尔类型，返回值为 true 的元素放入新数组，通常来筛选删除不需要的元素。</p></blockquote><h6 id="1）该函数存在三个参数：-1"><a href="#1）该函数存在三个参数：-1" class="headerlink" title="1）该函数存在三个参数："></a>1）该函数存在三个参数：</h6><ul><li>element :  对应数组的每个元素。</li><li>index : 数组元素的下标。</li><li>arr : 原数组。</li></ul><h6 id="2）代码实现-1"><a href="#2）代码实现-1" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr = array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> element != <span class="number">6</span>;</span><br><span class="line">&#125;)<span class="comment">// [1,2,4]</span></span><br></pre></td></tr></table></figure><p><strong>※ reduce 有什么作用？</strong> </p><blockquote><p>reduce 可以将数组中的元素通过回调函数最终转换为一个值。</p></blockquote><h6 id="1）传入-reduce-两个参数："><a href="#1）传入-reduce-两个参数：" class="headerlink" title="1）传入 reduce 两个参数："></a>1）传入 reduce 两个参数：</h6><ul><li>回调函数<ul><li>accum：累计值(第一次的值代表初始化的值)。</li><li>element：当前元素。</li><li>index：当前索引。</li><li>arr：原数组。</li></ul></li><li>初始值</li></ul><h6 id="2）代码实现-2"><a href="#2）代码实现-2" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">acc,element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> acc + element;</span><br><span class="line">&#125;,<span class="number">0</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h6 id="3）reduce-的执行过程"><a href="#3）reduce-的执行过程" class="headerlink" title="3）reduce 的执行过程"></a>3）reduce 的执行过程</h6><ul><li>初始值为 0 ，该值会传入第一次回调函数。</li><li>回到函数接收四个值，第一个值是累计值。</li><li>第一次执行回调函数将「初始值」和「当前值」做运算。</li><li>然后将结果值传入第二次执行的回调函数。</li><li>第二次回调函数会和当前值再做运算。</li></ul><h4 id="5、Proxy-可以实现什么功能？"><a href="#5、Proxy-可以实现什么功能？" class="headerlink" title="5、Proxy 可以实现什么功能？"></a>5、Proxy 可以实现什么功能？</h4><blockquote><p>Proxy 中文意思代理，可以用来自定义对象中的操作。</p><p>① 如果设置了拦截操作，那么访问目标对象时被拦截。</p><p>② 如果没有设置拦截操作，但是生成了 Proxy 的实例，那么可以正常访问到原始值。</p></blockquote><h6 id="▉-格式"><a href="#▉-格式" class="headerlink" title="▉ 格式"></a>▉ 格式</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><ul><li>target：所要拦截的目标对象。</li><li>handle：设置拦截的行为。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端 js、css、vue等面试题解答汇总。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之递归系列</title>
    <link href="http://yoursite.com/2019/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/12/数据结构与算法之递归系列/</id>
    <published>2019-05-12T00:38:25.297Z</published>
    <updated>2019-05-28T12:37:37.985Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据结构与算法之递归系列，题目详细解析！</p><a id="more"></a><h2 id="数据结构与算法之递归系列"><a href="#数据结构与算法之递归系列" class="headerlink" title="数据结构与算法之递归系列"></a>数据结构与算法之递归系列</h2><p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几个月之前就想写这样一篇文章分享给大家，由于自己有心而力不足，没有把真正的学到的东西沉淀下来，所以一直在不断的自学。可能是因为在一所三流大学，资源也比较少，只能自己在网搜索相关资料，在互联网上遇到了一些朋友的帮助下去深入理解，然后自己抽出大量时间做题总结、归纳，才会把已有的知识概念所被自己吸收和理解，形成了自己的技术思想体系。</p><p>然后自己又了用了一个星期的时间去整理、分类，才有了这篇 8000 字有关递归的分享，希望能够帮助正在学习递归的小伙伴们。而且有了这篇文章的支撑和动力，往后还会写出关于数据结构与算法一些难懂的概念简单化。如果文章中有错误的地方，希望大家指正，能够为他人分享出更有质量的文章！</p><h2 id="为什么要写这篇递归文章"><a href="#为什么要写这篇递归文章" class="headerlink" title="为什么要写这篇递归文章"></a>为什么要写这篇递归文章</h2><p>看了很多关于递归的文章，也总结了很多递归的文章，也看了多篇文章下方读者的评论。有的读者评论到文章清晰易懂，有的却喷作者写的存在很多错误，埋怨作者写出来很垃圾，还不如不写。我想从理性的角度说一下，创作者写文章的最初好意是能够帮助别人对此知识点有进一步的了解，并不代表一定能够满足每个人的要求。</p><p>另一方面，每篇文章的作者可能理解的不够透彻，很多地方可能存在许多错误，包括理解上的错误，笔误等，这也是写文章的第二个目的，能够让别人挑出自己文章中的不足，能够达到与别人共同进步的目的，一举两得，两全其美。</p><p>接下来分享的文章是关于递归的，这篇文章不单单分享递归的一切，我觉得更重要的是向每位读者传递一个思想。思想？对的，没错！这篇文章不能说包含递归的边边角角，但是通过自己的理论上的学习和实践，有了自己的一套递归思想。</p><p>什么问题该用递归，什么问题用递归简洁，什么问题就不能使用递归解决，以及对于特定的问题用递归解决的陷阱，能不能进一步对递归进行二次优化，这些都是今天小鹿分享的内容。</p><h2 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h2><blockquote><p>递归，顾名思义，有递有归才叫递归，有递无归，有归无递那叫 “耍流氓” 。</p></blockquote><h2 id="为什么要学习递归？"><a href="#为什么要学习递归？" class="headerlink" title="为什么要学习递归？"></a>为什么要学习递归？</h2><p>我们学习一门技术也好，编程语言也好，首先学习之前我们知道它将能给我们带来什么，能帮助我们解决什么样的问题，这也是激励我们去学习它的动力所在。</p><p>从数组到链表、散列表，再到基本算法等，直到遇到递归之后，感觉非常的难理解。我相信每个人都有这种感觉，一开始觉得非常难，经历了九九八十一难之后，还是没有弄懂递归里边的猫腻，然后就自然而然的跳过了。</p><p>后来我就开始刷了一个月的 LeetCode 题，发现递归在数据结构与算法中有着一席之地，统治着江山。大部分的题都可以用递归去解决，如：二叉树的遍历、回溯算法、0-1 背包问题、深度优先遍历、回溯算法等等，我整理了至少二三十到关于递归的题，才发现递归的重要性，所以不得不重新深入递归学习，所有有了今天这篇文章。</p><h2 id="怎么理解递归的过程？"><a href="#怎么理解递归的过程？" class="headerlink" title="怎么理解递归的过程？"></a>怎么理解递归的过程？</h2><blockquote><p>上方我对递归“耍流氓”式的定义并不能让你准确的理解递归是什么，那么我们就来活生生的举个生活中的例子。</p></blockquote><h4 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h4><blockquote><p>比如你和小鹿我一样，在大学里喜欢插队打饭（作为一个三好学生，我怎么能干这种事呢？哈哈），那么队伍后边的同学本数着自己前边还有 5 个同学就改轮到自己了，由于前边同学不断的插队，这时他发现，怎么觉得自己离着打饭的窗口越来越远呢？这时如果他想知道自己在队队列中的的第几个（前提是前边不再有人插队），用递归思想来解决，我们怎么做呢？</p></blockquote><h4 id="2、“递”"><a href="#2、“递”" class="headerlink" title="2、“递”"></a>2、“递”</h4><blockquote><p>于是他问前边的同学是第几位，前边的同学也不只到呀，于是前边的同学问他前边的同学是第几位，直到前边第二个同学问到第一个正在打饭的同学是队伍的第几个（有点小尴尬）。打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？<strong>这个过程其实是就是一个递归中“递”的过程</strong>。</p></blockquote><h4 id="3、“归”"><a href="#3、“归”" class="headerlink" title="3、“归”"></a>3、“归”</h4><blockquote><p>然后前边打饭的第二个同学不耐烦的又告诉第三个同学，我是第二个，没看单我前边有个家伙正在打饭吗？然后第三个传给第四个，以后往后传，直到那位逐渐远离窗口的同学的前一个人告诉他是第几个之后，他知道了自己目前在队伍中的第几个位置。<strong>这个过程我们可以理解为递归中“归”的过程</strong>。</p></blockquote><h4 id="4、终止条件"><a href="#4、终止条件" class="headerlink" title="4、终止条件"></a>4、终止条件</h4><blockquote><p>“打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？”，在递归中，我们称为<strong>终止条件</strong>。</p></blockquote><h4 id="5、怎么理解递归？"><a href="#5、怎么理解递归？" class="headerlink" title="5、怎么理解递归？"></a>5、怎么理解递归？</h4><blockquote><p>1）问题虽然是层层递归的分析，但是用程序表示的时候，不要层层的在大脑中调用递归代码去想，这样可能会使你完全陷入到 “递” 的过程中去，“归” 的时候，归不出来了，这些都是我们交给计算机干的事情。</p><p>2）那我们在写程序的时候怎么理解递归呢？我们只找问题之间存在的关系，<strong>屏蔽掉递归的细节</strong>，具体看（五）分析。</p></blockquote><h2 id="满足递归的三个条件"><a href="#满足递归的三个条件" class="headerlink" title="满足递归的三个条件"></a>满足递归的三个条件</h2><blockquote><p>通过上方的例子，我们可以很容易的总结出满足递归的三个条件。</p></blockquote><h4 id="1、一个问题能不能分解成多个子问题来解决"><a href="#1、一个问题能不能分解成多个子问题来解决" class="headerlink" title="1、一个问题能不能分解成多个子问题来解决"></a>1、一个问题能不能分解成多个子问题来解决</h4><blockquote><p>想知道自己在队伍中的位置，将其问题分解为“每个人所处队伍中的位置”这样的多个子问题。</p></blockquote><h4 id="2、该问题是否和子问题的解决思路相同"><a href="#2、该问题是否和子问题的解决思路相同" class="headerlink" title="2、该问题是否和子问题的解决思路相同"></a>2、该问题是否和子问题的解决思路相同</h4><blockquote><p>想要知道自己当前的位置，就要问前边人所处的位置。那么前边人想要知道自己所处的位置，就要知道他前边人的位置。所以说，该问题和子问题的解决思路相同，满足第二个条件。</p></blockquote><h4 id="3、该问题是否有终止条件"><a href="#3、该问题是否有终止条件" class="headerlink" title="3、该问题是否有终止条件"></a>3、该问题是否有终止条件</h4><blockquote><p>第一个正在打饭的同学说自己是队伍中的第一人，这就是所谓的终止条件，找到终止条件之后就开始进行“归”的过程。</p></blockquote><h2 id="怎么编写递归代码？"><a href="#怎么编写递归代码？" class="headerlink" title="怎么编写递归代码？"></a>怎么编写递归代码？</h2><blockquote><p>如果你对递归有了一定的了解，上边的例子对你来说小菜一碟，下边还有更大的难度来进行挑战。那么问题分析清楚了，怎么根据问题编写出递归代码来呢？</p></blockquote><h4 id="1、写出递推公式"><a href="#1、写出递推公式" class="headerlink" title="1、写出递推公式"></a>1、写出递推公式</h4><blockquote><p>写递归公式最重要的一点就是找到该问题和子问题的关系，怎么找到之间存在的关系呢？这里我要强调注意的一点就是不要让大脑试图去想层层的递归过程，毕竟大脑的思考方式是顺势思考的（一开始学习递归总是把自己绕绕进去，归的时候，就完全乱套的）。那怎么找到每个子问题之间存在的某种关系呢？</p></blockquote><p>我们只想其中一层（第一层关系），以上述为例，如果我想知道当前队伍的位置，所以我要之前前一个人的位置，然后 <code>+1</code> 就是我的位置了。对于他在什么位置，我丝毫不用关系，而是让递归去解决他的位置。我们可以写出递推公式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(n) 代表当前我在队伍中的位置</span></span><br><span class="line"><span class="comment">// f(n-1) 代表我前边那个人的位置</span></span><br><span class="line"><span class="comment">// 递推公式</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>※ 注意：</strong>这个式子的含义就是 <code>f(n)</code> 求当前 n 这个人的位置， <code>f(n-1) + 1</code> 代表的就是前一个人的位置 <code>+ 1</code> 就是 <code>n</code> 的位置。</p></blockquote><h4 id="2、找到终止条件"><a href="#2、找到终止条件" class="headerlink" title="2、找到终止条件"></a>2、找到终止条件</h4><blockquote><p>递推公式我们很轻松的写出来了，但是没有终止条件的递推公式会永远的执行下去的，所以我们要有一个终止条件终止程序的运行。那么怎么找到终止条件呢？</p></blockquote><p>所谓的终止条件就是已知的条件，比如上述的排队打饭的例子中，第一个人正在窗口打饭，他的前边是没有人的，所以他是第一个。第一个人的位置为 1，我们应该怎么表示呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>※ 注意：</strong>有的问题终止条件不止一个哦，比如：斐波那契数列。具体问题具体分析。</p></blockquote><h4 id="3、转换递归代码"><a href="#3、转换递归代码" class="headerlink" title="3、转换递归代码"></a>3、转换递归代码</h4><blockquote><p>递推公式和终止条件我们分析出来了，那么将递推公式转化为递归代码非常容易了。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) retun <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line"><span class="keyword">return</span> f(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归的分类"><a href="#递归的分类" class="headerlink" title="递归的分类"></a>递归的分类</h2><blockquote><p>通过做大量的题，根据递归解决不同的问题，引申出来的几种解决和思考的方式。之所以将其分类，是为了能够更好的理解递归在不同的问题下起着什么作用，如：每层递归之间存在的关系、计算，以及递归枚举所有情况和面临选择性问题的递归。虽然分为了几类，但是递归的本质是一成不变的。</p></blockquote><h4 id="分类一：递归计算型"><a href="#分类一：递归计算型" class="headerlink" title="分类一：递归计算型"></a>分类一：递归计算型</h4><blockquote><p>将哪一类用递归解决的问题作为计算型呢？我简单总结了为两点，<strong>层层计算和并列计算</strong>。</p></blockquote><h5 id="1、层层计算"><a href="#1、层层计算" class="headerlink" title="1、层层计算"></a>1、层层计算</h5><blockquote><p>层层计算，顾名思义，能够用递归解决的问题都可以分为多个子问题，我们把每个子问题可以抽象成一层，子问题之间的关系可以表示为层与层之间的关系。我们通过层与层之间的计算关系用递推公式表达出来做计算，经过层层的递归，最终得到结果值。</p></blockquote><p><strong>▉ 例子：</strong></p><blockquote><p>我们再那上方排队打饭的例子来说明，我们的子问题已经分析出来了，就是我想知道当前在队伍中的位置，就是去问我前边人的位置加一就是我当前队伍的位置，这为一层。而前边这个人想知道当前自己的位置，需要用同样的解决思路，作为另一层。</p></blockquote><p>层与层之间的关系是什么（我当前队伍中的位置与前边人的位置存在什么样的关系）？这时你会说，当前是 <code>+1</code>。这个大部分人都很容易找出，既然关系确定了，然后通过递推公式很容易写出递归代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(n) 为我所在的当前层</span></span><br><span class="line"><span class="comment">// f(n-1) 为我前边的人所在的当前层</span></span><br><span class="line"><span class="comment">// + 1 是层与层之间的计算关系</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>▉ 总结：</strong></p><blockquote><p>我将以上一类递归问题命名为「递归计算型」的「层层计算类型」。</p></blockquote><p><strong>▉ 举一反三：</strong></p><blockquote><p>求年龄的问题也是层层计算类型的问题，自己尝试分析一下（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。</p><p><strong>问题一：</strong>有 5 个人坐在一起，问第 5 个人多少岁，他说比第 4 个人大 2 岁。问第 4 个人多少岁，他说比第 3 个人大2岁。问第 3 人多少岁，他说比第 2个 人大 2 岁。问第2个人多少岁，他说比第 1 个人大 2 岁。最后问第 1 个人，他说他是 10 岁。编写程序，当输入第几个人时求出其对应的年龄。</p><p><strong>问题二：</strong>单链表从尾到头一次输出结点值，用递归实现。</p></blockquote><h5 id="2、并列计算"><a href="#2、并列计算" class="headerlink" title="2、并列计算"></a>2、并列计算</h5><blockquote><p>并列计算，顾名思义，问题的解决方式是通过递归的并列计算来得到结果的。层与层之间并没有一定的计算关系，而只是简单的改变输入的参数值。</p></blockquote><p><strong>▉ 例子：</strong></p><blockquote><p>最经典的题型就是<strong>斐波那契数列</strong>。观察这样一组数据0、 1、1、2、3、5、8、13、21、34…，去除第一个和第二个数据外，其余的数据等于前两个数据之和（如：<code>2 = 1 + 1</code>，<code>8 = 3 + 5</code>，<code>34 = 21 + 13</code>）。你可以尝试着根据「满足递归的三个条件」以及「怎么写出递归代码」的步骤自己动手动脑亲自分析一下。</p></blockquote><p>我也在这里稍微做一个分析。</p><p>1）第一步：首先判断能不能将问题分解为多个子问题，上边我也分析过了，除了第一个和第二个数据，其他数据是前两个数据之和。那么前两个数据怎么知道呢？同样的解决方式，是他们前两个数之和。</p><p>2）第二步：找到终止条件，如果不断的找到前两个数之和，直到最前边三个数据 <code>0、1、1</code> 。如果递归求第一个 1 时，前边的数据不够，所以这也是我们找到的终止条件。</p><p>3）第三步：既然我们终止条件和关系找到了，递推公式也就不难写出 <code>f(n) = f(n-1) + f(n-2)</code>（n 为要求的第几个数字的值）。</p><p>4）转化为递归代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>▉ 总结：</strong></p><blockquote><p>我将上方的问题总结为并列计算型。也可以归属为层层计算的一种，只不过是 + 1 改成了加一个 f 函数自身的递归（说白了，递归的结果也是一个确切的数值）。之所谓并列计算 <code>f(n-1)</code> 和 <code>f(n-2)</code> 互不打扰，各自递归计算各的值。最后我们将其计算的结果值相加是我们最想要的结果。</p></blockquote><p><strong>▉ 举一反三：</strong></p><blockquote><p>青蛙跳台阶的问题也是一种并列计算的一种，自己尝试着根据上边的思路分析一下，实践出真知（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。</p><p><strong>问题：</strong></p><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。</p></blockquote><h4 id="分类二：递归枚举型"><a href="#分类二：递归枚举型" class="headerlink" title="分类二：递归枚举型"></a>分类二：递归枚举型</h4><blockquote><p>递归枚举型最多的应用就是回溯算法，枚举出所有可能的情况，怎么枚举所有情况呢？通过递归编程技巧进行枚举。那什么是回溯算法？比如走迷宫，从入口走到出口，如果遇到死胡同，需要回退，退回上一个路口，然后走另一岔路口，重复上述方式，直到找到出口。</p></blockquote><p>回溯算法最经典的问题又深度优先遍历、八皇后问题等，应用非常广泛，下边以八皇后问题为例子，展开分析，其他利用递归枚举型的回溯算法就很简单了。</p><h5 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h5><blockquote><p>在 8 X 8 的网格中，放入八个皇后（棋子），满足的条件是，任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，问有多少种摆放方式？</p></blockquote><p>【图片】</p><p><strong>▉ 问题分析：</strong></p><blockquote><p>要想满足任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，需要一一枚举皇后（棋子）的所有摆放情况，然后设定条件，筛选出满足条件的情况。</p></blockquote><p><strong>▉ 算法思路：</strong></p><blockquote><p>我们把问题分析清楚了之后，怎么通过递归实现回溯算法枚举八个皇后（棋子）出现的所有情况呢？</p><p>1）我们在 8 X 8 的网格中，先将第一枚皇后（棋子）摆放到第一行的第一列的位置（也就是坐标: (0,0)）。</p><p>2）然后我们在第二行安置第二个皇后（棋子），先放到第一列的位置，然后判断同一行、同一列、同一斜线是否存在另一个皇后？如果存在，则该位置不合适，然后放到下一列的位置，然后在判断是否满足我们设定的条件。</p><p>3）第二个皇后（棋子）找到合适的位置之后，然后在第三行放置第三枚棋子，依次将八个皇后放到合适的位置。</p><p>4）这只是一种可能，因为我设定的第一个皇后是固定位置的，在网格坐标的（0,0） 位置，那么怎么枚举所有的情况呢？然后我们不断的改变第一个皇后位置，第二个皇后位置…… ，就可以枚举出所有的情况。如果你和我一样，看了这个题之后，如果还有点懵懵懂懂，那么直接分析代码吧。</p></blockquote><p><strong>▉ 代码实现：</strong></p><blockquote><p>虽然是用 <code>javascript</code> 实现的代码，相信学过编程的小伙伴基本的代码逻辑都可以看懂。根据上方总结的递归分析满足的三个条件以及怎么写出递归代码的步骤，一步步来分析八皇后问题。</p></blockquote><p>1、将问题分解为多个子问题</p><blockquote><p>在上述的代码分析和算法思路分析中，我们可以大体知道怎么分解该问题了，枚举出八个皇后（棋子）所有的满足情况可以分解为，先寻找每一种满足的情况这种子问题。比如，每个子问题的算法思路就是上方列出的四个步骤。</p></blockquote><p>2、找出终止条件</p><blockquote><p>当遍历到第八行的时候，递归结束。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">if</span>(row === <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// 打印第 n 种满足的情况</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、写出递推公式</p><blockquote><p><code>isOkCulomn()</code> 函数判断找到的该位置是否满足条件（不能处于同一行、同一列或同一斜线上）。如果满足条件，我们返回 <code>true</code>，进入 <code>if</code> 判断，<code>row</code>行数加一传入进行递归下一行的皇后位置。直至递归遇到终止条件位置，<code>column ++</code>，将第一行的皇后放到下一位置，进行继续递归，枚举出所有可能的摆放情况。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一列的判断</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++)&#123;</span><br><span class="line">    <span class="comment">// 判断当前的列位置是否合适</span></span><br><span class="line">    <span class="keyword">if</span>(isOkCulomn(row,column))&#123;</span><br><span class="line">        <span class="comment">// 保存皇后的位置</span></span><br><span class="line">        result[row] = column;</span><br><span class="line">        <span class="comment">// 对下一行寻找数据</span></span><br><span class="line">        cal8queens(row + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前列是否合适</span></span><br><span class="line"><span class="keyword">const</span> isOkCulomn = <span class="function">(<span class="params">row,column</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 左上角列的位置</span></span><br><span class="line">    <span class="keyword">let</span> leftcolumn = column - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右上角列的位置</span></span><br><span class="line">    <span class="keyword">let</span> rightcolumn = column + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 判断当前格子正上方是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] === column) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格子左上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === leftcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格式右上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === rightcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历</span></span><br><span class="line">        leftcolumn --;</span><br><span class="line">        rightcolumn ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、转换为递归代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="comment">// result 为数组，下标为行，数组中存储的是每一行中皇后的存储的列的位置。</span></span><br><span class="line"><span class="comment">// row 行  </span></span><br><span class="line"><span class="comment">// column 列</span></span><br><span class="line"><span class="comment">// n 计数满足条件的多少种</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> cal8queens = <span class="function">(<span class="params">row</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(row === <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每一列的判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++)&#123;</span><br><span class="line">        <span class="comment">// 判断当前的列位置是否合适</span></span><br><span class="line">        <span class="keyword">if</span>(isOkCulomn(row,column))&#123;</span><br><span class="line">            <span class="comment">// 保存皇后的位置</span></span><br><span class="line">            result[row] = column;</span><br><span class="line">            <span class="comment">// 对下一行寻找数据</span></span><br><span class="line">            cal8queens(row + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前列是否合适</span></span><br><span class="line"><span class="keyword">const</span> isOkCulomn = <span class="function">(<span class="params">row,column</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 设置左上角</span></span><br><span class="line">    <span class="keyword">let</span> leftcolumn = column - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> rightcolumn = column + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 判断当前格子正上方是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] === column) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格子左上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === leftcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格式右上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === rightcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历</span></span><br><span class="line">        leftcolumn --;</span><br><span class="line">        rightcolumn ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归打印所有情况</span></span><br><span class="line"><span class="keyword">const</span> print = <span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === j)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'Q'</span> + <span class="string">' '</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'*'</span> + <span class="string">' '</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">cal8queens(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br></pre></td></tr></table></figure><p><strong>▉ 总结</strong></p><blockquote><p>上述八皇后的问题就是用递归来枚举所有情况，然后再从中设置条件，只筛选满足条件的选项。上述代码建议多看几遍，亲自动手实践一下。一开始解决八皇后问题，我自己看了好长时间才明白的，以及递归如何发挥技巧作用的。</p></blockquote><p><strong>▉ 举一反三：</strong></p><blockquote><p>如果你想练练手，可以自己实现以下图的深度优先遍历，这个理解起来并不难，可以自己动手尝试着写一写，我把代码传到我的 <code>Github</code> 上了。</p></blockquote><h4 id="分类三：递归选择型"><a href="#分类三：递归选择型" class="headerlink" title="分类三：递归选择型"></a>分类三：递归选择型</h4><blockquote><p>所谓的递归选择型，每个子问题都要面临选择，求最优解的情况。有的小伙伴会说，求最优解动态规划最适合，对的，没错，但是递归通过选择型枚举所有情况，设置条件，求得问题的最优解也是可以实现的，所有我呢将其这一类问题归为递归选择型问题。</p></blockquote><h5 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0 -1 背包问题"></a>0 -1 背包问题</h5><blockquote><p><code>0 - 1</code> 背包问题，了解过的小伙伴也是很熟悉的了。其实这个问题也属于回溯算法的一种，废话不多说，直接上问题。有一个背包，背包总的承载重量是 <code>Wkg</code>。现在我们有 <code>n</code> 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p></blockquote><p><strong>▉ 问题分析：</strong></p><blockquote><p>如果你对该问题看懵了，没关系，我们一点点的分析。假如每个物品我们有两种状态，总的装法就有 <code>2^n</code>种，怎么才能不重复的穷举这些可能呢？</p></blockquote><p><strong>▉ 算法思路：</strong></p><blockquote><p>我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p></blockquote><p>▉ <strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来存储背包中承受的最大重量</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Number</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">// i: 对第 i 个物品做出选择</span></span><br><span class="line"><span class="comment">// currentw: 当前背包的总重量</span></span><br><span class="line"><span class="comment">// goods：数组，存储每个物品的质量</span></span><br><span class="line"><span class="comment">// n: 物品的数量</span></span><br><span class="line"><span class="comment">// weight: 背包应承受的重量</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">i, currentw, goods, n, weight</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(currentw === weight || i === n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(currentw &gt; max)&#123;</span><br><span class="line">            max = currentw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择跳过当前物品不装入背包</span></span><br><span class="line">    f(i+<span class="number">1</span>, currentw, goods, n, weight)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前物品装入背包</span></span><br><span class="line">    <span class="comment">// 判断当前物品装入背包之前是否超过背包的重量,如果已经超过当前背包重量，就不要就继续装了</span></span><br><span class="line">    <span class="keyword">if</span>(currentw + goods[i] &lt;= weight)&#123;</span><br><span class="line">        f(i+<span class="number">1</span> ,currentw + goods[i], goods, n, weight)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">f(<span class="number">0</span>,<span class="number">0</span>,a,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(max)</span><br></pre></td></tr></table></figure><h2 id="递归的缺点"><a href="#递归的缺点" class="headerlink" title="递归的缺点"></a>递归的缺点</h2><blockquote><p>虽然递归的使用非常的简洁，但是也有很多缺点，也是我们在使用中需要额外注意的地方和优化的地方。</p></blockquote><h4 id="1、递归警惕堆栈溢出"><a href="#1、递归警惕堆栈溢出" class="headerlink" title="1、递归警惕堆栈溢出"></a>1、递归警惕堆栈溢出</h4><blockquote><p>你可能会问，递归和系统中的堆栈有什么关联？不要急，听我慢慢细说。</p></blockquote><h5 id="▉-理解堆栈溢出"><a href="#▉-理解堆栈溢出" class="headerlink" title="▉ 理解堆栈溢出"></a>▉ 理解堆栈溢出</h5><blockquote><p>1）递归的本质就是重复调用本身的过程，本身是什么？当然是一个函数，那好，函数中有参数以及一些局部的声明的变量，相信很多小伙伴只会用函数，而不知道函数中的变量是怎么存储的吧。没关系，等你听我分析完，你就会了。</p><p>2）函数中变量是存储到系统中的栈中的，栈数据结构的特点就是先进后出，后进先出。一个函数中的变量的使用情况就是随函数的声明周期变化的。当我们执行一个函数时，该函数的变量就会一直不断的压入栈中，当函数执行完毕销毁的时候，栈内的元素依次出栈。还是不懂，没关系，看下方示意图。</p><p>3）我们理解了上述过程之后，回到递归上来，我们的递归调用是在函数里调用自身，且当前函数并没有销毁，因为当前函数在执行自身层层递归进去了，所以递归的过程，函数中的变量一直不断的压栈，由于我们系统栈或虚拟机栈空间是非常小的，当栈压满之后，再压时，就会导致堆栈溢出。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【图】</p><h5 id="▉-解决办法"><a href="#▉-解决办法" class="headerlink" title="▉ 解决办法"></a>▉ 解决办法</h5><blockquote><p>那么遇到这种情况，我们怎么解决呢？</p></blockquote><p>通常我们设置递归深度，简单的理解就是，如果递归超过我们设置的深度，我们就退出，不再递归下去。</p><h4 id="2、递归警惕重复元素"><a href="#2、递归警惕重复元素" class="headerlink" title="2、递归警惕重复元素"></a>2、递归警惕重复元素</h4><blockquote><p>有些递归问题中，存在重复计算问题，比如求斐波那契数列，我们画一下递归树如下图，我们会发现有很多重复递归计算的值，重复计算会导致程序的时间复杂度很高，而且是指数级别的，导致我们的程序效率低下。</p></blockquote><p>【递归树图】</p><h5 id="▉-解决办法-1"><a href="#▉-解决办法-1" class="headerlink" title="▉ 解决办法"></a>▉ 解决办法</h5><blockquote><p>重复计算问题，我们应该怎么解决？有的小伙伴想到了，我们把已经计算过的值保存起来，每次递归计算之前先检查一下保存的数据有没有该数据，如果有，我们拿出来直接用。如果没有，我们计算出来保存起来。一般我们用散列表来保存。（所谓的散列表就是键值对的形式，如 map ）</p></blockquote><p>【代码实现】</p><h4 id="3、递归高空间复杂度"><a href="#3、递归高空间复杂度" class="headerlink" title="3、递归高空间复杂度"></a>3、递归高空间复杂度</h4><blockquote><p>因为递归时函数的变量的存储需要额外的栈空间，当递归深度很深时，需要额外的内存占空间就会很多，所以递归有非常高的空间复杂度。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法之递归系列，题目详细解析！&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Webpack成神之路之插件配置【处理CSS3属性前缀_11】</title>
    <link href="http://yoursite.com/2019/05/09/Webpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90%E5%A4%84%E7%90%86CSS3%E5%B1%9E%E6%80%A7%E5%89%8D%E7%BC%80_11%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/09/Webpack成神之路之插件配置【处理CSS3属性前缀_11】/</id>
    <published>2019-05-09T06:52:32.787Z</published>
    <updated>2019-05-09T07:44:00.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>处理 CSS3 属性前缀！</p><a id="more"></a><h2 id="CSS进阶：自动处理CSS3属性前缀"><a href="#CSS进阶：自动处理CSS3属性前缀" class="headerlink" title="CSS进阶：自动处理CSS3属性前缀"></a>CSS进阶：自动处理CSS3属性前缀</h2><blockquote><p>CSS3 是前段必会的技能，但是通常需要添加像 <code>-webkit,-ms,-o,-moz</code> 这些前缀，为了能够在不同浏览器上都可已顺利的运行。为了能够自动添加这些繁琐的前缀，我们借助插件来实现。</p></blockquote><p>1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;处理 CSS3 属性前缀！&lt;/p&gt;
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/webpack/"/>
    
    
      <category term="前端工具" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>吃透 javascript 之【完整篇】</title>
    <link href="http://yoursite.com/2019/05/08/%E5%90%83%E9%80%8F%20JavaScript%20%E4%B9%8B%E3%80%90%E5%AE%8C%E6%95%B4%E7%AF%87%E3%80%91%20/"/>
    <id>http://yoursite.com/2019/05/08/吃透 JavaScript 之【完整篇】 /</id>
    <published>2019-05-08T11:19:46.959Z</published>
    <updated>2019-05-08T11:19:46.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Javascript 的重点学习路线完整篇。</p><a id="more"></a><p>[TOC]</p><h3 id="一、JavaScript-简介"><a href="#一、JavaScript-简介" class="headerlink" title="一、JavaScript 简介"></a>一、JavaScript 简介</h3><h4 id="1、诞生"><a href="#1、诞生" class="headerlink" title="1、诞生"></a>1、诞生</h4><blockquote><p>最早期网景公司开启 web 时代的第一代互联网，早起网景公司只是做静态页面，为了能够在静态页面添加一些动态的效果，所以叫Brendan Eich 这两个人两星期之内设计出 javascript ，不出所料，这两人只用了短短的10天时间。为了使其能够借助 java 的盛行，所以起名 javascript。</p></blockquote><h4 id="2、ECMAScript"><a href="#2、ECMAScript" class="headerlink" title="2、ECMAScript"></a>2、ECMAScript</h4><blockquote><p>网景开发了 javascript 之后，微软也模仿开发了 Jscript，为了能够让 javascript 称为全球的开发标准，所以几个公司联合发布了 ECMA 标准。ECMAScript 是一种语言标准，而网景公司开发的 javascript 是这一标准的实现。</p></blockquote><h4 id="3、版本"><a href="#3、版本" class="headerlink" title="3、版本"></a>3、版本</h4><blockquote><p>因为 javascript 的标准在短时间实现的，其中存在很多的缺陷，所以 javascript 的标准 ECMAScript 不断发展，到目前的 ES6 版本 2015 年发布。这里的 javascript 版本一般说的就是实现了 ECMAScript 哪个版本。</p></blockquote><h3 id="二、数据类型和变量"><a href="#二、数据类型和变量" class="headerlink" title="二、数据类型和变量"></a>二、数据类型和变量</h3><h4 id="1、-和-的区别？"><a href="#1、-和-的区别？" class="headerlink" title="1、== 和 ===的区别？"></a>1、<code>==</code> 和 <code>===</code>的区别？</h4><blockquote><p>== 是 javascript 的设计缺陷，一般使用 === 来比较。</p><p><code>==</code> : 两种之间比较需要先进行转换，然后进行比较，有时候出现很奇怪的情况。</p><p><code>===</code> :  先比较类型，如果类型相等，然后在比较值。</p></blockquote><h4 id="2、NAN-是-Number-特殊的值"><a href="#2、NAN-是-Number-特殊的值" class="headerlink" title="2、NAN 是 Number 特殊的值"></a>2、NAN 是 Number 特殊的值</h4><blockquote><p>NAN 与任何值都不相等，包括它本身自己。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN === NaN; // false</span><br></pre></td></tr></table></figure><blockquote><p>唯一能判断 <code>NaN</code> 的方法是通过 <code>isNaN()</code> 函数 </p></blockquote><h4 id="3、浮点型之间的比较"><a href="#3、浮点型之间的比较" class="headerlink" title="3、浮点型之间的比较"></a>3、浮点型之间的比较</h4><blockquote><p><strong>问题</strong>：浮点型在运算会产生误差，导致计算机无法准确表示无限循环小数，所以导致比较不相等。</p><p><strong>解决：</strong>要比较浮点型之间的大小，要比较两个浮点型之差的绝对值是否小于某一个阈值。</p></blockquote><h4 id="4、null-和-undefined"><a href="#4、null-和-undefined" class="headerlink" title="4、null 和 undefined"></a>4、null 和 undefined</h4><blockquote><p><code>NULL</code> 表示“空”。<code>undefined</code> 表示未定义。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。 </p></blockquote><h4 id="5、严格模式是什么？"><a href="#5、严格模式是什么？" class="headerlink" title="5、严格模式是什么？"></a>5、严格模式是什么？</h4><blockquote><p><strong>缘由：</strong>初期，为了方便，不强制要求 var 声明变量，所以会导致未被 var 声明的变量自动声明为全局变量，如果同一页面不同 js 文件都用到了 js 文件的相同变量，导致变量之间相互影响，也就是我们所说的污染全局环境变量。</p><p><strong>strict模式：</strong>不用<code>var</code>申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。 </p></blockquote><h3 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h3><h4 id="1、多行字符串"><a href="#1、多行字符串" class="headerlink" title="1、多行字符串"></a>1、多行字符串</h4><blockquote><p>多行字符串用 <code></code> 反引号来表示，ES6 新增加语法。</p></blockquote><h4 id="2、字符串拼接"><a href="#2、字符串拼接" class="headerlink" title="2、字符串拼接"></a>2、字符串拼接</h4><blockquote><p>关于字符串拼接用 ${name} 引用，ES6 新增加语法。</p></blockquote><h3 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h3><h4 id="1、indexof"><a href="#1、indexof" class="headerlink" title="1、indexof"></a>1、indexof</h4><blockquote><p>搜索一个指定的元素的位置 。</p></blockquote><h4 id="2、slice"><a href="#2、slice" class="headerlink" title="2、slice"></a>2、slice</h4><blockquote><p>字符串截取。单参数为从参数起到结束，双参数为中间元素（不包括尾元素），返回新数组。</p></blockquote><h4 id="3、push-和-pop"><a href="#3、push-和-pop" class="headerlink" title="3、push 和 pop"></a>3、push 和 pop</h4><blockquote><p>末尾添加元素和末尾删除元素。</p></blockquote><h4 id="4、unshift-和-shift"><a href="#4、unshift-和-shift" class="headerlink" title="4、unshift 和 shift"></a>4、unshift 和 shift</h4><blockquote><p>头部添加元素和头部删除元素。</p></blockquote><h4 id="5、sort"><a href="#5、sort" class="headerlink" title="5、sort"></a>5、sort</h4><blockquote><p>对当前数组进行排序。</p></blockquote><h4 id="6、reverse"><a href="#6、reverse" class="headerlink" title="6、reverse"></a>6、reverse</h4><blockquote><p>将数组元素反转。</p></blockquote><h4 id="7、splice"><a href="#7、splice" class="headerlink" title="7、splice"></a>7、splice</h4><blockquote><p>可以删除元素也可以删除同时添加元素。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;);</span><br></pre></td></tr></table></figure><h4 id="8、concat"><a href="#8、concat" class="headerlink" title="8、concat"></a>8、concat</h4><blockquote><p>合并两个数组，返回新数组。</p></blockquote><h4 id="9、join"><a href="#9、join" class="headerlink" title="9、join"></a>9、join</h4><blockquote><p>指定字符连接数组中的元素。</p></blockquote><h3 id="五、Map-和-Set"><a href="#五、Map-和-Set" class="headerlink" title="五、Map 和 Set"></a>五、Map 和 Set</h3><h4 id="1、Map"><a href="#1、Map" class="headerlink" title="1、Map"></a>1、Map</h4><blockquote><p>一组键值对，键必须为字符串类型。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;);</span><br><span class="line">m.set(&apos;Bob&apos;,59)</span><br><span class="line">m.delete(&apos;Adam&apos;);</span><br></pre></td></tr></table></figure><h4 id="2、Set"><a href="#2、Set" class="headerlink" title="2、Set"></a>2、Set</h4><blockquote><p>一组 key 的集合，不存储 value。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set([1, 2, 3]);</span><br><span class="line">s.add(4);</span><br><span class="line">s.delete(3);</span><br></pre></td></tr></table></figure><h3 id="六、iterable"><a href="#六、iterable" class="headerlink" title="六、iterable"></a>六、iterable</h3><h6 id="▉-普通-for-循环"><a href="#▉-普通-for-循环" class="headerlink" title="▉ 普通 for 循环"></a>▉ 普通 for 循环</h6><blockquote><p>当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率 。</p></blockquote><h6 id="▉-foreach-循环"><a href="#▉-foreach-循环" class="headerlink" title="▉ foreach 循环"></a>▉ foreach 循环</h6><blockquote><p><strong>功能：</strong>可以获取到 key 和 value 数组的本身。</p><p><strong>缺点：</strong></p><ul><li>不能用 break，continue 语句跳出循环。</li><li>函数内不能使用 return 语句。</li></ul><p><strong>注意：</strong>在不同浏览器下测试的结果都是 forEach 的速度不如 for 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//item 为数组元素</span></span><br><span class="line"><span class="comment">//index 为索引下标</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item,index,arr)</span><br><span class="line">&#125;,<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h6 id="▉-for…in-循环"><a href="#▉-for…in-循环" class="headerlink" title="▉  for…in 循环"></a>▉  for…in 循环</h6><blockquote><p><strong>for-in 循环遍历的是对象的属性。</strong>而不是数组的索引 ，除了遍历数组也可以遍历对象。</p><p><strong>缺点：</strong></p><ul><li>for-in 遍历的顺序并不是确定的。</li><li>它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。 </li><li>for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性 （Array 中的 length 不能遍历到），for-in 不适合遍历 Array 。【链接】：<a href="https://juejin.im/entry/5a1654e951882554b8373622" target="_blank" rel="noopener">https://juejin.im/entry/5a1654e951882554b8373622</a></li></ul></blockquote><h6 id="▉-for…of-循环"><a href="#▉-for…of-循环" class="headerlink" title="▉  for…of 循环"></a>▉  for…of 循环</h6><blockquote><p>ES6 新增语法。</p><p><strong>优点：</strong></p><ul><li>以正确响应 break, continue, return。 </li><li>for-of 循环不仅支持数组，还支持大多数类数组对象。</li><li>for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。</li><li>for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历 </li></ul></blockquote><h3 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h3><blockquote><p>在函数中如果没有 <code>return</code> 语句，函数执行完返回 <code>undefined</code>。</p></blockquote><h4 id="1、arguments"><a href="#1、arguments" class="headerlink" title="1、arguments"></a>1、arguments</h4><blockquote><p>此关键字只在函数内部起作用，并且永远指向当前函数调用者传入的所有参数。</p><p>1、即使函数不定义参数，也是可以通过 arguments 对象拿到传入的参数的。</p><p>2、通常用来判断传入参数的个数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x = '</span> + x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'arg '</span> + i + <span class="string">' = '</span> + <span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><h4 id="2、reset-参数（ES6）"><a href="#2、reset-参数（ES6）" class="headerlink" title="2、reset 参数（ES6）"></a>2、reset 参数（ES6）</h4><blockquote><p>由于 arguments 获取额外的传参非常的别扭，所以 ES6 新增了 rest 参数用来处理额外的参数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b,...rest</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入多余两个参数</span></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// Array[3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传入少于定义参数的个数</span></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//Array[] 空数组</span></span><br></pre></td></tr></table></figure><h4 id="3、注意-return-语句"><a href="#3、注意-return-语句" class="headerlink" title="3、注意 return  语句"></a>3、注意 return  语句</h4><blockquote><p>javascript 引擎会有一个行末添加分号的机制。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为&#123;表示语句尚未结束</span></span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>   <span class="comment">//这一行会可能被引擎自动加分号</span></span><br><span class="line">       &#123; <span class="attr">name</span>: <span class="string">'foo'</span>&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、变量作用域和解构赋值"><a href="#4、变量作用域和解构赋值" class="headerlink" title="4、变量作用域和解构赋值"></a>4、变量作用域和解构赋值</h4><h6 id="▉-全局作用域"><a href="#▉-全局作用域" class="headerlink" title="▉ 全局作用域"></a>▉ 全局作用域</h6><blockquote><p>javascript 只有一个全局作用域，如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报<code>ReferenceError</code>错误。 </p></blockquote><h6 id="▉-命名空间"><a href="#▉-命名空间" class="headerlink" title="▉ 命名空间"></a>▉ 命名空间</h6><blockquote><p>全局变量会绑定到 windows 上，不同的 javascript 文件使用相同的全局变量会产生命名冲突，我们很难发现，所以一般减少冲突的方法就是所有变量和函数全部绑定到一个全局变量中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line">MYAPP.name = <span class="string">'myapp'</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>许多 js 库都是这么干的，jQuery，YUI等。</p></blockquote><h6 id="▉-局部作用域"><a href="#▉-局部作用域" class="headerlink" title="▉ 局部作用域"></a>▉ 局部作用域</h6><blockquote><p>所谓的 js 作用域是在函数内部的，for 循环等语句块中是无法定义具有局部作用域变量的。ES6 引用了 let 代替 var 声明块级作用域变量。</p></blockquote><h6 id="▉-对多个变量同时赋值"><a href="#▉-对多个变量同时赋值" class="headerlink" title="▉ 对多个变量同时赋值"></a>▉ 对多个变量同时赋值</h6><blockquote><p>使用 ES6 新增加的解构赋值。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>];</span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><p>1、交换两个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>,y = <span class="number">2</span>;</span><br><span class="line">[x,y] = [y,x]</span><br></pre></td></tr></table></figure><p>2、快速获取当前页面的域名和路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">hostname</span>:domain, <span class="attr">pathname</span>:path&#125; = location;</span><br></pre></td></tr></table></figure><p>3、函数接受对象的属性为参数</p><blockquote><p>用解构直接将对象的属性绑定到变量中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildDate</span>(<span class="params">&#123;year, month, day, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(year + <span class="string">'-'</span> + month + <span class="string">'-'</span> + day + <span class="string">' '</span> + hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second);</span><br><span class="line">&#125;</span><br><span class="line">buildDate(&#123; <span class="attr">year</span>: <span class="number">2017</span>, <span class="attr">month</span>: <span class="number">1</span>, <span class="attr">day</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="5、方法"><a href="#5、方法" class="headerlink" title="5、方法"></a>5、方法</h4><h6 id="▉-this-指针"><a href="#▉-this-指针" class="headerlink" title="▉ this 指针"></a>▉ this 指针</h6><blockquote><p>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>。如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向全局对象，也就是<code>window</code>。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25, 正常结果</span></span><br><span class="line">getAge(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></span><br><span class="line">fn(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><blockquote><p>以上是 js 的设计错误，ECMA决定，在 strict 模式下让函数的<code>this</code>指向<code>undefined</code> 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="keyword">this</span>.birth; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>报错了，<code>this</code>  指针只在 <code>age</code> 方法的函数内指向 <code>xiaoming</code> 在函数内部定义的函数 ，this 指针指向 undefined ，他重新指向全局变量。</p></blockquote><p>改进方法，用 that 进行捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h6 id="▉-apply-方法"><a href="#▉-apply-方法" class="headerlink" title="▉ apply() 方法"></a>▉ apply() 方法</h6><blockquote><p><strong>作用： </strong>指针函数的 this 指向哪个对象。</p><p><strong>使用：</strong></p><ul><li>参数一：需要绑定的 this 变量。</li><li>参数二：传入的是 Array，表示函数本身的参数。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure><h6 id="▉-call-方法"><a href="#▉-call-方法" class="headerlink" title="▉ call() 方法"></a>▉ call() 方法</h6><blockquote><p>把参数按照顺序传入。</p></blockquote><h6 id="▉-装饰器"><a href="#▉-装饰器" class="headerlink" title="▉ 装饰器"></a>▉ 装饰器</h6><blockquote><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6、高阶函数"><a href="#6、高阶函数" class="headerlink" title="6、高阶函数"></a>6、高阶函数</h4><blockquote><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为<strong>高阶函数 </strong>。 </p></blockquote><h6 id="▉-map-对元素自身进行计算"><a href="#▉-map-对元素自身进行计算" class="headerlink" title="▉ map 对元素自身进行计算"></a>▉ map 对元素自身进行计算</h6><blockquote><p><code>map()</code> 方法定义在 JavaScript 的 <code>Array</code> 中 ,对数组中的每个数据做处理。</p><p><code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"><span class="built_in">console</span>.log(results);</span><br></pre></td></tr></table></figure><h6 id="▉-reduce-所有元素进行累加计算"><a href="#▉-reduce-所有元素进行累加计算" class="headerlink" title="▉ reduce 所有元素进行累加计算"></a>▉ reduce 所有元素进行累加计算</h6><blockquote><p>Array的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h6 id="▉-filter-过滤元素"><a href="#▉-filter-过滤元素" class="headerlink" title="▉ filter 过滤元素"></a>▉ filter 过滤元素</h6><blockquote><p>用于把  <code>Array</code>的某些元素过滤掉，然后返回剩下的元素。 和 <code>map()</code> 不同的是，<code>filter()</code> <strong>把传入的函数依次作用于每个元素，然后根据返回值是 <code>true</code> 还是 <code>false</code> 决定保留还是丢弃该元素。</strong> </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个Array中，删掉偶数，只保留奇数</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure><p><strong>● 回调函数</strong></p><blockquote><p>filter 有多个参数。</p><p><strong>1、一个参数：</strong>仅使用一个表示 Array 的某个元素。</p><p><strong>2、三个参数：</strong>回调函数可以接受另外两个参数，表示元素的<strong>位置</strong>和<strong>数组本身</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除重复元素依靠的是 indexOf 总是返回第一个元素的位置，后续的重复元素位置与 indexOf 返回的位置不相等，因此被 filter 滤掉了。</span></span><br><span class="line"><span class="keyword">var</span> r,</span><br><span class="line">arr = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'orange'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="▉-sort-排序"><a href="#▉-sort-排序" class="headerlink" title="▉ sort 排序"></a>▉ sort 排序</h6><blockquote><p>1、比较字符或者字符串，根据 ASCLL 码进行排序的。</p><p>2、比较数字，先将数组中的数字转换成字符串，然后再进行排序。</p></blockquote><p>sort 是一个高阶函数，可以传入函数来进行自定义的比较：</p><ul><li>数字比较</li></ul><blockquote><p>传入一个比较函数，-返回值为 1，-1，0；</p><p><strong>注意：</strong>sort 直接对 Array 进行修改，结果返回 Array。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="comment">//经断点调试，更像是一种插入排序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//变</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不变</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure><h4 id="6、闭包"><a href="#6、闭包" class="headerlink" title="6、闭包"></a>6、闭包</h4><blockquote><p>将闭包和 Java 类中的 get 获取内部私有变量做对比。</p></blockquote><h6 id="▉-什么是闭包？"><a href="#▉-什么是闭包？" class="headerlink" title="▉ 什么是闭包？"></a>▉ 什么是闭包？</h6><blockquote><p>只有函数内部的子函数才能读取局部变量，定义在一个函数内部的函数 。</p></blockquote><h6 id="▉-作用"><a href="#▉-作用" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>1）在函数的外部也可以获取到函数内部的局部变量。</p><p>2）让这些局部变量值始终保存在内存中，保证不会被 js “垃圾回收机制”回收。</p></blockquote><h6 id="▉-使用闭包注意事项"><a href="#▉-使用闭包注意事项" class="headerlink" title="▉ 使用闭包注意事项"></a>▉ 使用闭包注意事项</h6><blockquote><p>1）闭包会被保存到内存中，内存消耗很大，会造成网页性能问题，在 IE 会导致内存泄漏。在退出函数之前，将不适用的局部变量全部删除。</p></blockquote><h4 id="7、垃圾回收机制"><a href="#7、垃圾回收机制" class="headerlink" title="7、垃圾回收机制"></a>7、垃圾回收机制</h4><h6 id="▉-生命周期"><a href="#▉-生命周期" class="headerlink" title="▉ 生命周期"></a>▉ 生命周期</h6><blockquote><p>1）分配内存： javascript 自动完成内存的分配</p><p>2）使用内存（读或写）：使用值的过程实际上是对分配内存进行读取与写入的操作 </p><p>3）释放内存：在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。所以高级语言潜入垃圾回收机制。</p></blockquote><h6 id="▉-垃圾回收机制"><a href="#▉-垃圾回收机制" class="headerlink" title="▉ 垃圾回收机制"></a>▉ 垃圾回收机制</h6><blockquote><p>主要工作是跟踪内存的<strong>分配</strong>和<strong>使用</strong>，以便当分配的内存不再使用时，自动释放它。</p></blockquote><p><strong>1）引用</strong></p><blockquote><p>垃圾回收算法主要依赖于引用的概念 ，一个对象访问另一个对象就叫做引用。</p></blockquote><p><strong>2）引用计数垃圾收集</strong></p><blockquote><p>初级的垃圾回收算法，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p></blockquote><p><strong>3）限制：循环引用</strong></p><blockquote><p>当该函数调用完成离开作用域之后，可以被回收了，但是两个对象相互引用，所以不会被回收。（IE 6, 7对 DOM 结点进行计数垃圾回收）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）标记—清除算法</strong></p><blockquote><p>针对于“对象是否不再需要”。</p><p>1）算法假设有一个根对象（全局对象），垃圾回收器从根开始找所有从根开始引用的对象。</p><p>2）垃圾回收器将找到所有<strong>可以获得的对象</strong>和收集所有<strong>不能获得的对象</strong>。 （零引用总不可获得的）</p></blockquote><p><strong>5）限制：那些无法从根对象查询到的对象都将被清除</strong></p><h4 id="8、箭头函数"><a href="#8、箭头函数" class="headerlink" title="8、箭头函数"></a>8、箭头函数</h4><h6 id="▉-箭头中的-this"><a href="#▉-箭头中的-this" class="headerlink" title="▉ 箭头中的 this"></a>▉ 箭头中的 this</h6><blockquote><p>由于之前的函数中 this 绑定的错误处理，this 在箭头函数中被修复了。<strong>this 总是与词法作用域绑定</strong>（函数的作用域在函数定义的时候就决定了 ），由上下文确定 ，外层调用者 <code>obj</code>.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向window 或 undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="▉-注意"><a href="#▉-注意" class="headerlink" title="▉ 注意"></a>▉ 注意</h6><blockquote><p>由于<code>this</code>在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>调用箭头函数时，无法对<code>this</code>进行绑定，即传入的第一个参数被忽略。</p></blockquote><h4 id="9、generator-生成器"><a href="#9、generator-生成器" class="headerlink" title="9、generator 生成器"></a>9、generator 生成器</h4><h6 id="▉-定义"><a href="#▉-定义" class="headerlink" title="▉ 定义"></a>▉ 定义</h6><blockquote><p>整个 Generator 函数封装了异步任务。 标注 yield 地方都是异步需要暂停的地方（yield 将任务分为几个阶段）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-过程"><a href="#▉-过程" class="headerlink" title="▉ 过程"></a>▉ 过程</h6><blockquote><p><strong>1）</strong>调用 Generator 会返回一个指针对象（<strong>遍历器对象</strong> ），调用指针对象的的 next 方法，会移动指针的位置（异步任务的第一阶段），也就是指向遇到第一个 yield  的位置。 </p><p><strong>2）</strong>next 方法会返回一个当前阶段的对象，表示当前阶段的信息（value:当前阶段的值，yield：布尔值 ）表示 generator 是否执行完毕。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h6 id="▉-数据交换"><a href="#▉-数据交换" class="headerlink" title="▉ 数据交换"></a>▉ 数据交换</h6><blockquote><p>除了能够暂停、恢复之外，还可以作为函数体内外的数据交换。</p><p>1、不带有参数的 next 方法可以输出返回值。</p><p>2、带有参数的方法可以将参数作为上一阶段异步任务的返回结果，也就是输入。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><h6 id="▉-错误处理"><a href="#▉-错误处理" class="headerlink" title="▉ 错误处理"></a>▉ 错误处理</h6><blockquote><p>Generator 内部可以部署错误处理代码，捕获函数体外抛出的错误。</p><p>1、在函数外用指针的throw抛出的错误，被函数体内的  try … catch  代码块进行捕获。</p><p>2、实现了出错代码和处理错误的代码时间和空间上的分离。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw（<span class="string">'出错了'</span>）;</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><h6 id="▉-作用-1"><a href="#▉-作用-1" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>异步回调代码变成“同步”代码。</p></blockquote><h3 id="八、标准对象"><a href="#八、标准对象" class="headerlink" title="八、标准对象"></a>八、标准对象</h3><blockquote><p>总结一下，有这么几条规则需要遵守：</p></blockquote><ul><li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li><li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li><li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li><li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li><li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li><li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li><li>判断<code>null</code>请使用<code>myVar === null</code>；</li><li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li><li>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code>。</li></ul><blockquote><p>任何对象都有<code>toString()</code>方法吗？<code>null</code>和<code>undefined</code>就没有！确实如此，这两个特殊值要除外，虽然<code>null</code>还伪装成了<code>object</code>类型。</p></blockquote><h4 id="1、Date"><a href="#1、Date" class="headerlink" title="1、Date"></a>1、Date</h4><blockquote><p> JavaScript的 Date 对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure><h3 id="九、面向对象编程"><a href="#九、面向对象编程" class="headerlink" title="九、面向对象编程"></a>九、面向对象编程</h3><h4 id="1、继承设计思想"><a href="#1、继承设计思想" class="headerlink" title="1、继承设计思想"></a>1、继承设计思想</h4><h6 id="▉-js-的诞生"><a href="#▉-js-的诞生" class="headerlink" title="▉ js 的诞生"></a>▉ js 的诞生</h6><blockquote><p>为了让静态页面进行交互，设计一种语言完成不需要借助服务器完成的操作，如：表单验证。</p></blockquote><h6 id="▉-模仿其他-oop-进行设计"><a href="#▉-模仿其他-oop-进行设计" class="headerlink" title="▉  模仿其他 oop 进行设计"></a>▉  模仿其他 oop 进行设计</h6><blockquote><p>js 不像其他语言是面向对象语言有类的概念，为了能够即不引入类又能实现继承，所以 js 设计者模仿 oop 语言进行设计。</p><p>1、其他语言通过 new 来生成实例，所以 js 也通过 new 生成实例。</p><p>2、其他语言有类可以通过 new 来实现，js 并没有类，所以借助 new 构造函数来生成实例。</p><p>3、不同对象有不同的属性，也有相同的属性，对于每个对象相同的属性都需要在内存中开辟多个空间存储。能否使相同的属性只存一个呢？然后拥有该属性的对象都去引用它。</p></blockquote><h6 id="▉-prototype-属性"><a href="#▉-prototype-属性" class="headerlink" title="▉  prototype 属性"></a>▉  <strong>prototype</strong> 属性</h6><blockquote><p>我们就给构造函数设计一个 prototype 属性，用来存储不同对象相同的属性，共享的属性都存到这里边，不共享的属性就存放到构造函数中。其实 prototype 属性存储的就是一个对象，构造函数里边存放的都是变量，具体看变量和对象在内存中的引用。</p></blockquote><h6 id="▉-继承"><a href="#▉-继承" class="headerlink" title="▉  继承"></a>▉  继承</h6><blockquote><p>所有构造函数生成的对象都具有 prototype 对象里边的共享属性，就像是所有实例对象继承了 prototype 对象一样。</p></blockquote><h4 id="2、封装"><a href="#2、封装" class="headerlink" title="2、封装"></a>2、封装</h4><blockquote><p>其他语言因为有类的概念，对对象的封装是非常方便的，那么 js 是怎么封装对象的呢？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//猫对象</span></span><br><span class="line"><span class="keyword">var</span> Cat = &#123;</span><br><span class="line">    name : <span class="string">''</span>,</span><br><span class="line">    color : <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-原始模式"><a href="#▉-原始模式" class="headerlink" title="▉  原始模式"></a>▉  原始模式</h6><blockquote><p>下面简单的进行两个不同对象的封装，就会有两个问题：</p><p><strong>问题：</strong></p><p>1）生成多个实例对象写起来非常麻烦。</p><p>2）实例对象和原型对象之间没什么联系。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = &#123;&#125;; <span class="comment">// 创建一个空对象</span></span><br><span class="line">cat1.name = <span class="string">"大毛"</span>; <span class="comment">// 按照原型对象的属性赋值</span></span><br><span class="line">cat1.color = <span class="string">"黄色"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat2 = &#123;&#125;;</span><br><span class="line">cat2.name = <span class="string">"二毛"</span>;</span><br><span class="line">cat2.color = <span class="string">"黑色"</span>;</span><br></pre></td></tr></table></figure><h6 id="▉-原始模式改进"><a href="#▉-原始模式改进" class="headerlink" title="▉  原始模式改进"></a>▉  原始模式改进</h6><blockquote><p>用函数来解决代码重复的问题。</p><p><strong>问题：</strong></p><p>1）但是不能反映他们来自于同一个原型对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name:name,</span><br><span class="line">        color:color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成实例对象</span></span><br><span class="line"><span class="keyword">var</span> cat1 = Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = Cat(<span class="string">"二毛"</span>,<span class="string">"黑色"</span>);</span><br></pre></td></tr></table></figure><h6 id="▉-构造函数模式"><a href="#▉-构造函数模式" class="headerlink" title="▉  构造函数模式"></a>▉  构造函数模式</h6><blockquote><p>为了解决原型对象生成实例的问题，引入构造函数模式。</p><p>1）构造函数就是一个普通函数。</p><p>2）内部使用 this 变量，对构造函数使用 new 就能生成实例对象，内部的 this 指针就会指向实例对象。</p><p>3）每个实例对象都有 constructor 属性，并指向他们的构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.color=color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2）</span></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>,<span class="string">"黑色"</span>);</span><br><span class="line"><span class="comment">//3)</span></span><br><span class="line">alert(cat1.constructor == Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>问题：</strong></p><p>1）对于每个实例共享的属性，存在浪费内存的问题。</p></blockquote><h6 id="▉-原型模式（prototype-模式）"><a href="#▉-原型模式（prototype-模式）" class="headerlink" title="▉  原型模式（prototype 模式）"></a>▉  原型模式（prototype 模式）</h6><blockquote><p>每个构造函数都有一个 prototype 属性指向原型对象，我们将共享的属性存放到原型对象上，所有实例的共享属性其实都是同一个内存地址，指向<code>prototype</code>对象，因此就提高了运行效率。</p><p><strong>验证方法：</strong></p><p><strong>1）isPrototypeOf()</strong> ：验证实例与原型对象之间的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(Cat.prototype.isPrototypeOf(cat1)); //true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>2）hasOwnProperty()</strong>：判断某个属性来自本地还是原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>3）in运算符</strong>：判断某个实例是否拥有某个属性。以及遍历某个实例的所有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(&quot;name&quot; in cat1); // true</span><br><span class="line">&gt; for(var prop in cat1) &#123; alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2、原型继承"><a href="#2、原型继承" class="headerlink" title="2、原型继承"></a>2、原型继承</h4><h4 id="3、构造函数继承（五种）"><a href="#3、构造函数继承（五种）" class="headerlink" title="3、构造函数继承（五种）"></a>3、构造函数继承（五种）</h4><blockquote><p>两个构造函数。怎么让猫继承动物？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动物构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//猫的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第一种：构造函数的绑定"><a href="#▉-第一种：构造函数的绑定" class="headerlink" title="▉  第一种：构造函数的绑定"></a>▉  第一种：构造函数的绑定</h6><blockquote><p>用 call 或 apply 方法将父对象的构造函数绑定到子对象的构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//改变 this 的绑定</span></span><br><span class="line">    Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第二种：原型模式"><a href="#▉-第二种：原型模式" class="headerlink" title="▉  第二种：原型模式"></a>▉  第二种：原型模式</h6><blockquote><p>让猫构造函数的 prototype 等于 Animal 的实例，Animal 的实例拥有 Animal  的所有属性，所以相当于猫构造函数的 prototype 指向 Animal 实例了， 所有的猫的实例共享 Animal  里的属性了。</p><p>1) 每个实例都有 construct 属性，每个 prototype 也都有 construct 属性。</p><p>2）实例中的 construct 指向与 prototype 对象中 construct 指向同一个构造函数。也就是说改变 Cat 的原型对象之后，Cat 的实例对象 construct 属性指向的是 Animal 实例对象的 construct 属性，也就是 Animal 原型对象的 construct 属性，也就是构造函数 Animal 。</p><p>3）猫的实例对象是由 Cat 生成的，怎么能指向 Animal 呢，所以手动修改过来。</p><p>4）如果更换了 prototype对象 ，一定将 construct 属性修改过来。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><h6 id="▉-第三种：直接继承原型"><a href="#▉-第三种：直接继承原型" class="headerlink" title="▉  第三种：直接继承原型"></a>▉  第三种：直接继承原型</h6><blockquote><p>第二种方式的改进，跳过 Animal 的实例，直接将 Animal 的原型对象赋值给 Cat.prototype;</p><p><strong>优点：</strong>效率更高（不用执行和建立Animal的实例了 ）</p><p><strong>缺点：</strong><code>Cat.prototype</code> 和 <code>Animal.prototype</code> 现在指向了同一个对象，那么任何对 <code>Cat.prototype</code> 的修改，都会反映到 <code>Animal.prototype</code>。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = Animal.prototype;</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><h6 id="▉-第四种：空对象作为中介"><a href="#▉-第四种：空对象作为中介" class="headerlink" title="▉  第四种：空对象作为中介"></a>▉  第四种：空对象作为中介</h6><blockquote><p>对于第三种的缺点，第四种作为改进。F是空对象，所以几乎不占内存。 </p><p><strong>优点：</strong>修改Cat的prototype对象，就不会影响到Animal的prototype对象。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = Animal.prototype;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> F();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><p>将其封装成方法:</p><blockquote><p>这个 extend 函数，就是 YUI 库如何实现继承的方法。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　<span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">　　　　F.prototype = Parent.prototype;</span><br><span class="line">　　　　Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">　　　　Child.prototype.constructor = Child;</span><br><span class="line">　　　　Child.uber = Parent.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第五种：拷贝继承"><a href="#▉-第五种：拷贝继承" class="headerlink" title="▉  第五种：拷贝继承"></a>▉  第五种：拷贝继承</h6><blockquote><p>如果把父对象的 prototype 所有属性和方法，拷贝进子对象的 prototype 中 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> p = Parent.prototype;</span><br><span class="line">　　　　<span class="keyword">var</span> c = Child.prototype;</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　　　c[i] = p[i];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　c.uber = p;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h4 id="4、非构造函数继承"><a href="#4、非构造函数继承" class="headerlink" title="4、非构造函数继承"></a>4、非构造函数继承</h4><blockquote><p>让医生继承中国。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//父对象</span><br><span class="line">var Chinese = &#123;</span><br><span class="line">nation:&apos;中国&apos;</span><br><span class="line">&#125;;</span><br><span class="line">//子对象</span><br><span class="line">var Doctor =&#123;</span><br><span class="line">career:&apos;医生&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第一种：object-方法"><a href="#▉-第一种：object-方法" class="headerlink" title="▉  第一种：object()方法"></a>▉  第一种：object()方法</h6><blockquote><p>让中国成为医生的原型对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="▉-第二种：浅拷贝"><a href="#▉-第二种：浅拷贝" class="headerlink" title="▉  第二种：浅拷贝"></a>▉  第二种：浅拷贝</h6><blockquote><p>把父对象的属性，全部拷贝给子对象，也能实现继承。 拷贝继承分为浅拷贝和深拷贝。</p><p><strong>问题：</strong></p><p>1）如果父对象的属性等于数组或另一个对象，子对象获得的只是一个内存地址 ，子对象改变，父对象的属性也将改变。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function extendCopy(p) &#123;</span><br><span class="line">    var c = &#123;&#125;;</span><br><span class="line">    for (var i in p) &#123; </span><br><span class="line">    c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.uber = p;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第二种：深拷贝"><a href="#▉-第二种：深拷贝" class="headerlink" title="▉  第二种：深拷贝"></a>▉  第二种：深拷贝</h6><blockquote><p>弥补浅拷贝出现的问题，真正的将对象和数组及逆行拷贝，只要递归调用”浅拷贝”就行了 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　　　<span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">　　　　　　　　c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">　　　　　　　　deepCopy(p[i], c[i]);</span><br><span class="line">　　　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　　　　c[i] = p[i];</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> c;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><blockquote><p>jQuery库使用的就是这种继承方法。 </p></blockquote><h4 id="5、class-继承"><a href="#5、class-继承" class="headerlink" title="5、class 继承"></a>5、class 继承</h4><blockquote><p>class 的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用 class 的好处就是极大地简化了原型链代码。</p></blockquote><h3 id="十、浏览器"><a href="#十、浏览器" class="headerlink" title="十、浏览器"></a>十、浏览器</h3><h4 id="1、浏览器对象"><a href="#1、浏览器对象" class="headerlink" title="1、浏览器对象"></a>1、浏览器对象</h4><h6 id="▉-window"><a href="#▉-window" class="headerlink" title="▉ window"></a>▉ window</h6><blockquote><p><code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'window inner size: '</span> + <span class="built_in">window</span>.innerWidth + <span class="string">' x '</span> + <span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure><h6 id="▉-navigator"><a href="#▉-navigator" class="headerlink" title="▉ navigator"></a>▉ navigator</h6><blockquote><p><code>navigator</code>对象表示浏览器的信息，最常用的属性包括： </p></blockquote><ul><li>navigator.appName：浏览器名称；</li><li>navigator.appVersion：浏览器版本；</li><li>navigator.language：浏览器设置的语言；</li><li>navigator.platform：操作系统类型；</li><li>navigator.userAgent：浏览器设定的<code>User-Agent</code>字符串。</li></ul><h6 id="▉-screen"><a href="#▉-screen" class="headerlink" title="▉ screen"></a>▉ screen</h6><blockquote><p><code>screen</code>对象表示屏幕的信息，常用的属性有： </p></blockquote><ul><li>screen.width：屏幕宽度，以像素为单位；</li><li>screen.height：屏幕高度，以像素为单位；</li><li>screen.colorDepth：返回颜色位数，如8、16、24。</li></ul><h6 id="▉-location"><a href="#▉-location" class="headerlink" title="▉ location"></a>▉ location</h6><blockquote><p><code>location</code>对象表示当前页面的URL信息。 </p><p><strong>加载新页面：</strong>location.assign() 。</p><p><strong>重新加载：</strong>location.reload() 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</span></span><br><span class="line"><span class="comment">//可以用location.href获取</span></span><br><span class="line">location.protocol; <span class="comment">// 'http'</span></span><br><span class="line">location.host; <span class="comment">// 'www.example.com'</span></span><br><span class="line">location.port; <span class="comment">// '8080'</span></span><br><span class="line">location.pathname; <span class="comment">// '/path/index.html'</span></span><br><span class="line">location.search; <span class="comment">// '?a=1&amp;b=2'</span></span><br><span class="line">location.hash; <span class="comment">// 'TOP'</span></span><br></pre></td></tr></table></figure><h6 id="▉-document"><a href="#▉-document" class="headerlink" title="▉ document"></a>▉ document</h6><blockquote><p><code>document</code> 对象表示当前页面。由于 HTML 在浏览器中以 DOM 形式表示为树形结构，<code>document</code> 对象就是整个 DOM 树的根节点。 </p></blockquote><p><strong>Cookie</strong></p><blockquote><p>1) Cookie 是由服务器发送的 key-value 标示符。因为 HTTP 协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用 Cookie 来区分 。</p><p>2) 当一个用户成功登录后，服务器发送一个 Cookie 给浏览器，例如 <code>user=ABC123XYZ(加密的字符串)...</code>，此后，浏览器访问该网站时，会在请求头附上这个 Cookie，服务器根据 Cookie 即可区分出用户。<em>**</em></p><p><strong>安全性：</strong> </p><p>如果引入的第三方库存在恶意代码，则被第三方直接获取到用户登录信息。为了解决这个问题，服务器在设置 Cookie 的时候使用 <strong>httpOnly</strong>，设置的 Cookie 不能被 Javascript 读取。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie; <span class="comment">// 'v=123; remember=true; prefer=zh'</span></span><br></pre></td></tr></table></figure><h6 id="▉-history"><a href="#▉-history" class="headerlink" title="▉ history"></a>▉ history</h6><blockquote><p><code>history</code>对象保存了浏览器的历史记录，JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。 </p></blockquote><h4 id="2、操作-DOM"><a href="#2、操作-DOM" class="headerlink" title="2、操作 DOM"></a>2、操作 DOM</h4><h6 id="▉-更新-DOM"><a href="#▉-更新-DOM" class="headerlink" title="▉ 更新 DOM"></a>▉ 更新 DOM</h6><p><strong>1）<code>innerHtml</code>属性</strong></p><blockquote><p>修改文本。用<code>innerHTML</code>时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，<strong>要注意对字符编码来避免XSS攻击。</strong> </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC'</span>; <span class="comment">// &lt;p id="p-id"&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ'</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure><p><strong>2) 修改 innerText 或 textContent 属性</strong></p><blockquote><p>可以自动对字符串进行HTML编码，保证无法设置任何HTML标签： </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.innerText = <span class="string">'&lt;script&gt;alert("Hi")&lt;/script&gt;'</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br></pre></td></tr></table></figure><p><strong>3) 两者区别 </strong></p><blockquote><p>读取属性，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本。另外注意 <strong>IE &lt; 9</strong> 支持<code>textContent</code>。 </p></blockquote><p><strong>4）设置 CSS 样式 </strong></p><blockquote><p>DOM节点的<code>style</code>属性对应所有的 CSS 。CSS允许<code>font-size</code>这样的名称使用驼峰命名法（fontSize）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.style.fontSize = &apos;20px&apos;;</span><br></pre></td></tr></table></figure><h6 id="▉-插入-DOM"><a href="#▉-插入-DOM" class="headerlink" title="▉ 插入 DOM"></a>▉ 插入 DOM</h6><p><strong>1）使用 <code>appendChild</code> 把一个子节点添加到父节点的最后一个子节点。 </strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">    haskell.id = <span class="string">'haskell'</span>;</span><br><span class="line">    haskell.innerText = <span class="string">'Haskell'</span>;</span><br><span class="line">    list.appendChild(haskell);</span><br></pre></td></tr></table></figure><p><strong>2) insertBefore 插入指定位置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将子节点插入到 referenceElement 之前</span><br><span class="line">parentElement.insertBefore(newElement, referenceElement);</span><br></pre></td></tr></table></figure><h6 id="▉-删除-DOM"><a href="#▉-删除-DOM" class="headerlink" title="▉ 删除 DOM"></a>▉ 删除 DOM</h6><blockquote><p>parentElement () 得到删除节点的父节点，然后 removeChild() 删除节点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">'to-be-removed'</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">var</span> parent = self.parentElement;</span><br><span class="line"><span class="comment">// 删除:</span></span><br><span class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>1、删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 </p><p>2、parent.children[0] 删除节点的时候注意下标。</p></blockquote><h4 id="3、操作表单"><a href="#3、操作表单" class="headerlink" title="3、操作表单"></a>3、操作表单</h4><p>HTML表单的输入控件主要有以下几种： </p><ul><li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li><li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li><li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li><li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li><li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li><li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li></ul><h6 id="▉-获取值"><a href="#▉-获取值" class="headerlink" title="▉ 获取值"></a>▉ 获取值</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type="text" id="email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>);</span><br><span class="line">input.value; <span class="comment">// '用户输入的值'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;</span></span><br><span class="line">mon.value; <span class="comment">// '1'</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure><h6 id="▉-提交表单"><a href="#▉-提交表单" class="headerlink" title="▉ 提交表单"></a>▉ 提交表单</h6><p><strong>方法一：</strong></p><blockquote><p>响应一个 button 方法。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"doSubmitForm()"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 提交form:</span></span></span><br><span class="line"><span class="undefined">    form.submit();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><blockquote><p>onsubmit 事件。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"input-password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"md5-password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'input-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'md5-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line"><span class="undefined">    md5_pwd.value = toMD5(input_pwd.value);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="4、操作文件"><a href="#4、操作文件" class="headerlink" title="4、操作文件"></a>4、操作文件</h4><blockquote><p>在表单提交文件时，from 表单的 enctype  属性应该使用 <code>multipart/form-data</code>  不对文件数据进行编码才能上传，其他数据默认 <code>application/x-www-form-urlencoded</code>  编码再提交。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//input 的 ID</span><br><span class="line">var f = document.getElementById(&apos;test-file-upload&apos;);</span><br><span class="line">var filename = f.value; // &apos;C:\fakepath\test.png&apos;</span><br><span class="line">if (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) &#123;</span><br><span class="line">    alert(&apos;Can only upload image file.&apos;);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-File-API-操作文件"><a href="#▉-File-API-操作文件" class="headerlink" title="▉ File API 操作文件"></a>▉ File API 操作文件</h6><blockquote><p>HTML5的File API提供了 <code>File</code> 和 <code>FileReader</code> 两个主要对象，可以获得文件信息并读取文件。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">            fileInput = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-file'</span>),</span><br><span class="line">            info = <span class="built_in">document</span>.getElementById(<span class="string">'test-file-info'</span>),</span><br><span class="line">            preview = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-preview'</span>);</span><br><span class="line">            <span class="comment">// 监听change事件:</span></span><br><span class="line">            fileInput.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 清除背景图片:</span></span><br><span class="line">                preview.style.backgroundImage = <span class="string">''</span>;</span><br><span class="line">                <span class="comment">// 检查文件是否选择:</span></span><br><span class="line">                <span class="keyword">if</span> (!fileInput.value) &#123;</span><br><span class="line">                    info.innerHTML = <span class="string">'没有选择文件'</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取File引用:</span></span><br><span class="line">                <span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 获取File信息:</span></span><br><span class="line">                info.innerHTML = <span class="string">'文件: '</span> + file.name + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                                <span class="string">'大小: '</span> + file.size + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                                <span class="string">'修改: '</span> + file.lastModifiedDate;</span><br><span class="line">                <span class="keyword">if</span> (file.type !== <span class="string">'image/jpeg'</span> &amp;&amp; file.type !== <span class="string">'image/png'</span> &amp;&amp; file.type !== <span class="string">'image/gif'</span>) &#123;</span><br><span class="line">                    alert(<span class="string">'不是有效的图片文件!'</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 读取文件:</span></span><br><span class="line">                <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">                <span class="comment">//异步操作的回调函数</span></span><br><span class="line">                reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span></span><br><span class="line">                        data = e.target.result; <span class="comment">// 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            </span></span><br><span class="line">                    preview.style.backgroundImage = <span class="string">'url('</span> + data + <span class="string">')'</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 以DataURL的形式读取文件:(异步操作)</span></span><br><span class="line">                reader.readAsDataURL(file);</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h4 id="5、AJAX"><a href="#5、AJAX" class="headerlink" title="5、AJAX"></a>5、AJAX</h4><blockquote><p>需要注意的几点：</p><p>1、通过检测<code>window</code>对象是否有<code>XMLHttpRequest</code>属性来确定浏览器是否支持标准的<code>XMLHttpRequest</code> </p><p>2、先设置<code>onreadystatechange</code>的回调函数。在回调函数中，通常我们只需通过<code>readyState === 4</code>判断请求是否完成 </p><p>3、<code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数，分别为请求方式、URL地址、是否使用异步。</p><p>4、send 发送，Get 不需要参数，Post 需要把 body 部分以字符串或者 FormData 对象传进去。</p><p>关于 FromData 请查看：<a href="https://wangdoc.com/javascript/bom/form.html#formdata-%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">FormData</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = <span class="string">'Error code: '</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">//现代浏览器</span></span><br><span class="line">    request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//低版本 IE 浏览器</span></span><br><span class="line">    request = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</span><br></pre></td></tr></table></figure><h4 id="6、Cookie"><a href="#6、Cookie" class="headerlink" title="6、Cookie"></a>6、Cookie</h4><h6 id="▉-定义-1"><a href="#▉-定义-1" class="headerlink" title="▉ 定义"></a>▉ 定义</h6><blockquote><p>1）概念：Cookie 小段文本信息，存储于计算机硬盘中，大小只有 4 k。</p><p>2）特点：每个 Cookie 文件都对应一个域名，同一域名下的所以页面可以共享 Cookie，不能跨域名访问。</p><p>3）使用：通常从 document 中提取 cookie 属性提供给 javascript，然后进行创建或发送 cookie 到服务器。</p></blockquote><h6 id="▉-作用-2"><a href="#▉-作用-2" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>cookie 是存在用户硬盘中，用户每次访问站点时，Web应用程序都可以读取 Cookie 包含的信息。当用户再次访问这个站点时，<strong>浏览器就会在本地硬盘上查找与该 URL 相关联的 <code>Cookie</code></strong>。如果该 Cookie 存在，浏览器就将它添加到 <code>request header</code> 的 <code>Cookie</code> 字段中，与 <code>http请求</code> 一起发送到该站点。 </p></blockquote><h6 id="▉-缺点"><a href="#▉-缺点" class="headerlink" title="▉ 缺点"></a>▉ 缺点</h6><ul><li>安全性：由于cookie在HTTP中是明文传递的，其中包含的数据都可以被他人访问，可能会被篡改、盗用。</li><li>大小限制：cookie的大小限制在4KB左右，若要做大量存储显然不是理想的选择。</li><li>增加流量：cookie每次请求都会被自动添加到Request Header中，无形中增加了流量。cookie信息越大，对服务器请求的时间也越长。</li></ul><h6 id="▉-用途"><a href="#▉-用途" class="headerlink" title="▉ 用途"></a>▉ 用途</h6><blockquote><p>Cookie 一般用于保存网页访问者的信息。</p><p>1）保存用户登录信息。在一些登录网站选择下次自动登录，登录成功后，后台对用户名和密码进行加密返回数据，客户端就会将数据存储到 Cookie 中。当用户下一次进行登录时，判断 Cookie 中否存在值，存在则将Cookie 信息加到 HTTP 头部发送到服务器，实现自动登录。</p><p>2）创建购物车。通常将选择的物品放入 Cookie 中，同一域名下页面实现 Cookie 共享，提交订单将 Cookie 传到后台。</p><p>3）跟踪用户。用 Cookie 记录用户的偏好信息，然后推广小广告，在侧边栏经常是我们之前搜索过的内容。</p></blockquote><h6 id="▉-其他存储机制"><a href="#▉-其他存储机制" class="headerlink" title="▉ 其他存储机制"></a>▉ 其他存储机制</h6><blockquote><p><strong>1）web存储机制 </strong> </p><ul><li>sessionStorage：用于一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除 </li><li>localStorage ：用于跨会话持久化地存储数据。</li></ul><p><strong>2）indexedDB </strong></p><ul><li>是 indexed Database API 的简称，是在浏览器中保存结构化数据的一种「数据库」，它类似SQL数据库的结构化数据存储机制 ， 它能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。 </li></ul></blockquote><h4 id="7、-同源跨域问题"><a href="#7、-同源跨域问题" class="headerlink" title="7、 同源跨域问题"></a>7、 同源跨域问题</h4><p>请查看另一篇：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript 的重点学习路线完整篇。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack成神之路之插件配置【CSS 图片处理_08】</title>
    <link href="http://yoursite.com/2019/05/08/Webpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90CSS%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86_08%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/08/Webpack成神之路之插件配置【CSS图片处理_08】/</id>
    <published>2019-05-08T08:25:02.150Z</published>
    <updated>2019-05-09T06:52:09.523Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>webpack 处理 CSS 中的图片！</p><a id="more"></a> <h2 id="01-CSS-中的图片处理"><a href="#01-CSS-中的图片处理" class="headerlink" title="01|CSS 中的图片处理"></a>01|CSS 中的图片处理</h2><h4 id="1、图片准备"><a href="#1、图片准备" class="headerlink" title="1、图片准备"></a>1、图片准备</h4><blockquote><p>通常我们保存的图片早 <code>src</code> 中的 <code>images</code> 文件夹下。</p></blockquote><h4 id="2、安装解析图片的-loader"><a href="#2、安装解析图片的-loader" class="headerlink" title="2、安装解析图片的 loader"></a>2、安装解析图片的 loader</h4><blockquote><p>1）当我们直接用 <code>webpack</code> 命令时，就会报错，报错的原因就是无法解析 <code>CSS</code> 中的图片。之前解析 <code>CSS</code> 文件使用的 <code>loader</code> ，所以我们要添加专门解析图片用的 <code>loader</code>。</p><p>2）<code>webpack</code> 打包将各个模块打包成一个文件，所以我们的样式文件 <code>url</code> 是相对于 <code>CSS</code> 文件的，当我们打包成一个文件，<code>url</code>  的路径是相对于 <code>html</code> 而言的，导致原来的 <code>css</code> 文件引入的路径就会导致找不到原来的图片位置。</p><p>3）图片过多，导致有很多的 http 请求，降低页面的性能。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br></pre></td></tr></table></figure><ul><li><strong>file-loader：</strong>这个模块主要解决上述 （2）的问题。<code>file-loader</code> 可以解析项目中的 <code>ur</code> l引入（不仅限于 <code>css</code> ），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。</li><li><strong>url-loader：</strong>这个模块主要解决上述 （3）的问题。<code>url-loader</code> 会将引入的图片编码，生成 <code>dataURl</code>。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此 <code>url-loader</code> 提供了一个 <code>limit</code> 参数，小于 <code>limit</code> 字节的文件会被转为 <code>DataURl</code>，大于 <code>limit</code> 的还会使用 <code>file-loader</code> 进行 <code>copy</code>.。</li></ul><h4 id="3、配置-loader"><a href="#3、配置-loader" class="headerlink" title="3、配置 loader"></a>3、配置 loader</h4><blockquote><ul><li><code>test:/.(png|jpg|gif)/：</code>是匹配图片文件后缀名称。</li><li><code>use：</code>是指定使用的 <code>loader</code> 和 <code>loader</code> 的配置参数。</li><li><code>imit：</code>是把小于 <code>500000B</code> 的文件打成 <code>Base64</code> 的格式，写入JS。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpg|gif)/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        limit: <span class="number">500000</span>,</span><br><span class="line">                        outputPath:<span class="string">'images/'</span>, <span class="comment">// 将图片放到规定的目录下</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125; </span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="4、url-loader-和-file-loader-的关系"><a href="#4、url-loader-和-file-loader-的关系" class="headerlink" title="4、url-loader 和 file-loader 的关系"></a>4、url-loader 和 file-loader 的关系</h4><blockquote><p><code>url-loader</code>封装了 <code>file-loader</code>，配置中的 <code>limit</code> ，<code>url-loader</code> 会调用  <code>file-loader</code>进行处理。</p></blockquote><h2 id="02-CSS分离与图片路径处理"><a href="#02-CSS分离与图片路径处理" class="headerlink" title="02|CSS分离与图片路径处理"></a>02|CSS分离与图片路径处理</h2><blockquote><p>1）把 <code>CSS</code> 从J <code>avasScript</code> 代码中分离出来 。</p><p>2）如何处理分离出来后 <code>CSS</code> 中的图片路径不对问题 。</p></blockquote><h4 id="1、CSS-分离"><a href="#1、CSS-分离" class="headerlink" title="1、CSS 分离"></a>1、CSS 分离</h4><blockquote></blockquote><h4 id="2、安装插件（extract-text-webpack-plugin）"><a href="#2、安装插件（extract-text-webpack-plugin）" class="headerlink" title="2、安装插件（extract-text-webpack-plugin）"></a>2、安装插件（extract-text-webpack-plugin）</h4><blockquote><p>注意版本号，我 webpack3.0 使用的是 2.0.1 版本的插件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin@<span class="number">2.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h4 id="3、配置文件"><a href="#3、配置文件" class="headerlink" title="3、配置文件"></a>3、配置文件</h4><blockquote><p>1）引入插件。</p><p>2）new 出插件对象。</p><p>3）修改 <code>style-loader</code> 和 <code>css-loader</code>。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> extractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>); </span><br><span class="line"><span class="comment">// 此路径是分离的 CSS 文件路径</span></span><br><span class="line"><span class="keyword">new</span> extractTextPlugin(<span class="string">"/css/index.css"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">        use:extractTextPlugin.extract(&#123;</span><br><span class="line">            fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">            use: <span class="string">"css-loader"</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="4、路径失效问题"><a href="#4、路径失效问题" class="headerlink" title="4、路径失效问题"></a>4、路径失效问题</h4><h2 id="03-处理-HTML-中的图片"><a href="#03-处理-HTML-中的图片" class="headerlink" title="03|处理 HTML 中的图片"></a>03|处理 HTML 中的图片</h2><blockquote><p>通常我们会在 HTML 中引入图片，需要对 HTML 中的图片进行打包。</p></blockquote><h4 id="1、安装-Loader"><a href="#1、安装-Loader" class="headerlink" title="1、安装 Loader"></a>1、安装 Loader</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br></pre></td></tr></table></figure><h4 id="2、配置-Loader"><a href="#2、配置-Loader" class="headerlink" title="2、配置 Loader"></a>2、配置 Loader</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(htm|html)$/i</span>,</span><br><span class="line">     use:[ <span class="string">'html-withimg-loader'</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack 处理 CSS 中的图片！&lt;/p&gt;
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/webpack/"/>
    
    
      <category term="前端工具" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【CSS 常用布局】</title>
    <link href="http://yoursite.com/2019/05/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90CSS%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/06/前端面试之道【CSS常用布局】/</id>
    <published>2019-05-05T23:43:01.094Z</published>
    <updated>2019-05-06T00:09:13.321Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CSS 中常用的几种布局方式！</p><a id="more"></a><h2 id="三种最基本的布局方式"><a href="#三种最基本的布局方式" class="headerlink" title="三种最基本的布局方式"></a>三种最基本的布局方式</h2><h3 id="1、流式布局"><a href="#1、流式布局" class="headerlink" title="1、流式布局"></a>1、流式布局</h3><blockquote><p>流动布局模型就是<strong>默认的</strong>网页布局模式。</p></blockquote><ul><li><strong>块级元素</strong>都会在所处的最近父级容器元素内<strong>自上而下</strong>按顺序垂直顺延分布，块元素的宽度一般为 100%，也就是父元素的宽度。</li><li><strong>内联元素</strong>一般<strong>从左到右</strong>依次分布显示。</li></ul><h3 id="2、浮动布局"><a href="#2、浮动布局" class="headerlink" title="2、浮动布局"></a>2、浮动布局</h3><blockquote><p>流式布局的元素基本都是在整个文档流中的，如果使用浮动布局，需要给某一元素设置浮动属性，脱离当前文档流。</p></blockquote><h3 id="3、层级布局"><a href="#3、层级布局" class="headerlink" title="3、层级布局"></a>3、层级布局</h3><blockquote><p>层级布局指的是通过<strong>相对定位</strong>以及<strong>绝对定位</strong>以及<strong>固定定位</strong>的方式来进行布局。</p><p>1）通过设置 top、left、right、bottom 来记性定位元素。</p><p>2）缺点：对于相应式的布局，该布局方式还有很多不便之处。</p></blockquote><ul><li><strong>fixed 定位：</strong>固定定位，相对于浏览器窗口进行定位，不随窗口滚动，可以和其他元素重叠，不占据空间。</li><li><strong>relative 定位：</strong>相对定位，相对于正常位置进行定位，原本的空间不会改变。</li><li><strong>absolute 定位：</strong>绝对定位，是相对于已经定位的父元素进行定位，如果没有父元素，就相当于 <code>&lt;html&gt;</code> ，不占据任何空间，定位元素可以和其他元素进行重叠。</li></ul><h2 id="弹性布局（Flex）"><a href="#弹性布局（Flex）" class="headerlink" title="弹性布局（Flex）"></a>弹性布局（Flex）</h2><h2 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h2><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><h2 id="两种自适应布局"><a href="#两种自适应布局" class="headerlink" title="两种自适应布局"></a>两种自适应布局</h2><h3 id="1、双飞翼布局"><a href="#1、双飞翼布局" class="headerlink" title="1、双飞翼布局"></a>1、双飞翼布局</h3><h3 id="2、圣杯布局"><a href="#2、圣杯布局" class="headerlink" title="2、圣杯布局"></a>2、圣杯布局</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 中常用的几种布局方式！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【盒模型】</title>
    <link href="http://yoursite.com/2019/05/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E7%9B%92%E6%A8%A1%E5%9E%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/06/前端面试之道【盒模型】/</id>
    <published>2019-05-05T23:12:51.565Z</published>
    <updated>2019-05-05T23:42:55.427Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>盒模型相关知识点！</p><a id="more"></a><h2 id="css-盒模型"><a href="#css-盒模型" class="headerlink" title="css 盒模型"></a>css 盒模型</h2><h3 id="一、盒模型的分类"><a href="#一、盒模型的分类" class="headerlink" title="一、盒模型的分类"></a>一、盒模型的分类</h3><blockquote><p>IE 盒模型和 W3C 标准盒模型。</p></blockquote><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><blockquote><p>一个盒子模型是由 外边距（margin）、边框（border）、内边距（padding）、内容（content）四部分组成的。</p></blockquote><h4 id="IE-盒模型"><a href="#IE-盒模型" class="headerlink" title="IE 盒模型"></a>IE 盒模型</h4><blockquote><p>盒子的属性 <code>width</code>  和 <code>height</code> 指的是 <code>content + padding + border</code>。</p></blockquote><h4 id="W3C-标准盒模型"><a href="#W3C-标准盒模型" class="headerlink" title="W3C 标准盒模型"></a>W3C 标准盒模型</h4><blockquote><p>盒子的属性 <code>width</code>  和 <code>height</code> 指的是 <code>content</code>。</p></blockquote><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><blockquote><p>1）只有在 IE8 + 版本中可以通过 <code>box-sizing（centent-box 标准盒模型/border-sizing IE 盒模型）</code> 切换 IE 盒模型和 W3C 标准盒模型。其他浏览器需要加上前缀。</p><p>2）在 IE6、IE7、IE8 中添加 <code>&lt;!DOCTYPE&gt;</code> 就会使用 <code>W3C</code> 标准盒模型。否则出现不同浏览器兼容性问题（IE浏览器会将盒子模型解释为 IE 盒子模型，FireFox等会将其解释为 W3C 盒子模型）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;盒模型相关知识点！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【网络攻击】</title>
    <link href="http://yoursite.com/2019/05/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/02/前端面试之道【网络攻击】/</id>
    <published>2019-05-02T12:21:03.578Z</published>
    <updated>2019-05-04T03:09:38.879Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常见的网络攻击！</p><a id="more"></a><h2 id="一、XSS-攻击"><a href="#一、XSS-攻击" class="headerlink" title="一、XSS 攻击"></a>一、XSS 攻击</h2><h4 id="1、XSS-是什么"><a href="#1、XSS-是什么" class="headerlink" title="1、XSS 是什么"></a>1、XSS 是什么</h4><blockquote><p>XSS 攻击称为跨站脚本攻击，是一种代码注入的攻击。攻击者通过向目标网站注入恶意脚本，使之在浏览器中运行。利用脚本获取到用户的信息。</p></blockquote><p>XSS 常见几种注入方法：</p><ul><li>以 javascript 标签的形式注入。</li><li>在内联 javascript 中，拼接的数据突破了原本的限制（字符串、变量等）</li><li>在属性标签中，恶意内容包含引号，突破属性值的限制，注入其他属性。</li><li>在标签的 href、src 等属性中，包含 js 可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制的代码。</li></ul><h4 id="2、XSS-攻击的分类"><a href="#2、XSS-攻击的分类" class="headerlink" title="2、XSS 攻击的分类"></a>2、XSS 攻击的分类</h4><ul><li>存储型 XSS</li><li>反射型 XSS</li><li>DOM型 XSS</li></ul><h5 id="▉-存储型-XSS"><a href="#▉-存储型-XSS" class="headerlink" title="▉ 存储型 XSS"></a>▉ 存储型 XSS</h5><blockquote><p>最危险的一种跨站脚本攻击，危害比反射性和DOM型都要大，因为不需要用户手动触发。<strong>恶意代码存储在数据库中</strong>。</p></blockquote><p>1）攻击者将恶意代码提交至目标网站的数据库中。</p><p>2）用户打开网站，网站将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</p><p>3）浏览器将服务器返回的 HTML 进行解析，恶意代码被执行。</p><p>4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。</p><h5 id="▉-反射型-XSS"><a href="#▉-反射型-XSS" class="headerlink" title="▉ 反射型 XSS"></a>▉ 反射型 XSS</h5><blockquote><p>需要用户主动打开 URL 。<strong>恶意代码存储在 URL 中</strong>。常见的用于 URL 传递参数的功能，如：网站搜索、跳转等。</p></blockquote><p>1）攻击者伪造包含恶意代码的URL。</p><p>2）用户打开恶意的URL，服务端将恶意的 <code>URL</code> 代码取出拼接在<code>HTML</code> 后返回给浏览器。</p><p>3）用户浏览器解析请求，恶意代码得到执行。</p><p>4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。</p><h5 id="▉DOM-型-XSS"><a href="#▉DOM-型-XSS" class="headerlink" title="▉DOM 型 XSS"></a>▉DOM 型 XSS</h5><blockquote><p>DOM 型 XSS 攻击中，取出和执行<strong>恶意代码由浏览器端完成</strong>，属于前端 <code>JavaScript</code> 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 </p></blockquote><p>1）攻击者伪造包含恶意代码的 <code>URL</code>。</p><p>2）用户打开恶意的 <code>URL</code>。</p><p>3）前端 <code>Javascript</code> 取出 <code>URL</code> 中的恶意代码<strong>由浏览器完成</strong>，属于前端 <code>javascript</code> 自身的安全漏洞，触发XSS <strong>靠的是浏览器端的DOM解析</strong> 。</p><p>4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。</p><h4 id="3、防御-XSS"><a href="#3、防御-XSS" class="headerlink" title="3、防御 XSS"></a>3、防御 XSS</h4><h5 id="▉-常用的防御方法"><a href="#▉-常用的防御方法" class="headerlink" title="▉ 常用的防御方法"></a>▉ 常用的防御方法</h5><blockquote><p>一般页面输入的地方会存在 XSS 攻击的危险。</p></blockquote><ul><li><strong>httpOnly:</strong> 在 <code>cookie</code> 中设置 <code>HttpOnly</code> 属性后，js 脚本无法读取到 <code>Cookie</code> 信息。</li><li><strong>输入过滤：</strong>用于对输入格式的检查（邮箱、电话号码等）。前后台多要进行过滤检查，因为攻击者完全可以绕过前端直接利用接口对后端发送设置。</li><li><strong>白名单：</strong>名单控制允许的 <code>HTML</code>标签及各标签的属性 。</li><li><strong>转义 HTML：</strong>如果拼接 <code>HTML</code> 是必要的，对于引号，尖括号，斜杠进行转义（可以借助转义库）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">'&amp;#96;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2F;'</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="▉-预防存储型和反射性-XSS-攻击"><a href="#▉-预防存储型和反射性-XSS-攻击" class="headerlink" title="▉ 预防存储型和反射性 XSS 攻击"></a>▉ 预防存储型和反射性 XSS 攻击</h5><blockquote><p>这两种攻击一般在服务器端取出恶意代码，拼接到 <code>HTML</code> 中，然后被浏览器所执行。</p></blockquote><p><strong>1、改成纯前端渲染，使代码和数据分离。</strong></p><blockquote><p><strong>作用：</strong>明确告诉浏览器，要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了 。</p><p><strong>缺点：</strong>需要避免 DOM 型的 XSS 攻击。</p><p>1）浏览器先加载一个静态 <code>HTML</code>，此 <code>HTML</code> 中不包含任何跟业务相关的数据。</p><p>2）然后浏览器执行 <code>HTML</code> 中的 <code>JavaScript</code>。</p><p>3）<code>JavaScript</code> 通过 <code>Ajax</code> 加载业务数据，调用 <code>DOM API</code> 更新到页面上 </p></blockquote><p><strong>2、对 HTML 做充分的转义。</strong></p><blockquote><p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题,这时就需要对HTML进行充分的转义。 </p></blockquote><h5 id="▉-预防-DOM-型-XSS-攻击"><a href="#▉-预防-DOM-型-XSS-攻击" class="headerlink" title="▉ 预防 DOM 型 XSS 攻击"></a>▉ 预防 DOM 型 XSS 攻击</h5><blockquote><p>由于前端的 javascript 代码本身不够严谨，把不可信的数据当做代码执行了。</p></blockquote><p><strong>1、HTML 插入数据</strong></p><blockquote><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等 </p></blockquote><p><strong>2、DOM 内联监听</strong></p><blockquote><p>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;</span><br><span class="line">&lt;img onclick=<span class="string">"UNTRUSTED"</span> onerror=<span class="string">"UNTRUSTED"</span> src=<span class="string">"data:image/png,"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 链接内包含恶意代码 --&gt;</span><br><span class="line">&lt;a href=<span class="string">"UNTRUSTED"</span>&gt;<span class="number">1</span>&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ setTimeout()/</span>setInterval() 中调用恶意代码</span><br><span class="line">setTimeout(<span class="string">"UNTRUSTED"</span>)</span><br><span class="line">setInterval(<span class="string">"UNTRUSTED"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// location 调用恶意代码</span></span><br><span class="line">location.href = <span class="string">'UNTRUSTED'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eval() 中调用恶意代码</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"UNTRUSTED"</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、CSRF-跨站请求伪造"><a href="#二、CSRF-跨站请求伪造" class="headerlink" title="二、CSRF 跨站请求伪造"></a>二、CSRF 跨站请求伪造</h2><h3 id="2-1-跨站请求伪造（CSRF）"><a href="#2-1-跨站请求伪造（CSRF）" class="headerlink" title="2.1 跨站请求伪造（CSRF）"></a>2.1 跨站请求伪造（CSRF）</h3><blockquote><p>跨站伪造请求（Cross-site request forgery ），缩写为 CSRF。冒充用户发起请求（在用户不知情的情况下）， 完成一些违背用户意愿的事情（如修改用户信息，删初评论等）。 </p></blockquote><h4 id="1、攻击原理"><a href="#1、攻击原理" class="headerlink" title="1、攻击原理"></a>1、攻击原理</h4><blockquote><p>攻击者通过技术手段欺骗用户的浏览器去访问一个曾经认证过的网站，所以用户不用进行重新认证，这是一个用户身份验证的一个漏洞：<strong>简单身份认证只保证请求来自某个用户的浏览器，确不能保证请求的本身是用户自愿发出的。</strong>攻击者诱导用户在刚访问不久的网站中点击设定的链接（本页的论坛、博客等自动生成的链接内容）。</p></blockquote><h4 id="2、防御措施"><a href="#2、防御措施" class="headerlink" title="2、防御措施"></a>2、防御措施</h4><h6 id="▉-检查-Referer-字段"><a href="#▉-检查-Referer-字段" class="headerlink" title="▉ 检查 Referer 字段"></a>▉ 检查 Referer 字段</h6><blockquote><p>HTTP 头有一个 <code>Referer</code> 字段，用来标记请求来源于哪个地址。<code>Referer</code> 字段应和请求的地址位于同一域名下。 服务器在处理请求的时候，可以判断该字段是否位于正确的源地址下发送的请求。如果是 CSRF 攻击，该字段会包含恶意的网址。</p><p><strong>局限性：</strong>设置 <code>Referer</code> 有本身的局限性，攻击者可以篡改 <code>Referer</code> 字段来达到攻击的目的。</p></blockquote><h6 id="▉-Token-验证"><a href="#▉-Token-验证" class="headerlink" title="▉  Token 验证"></a>▉  Token 验证</h6><blockquote><p>CSRF 的本质是在于攻击者欺骗自己去访问设置的地址，如果在请求数据的时候，用户不把信息保存到浏览器的 <code>Cookie</code> 中，那么攻击者无法获取数据校验，从而不能进行 CSRF 攻击。</p></blockquote><ul><li><strong>第一步：</strong>后端随机产生一个 <code>token</code>，把这个 <code>token</code> 保存到 <code>session</code> 状态中；同时后端把这个 <code>token</code> 交给前端页面；</li><li><strong>第二步：</strong>前端页面提交请求时，把 <code>token</code> 加入到请求数据或者头信息中，一起传给后端；</li><li><strong>第三步：</strong>端验证前端传来的 <code>token</code> 与 <code>session</code> 是否一致，一致则合法，否则是非法请求。</li></ul><h2 id="四、DNS-攻击"><a href="#四、DNS-攻击" class="headerlink" title="四、DNS 攻击"></a>四、DNS 攻击</h2><h4 id="1、什么是-DNS-攻击？"><a href="#1、什么是-DNS-攻击？" class="headerlink" title="1、什么是 DNS 攻击？"></a>1、什么是 DNS 攻击？</h4><blockquote><p>利用 DNS（域名系统）中的漏洞，发起 DNS 攻击。</p></blockquote><h6 id="▉-DNS-的工作原理"><a href="#▉-DNS-的工作原理" class="headerlink" title="▉ DNS 的工作原理"></a>▉ DNS 的工作原理</h6><blockquote><p>将用户输入的域名转换成相对应的 IP 地址。</p></blockquote><ul><li>DNS 首先搜索缓存中是否存在该域名的 IP 地址。</li><li>如果找不到该域名的地址，就到 DNS 服务器查找该域名准确的 IP 地址。</li><li>DNS 一直循环工作，DNS 服务器之间可以相互查询到域名的 IP 地址的DNS 服务器。</li><li>DNS 一旦找到 IP 地址，就将当前的 IP 地址返回给请求的程序，将其存储缓存中。</li></ul><h6 id="▉-如何利用-DNS-攻击"><a href="#▉-如何利用-DNS-攻击" class="headerlink" title="▉ 如何利用 DNS 攻击"></a>▉ 如何利用 DNS 攻击</h6><blockquote><p>1）DNS 不太注重安全问题，所以容易被攻击者发起 DNS 攻击。攻击者利用一种方式来用恶意的 IP 地址替换 DNS 解析的域名的 IP 地址，那么用户发送的数据发送到这个攻击者替换的 IP 假地址中去。</p><p>2）DNS 服务器配置不记得它的默认配置，所以利用这一漏洞进行攻击。</p></blockquote><h6 id="▉-DNS-的攻击类型"><a href="#▉-DNS-的攻击类型" class="headerlink" title="▉ DNS 的攻击类型"></a>▉ DNS 的攻击类型</h6><ul><li><strong>零日攻击：</strong>利用 DNS 服务器软件和协议堆栈中未知的漏洞。</li><li><strong>Fast Flux DNS ： </strong>以高频率交换 DNS 记录以重定向 DNS 请求，也有利于攻击者避免检测。</li><li><strong>DNS 欺骗：</strong>攻击者通过用服务器缓存中的伪造 IP 地址替换授权的 IP 地址来破坏整个DNS服务器。通过这种方式，他们将整个流量重定向到恶意网站并收集重要信息。 </li></ul><h2 id="五、DDOS-攻击"><a href="#五、DDOS-攻击" class="headerlink" title="五、DDOS 攻击"></a>五、DDOS 攻击</h2><blockquote><p>DDoS 攻击称为<strong>分布式拒绝服务攻击</strong>。 通过多台计算机对 DNS 服务器发送大量的请求，达到目标的 DNS 服务器无法进行正常队请求进行解析回应的目的。DDoS 攻击可能导致整个 DNS 服务器崩溃并使用户无法访问 Web。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的网络攻击！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之题型篇【查找和排序】</title>
    <link href="http://yoursite.com/2019/05/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A2%98%E5%9E%8B%E7%AF%87%E3%80%90%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/02/数据结构与算法之题型篇【查找和排序】/</id>
    <published>2019-05-02T10:57:10.751Z</published>
    <updated>2019-05-04T08:37:35.439Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据结构与算法中所必会的查找和排序算法。</p><a id="more"></a><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><h2 id="一、查找和排序的基础练习（阶段一）"><a href="#一、查找和排序的基础练习（阶段一）" class="headerlink" title="一、查找和排序的基础练习（阶段一）"></a>一、查找和排序的基础练习（阶段一）</h2><h2 id="二、查找和排序的进阶练习（阶段二）"><a href="#二、查找和排序的进阶练习（阶段二）" class="headerlink" title="二、查找和排序的进阶练习（阶段二）"></a>二、查找和排序的进阶练习（阶段二）</h2><h3 id="1、旋转数组的最小数字"><a href="#1、旋转数组的最小数字" class="headerlink" title="1、旋转数组的最小数字"></a>1、旋转数组的最小数字</h3><blockquote><p>题目：把一个数组最开始的若干个元素搬移到数组的尾部，称为旋转数组。输入一个递增排序的数组的一个旋转，输出旋转数组中最小的值。</p></blockquote><h4 id="1-1-问题分析与解决"><a href="#1-1-问题分析与解决" class="headerlink" title="1.1 问题分析与解决"></a>1.1 问题分析与解决</h4><h6 id="▉-问题分析"><a href="#▉-问题分析" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><blockquote><p>1）最先想到的方法是暴力破解法，能否遍历整个数组，得出最小值呢？</p><p>2）暴力破解法时间复杂度太高，是否还有其他方法减少时间复杂度呢？查找一个数据，我们想到的方法是二分查找，但是二分查找是查找一个给定值的数据。能够自己改进一下，借助二分查找的思想呢？</p><p>我们发现旋转数组是由两个升序的数组组成的，最小值的位置是在第一个升序数组的后边，第二个数组的最大值小于第一个升序数组中最小值的，我们发现是有规律可循的。</p></blockquote><h6 id="▉-算法思路"><a href="#▉-算法思路" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote><p>暴力破解法：</p><p>1）遍历整个数组，找出数组中的最小值。</p><p>二分查找法：</p><p>1）首先声明两个指针分别指向数组的起始位置和终止位置，取中间元素 mid。</p><p>2）判断当前数据 mid 和起始指针的大小，如果大于<strong>起始指针</strong>（或等于），说明这个中间数据一定是第一个数组中的值。那数组中的最小值一定在该数字的后边。</p><p>3）判断当前数据 mid 和起始指针的大小，如果小于<strong>终止指针</strong>（或等于），说明这个中间数据一定是第二个数组中的值。那数组中的最小值一定在该数字的前边。</p><p>4）我们把指针指向中间元素，将搜索范围缩小到原来的一半了，循环以上过程。</p><p>5）那么终止条件是什么呢？我们不断的缩小范围，我们会发现，起始指针和终止指针最终相邻，起始指针会指向数组的最后一个元素，终止指针会指向第二个数组的起始元素。那么终止指针指向的就是我们要查找的最小值。（之所以两个指针最后相邻，是因为我们不断你的在第一个或第二个数组中移动起始或终止指针，该指针永远不会越界指向超出本身数组的值）</p></blockquote><h6 id="▉-边界条件"><a href="#▉-边界条件" class="headerlink" title="▉ 边界条件"></a>▉ 边界条件</h6><blockquote><p>虽然我们上述的算法思路可以实现，但是有几个特殊情况需要处理一下：</p><p>1）如果数组中有重复的值，上述的方法不再适用。假如三个数组{11101} 是 {01111}的旋转数组，那么起始指针与终止指针以及中间元素相等，无法再用之前的判断，此时遇到这种情况需要遍历当前数组。</p><p>2）向后移动 0 个元素也算是一个旋转数组呀，相当于数组本身。此时需要判断数组的最后一个元素是否大于第一个元素，如果是这种情况，那就说明旋转数组就是本身。</p></blockquote><h6 id="▉-测试用例"><a href="#▉-测试用例" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote><p>1）空数组</p><p>2）原数组</p><p>3）重复元素的数组</p><p>4）正常旋转数组（升序数组，为一个值的数组）</p></blockquote><h6 id="▉-代码实现"><a href="#▉-代码实现" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="▉-性能分析"><a href="#▉-性能分析" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><blockquote><p>暴力破解法</p><ul><li>时间复杂度：O(n)。遍历整个数组。</li><li>空间复杂度：O(1)。不需要额外的内存空间。</li></ul><p>二分查找法</p><ul><li>时间复杂度：log(n)。二分查找，每次都缩小范围的 1/2 。</li><li>空间复杂度：不需要额外的内存空间 O(1)。</li></ul></blockquote><h4 id="1-2-小结"><a href="#1-2-小结" class="headerlink" title="1.2 小结"></a>1.2 小结</h4><h6 id="▉-考查内容"><a href="#▉-考查内容" class="headerlink" title="▉ 考查内容"></a>▉ 考查内容</h6><blockquote><p>1）对二分查找的充分理解。</p><p>2）能在短时间内了解旋转数组这种新的概念。</p><p>3）问题的全面性。（重复元素以及向后移动 0 个元素）</p></blockquote><h6 id="▉-扩展思考"><a href="#▉-扩展思考" class="headerlink" title="▉ 扩展思考"></a>▉ 扩展思考</h6><blockquote><p>1）对二分查找条件的变换，使得问题可以举一反三。</p></blockquote><h3 id="2、二叉查找树的后续序列"><a href="#2、二叉查找树的后续序列" class="headerlink" title="2、二叉查找树的后续序列"></a>2、二叉查找树的后续序列</h3><blockquote><p>题目：给你一个整型数组，判断该数组是否为二叉查找树的后序遍历。如果是返回 true，如果不是返回 false。</p></blockquote><h4 id="2-1-问题分析与解决"><a href="#2-1-问题分析与解决" class="headerlink" title="2.1 问题分析与解决"></a>2.1 问题分析与解决</h4><h6 id="▉-问题分析-1"><a href="#▉-问题分析-1" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><blockquote><p>1）根据二叉查找树后续遍历的特点，先遍历左子树，然后遍历右子树，最后遍历根节点。存储在数组中的二叉查找树是有规律的，所以观察数组中的数据，与后序遍历是否存在一些规律和关系呢？</p><p>2）二叉查找树的后序遍可以用递归实现遍历的，如果判断一组数据是否为后序遍历是否也可以通过递归来进行判断呢？</p></blockquote><h6 id="▉-算法思路-1"><a href="#▉-算法思路-1" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote><p>1）数组中的数据最后一个数据一定是树的根节点。</p><p>2）如果为一棵二叉查找树，除最后一个根节结点外，数组分为两份数据，我们发现前一份数据小于根节点，后一份数据大于根节点。也就是说，前一半数据为树的左子节点，后一半数据为树的右子节点。</p><p>3）然后对左右两部分的数据分别递归按照上述的方法进行判断。</p></blockquote><h6 id="▉-测试用例-1"><a href="#▉-测试用例-1" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote><p>1）空树</p><p>2）非二叉查找树</p><p>3）只有一个结点的二叉查找树。</p><p>4）只有右/左子树的二叉查找树。</p></blockquote><h6 id="▉-代码实现-1"><a href="#▉-代码实现-1" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><blockquote></blockquote><h6 id="▉-性能分析-1"><a href="#▉-性能分析-1" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><blockquote></blockquote><h4 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><h6 id="▉-考查内容-1"><a href="#▉-考查内容-1" class="headerlink" title="▉ 考查内容"></a>▉ 考查内容</h6><blockquote><p>1）对问题的分析能力，能否找到解题问题的规律。</p><p>2）对二叉查找树遍历的理解。</p><p>3）递归的灵活运用。</p></blockquote><h6 id="▉-扩展思考-1"><a href="#▉-扩展思考-1" class="headerlink" title="▉ 扩展思考"></a>▉ 扩展思考</h6><blockquote><p>1）判断一个数组是否为树的前序遍历或中序遍历？</p><p>2）”重建二叉树“ 也是同样的解题思路。</p></blockquote><h2 id="三、查找和排序的高级练习（阶段三）"><a href="#三、查找和排序的高级练习（阶段三）" class="headerlink" title="三、查找和排序的高级练习（阶段三）"></a>三、查找和排序的高级练习（阶段三）</h2><h2 id="四、查找和排序的总结"><a href="#四、查找和排序的总结" class="headerlink" title="四、查找和排序的总结"></a>四、查找和排序的总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中所必会的查找和排序算法。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【事件流与委托】</title>
    <link href="http://yoursite.com/2019/05/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%8E%E5%A7%94%E6%89%98%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/02/前端面试之道【事件流与委托】/</id>
    <published>2019-05-01T23:18:56.655Z</published>
    <updated>2019-05-10T07:43:40.822Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>事件流与委托是前端重点内容之一！</p><a id="more"></a><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><blockquote><p>浏览器开发团队遇到的问题是，当点击页面的某一元素的时候，不仅点击了当前源苏苏，而且也点击了包含当前元素的容器，也相当于点击了整个页面。然而为了规范页面中的事件的接收顺序，两个浏览器团队提出了完全相反的想法。</p></blockquote><h3 id="一、事件流"><a href="#一、事件流" class="headerlink" title="一、事件流"></a>一、事件流</h3><blockquote><p>所谓的事件流描述的是从页面中接收事件的顺序。</p><p>1）IE 提出的是<strong>事件冒泡流</strong>。</p><p>2）NC 提出的是<strong>事件捕获流</strong>。</p></blockquote><h4 id="1、事件冒泡"><a href="#1、事件冒泡" class="headerlink" title="1、事件冒泡"></a>1、事件冒泡</h4><blockquote><p>IE 的事件流叫做事件冒泡。事件是从具体的元素接收，向上传播到不具体的结点。</p><p>1）所有的浏览器都支持事件冒泡。</p><p>2）IE 5 之前事件冒泡会跳过<code>&lt;html&gt;</code> 元素，从 <code>body</code> 到 <code>document</code>。</p><p>3）<code>IE 9</code>、<code>Firefox</code>、<code>Safari</code>、<code>Chrome</code> 等浏览器事件一直冒泡到 <code>window</code> 对象。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 例子</span><br><span class="line">div &gt; body &gt; html &gt; document &gt; window // 当点击页面的 div 元素时，事件的传播顺序</span><br></pre></td></tr></table></figure><h4 id="2、事件捕获"><a href="#2、事件捕获" class="headerlink" title="2、事件捕获"></a>2、事件捕获</h4><blockquote><p>NC 提出的另一个事件流叫做事件捕获。事件从不具体的结点到具体的元素。用意是事件到达预定的目标结点之前捕获它。</p><p>1）老版本的浏览器只支持事件冒泡，不支持事件捕获。</p><p>2）一般没有特殊要求，都是用事件冒泡。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 例子</span><br><span class="line">window &gt; document &gt; html &gt; body &gt; div // 当点击页面的 div 元素时，事件的传播顺序</span><br></pre></td></tr></table></figure><h4 id="3、DOM-事件流"><a href="#3、DOM-事件流" class="headerlink" title="3、DOM 事件流"></a>3、DOM 事件流</h4><blockquote><p>“DOM2” 的事件流包括三个阶段，<strong>事件捕获、处于目标阶段、事件冒泡阶段</strong>。</p><p>1）一般「处于目标阶段」属于事件「冒泡阶段」的一部分。</p><p>1）<code>IE 9</code>、<code>Firefox</code>、<code>Safari</code>、<code>Chrome</code> 等浏览器会在事件捕获阶段触发事件对象上的目标。相当于有两个机会在目标对象上操作事件。</p><p>2）<code>IE 8</code> 更早的版本不支持 <code>DOM</code> 事件流。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 事件捕获</span><br><span class="line">window &gt; document &gt; html &gt; body</span><br><span class="line">// 处于目标阶段</span><br><span class="line">body &gt; div </span><br><span class="line">// 事件冒泡阶段</span><br><span class="line">div &gt; body &gt; html &gt; document &gt; window</span><br></pre></td></tr></table></figure><h3 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h3><p>链接：<a href="http://luxiangqiang.xn--6qq986b3xl/2019/04/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%91/" target="_blank" rel="noopener">事件绑定和事件对象</a></p><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><blockquote><p>事件处理程序的数量直接关系到页面的性能问题，主要分为两个方面：</p><p>1）每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。</p><p>2）事先指定所有事件处理程序而导致的 <code>DOM</code> 访问次数过多，会延迟整个页面的交互就绪时间。</p></blockquote><h3 id="一、事件委托"><a href="#一、事件委托" class="headerlink" title="一、事件委托"></a>一、事件委托</h3><blockquote><p>为了解决“事件绑定”过多的问题，解决方案是<strong>事件委托</strong>。利用事件冒泡，只需绑定一个事件处理程序，就可以管理页面所有的事件。</p></blockquote><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><blockquote><p>1）事件委托，只需将事件处理程序绑定到 <code>DOM</code> 树最高的层次上。</p><p>2）一般考虑绑定到页面的 <code>document</code> 对象上。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定到 document 对象上</span></span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"click"</span>, handler);</span><br><span class="line"><span class="keyword">const</span> handler = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent();</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.getTarget(event);</span><br><span class="line">    <span class="keyword">if</span> (target.name &amp;&amp; target.id) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (target.name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'delete'</span>:   </span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'edit'</span>:</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'selectImg'</span>:</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'updataImg'</span>:</span><br><span class="line">               </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'modifyStaffInfo'</span>:</span><br><span class="line">               </span><br><span class="line">            <span class="keyword">case</span> <span class="string">'modelYes'</span>:   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h4><blockquote><p>1）<code>document</code> 很快就可以访问，页面呈现的元素立即具备了绑定的功能。</p><p>2）页面设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的 <code>DOM</code> <strong>引用更少</strong>，<strong>时间就越少</strong>。</p><p>3）整个页面占用的<strong>内存空间少</strong>，提升了整体的性能。</p></blockquote><h3 id="二、移除事件绑定"><a href="#二、移除事件绑定" class="headerlink" title="二、移除事件绑定"></a>二、移除事件绑定</h3><blockquote><p>页面元素在绑定事件处理程序的时候，浏览器中的代码就会和 javascript 代码之间建立一个链接。这种链接越多，页面就会越慢。</p><p>1）事件委托减少事件绑定，限制连接的数量。</p><p>2）在不需要时移除时间绑定程序（内存中留有不用的处理程序）。</p></blockquote><h4 id="1、两种情况"><a href="#1、两种情况" class="headerlink" title="1、两种情况"></a>1、两种情况</h4><blockquote><p>造成以上问题的两种情况：</p><p><strong>1）文档中移除绑定事件的元素。</strong>虽然元素被移除，但是事件处理程序还在内存中，无法当做垃圾被回收,因为虽然元素被移除了，但是在内存中与元素保持的引用的关系。</p><p>例如：<code>removeChild()</code> 和 <code>replaceChild()</code> 方法，更多的是使用 <code>innerHtml</code> 替换页面的一部分。</p><p><strong>2）卸载页面的时候。</strong>如果在页面卸载之前没有清理干净事件处理程序，还会存储在内存中。不断的刷新、卸载页面使得内存中事件处理程序的数量越来越多，因为事件处理程序占用的内存空间有没释放掉。</p></blockquote><h4 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h4><blockquote><p>通过 onunload 事件处理在页面卸载的时候，将页面中绑定的事件处理程序全部移除掉。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件流与委托是前端重点内容之一！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端功能之【Datatables插件】</title>
    <link href="http://yoursite.com/2019/04/28/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E4%B9%8B%E3%80%90Datatables%E6%8F%92%E4%BB%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/28/前端功能之【Datatables插件】/</id>
    <published>2019-04-28T14:43:59.565Z</published>
    <updated>2019-04-28T15:44:37.722Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Datatables 功能插件的使用详细讲解！</p><a id="more"></a><h3 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h3><h4 id="1、引用插件"><a href="#1、引用插件" class="headerlink" title="1、引用插件"></a>1、引用插件</h4><blockquote><p>首先引入 Datatables 插件、Bootstrap、jQuery 插件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--DataTables js--&gt;</span><br><span class="line">&lt;script src=<span class="string">"assets/plugins/Datatable/js/jquery.dataTables.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"assets/plugins/Datatable/js/dataTables.bootstrap4.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="2、HTML-表格"><a href="#2、HTML-表格" class="headerlink" title="2、HTML 表格"></a>2、HTML 表格</h4><blockquote><p>在界面添加 HTML 表格代码。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 行标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 每列的标题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-15p"</span>&gt;</span>权限<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-15p"</span>&gt;</span>登陆号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-20p"</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">class</span>=<span class="string">"wd-15p"</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表格内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bella<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>Chloe<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>System Developer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>2018/03/12<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、Datatables-语言设置"><a href="#3、Datatables-语言设置" class="headerlink" title="3、Datatables 语言设置"></a>3、Datatables 语言设置</h4><blockquote><p>Datatables 默认的语言设置是英文，我们要将其设置为中文。在 <code>$(document).render(function(){})</code> <code>HTML</code> 结构渲染完进行设置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">let</span> table = $(<span class="string">'#example'</span>).DataTable(&#123;</span><br><span class="line">        <span class="comment">// Datatable 语言设置</span></span><br><span class="line">        <span class="string">'language'</span>: &#123;</span><br><span class="line">            <span class="comment">// 左上角的显示数量设置</span></span><br><span class="line">            <span class="string">"lengthMenu"</span>: <span class="string">'每页显示&lt;select class="form-control"&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="10"&gt;10&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="20"&gt;20&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="30"&gt;30&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="40"&gt;40&lt;/option&gt;'</span></span><br><span class="line">            + <span class="string">'&lt;option value="50"&gt;50&lt;/option&gt;'</span> + <span class="string">'&lt;/select&gt;条'</span>,</span><br><span class="line">            <span class="comment">// 右下角的翻页设置</span></span><br><span class="line">            <span class="string">"paginate"</span>: &#123;</span><br><span class="line">                <span class="string">"first"</span>: <span class="string">"首页"</span>,</span><br><span class="line">                <span class="string">"last"</span>: <span class="string">"尾页"</span>,</span><br><span class="line">                <span class="string">"previous"</span>: <span class="string">"上一页"</span>,</span><br><span class="line">                <span class="string">"next"</span>: <span class="string">"下一页"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"processing"</span>: <span class="string">"加载中..."</span>,  <span class="comment">// DataTables载入数据时，是否显示进度条 </span></span><br><span class="line">            <span class="string">"emptyTable"</span>: <span class="string">"暂无数据"</span>,   <span class="comment">// 表格无数据时显示情况</span></span><br><span class="line">            <span class="string">"info"</span>: <span class="string">"共 _PAGES_ 页  _TOTAL_ 条数据  "</span>,</span><br><span class="line">            <span class="string">"infoEmpty"</span>: <span class="string">"暂无数据"</span>,</span><br><span class="line">            <span class="string">"emptyTable"</span>: <span class="string">"暂无要处理的数据..."</span>,  <span class="comment">//表格中无数据</span></span><br><span class="line">            <span class="string">"search"</span>: <span class="string">"搜索:"</span>,</span><br><span class="line">            <span class="string">"infoFiltered"</span>: <span class="string">" —— 从  _MAX_ 条数据中筛选"</span>,</span><br><span class="line">            <span class="string">"zeroRecords"</span>: <span class="string">"没有找到记录"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// datatables 自带的 ajax 请求数据</span></span><br><span class="line">        <span class="string">"ajax"</span>: &#123;</span><br><span class="line">            url: <span class="string">''</span>, <span class="comment">// 请求的 url</span></span><br><span class="line">            method: <span class="string">'post'</span>, <span class="comment">// 请求方式</span></span><br><span class="line">            timeout: <span class="number">5000</span>,  <span class="comment">// 请求延迟</span></span><br><span class="line">            dataType: <span class="string">'JSON'</span>, <span class="comment">// 数据类型</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">let</span> alldata = [<span class="string">'role'</span>, <span class="string">'name'</span>, <span class="string">'password'</span>];</span><br><span class="line">        <span class="comment">// 设置后台返回的字段名，Datatable 会自动填充</span></span><br><span class="line"><span class="string">'columns'</span>: [</span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'role'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'name'</span> &#125;,</span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'password'</span> &#125;,</span><br><span class="line"><span class="comment">// name 为每一行传入的 data 字段</span></span><br><span class="line">&#123; <span class="string">'data'</span>: <span class="string">'name'</span>,</span><br><span class="line"><span class="string">'render'</span>:<span class="function"><span class="keyword">function</span>(<span class="params">data,type,row,meta</span>)</span>&#123;</span><br><span class="line">                                <span class="comment">// 自定义代码（一般添加增、删、改按钮），data 为传入的 name 值</span></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">`&lt;button name="add" id="add_<span class="subst">$&#123;data&#125;</span>"&gt;添加&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;button name="delete" id="delete_<span class="subst">$&#123;data&#125;</span>"&gt;删除&lt;/button&gt;`</span> </span><br><span class="line"><span class="keyword">return</span> html;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">         <span class="comment">// cells 存储着所有行对象（通过 . 可获取属性）</span></span><br><span class="line">         createdRow: <span class="function"><span class="keyword">function</span> (<span class="params">row, data, dataIndex, cells</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; alldata.length; i++) &#123;</span><br><span class="line">             <span class="comment">// 为每一行元素添加唯一标识 ID</span></span><br><span class="line">             cells[i].id = alldata[i]</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、为-Table-添加点击事件"><a href="#4、为-Table-添加点击事件" class="headerlink" title="4、为 Table 添加点击事件"></a>4、为 Table 添加点击事件</h4><blockquote><p>通过事件委托的方式添加事件监听。</p><p>1）虽然监听事件添加到 <code>table</code> 上，但是可以通过  <code>event</code> 事件对象判断点击了哪一个 <code>id</code> 或 <code>name</code> 的控件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#example'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每一行数据中每个字段的 name 值和 id 值</span></span><br><span class="line">    <span class="keyword">if</span> (event.target.name &amp;&amp; event.target.id) &#123;</span><br><span class="line">        <span class="comment">// 通过判断 name 值来确定删除/添加</span></span><br><span class="line">        <span class="keyword">switch</span> (event.target.name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">                <span class="comment">// 对表格做添加数据</span></span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'delete'</span>:</span><br><span class="line">                <span class="comment">// 对该行做删除处理</span></span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="5、获取同行的所有数据"><a href="#5、获取同行的所有数据" class="headerlink" title="5、获取同行的所有数据"></a>5、获取同行的所有数据</h4><blockquote><p>通过点击某按钮的 id 获取父节点，从而达到获取同行的数据。</p><p>1）得到同一行数据之后，我们可以进行传值编辑或者删除一行数据。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同行某点击事件的 id</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSameValue</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取该 id 父节点的所有兄弟节点（存储所有数据的结点）</span></span><br><span class="line">    <span class="keyword">let</span> values = $(<span class="string">'#'</span> + id).parent().parent().siblings();</span><br><span class="line">    <span class="comment">// 以键值对的方式存储到 map 中</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="comment">// 将同一行的数据 name:value 遍历出来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> obj <span class="keyword">of</span> values) &#123;</span><br><span class="line">        <span class="comment">// 通过结点得到想要的属性存储起来</span></span><br><span class="line">        result.set(obj.id, obj.outerText);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 map</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、删除一行数据"><a href="#6、删除一行数据" class="headerlink" title="6、删除一行数据"></a>6、删除一行数据</h4><blockquote><p>得到同一行数据之后，进行删除操作。</p><p>1）删除一行需要的到该行的 DOM 对象，可以通过目标值的父节点获取</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> row = event.target.parentNode.（...）.parentNode;</span><br><span class="line"><span class="comment">// 进行删除更新</span></span><br><span class="line">table.row(row).remove().draw(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h4 id="7、添加一行数据"><a href="#7、添加一行数据" class="headerlink" title="7、添加一行数据"></a>7、添加一行数据</h4><blockquote></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> table = $(<span class="string">'#example'</span>).DataTable(&#123;&#125;)</span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line">table.ajax.reload(<span class="literal">null</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Datatables 功能插件的使用详细讲解！&lt;/p&gt;
    
    </summary>
    
      <category term="前端功能实现" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
    
      <category term="前端功能实现" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【事件绑定】</title>
    <link href="http://yoursite.com/2019/04/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/28/前端面试之道【事件绑定】/</id>
    <published>2019-04-28T02:12:55.467Z</published>
    <updated>2019-05-10T08:42:25.643Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>js 事件的处理程序！</p><a id="more"></a><p>[TOC]</p><h2 id="事件绑定（事件处理程序）"><a href="#事件绑定（事件处理程序）" class="headerlink" title="事件绑定（事件处理程序）"></a>事件绑定（事件处理程序）</h2><h3 id="一、HTML-事件绑定"><a href="#一、HTML-事件绑定" class="headerlink" title="一、HTML 事件绑定"></a>一、HTML 事件绑定</h3><blockquote><p>最直接的事件绑定就是在 <code>HTML</code> 上做处理，显式的为按钮绑定 <code>click</code> 事件，用户点击按钮就会触发事件。</p></blockquote><h4 id="1、事件绑定定义"><a href="#1、事件绑定定义" class="headerlink" title="1、事件绑定定义"></a>1、事件绑定定义</h4><p>1）<code>onClick</code> 特性的值是 <code>javascript</code> ，所以不能在内使用未转义的 <code>HTML</code> 语法字符。</p><p>2）<code>onClick</code> 也可以调用页面定义的脚本（函数名）。也可以是外部文件，事件处理程序有权访问全局变量。</p><p>3）<code>onClick</code> 内定义的函数自带的一个 <code>event</code>变量存储事件对象，通过 <code>event</code> 变量可以访问事件对象的属性值（也可以使用 <code>this</code> ，<code>this</code> 指向事件对象本身）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、onClick 内不能使用未转义的 HTML 语法字符（单引号）</span></span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"alert(&amp;quot;Clicked&amp;quot;)"</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、调用页面其他地方的脚本</span></span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"showMessage()"</span> /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">showMessage = ()=&#123;</span><br><span class="line">        alert(<span class="string">"Hello Word"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、event 事件对象</span></span><br><span class="line">&lt;!--两个都输出‘点击我’--&gt;</span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"alert('event.value')"</span> /&gt; </span><br><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"alert(this.value)"</span> /&gt;</span><br></pre></td></tr></table></figure><h4 id="2、存在的缺点"><a href="#2、存在的缺点" class="headerlink" title="2、存在的缺点"></a>2、存在的缺点</h4><h6 id="▉-缺点"><a href="#▉-缺点" class="headerlink" title="▉ 缺点"></a>▉ 缺点</h6><blockquote><p>1）用户在 <code>HTML</code> 元素一出现就点击元素触发相应的事件，但可能改事件还没有初始化（尚未具备执行的条件），导致报错。</p><p>2）<code>HTML</code> 和 <code>Javascript</code> 紧密耦合。修改事件时，会修改两处，所以一般不使用 <code>HTML</code> 事件绑定。</p></blockquote><h6 id="▉-解决"><a href="#▉-解决" class="headerlink" title="▉ 解决"></a>▉ 解决</h6><blockquote><p>1）加入 <code>try catch</code> 语句，在脚本函数没有被解析之前就点击了元素，就会引出错误。该错误不会让用户看见，而是被捕获。</p><p>2）不使用 <code>HTML</code> 事件绑定，而是转向使用 <code>javascript</code> 执行事件处理程序。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">'button'</span> value=<span class="string">"点击我"</span> onclick=<span class="string">"try&#123;showMessage();&#125;catch(ex)&#123;&#125;"</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="二、DOM0-级事件绑定"><a href="#二、DOM0-级事件绑定" class="headerlink" title="二、DOM0 级事件绑定"></a>二、DOM0 级事件绑定</h3><blockquote><p>通过将一个函数的值赋值给事件处理程序的属性来绑定事件。</p><p>1）简单</p><p>2）跨浏览器</p></blockquote><h3 id="1、事件绑定定义-1"><a href="#1、事件绑定定义-1" class="headerlink" title="1、事件绑定定义"></a>1、事件绑定定义</h3><blockquote><p>1）先获取某个拥有事件处理程序属性的对象（属性一般都是小写，如 <code>onclick</code>），然后将该属性指向一个事件处理函数。</p><p>2）该方法被认为定义了元素的方法，处理事件是在该元素的作用域执行的，所以 <code>this</code>  指向该元素（可以通过 <code>this</code> 访问该元素的任何属性和方法）。</p><p>3）DOM0 级事件处理是在事件的<strong>冒泡阶段</strong>进行绑定的。</p><p>4）删除元素的绑定事件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = documentElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.ElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id) <span class="comment">// 输出 myBtn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="三、DOM2级事件绑定"><a href="#三、DOM2级事件绑定" class="headerlink" title="三、DOM2级事件绑定"></a>三、DOM2级事件绑定</h3><blockquote><p>DOM2 级事件处理程序定义了两个方法，分别是处理事件和删除事件的两个操作：<code>addEventListener()</code> 和 <code>removeEventListener()</code> 。</p></blockquote><h4 id="1、事件绑定定义-2"><a href="#1、事件绑定定义-2" class="headerlink" title="1、事件绑定定义"></a>1、事件绑定定义</h4><blockquote><p>1）可以添加多个事件处理函数。</p><p>2）移除函数必须和移除函数相同的参数。并且 <code>addEventListener()</code> 函数必须使用 <code>removeEventListener()</code> 才能移除。</p></blockquote><p>该函数接受三个参数：</p><ul><li>要处理的事件名；</li><li>绑定的函数；</li><li>布尔值（<code>true</code>：表示<strong>捕获阶段</strong>调用事件程序，<code>false</code>：表示<strong>冒泡阶段</strong>调用事件程序）；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为 btn 绑定了两个事件处理函数，按顺序执行</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>) <span class="comment">// 先执行 HelloWord</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)  <span class="comment">// 再执行 ID</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这里的 function 和上方不是同一个函数，所以移除失败</span></span><br><span class="line"><span class="comment">// 通过将同一个函数赋值给统一的变量，就可以视作为统一参数</span></span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h4 id="2、兼容性"><a href="#2、兼容性" class="headerlink" title="2、兼容性"></a>2、兼容性</h4><blockquote><p>1）DOM2 级事件处理程序兼容的浏览器有 <code>IE9、Firefox、Safari、Chrome</code> 和 <code>Opera</code>。</p><p>2）大多情况下，都将事件处理程序添加到<strong>冒泡阶段，为了最大限度的兼容各种浏览器</strong>。</p></blockquote><h3 id="四、IE-事件绑定"><a href="#四、IE-事件绑定" class="headerlink" title="四、IE 事件绑定"></a>四、IE 事件绑定</h3><blockquote><p>1）IE 实现了与 DOM 类中的两个方法：<code>attachEvent()</code> 和 <code>detachEvent()</code> 。</p><p>2）IE8 版本之前所有的事件绑定都是在冒泡阶段。</p><p>3）IE 与 <code>DOM0</code> 级绑定事件的区别在于事件的作用域是「<strong>全局变量</strong>」（ <code>this</code> 指向 <code>window</code> 作用域）。</p><p>4）可以通过 <code>attach</code> 添加多个事件，且「<strong>执行顺序和 <code>DOM2</code> 级相反</strong>」。</p><p>5）<code>detachEvent</code> 删除事件也必须提供相同的参数，匿名函数无效。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.attach(<span class="string">'onclick'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.attach(<span class="string">'onclick'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'HelloWord'</span>) <span class="comment">// 再执行 HelloWord</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br><span class="line">btn.attach(<span class="string">'onclick'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)  <span class="comment">// 先执行 ID</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除无效</span></span><br><span class="line">btn.detachEvent(<span class="string">'onclick'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="五、跨浏览器的事件绑定"><a href="#五、跨浏览器的事件绑定" class="headerlink" title="五、跨浏览器的事件绑定"></a>五、跨浏览器的事件绑定</h3><blockquote><p>为了能够保证事件绑定能在大多数的浏览器下运行，一般有两种方式：</p><p>1）使用能够隔离浏览器差异的 javascript 库。</p><p>2）自己开发合适的功能，使用能力检测，保证能够在大多数的浏览器下运行。</p><p>3）该程序没有考虑到浏览器的所有问题。如：在 IE 中的作用域问题。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">    <span class="comment">// 绑定事件</span></span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 解除绑定</span></span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.detachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="1、IE-与-DOM0-DOM2-之间的区别"><a href="#1、IE-与-DOM0-DOM2-之间的区别" class="headerlink" title="1、IE 与 DOM0/DOM2 之间的区别"></a>1、<code>IE</code> 与 <code>DOM0/DOM2</code> 之间的区别</h4><blockquote><p>1）<code>IE</code> 与 <code>DOM0</code> 比较：<code>IE</code> 事件绑定时，<code>this</code> 指向全局变量 <code>window</code>，而 DOM0 的 <code>this</code> 却指向事件本身。</p><p>2）<code>IE</code> 与 <code>DOM2</code> 比较：<code>IE</code> 与 <code>DOM2</code> 相比，<code>DOM2</code> 中的添加多个事件执行的顺序（正序）与 <code>IE</code> 绑定多个事件执行的顺序相反（逆序）。</p></blockquote><h4 id="2、兼容性-1"><a href="#2、兼容性-1" class="headerlink" title="2、兼容性"></a>2、兼容性</h4><blockquote><p>1）<code>IE8</code> 之前的只有冒泡阶段，所以  <code>IE8</code> 之前的事件绑定都是在冒泡阶段完成的（<code>DOM0</code> 级以及 IE 事件绑定）。</p><p>2）<code>DOM2</code> 事件第三个参数可以选择绑定阶段（冒泡还是捕获），因为 IE8 之前只有冒泡阶段，所以 <code>DOM2</code>级别的事件绑定只适用于 <code>IE9+</code> 。</p></blockquote><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><blockquote><p>当触发 DOM 的某个事件时，就会产生一个 <code>event</code> 对象，对象中包含着与事件相关信息。</p></blockquote><h3 id="一、DOM-中的事件对象"><a href="#一、DOM-中的事件对象" class="headerlink" title="一、DOM 中的事件对象"></a>一、DOM 中的事件对象</h3><h4 id="1、this、currentTarget、target"><a href="#1、this、currentTarget、target" class="headerlink" title="1、this、currentTarget、target"></a>1、this、currentTarget、target</h4><blockquote><p>1）当事件直接绑定到目标事件时，三者的值相同。</p><p>2）当事件绑定到目标事件的父节点上，<code>this</code>  与<code>currentTarget</code> 的值与 <code>target</code> 的值不相同。</p><p>当点击该按钮时，事件的绑定是按钮的父节点，所以目标对象 <code>target</code> 是指向按钮元素的（<code>click</code> 的真正目标），由于按钮没有绑定事件处理程序，所以 <code>click</code> 事件冒泡到 <code>document.body</code> 事件才得到处理 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将事件绑定 btn 按钮的父节点上</span></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    alert(event.target === <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、处理多个事件"><a href="#2、处理多个事件" class="headerlink" title="2、处理多个事件"></a>2、处理多个事件</h4><blockquote><p>为了能够减少代码量，通过 <code>event.type</code> 来确定一个函数处理多个事件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">handler = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(event.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'click'</span>:</span><br><span class="line">            <span class="comment">//要处理的点击事件</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'mouseover'</span>:</span><br><span class="line">            <span class="comment">// 要处理的鼠标进入事件</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'mouseout'</span>:</span><br><span class="line">            <span class="comment">// 要处理的鼠标滑出事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.onclick = handler;</span><br><span class="line">btn.mouseover = handler;</span><br><span class="line">btn.mouseout = handler;</span><br></pre></td></tr></table></figure><h4 id="3、阻止默认的事件行为"><a href="#3、阻止默认的事件行为" class="headerlink" title="3、阻止默认的事件行为"></a>3、阻止默认的事件行为</h4><blockquote><p>可以通过使用 <code>preventDefault()</code> 方法来取消默认的行为（必须设置属性 <code>cancelable</code> 为 <code>true</code>），如 <code>a</code>标签的链接事件，阻止了跳转 <code>href</code> 的链接。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">link.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event.cancelable = <span class="literal">true</span>;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、立即停止事件的传播"><a href="#4、立即停止事件的传播" class="headerlink" title="4、立即停止事件的传播"></a>4、立即停止事件的传播</h4><blockquote><p>通过设置 <code>stopPropagation()</code> 方法立即停止在 DOM 层次中的传播（停止事件的捕获或冒泡）。</p><p>1）通过这种方式可以避免发生在父节点绑定的事件处理程序。</p></blockquote><h3 id="二、IE-中的事件对象"><a href="#二、IE-中的事件对象" class="headerlink" title="二、IE 中的事件对象"></a>二、IE 中的事件对象</h3><blockquote><p>IE 中事件对象 <code>event</code> 有一种不同的方式。</p><p>1）DOM0 级：<code>event</code> 作为 <code>window</code> 的一个属性。</p><p>2）attatach 添加的：传入一个 event 对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">    alert(event.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、srcElement"><a href="#1、srcElement" class="headerlink" title="1、srcElement"></a>1、srcElement</h4><blockquote><p><code>srcElement</code> 属性相当于 <code>DOM</code> 中的 <code>target</code> 属性，用来确定事件目标对象的。</p><p>1）因为事件处理程序的作用域是根据指定它的方式来确定，所以 <code>this</code> 不一定指向目标对象。因此我们通常用 <code>srcElement</code> 来替换。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>,(event)=&gt;&#123;</span><br><span class="line">    alert(event.srcElement === <span class="keyword">this</span>) <span class="comment">// false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2、阻止默认的事件行为"><a href="#2、阻止默认的事件行为" class="headerlink" title="2、阻止默认的事件行为"></a>2、阻止默认的事件行为</h4><blockquote><p>只要将 <code>returnValue</code> 设置为 <code>false</code> 就可以阻止默认的行为。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">link.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、立即停止事件的传播"><a href="#3、立即停止事件的传播" class="headerlink" title="3、立即停止事件的传播"></a>3、立即停止事件的传播</h4><blockquote><p>设置 <code>cancelBubble</code> 属性即可停止事件的传播。由于 IE 中只有冒泡阶段，所以也只能阻止冒泡阶段在 DOM 层次中的传播。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble  = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、跨浏览器的事件对象"><a href="#三、跨浏览器的事件对象" class="headerlink" title="三、跨浏览器的事件对象"></a>三、跨浏览器的事件对象</h3><blockquote><p>不同浏览器中的 Event 对象是不同的，所以要写一个跨浏览器的事件对象。</p></blockquote><h4 id="1、定义-Event-事件"><a href="#1、定义-Event-事件" class="headerlink" title="1、定义 Event 事件"></a>1、定义 Event 事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> EventUtil = &#123;</span><br><span class="line">    <span class="comment">// 绑定事件</span></span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 解除绑定</span></span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</span><br><span class="line">            element.detachEvent(<span class="string">'on'</span>+ type,handler)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取事件对象</span></span><br><span class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取事件目标对象</span></span><br><span class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 阻止事件</span></span><br><span class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event.preventDefault)&#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            event.returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 立即停止事件传播</span></span><br><span class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event.stopPropagation)&#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、调用-Event-对象事件"><a href="#2、调用-Event-对象事件" class="headerlink" title="2、调用 Event 对象事件"></a>2、调用 Event 对象事件</h4><blockquote><p>1）<code>getEvent()</code></p><p>2）<code>getTarget()</code></p><p>3）<code>preventDefault（）</code></p><p>4）<code>stopPropagation（）</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IE 不存在 event (undefined)就返回 window.event</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标对象</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.getTarget(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻止事件</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.preventDefault(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即停止事件传播</span></span><br><span class="line">btn.onclick = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    <span class="keyword">let</span> target = EventUtil.stopPropagation(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><blockquote><p>1）<code>DOM0</code> 级别的 <code>Event</code> 存在 <code>window</code> 对象中，而 <code>DOM2</code> 和 <code>IE</code> 处理事件程序中的 <code>Event</code> 对象是当做参数传入的。</p><p>2）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js 事件的处理程序！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【异步编程】</title>
    <link href="http://yoursite.com/2019/04/25/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/04/25/前端面试之道【异步编程】/</id>
    <published>2019-04-25T09:17:54.497Z</published>
    <updated>2019-04-27T12:55:53.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>js 异步常考面试题！</p><a id="more"></a><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><blockquote><p>面试题一：并发和并行的区别？</p></blockquote><p><strong>※ 答✔：</strong></p><ul><li>并发：宏观概念。两个任务在一段时间内同时完成切换。</li><li>并行：微观概念。同时完成两个任务。</li></ul><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><blockquote><p>面试题二：什么是回调函数？回调函数有什么缺点？如何理解回调地狱的问题？</p></blockquote><p><strong>※ 答✔：什么是回调函数</strong></p><blockquote><p>回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该<strong>事件</strong>或<strong>条件</strong>进行响应 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>※ 答✔：回调函数有什么缺点？</strong></p><blockquote><p>容易写成回调地狱问题。也就是多个请求存在依赖性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>※ 答✔：如何理解回调地狱问题？</strong></p><blockquote><p>回调地狱存在几个问题如下：</p><p>1）嵌套函数存在耦合性，一旦有所改动，牵一发而动全身。</p><p>2）嵌套函数一多，就很难处理错误。</p><p>3）回调函数不能使用 <code>try catch</code>  捕获异常(异常的捕获只能在函数执行的时候才能捕获到)。</p><p>4）回调函数不能直接 <code>return</code> 。</p></blockquote><p><strong>※ 答✔：如何解决回调地狱问题？</strong></p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote><p>面试三：你理解的 Generator 是什么？</p></blockquote><blockquote><p>1）一般 <code>generator</code> 配合 co 库（用于 <code>generator</code> 函数的自动执行 ）去使用。</p><p><code>Generator</code> 最大的特点就是可以控制函数的执行，下面是最容易困惑的点也是难点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span> (y + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = foo(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(f.next()); =&gt; &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="number">4</span>));=&gt; &#123;<span class="attr">value</span>: <span class="number">10</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f.next(<span class="number">1</span>));=&gt; &#123;<span class="attr">value</span>: <span class="number">9</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><p>执行过程分析：</p><p>1）<code>generator</code> 函数的调用会返回一个迭代器。</p><p>2）执行第一次 <code>next</code> ，传入的 <code>next</code> 参数会被忽略，执行会停止在第一个 <code>yield</code> 处，返回其值。</p><p>3）执行第二次 <code>next</code> ，传入的参数代表第一个 <code>yield</code> 的返回值，<code>let y = 2 * 4</code> ，所以返回 <code>y + 2 = 8 + 2 = 10</code>  。如果不传入参数，就返回 <code>undefined</code>，打印的值为 <code>NAN</code> 。</p><p>4）执行第三个 <code>next</code>，传入的参数会代表第二个 <code>yield</code> 的返回值，<code>y + z = 8 + 1 = 9</code> 。</p><blockquote><p>我们可以通过 <code>generator</code> 解决回调地狱问题。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">fetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> ajax(url, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url1, () =&gt; &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> ajax(url2, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = fetch()</span><br><span class="line"><span class="keyword">let</span> result1 = it.next()</span><br><span class="line"><span class="keyword">let</span> result2 = it.next()</span><br><span class="line"><span class="keyword">let</span> result3 = it.next()</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote><p>面试四：Promise 的特点是什么？分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？</p></blockquote><p>1、了解 Promise 吗？</p><p>2、Promise 解决的痛点是什么？</p><p>3、Promise 解决的痛点还有其他方法可以解决吗？如果有，请列举。</p><p>4、Promise 如何使用？</p><p>5、Promise 常用的方法有哪些？它们的作用是什么？</p><p>6、Promise 在事件循环中的执行过程是怎样的？</p><p>7、Promise 的业界实现都有哪些？</p><p>8、能不能手写一个 Promise 的 polyfill。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js 异步常考面试题！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
