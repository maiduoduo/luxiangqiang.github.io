<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小鹿的博客</title>
  
  <subtitle>Ordinary life , Unwilling to be ordinary code farmers</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-25T12:33:06.149Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小鹿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端框架之【Vue全家桶】</title>
    <link href="http://yoursite.com/2019/06/24/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8B%E3%80%90Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/24/前端框架之【Vue全家桶】/</id>
    <published>2019-06-23T22:57:09.306Z</published>
    <updated>2019-06-25T12:33:06.149Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vue 全家桶（Vue-router、Vuex ）浅入浅出！</p><a id="more"></a><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h3><h4 id="1、created"><a href="#1、created" class="headerlink" title="1、created"></a>1、created</h4><blockquote><p>一般会在下边这个钩子函数中初始化页面的数据。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 做服务器请求什么的</span><br><span class="line">created：&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、computed"><a href="#2、computed" class="headerlink" title="2、computed"></a>2、computed</h4><blockquote><p>DOM 加载完成进行渲染，计算属性，实时响应，根据data中的值实时做出处理，就用 computed。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">方法（）&#123;</span><br><span class="line">return ； // 通过方法返回值来使页面的数据进行变换</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、指令"><a href="#二、指令" class="headerlink" title="二、指令"></a>二、指令</h3><h4 id="1、v-show"><a href="#1、v-show" class="headerlink" title="1、v-show"></a>1、v-show</h4><blockquote><p>用于控制控件的显示。</p></blockquote><h4 id="2、v-model"><a href="#2、v-model" class="headerlink" title="2、v-model"></a>2、v-model</h4><blockquote><p>用于数据双向绑定，一般用于 input。</p></blockquote><h4 id="3、v-for"><a href="#3、v-for" class="headerlink" title="3、v-for"></a>3、v-for</h4><blockquote><p>用于循环渲染数据。</p></blockquote><h4 id="4、-click"><a href="#4、-click" class="headerlink" title="4、@click"></a>4、@click</h4><blockquote><p>用于事件绑定。</p></blockquote><h3 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h3><blockquote><p>所有的组件存放到文件夹中，然后再 App.vue 进行导入。</p></blockquote><h4 id="1、公共组件"><a href="#1、公共组件" class="headerlink" title="1、公共组件"></a>1、公共组件</h4><blockquote><p>公共组件写到一个公共的文件夹中。</p></blockquote><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><blockquote><p>路由主要实现一级页面的跳转，二级页面跳转，三级页面跳转。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装路由</span><br><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure><h4 id="1、导入-使用路由"><a href="#1、导入-使用路由" class="headerlink" title="1、导入/使用路由"></a>1、导入/使用路由</h4><blockquote><p>新建一个路由文件夹，新建 router.js 文件，导入路由，使用路由。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Router)</span><br></pre></td></tr></table></figure><h4 id="2、实例化路由对象"><a href="#2、实例化路由对象" class="headerlink" title="2、实例化路由对象"></a>2、实例化路由对象</h4><blockquote><p>新建一个路由对象，然后暴露接口，在 Vue 的对象中去使用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode:&apos;history&apos;,</span><br><span class="line">  routes: []</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="3、配置路由的跳转路径"><a href="#3、配置路由的跳转路径" class="headerlink" title="3、配置路由的跳转路径"></a>3、配置路由的跳转路径</h4><blockquote><p>配置路由跳转对象，有三个参数：</p></blockquote><ul><li>path：跳转路径。</li><li>name：路由的名字。</li><li>component ：跳转的组件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Menu from &apos;@/components/Menu&apos;</span><br><span class="line">&#123;path: &apos;/menu&apos;,name: &apos;MenuLink&apos;,component: Menu&#125;</span><br></pre></td></tr></table></figure><h4 id="4、在跳转的组件上设置跳转"><a href="#4、在跳转的组件上设置跳转" class="headerlink" title="4、在跳转的组件上设置跳转"></a>4、在跳转的组件上设置跳转</h4><blockquote><p>使用 router-link 标签进行设置跳转。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// tag：替换的标签   :to : 使用的路由跳转对象（可以是由 path 也可以指定路由对象）</span><br><span class="line">// 方式一：静态绑定路由</span><br><span class="line">&lt;router-link to=&quot;/&quot;&gt;新闻&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">// 方式二：动态绑定路由</span><br><span class="line">&lt;router-link :to=&quot;homeLink&quot;&gt;新闻&lt;/router-link&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            homeLink:&apos;/&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 方式三：使用路由名字绑定路由</span><br><span class="line">&lt;router-link tag=&quot;div&quot; :to=&quot;&#123;name:&apos;historyLink&apos;&#125;&quot;&gt;新闻&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h6 id="▉-默认跳转页面"><a href="#▉-默认跳转页面" class="headerlink" title="▉  默认跳转页面"></a>▉  默认跳转页面</h6><blockquote><p>如果输入错误的 URL 需要设置默认的跳转页面。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 错误路径跳转根目录</span><br><span class="line">&#123;path: &apos;*&apos;,redirect:&apos;/&apos;&#125;,</span><br></pre></td></tr></table></figure><h6 id="▉-路由跳转方法"><a href="#▉-路由跳转方法" class="headerlink" title="▉  路由跳转方法"></a>▉  路由跳转方法</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 跳转上次浏览页面</span><br><span class="line">// this.$router.go(-1)</span><br><span class="line"></span><br><span class="line">// 指定跳转地址</span><br><span class="line">// this.$router.replace(&apos;/menu&apos;)</span><br><span class="line"></span><br><span class="line">// 指定跳转路由的名字下</span><br><span class="line">// this.$router.replace(&#123;name:&apos;MenuLink&apos;&#125;)</span><br><span class="line"></span><br><span class="line">// 通过push进行跳转(常用)</span><br><span class="line">this.$router.push(&apos;/menu&apos;)</span><br><span class="line">this.$router.push(&#123;name:&apos;MenuLink&apos;&#125;)</span><br></pre></td></tr></table></figure><h4 id="5、在页面使用路由"><a href="#5、在页面使用路由" class="headerlink" title="5、在页面使用路由"></a>5、在页面使用路由</h4><blockquote><p>全局的 Vue.app 下使用路由的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h4 id="6、二级路由和三级路由"><a href="#6、二级路由和三级路由" class="headerlink" title="6、二级路由和三级路由"></a>6、二级路由和三级路由</h4><blockquote><p>在路由文件中配置二级路由和三级路由。然后在对应的组件进行绑定路由名，和在二级或三级组件下进行显示跳转页面。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 二级路由</span><br><span class="line">&#123;path: &apos;/about&apos;,name: &apos;AboutLink&apos;,component: About,children:[</span><br><span class="line">      &#123;&#125;,</span><br><span class="line">  // 三级路由</span><br><span class="line">      &#123;&#125;,children:[</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">      ]&#125;,</span><br><span class="line">      &#123;&#125;,</span><br><span class="line">      &#123;&#125;,</span><br><span class="line">    ]&#125;,</span><br></pre></td></tr></table></figure><h4 id="7、进入默认显示页面"><a href="#7、进入默认显示页面" class="headerlink" title="7、进入默认显示页面"></a>7、进入默认显示页面</h4><blockquote><p>已进入二三级页面，要默认显示一个页面，而不是空白。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect:&apos; &apos;// 默认显示的组件路径</span><br></pre></td></tr></table></figure><h4 id="8、全局守卫"><a href="#8、全局守卫" class="headerlink" title="8、全局守卫"></a>8、全局守卫</h4><blockquote><p>全局守卫就是当进入整个路由页面时，要在进入之前做一些处理，比如弹框请先登录。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    // 判断如果是登录页面或注册页面直接进入,否则提示登录</span><br><span class="line">    if(to.path == &quot;/login&quot; || to.path == &quot;/register&quot;)&#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      alert(&quot;您还没有登录,请先登录！&quot;)</span><br><span class="line">      next(&quot;/login&quot;) // 将用户引导到登录页面中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="9、后置钩子"><a href="#9、后置钩子" class="headerlink" title="9、后置钩子"></a>9、后置钩子</h4><h4 id="10、路由独享守卫"><a href="#10、路由独享守卫" class="headerlink" title="10、路由独享守卫"></a>10、路由独享守卫</h4><blockquote><p>与全局守卫不同的是只作用于规定的路由页面。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;path: &apos;/admin&apos;,name: &apos;AdminLink&apos;,component: Admin,beforeEnter:(to, from, next)=&gt;&#123;</span><br><span class="line">    alert(&apos;非登陆状态进制访问！&apos;)</span><br><span class="line">    next();</span><br><span class="line">&#125;&#125;,</span><br></pre></td></tr></table></figure><h4 id="11、组件守卫"><a href="#11、组件守卫" class="headerlink" title="11、组件守卫"></a>11、组件守卫</h4><blockquote><p>在组件内使用，进入组件之前和离开组件之后进行做处理。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件内守卫(进入/离开组件时应该做的事情)</span></span><br><span class="line">  beforeRouteEnter:<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 页面的渲染顺序是先渲染组件内守卫，然后渲染data,所以在守卫里边直接拿不到data里的数据，所以要使用next回调函数</span></span><br><span class="line">      next(<span class="function">(<span class="params">vm</span>) =&gt;</span>&#123;</span><br><span class="line">          alert(<span class="string">"Hellow "</span>+vm.name)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 离开组件时的守卫</span></span><br><span class="line">  beforeRouteLeave:<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(confirm(<span class="string">"确定要离开本页面吗？"</span>) == <span class="literal">true</span>)&#123;</span><br><span class="line">          next();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          next(<span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="12、组件复用"><a href="#12、组件复用" class="headerlink" title="12、组件复用"></a>12、组件复用</h4><blockquote><p>想要在当前页面下复用其他组件，必须在相对应的路由中进行配置，components。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 想在根目录的主页中复用组件，所以在对应的路由中进行配置。</span><br><span class="line">&#123;path: &apos;/&apos;,name: &apos;HomeLink&apos;,components:&#123;</span><br><span class="line">      // 默认显示组件</span><br><span class="line">      default:Home,</span><br><span class="line">      // 组件复用</span><br><span class="line">      &quot;history&quot;:History,</span><br><span class="line">      &quot;delivery&quot;:Delivery,</span><br><span class="line">      &quot;orderingGuilde&quot;:OrderingGuilde</span><br><span class="line">    &#125;&#125;,</span><br></pre></td></tr></table></figure><h4 id="13、滚动行为"><a href="#13、滚动行为" class="headerlink" title="13、滚动行为"></a>13、滚动行为</h4><blockquote><p>滚动路由直接定位页面要展现的位置。</p></blockquote><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><blockquote><p>Vuex 可以很好的实现组件间的数据共享。</p></blockquote><h4 id="1、本地安装-vuex"><a href="#1、本地安装-vuex" class="headerlink" title="1、本地安装 vuex"></a>1、本地安装 vuex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><h4 id="2、在-src-下新建-store-文件夹以及文件-store-js"><a href="#2、在-src-下新建-store-文件夹以及文件-store-js" class="headerlink" title="2、在 src 下新建 store 文件夹以及文件 store.js"></a>2、在 src 下新建 store 文件夹以及文件 store.js</h4><h4 id="3、在文件中引入-Vuex"><a href="#3、在文件中引入-Vuex" class="headerlink" title="3、在文件中引入 Vuex"></a>3、在文件中引入 Vuex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br></pre></td></tr></table></figure><h4 id="4、使用-Vuex"><a href="#4、使用-Vuex" class="headerlink" title="4、使用 Vuex"></a>4、使用 Vuex</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><h4 id="5、暴露出-Vuex-实例"><a href="#5、暴露出-Vuex-实例" class="headerlink" title="5、暴露出 Vuex 实例"></a>5、暴露出 Vuex 实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export const store = new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        // 设置属性</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">        // 获取属性的状态</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        // 改变属性的状态</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">        // 应用 mutations</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="6、在-main-js-全局中的-Vue-实例中导入使用"><a href="#6、在-main-js-全局中的-Vue-实例中导入使用" class="headerlink" title="6、在 main.js 全局中的 Vue 实例中导入使用"></a>6、在 main.js 全局中的 Vue 实例中导入使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;store&#125; from &apos;./store/store.js&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="7、必须通过-mutations-改变-state-中的属性"><a href="#7、必须通过-mutations-改变-state-中的属性" class="headerlink" title="7、必须通过 mutations 改变 state 中的属性"></a>7、必须通过 mutations 改变 state 中的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutations:&#123;</span><br><span class="line">       // 改变属性的状态</span><br><span class="line">       setMenuItem(state,data)&#123;</span><br><span class="line">           state.menuItems = data</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h4 id="8、将数据存入-store（存入状态）"><a href="#8、将数据存入-store（存入状态）" class="headerlink" title="8、将数据存入 store（存入状态）"></a>8、将数据存入 store（存入状态）</h4><blockquote><p>通过在组件中调用 mutations  的方法就可以将值传入.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&quot;setMenuItem&quot;,data) //全局调用 store 中的 commit 方法</span><br></pre></td></tr></table></figure><h4 id="9、在-store-取出数据（取出状态）"><a href="#9、在-store-取出数据（取出状态）" class="headerlink" title="9、在 store 取出数据（取出状态）"></a>9、在 store 取出数据（取出状态）</h4><blockquote><p>在组件中获取状态通过全局调用 store.state 就可以。如果页面响应数据实时变化，可以将方法写在 computed 中。</p></blockquote><h6 id="▉-第一种方式："><a href="#▉-第一种方式：" class="headerlink" title="▉ 第一种方式："></a>▉ 第一种方式：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这样获取有个缺点，直接将属性暴露在外部了</span><br><span class="line">this.$store.state.menuItems; // 全局获取 store 中的数据</span><br></pre></td></tr></table></figure><h6 id="▉-第二种方式："><a href="#▉-第二种方式：" class="headerlink" title="▉ 第二种方式："></a>▉ 第二种方式：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过 getter 获取</span><br><span class="line">this.$store.getters.getMenuItems; // 调用 getters 里边的方法</span><br></pre></td></tr></table></figure><h2 id="模块化分离"><a href="#模块化分离" class="headerlink" title="模块化分离"></a>模块化分离</h2><blockquote><p>将 Vuex 中的各功能部分进行分离。分别建立独立文件，然后实现模块化。</p></blockquote><h4 id="1、四种状态进行分离"><a href="#1、四种状态进行分离" class="headerlink" title="1、四种状态进行分离"></a>1、四种状态进行分离</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export const 功能</span><br><span class="line">import * as getters from &apos;./getters&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export const store = new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        // 设置属性</span><br><span class="line">        menuItems:&#123;&#125;,  // Menu 菜单 </span><br><span class="line">        menuItems2:&#123;&#125;, // Admin 菜单 </span><br><span class="line">        username:null, // 当前用户名</span><br><span class="line">        isLogin:false  // 当前的登录状态</span><br><span class="line">    &#125;,</span><br><span class="line">    getters,</span><br><span class="line">    mutations,</span><br><span class="line">    actions</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2、使用-Moudle-优化分离"><a href="#2、使用-Moudle-优化分离" class="headerlink" title="2、使用 Moudle 优化分离"></a>2、使用 Moudle 优化分离</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const getters = &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mutations = &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const actions = &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    state,</span><br><span class="line">    getters,</span><br><span class="line">    mutations,</span><br><span class="line">    actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import users from &apos;./Module/users&apos;</span><br><span class="line">export const store = new Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        menu,</span><br><span class="line">        status,</span><br><span class="line">        users</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue 全家桶（Vue-router、Vuex ）浅入浅出！&lt;/p&gt;
    
    </summary>
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="前端框架" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【浏览器渲染原理】</title>
    <link href="http://yoursite.com/2019/06/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/21/前端面试之道【浏览器渲染原理】/</id>
    <published>2019-06-21T06:22:40.806Z</published>
    <updated>2019-06-23T00:01:00.022Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浏览器的渲染原理！</p><a id="more"></a><h2 id="一、浏览器的渲染原理"><a href="#一、浏览器的渲染原理" class="headerlink" title="一、浏览器的渲染原理"></a>一、浏览器的渲染原理</h2><blockquote><p>JS 代码执行有自己的 JS 引擎，而浏览器的渲染也有一个引擎叫做渲染引擎。<strong>Firefox</strong> 的渲染引擎叫做 <strong>Gecko</strong>，<strong>Chrome</strong> 和 <strong>Safari</strong> 中都是基于 <strong>WebKit</strong> 开发的。</p></blockquote><h3 id="1、DOM-树的构建"><a href="#1、DOM-树的构建" class="headerlink" title="1、DOM 树的构建"></a>1、DOM 树的构建</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167542b09875a74a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>① 当我们在网页中向服务器请求对应的 HTML 时，服务器将 HTML、CSS、JS 文件转化为 0,1字节数据在网络中传输给浏览器。</p><p>② 浏览器将接收到的字节数据转化为字符串。</p><p>③ 转化为字符串之后，浏览器再将这些字符串通过词法分析转化为标记（token）—— 代码的最小单位,这一过程叫做标记化。</p><p>④ 结束标记化后，将这些标记转化为 Node 结点，浏览器根据不同的结点构建为一棵 DOM 树。</p><h3 id="2、构建-CSSOM-树"><a href="#2、构建-CSSOM-树" class="headerlink" title="2、构建 CSSOM 树"></a>2、构建 CSSOM 树</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>① 将 CSS 文件转化为 CSSOM 树。这个过程和上述过程是类似的，但是有一点不同，浏览器为了确定结点的样式，这个过程是非常耗时的。</p><p>② 浏览器通过递归的方式 DOM 树为结点设置样式。通过过先找到具体的标签，然后递归找到设置的上级标签，最后确定选择器选择的所选标签的样式。</p><p>③ 所以应该避免书写过于具体的 CSS 选择器，少一些添加无意义的 HTML 标签，有利于提高习页面的性能。</p><h3 id="3、DOM-CSSOM-生成渲染树"><a href="#3、DOM-CSSOM-生成渲染树" class="headerlink" title="3、DOM + CSSOM 生成渲染树"></a>3、DOM + CSSOM 生成渲染树</h3><blockquote><p>将生成的 DOM 树和 CSSOM 树进行合并生成渲染树（Render Tree）。</p></blockquote><p>① 两者并不是简单的合并，而是渲染树只会包括需要<strong>显示的结点</strong>，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</p><p>② 浏览器生成渲染树的时候，就会根据渲染树进行布局（回流），调用 GPU 绘制，合成图层，显示在屏幕上。这一部分属于底层操作。</p><h2 id="二、浏览器的渲染流程"><a href="#二、浏览器的渲染流程" class="headerlink" title="二、浏览器的渲染流程"></a>二、浏览器的渲染流程</h2><blockquote><p>由于我们屏幕的刷新率为每秒 60 次，也就是 16.7 ms 一次，所有说在刷新一次之间页面重新绘制两次是没有意义的，只会影响性能。</p></blockquote><h4 id="1、渲染帧的流程"><a href="#1、渲染帧的流程" class="headerlink" title="1、渲染帧的流程"></a>1、渲染帧的流程</h4><blockquote><p>渲染帧指的是一次完整绘制的过程。所以在 16.7 ms 一帧内渲染完成才会保证不会掉帧，否则页面会有卡顿感。（屏幕都渲染完成了，你的动画确还没有变化）</p></blockquote><p>一帧需要完成以下操作：</p><p>①  <strong>脚本执行（JavaScript）：</strong>脚本造成了需要重绘的改动，比如增删 DOM、请求动画等；</p><p>②  <strong>样式计算（CSS Object Model）：</strong>级联地生成每个节点的生效样式；</p><p>③  <strong>布局（Layout）：</strong>计算布局，执行渲染算法；</p><p>④  <strong>重绘（Paint）：</strong>各层分别进行绘制（比如 3D 动画）；</p><p>⑤   <strong>合成（Composite）：</strong>合成各层的渲染结果；</p><h4 id="2、耗时的-JS-会阻塞渲染"><a href="#2、耗时的-JS-会阻塞渲染" class="headerlink" title="2、耗时的 JS 会阻塞渲染"></a>2、耗时的 JS 会阻塞渲染</h4><blockquote><p>可以观察到虽然每秒都会写一次 DOM，但在 5s 结束后才会全部渲染出来，明显耗时脚本阻塞了渲染。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">&lt;div id=<span class="string">"message"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> then = <span class="built_in">Date</span>.now()</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'message'</span>)</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">if</span> (now - then &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i++ &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    el.innerText += <span class="string">'hello!\n'</span></span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    then = now</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、为什么操作-DOM-慢"><a href="#三、为什么操作-DOM-慢" class="headerlink" title="三、为什么操作 DOM 慢"></a>三、为什么操作 DOM 慢</h2><blockquote><p>因为操作 DOM 是属于渲染引擎的东西，而 JS 属于 JS 引擎的东西，所以我们通过 JS 操作 DOM 的时候，这个过程涉及到两个线程的通信，那就回带来一些性能上的损耗。如果操作 DOM 次数过多，就相当于两个线程之间一直通信，并且操作 DOM 会导致重绘回流的情况，性能就会有所下降。</p></blockquote><h4 id="1、插入几万-DOM-怎么实现页面不卡顿？"><a href="#1、插入几万-DOM-怎么实现页面不卡顿？" class="headerlink" title="1、插入几万 DOM 怎么实现页面不卡顿？"></a>1、插入几万 DOM 怎么实现页面不卡顿？</h4><blockquote><p>两种解决方案：</p><p>1）第一种通过 <code>requestAnimationFrame</code> 的方式循环插入 DOM。</p><p>2）第二种方式是通过<strong>虚拟滚动</strong>。</p></blockquote><h4 id="2、两种实现方式"><a href="#2、两种实现方式" class="headerlink" title="2、两种实现方式"></a>2、两种实现方式</h4><blockquote><p>requestAnimationFrame 实现。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> total = <span class="number">30000</span>;              <span class="comment">// 总 DOM 数</span></span><br><span class="line"><span class="keyword">const</span> size = <span class="number">100</span>;                 <span class="comment">// 每次渲染的 DOM 数</span></span><br><span class="line"><span class="keyword">const</span> bathCount = total / size;   <span class="comment">// 一共处理 300 次</span></span><br><span class="line"><span class="keyword">var</span> countDone = <span class="number">0</span>;                <span class="comment">// 已经处理完的多少次</span></span><br><span class="line"><span class="keyword">const</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addItems</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="comment">// 一次渲染 100 个DOM </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">        li.innerText = <span class="string">'item '</span> + (countDone * size + i);</span><br><span class="line">        fragment.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次插入 100 个结点就修改 DOM 一次</span></span><br><span class="line">    ul.appendChild(fragment);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经完成插入的次数</span></span><br><span class="line">    countDone++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否处理完成</span></span><br><span class="line">    <span class="keyword">if</span>(countDone &lt; bathCount)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(addItems);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">addItems();</span><br></pre></td></tr></table></figure><blockquote><p>虚拟滚动实现：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、什么情况阻塞渲染"><a href="#四、什么情况阻塞渲染" class="headerlink" title="四、什么情况阻塞渲染"></a>四、什么情况阻塞渲染</h2><h4 id="1、阻塞的原因"><a href="#1、阻塞的原因" class="headerlink" title="1、阻塞的原因"></a>1、阻塞的原因</h4><blockquote><p>1）渲染的前提是生成渲染树才能下一步的渲染，所以生成渲染树的过程也就是加载 HTML 和 CSS 肯定会阻塞渲染。（<strong>js 阻塞渲染也会阻塞解析，而CSS 只会阻塞渲染，不会阻塞解析</strong>）</p><p>2）当浏览器在解析 script 标签的时候会暂停 DOM，完成后会在从暂停的地方重新开始。</p></blockquote><h4 id="2、减少阻塞"><a href="#2、减少阻塞" class="headerlink" title="2、减少阻塞"></a>2、减少阻塞</h4><blockquote><p>1）要想渲染的越快，就必须降低渲染文件的大小，优化选择器。</p><p>2）想要第一次加载页面加载的快，所以将 JS 文件标签放在 body 底部。</p><p>3）当 <code>script</code> 标签加上 <code>defer</code> 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 <code>script</code> 标签放在任意位置。</p><p>4）对于没有任何依赖的 JS 文件可以加上 <code>async</code> 属性，表示 JS 文件下载和解析不会阻塞渲染。</p></blockquote><p><strong>补充：</strong></p><ul><li>async 异步下载脚本，下载完执行执行，在 onload 事件触发之前，不会阻塞页面但是不能保证脚本出现的顺序执行。</li><li>defer 属性也会异步下载，但是会按照页面脚本的执行顺序下载，脚本的执行是按照页面脚本顺序执行的。而且是在 DOM 解析完成和 onload 触发之前执行。</li></ul><h2 id="五、重绘（Repaint）和回流-Reflow"><a href="#五、重绘（Repaint）和回流-Reflow" class="headerlink" title="五、重绘（Repaint）和回流(Reflow)"></a>五、重绘（Repaint）和回流(Reflow)</h2><blockquote><p><strong>回流必将引起重绘，重绘不一定会引起回流。</strong></p></blockquote><h4 id="1、重绘"><a href="#1、重绘" class="headerlink" title="1、重绘"></a>1、重绘</h4><blockquote><p>在文档流中的位置并未发生改变，重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘。</p></blockquote><h4 id="2、回流"><a href="#2、回流" class="headerlink" title="2、回流"></a>2、回流</h4><blockquote><p>在文档流中为止发生改变，回流是布局或者几何属性需要改变就称为回流。</p></blockquote><h4 id="3、重绘-回流与EventLoop"><a href="#3、重绘-回流与EventLoop" class="headerlink" title="3、重绘/回流与EventLoop"></a>3、重绘/回流与EventLoop</h4><p>① 当 EventLoop 执行完微任务后，会判断 <code>document</code> 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次；</p><p>② 然后判断是否有 <code>resize</code> 或者 <code>scroll</code> 事件，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 16ms 才会触发一次，并且自带节流功能；</p><p>③ 判断是否触发了 media query；</p><p>④ 更新动画并且发送事件；</p><p>⑤ 判断是否有全屏操作事件；</p><p>⑥ 执行 <code>requestAnimationFrame</code> 回调；</p><p>⑦ 执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好；</p><p>⑧ 更新界面；</p><p>⑨ 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调。</p><h4 id="4、如何减少重绘和回流"><a href="#4、如何减少重绘和回流" class="headerlink" title="4、如何减少重绘和回流"></a>4、如何减少重绘和回流</h4><p>①  使用 <code>transform</code> 替代 <code>top</code>；</p><p>②  使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）;</p><p>③  不要把节点的属性值放在一个循环里当成循环里的变量;</p><p>④  不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局;</p><p>⑤ 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code>;</p><p>⑥ CSS 选择符<strong>从右往左</strong>匹配查找，避免节点层级过多;</p><p>⑦ 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器的渲染原理！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【CSS3的新特性】</title>
    <link href="http://yoursite.com/2019/06/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90CSS3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/20/前端面试之道【CSS3的新特性】/</id>
    <published>2019-06-19T23:14:33.256Z</published>
    <updated>2019-06-20T23:47:55.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CSS3 的有哪些新特性？</p><a id="more"></a><h3 id="一、CSS3新增选择器"><a href="#一、CSS3新增选择器" class="headerlink" title="一、CSS3新增选择器"></a>一、CSS3新增选择器</h3><ul><li><code>p:first-of-type</code> |  <code>p:last-of-type</code> ` 选择所有父元素该元素出现的第一个(最后一个)元素。</li><li><code>p:nth-child(2)</code>  选择父元素的第二个元素。</li><li><code>p:first-child</code>  | <code>p:last-child</code>  选择父元素的第一个元素或最后一个元素。</li><li><code>p:only-of-type</code> 选择父元素唯一没有兄弟节点的元素。</li><li><code>:enabled</code>  <code>:disabled</code> 选择表单禁用状态的输入框。</li><li><code>:checked</code>  选择单选按钮或复选框被选择状态的。</li></ul><h3 id="二、文本"><a href="#二、文本" class="headerlink" title="二、文本"></a>二、文本</h3><ul><li><code>text-shadow:参数1 参数2 参数3 参数4</code>   向右偏移  向下偏移  渐变像素  渐变颜色；</li><li><code>white-space: nowrap;</code> 禁止文字换行；</li><li><code>text-overflow: ellipsis</code> 文字溢出部分显示省略号（必须隐藏元素overflow:hidden）；<ul><li><code>clip:</code>文字溢出部分剪切掉。</li></ul></li><li><code>word-wrap:</code>  对长的不可分割的单词进行分割并换行到下一行</li></ul><h3 id="三、边框"><a href="#三、边框" class="headerlink" title="三、边框"></a>三、边框</h3><ul><li><p><code>border-radius:</code>圆角边框</p></li><li><p><code>border-shaow:</code>盒阴影</p></li><li><p><code>border-shadow:</code> 右偏移 下偏移  模糊程度 阴影颜色</p></li><li><p><code>border-images-*:</code></p><ul><li><code>source</code> 图片路径 </li><li><code>slice</code> 向内偏移 </li><li><code>width</code> 边框宽度 </li><li><code>outset</code>边框区域超出边框的量 </li><li><code>repeat :</code> <code>repeat/round/stretch</code> 是否平铺/铺满/拉伸</li></ul></li></ul><h3 id="四、背景"><a href="#四、背景" class="headerlink" title="四、背景"></a>四、背景</h3><ul><li><code>background-image:</code>背景图片</li><li><code>background-size：</code>指定背景图片的大小 cover : 缩放不变 /contain：保持最大大小</li><li><code>background-origin：</code>定位背景图片的位置 <code>content-box/border-box/padding-box</code></li><li><code>background-clip：</code>规定背景的绘制区域</li></ul><h3 id="五、渐变"><a href="#五、渐变" class="headerlink" title="五、渐变"></a>五、渐变</h3><blockquote><p>渐变分为线性渐变（Linear-gradient）和径向渐变(Radial-gradient)</p></blockquote><h4 id="1、线性渐变"><a href="#1、线性渐变" class="headerlink" title="1、线性渐变"></a>1、线性渐变</h4><ul><li><code>background:linear-gradient (起始位置，起始颜色，终止颜色);</code><ul><li>top bottom left right 以及对角线组合;</li><li>自定义角度（30deg）— 顺时针;</li><li>颜色可多个组合;</li><li>透明度渐变(rgba CSS3新属性);</li></ul></li><li><code>repeating-linear-gradient()</code> 函数用于重复线性渐变;</li></ul><h4 id="2、径向渐变"><a href="#2、径向渐变" class="headerlink" title="2、径向渐变"></a>2、径向渐变</h4><ul><li><p><code>background: radial-gradient(center, shape size, start-color, ..., last-color);</code></p><ul><li>center 渐变中心</li><li>指定渐变颜色大小 size （不均匀分布）</li><li>第一参数：设置形状（circle、ellipse椭圆）</li><li>也可以设置成尺寸</li></ul></li><li><p><code>repeating-radial-gradient()</code> 函数用于重复线性渐变;</p></li></ul><h3 id="六、过渡"><a href="#六、过渡" class="headerlink" title="六、过渡"></a>六、过渡</h3><h3 id="七、动画、旋转"><a href="#七、动画、旋转" class="headerlink" title="七、动画、旋转"></a>七、动画、旋转</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS3 的有哪些新特性？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【垃圾回收机制】</title>
    <link href="http://yoursite.com/2019/06/19/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/19/前端进阶深入系列之【垃圾回收机制】/</id>
    <published>2019-06-19T10:57:46.695Z</published>
    <updated>2019-06-19T13:14:19.654Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JS 引擎以及 V8 引擎的垃圾回收机制是怎么样的？</p><a id="more"></a>s<br><br><br><br>### 内存泄漏<br><br>#### 1、什么是内存泄漏？<br><br>&gt; 不再用到的内存，没有及时释放，就叫做内存泄漏。<br><br><strong>内存泄漏是指我们已经无法再通过js代码来引用到某个对象，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它</strong>。导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。<br><br><br><br>#### 2、怎么解决内存泄漏？<br><br>&gt; 很多编程语言需要手动释放内存，但是很多开发者喜欢系统提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”。<br><br><br><br>### 一、为什么有垃圾回收机制？<br><br>&gt; js 中的字符串、对象、数组等只有确定固定大小时，才会动态分配内存，只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃<br><br><br><br>### 二、js 的垃圾回收机制<br><br>&gt; JavaScript 与其他语言不同，它具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。<br><br><br><br>### 三、垃圾回收机制原理<br><br>&gt; 找出那些不再继续使用的变量，然后释放其内存。垃圾回收器会按照固定的时间间隔，周期性的执行该垃圾回收操作。<br><br><br><br>### 四、两种垃圾回收策略<br><br>&gt; js 中最常用的就是标记清除法。垃圾收集器必须跟踪哪个变量有用哪个没用，对于没有用的变量打上标记，以备将来收集其内存。<br><br>- <strong>标记清除法</strong><br>- <strong>引用计数法</strong><br><br><br><br>#### 1、标记清除法<br><br>&gt; 垃圾回收器会在运行的时候，会给存储在内存中的所有变量都加上标记，然后它会去掉环境中变量以及被环境中的变量引用的变量的标记。剩下的就视为即将要删除的变量，原因是在环境中无法访问到这些变量了。最后垃圾回收器完成内存清除操作。<br><br><br><br>###### ▉ 实现原理<br><br>&gt; 通过判断一个变量是否在执行环境中被引用，来进行标记删除。<br><br><br><br>###### ▉ 标记清除的缺陷<br><br>&gt; 其实标记清除和引用计数的缺陷相同的，因为都是判断变量在执行环境中的引用来确定该变量是否应该被回收，当保持着引用时，改变变量会一直在内存中存储。<br><br><br><br>#### 2、引用计数法<br><br>&gt; 引用计数的垃圾收集策略不常用，引用计数的最基本含义就是跟踪记录每个值被引用的次数。<br><br><br><br>###### ▉ 实现原理<br><br>&gt; 当声明变量并将一个引用类型的值赋值给该变量时，则这个值的引用次数加 1，同一值被赋予另一个变量，该值的引用计数加 1 。当引用该值的变量被另一个值所取代，则引用计数减 1，当计数为 0 的时候，说明无法在访问这个值了，所有系统将会收回该值所占用的内存空间。<br><br><br><br>###### ▉ 引用计数的缺陷<br><br>&gt; 两个对象的相互循环引用，在函数执行完成的时候，两个对象相互的引用计数并未归 0 ，而是依然占据内存，无法回收，当该函数执行多次时，内存占用就会变多，导致大量的内存得不到回收。<br><br><strong>举例：</strong>最常见的就是在 IE BOM 和 DOM 中，使用的对象并不是 js 对象，所以垃圾回收是基于计数策略的。但是在 IE9 已经将 BOM 和 DOM 真正的转化为了 js 对象，所以循环引用的问题得到解决。<br><br><br><br>#### 3、管理内存<br><br>&gt; 虽然说是 js 的内存都是自动管理的，但是对于 js 还是存在一些问题的，最主要的一个问题就是<strong>分配给 Web 浏览器的可用内存数量通常比分配给桌面应用程序的少</strong>。<br><br><br><br>###### ▉ 主要原因<br><br>&gt; 也是为了安全方面考虑，防止运行 js 网页将系统内存耗尽，导致整个系统崩溃。内存限制问题不仅影响到了给变量分配内存，还会影响调用栈以及线程同时执行的语句数量。<br><br><br><br>###### ▉ 解决方案<br><br>&gt; 为了能够让页面获得最好的性能，必须确保 js 变量占用最少的内存，最好的方式就是将不用的变量引用释放掉，也叫做<strong>解除引用</strong>。<br><br>- 对于局部变量来说，函数执行完成离开环境变量，变量将自动解除。<br>- 对于全局变量我们需要进行手动解除。（注意：解除引用并不意味被收回，而是将变量真正的脱离执行环境，下一次垃圾回收将其收回）<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;  <span class="comment">// 在堆内存中给数值变量分配空间</span></span><br><span class="line">alert(a + <span class="number">100</span>);  <span class="comment">// 使用内存</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>; <span class="comment">// 使用完毕之后，释放内存空间</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>补充：</strong>因为通过上边的垃圾回收机制的标记清除法的原理得知，只有与环境变量失去引用的变量才会被标记回收，所用上述例子通过将对象的引用设置为 null ，此变量也就失去了引用，等待被垃圾回收器回收。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 引擎以及 V8 引擎的垃圾回收机制是怎么样的？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道【网络攻击】</title>
    <link href="http://yoursite.com/2019/06/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E4%B9%8B%E3%80%90H5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/19/前端面试之道之【H5的新特性】/</id>
    <published>2019-06-18T23:07:11.542Z</published>
    <updated>2019-06-19T01:26:45.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>H5 的新特性有哪些呢？</p><a id="more"></a><h2 id="H5-的新特性有哪些？"><a href="#H5-的新特性有哪些？" class="headerlink" title="H5 的新特性有哪些？"></a>H5 的新特性有哪些？</h2><ul><li><p>语义化标签</p></li><li><p>多媒体</p></li><li><p>用于绘画的 canvas</p></li><li><p>离线 &amp; 存储。对本地离线存储的更好的支持,local Store,Cookies。</p></li></ul><h3 id="一、新增标签"><a href="#一、新增标签" class="headerlink" title="一、新增标签"></a>一、新增标签</h3><h4 id="1、结构标签（10个）"><a href="#1、结构标签（10个）" class="headerlink" title="1、结构标签（10个）"></a>1、结构标签（10个）</h4><ul><li>\<article> ：标记一篇文章。 </article></li><li>\<header> ：标记一个页面的头部或一个区域的头部。</header></li><li>\<nav>：标记定义导航链接。</nav></li><li>\<section>：标记定义一个区域。</section></li><li>\<aside>：标记定义页面内容部分的侧边栏。</aside></li><li>\<hgroup>：标记定义文件中的一个区块的相关信息。</hgroup></li><li>\<figure>：标记定义一组媒体内容以及它们的标题。</figure></li><li>\<figcaption>：标记定义 figure元素的标题。</figcaption></li><li>\<footer>：标记定义一个页面或一个区域的底部。</footer></li><li>\<dialog>：标记定义一个对话框类似微信。</dialog></li></ul><h4 id="2、多媒体标签（5个）"><a href="#2、多媒体标签（5个）" class="headerlink" title="2、多媒体标签（5个）"></a>2、多媒体标签（5个）</h4><ul><li>video：定义一个视频。</li><li>audio：定义音频内容。</li><li>source：定义媒体资源。</li><li>canvas：画布。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//对于不是 mp4 格式的视频，使用 source 来解决</span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>  <span class="attr">src</span>=<span class="string">" "</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> <span class="attr">width</span>=<span class="string">""</span> <span class="attr">height</span>=<span class="string">""</span> <span class="attr">controls</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">//需要进行转码</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">" "</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span> &gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//对于不是 mp3 格式的音频，使用 source 来解决</span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">autoplay</span>=<span class="string">" "</span>&gt;</span></span><br><span class="line">//需要进行转码</span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">" "</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、应用标签（5个）"><a href="#3、应用标签（5个）" class="headerlink" title="3、应用标签（5个）"></a>3、应用标签（5个）</h4><h6 id="▉-状态标签"><a href="#▉-状态标签" class="headerlink" title="▉ 状态标签"></a>▉ 状态标签</h6><ul><li><p><code>&lt;meter&gt;</code>：状态标签（实时状态显示：气压、气温）</p></li><li><p><code>&lt;progress&gt;</code>：状态标签（任务过程：安装、加载)</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"380"</span> <span class="attr">min</span>=<span class="string">"20"</span> <span class="attr">max</span>=<span class="string">"380"</span> <span class="attr">low</span>=<span class="string">"200"</span> <span class="attr">high</span>=<span class="string">"240"</span> <span class="attr">optimum</span>=<span class="string">"220"</span>&gt;</span><span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"0.75"</span>&gt;</span>75%<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;progress value=&quot;30&quot; max=&quot;100&quot;&gt; &lt;/progress&gt;</span><br><span class="line">&lt;progress max=&quot;100&quot;&gt;</span><br></pre></td></tr></table></figure><h6 id="▉-列表标签"><a href="#▉-列表标签" class="headerlink" title="▉ 列表标签"></a>▉ 列表标签</h6><ul><li><p><code>&lt;datalist&gt;</code>：为 input 添加下拉列表。</p></li><li><p><code>&lt;details&gt;</code>：隐藏、显示详细内容。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 兼容性：Firefox、Opera</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"请选择您喜欢的手机品牌"</span> <span class="attr">list</span>=<span class="string">"phoneList"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"phoneList"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"iphone"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"sumsung"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"HUawei"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"HTC"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Meizu"</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 浏览器兼容 ：Chrome。</span><br><span class="line">&lt;details&gt;</span><br><span class="line">    &lt;summary&gt;问候&lt;/summary&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><h3 id="二、新增属性"><a href="#二、新增属性" class="headerlink" title="二、新增属性"></a>二、新增属性</h3><ul><li><strong>Input 标签</strong></li><li><strong>表单属性</strong></li><li><strong>链接属性</strong></li><li><strong>其它属性</strong></li></ul><h4 id="1、Input-标签"><a href="#1、Input-标签" class="headerlink" title="1、Input 标签"></a>1、Input 标签</h4><blockquote><p>1）针对于 iphone 手机端：<code>email /url /tel /number/Date Pickers</code></p><p>2）针对于客户端：<code>Range / Search /Color</code></p></blockquote><ul><li><strong>email类型：</strong>针对于手机端，出现特殊的键盘，电子邮件 Input 类型。</li><li><strong>url 类型：</strong>只应用于苹果手机端，特殊键盘。</li><li><strong>tel 类型：</strong>出现特殊的电话号码键盘。</li><li><strong>number 类型：</strong>出现数字运算键盘。</li><li><strong>Data Pickers 类型：</strong>日期类型，手机端只应用于 iphone**<ul><li><strong>Date</strong> —— 选取日、月、年。</li><li><strong>Month</strong> —— 选取月年。</li><li><strong>Week </strong> —— 选取周和年。</li><li><strong>Time</strong> —— 选取时间（小时和分钟）。</li><li><strong>Datetime</strong> —— 选取时间、日、月、年（UTC 时间）。</li><li><strong>Datetime-local</strong> —— 选取时间、日、月、年（本地时间）。</li></ul></li></ul><blockquote><p><strong>Datetime 和 Datetime-local  的区别？</strong></p><p><strong>1)兼容性。</strong><code>Datetime</code>类型只有 <code>Safire</code> 和<code>Opera</code>浏览器兼容；而  <code>Datetime-local</code>兼容 <code>Chrome</code> 、 <code>Safire</code>和 <code>Opera</code>。</p><p><strong>2) 返回类型不同。</strong>local  返回本地时间，而 Date 返回时区。</p></blockquote><h4 id="2、表单属性"><a href="#2、表单属性" class="headerlink" title="2、表单属性"></a>2、表单属性</h4><ul><li><strong>autocomplete 属性：</strong>当重新加载页面时，输入框重置，是否提示。autocomplete=”on/off”</li><li><strong>aotufocus 属性</strong>：页面加载时，自动获取属性。</li><li><strong>multiple 属性：</strong>规定输入域可选择多个值。一般应用于<strong>上传文件</strong>（file）和<strong>邮件 （email ）</strong>输入框。</li><li><strong>placeholder 属性：</strong>提供一种提示（hint）。</li><li><strong>require 属性：</strong>主要用来进行输入域验证（不能为空），必填字段</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">""</span> autocomplete=<span class="string">"on"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"text"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"email"</span> name=<span class="string">"email"</span> autocomplete=<span class="string">"off"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;text&quot; autofocus=&quot;autofocus&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;text&quot; placeholder=&quot;请输入您的用户名&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//填写完整才能进行提交</span><br><span class="line">&lt;input type=&quot;email&quot; name=&quot;email&quot; required=&quot;required&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="3、链接属性"><a href="#3、链接属性" class="headerlink" title="3、链接属性"></a>3、链接属性</h4><ul><li><strong>sizes 属性：</strong>根据屏幕不同的分辨率来调整不同的sizes。</li><li><strong>target 属性：</strong>base标签写在 \<hread> 之间。</hread></li><li><strong>超链接</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;icon.gif&quot; type=&quot;image/gif&quot; size=&quot;16X16&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//控制所有的页面的超链接默认选择新窗口。</span><br><span class="line">&lt;base href=&quot;http://localhost/&quot; target=&quot;_blank&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a：media=&quot;&quot;//表示对设备进行优化，handhelp对手持设备进行支持，tv 对“电视”设备进行支持。</span><br><span class="line">a:hreflang=&quot;zh&quot;//设置语言，这里设置的中文</span><br><span class="line">a:rel=&quot;external&quot; //这里的超链接为外部链接</span><br></pre></td></tr></table></figure><h4 id="4、其它属性"><a href="#4、其它属性" class="headerlink" title="4、其它属性"></a>4、其它属性</h4><ul><li><p><strong>script 标签：</strong></p><ul><li><p>defer 属性：（只兼容 IE 浏览器）加载完浏览器之后，再加载 js 外部文件夹。</p></li><li><p>async 属性：（兼容一切浏览器）加载页面的同时也加载外部文件。</p></li></ul></li><li><p><strong>ol 标签：</strong></p><ul><li><p>Start —— 起始值：有序列表的起始值。</p></li><li><p>Reversed —— 有序列表倒序输出。</p></li></ul></li><li><p><strong>html 标签：</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html mainifest=&quot;index.mainifest&quot;&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="H5-提供的新的API"><a href="#H5-提供的新的API" class="headerlink" title="H5 提供的新的API"></a>H5 提供的新的API</h2><ul><li><strong>canvas。</strong>可以画出很多绚丽的图形，甚至可以直接做出伪3D游戏。</li><li><p><strong>媒体控制。</strong>直译就是回放功能，假如只用 html5.0 以下的标签写，以前的音乐播放是不可能实现滚动条的。</p></li><li><p><strong>离线网页程序。</strong>在无网络的情况下也可以查看网页，可以把资源文件完全缓存在客户端，并且通过js的一些方法清空缓存 manifest 属性。</p></li><li><strong>拖动。</strong>可以将文件拖动到某些区域上传。</li><li><strong>跨文档请求</strong>。websocket，一种更加高效的通讯方式。</li><li><strong>客户端数据存储。</strong>localstoage、sessionstoage。</li></ul><h2 id="H5-最常用考面试题"><a href="#H5-最常用考面试题" class="headerlink" title="H5 最常用考面试题"></a>H5 最常用考面试题</h2><h5 id="1、新的-HTML5-文档类型和字符集是？"><a href="#1、新的-HTML5-文档类型和字符集是？" class="headerlink" title="1、新的 HTML5 文档类型和字符集是？"></a>1、新的 HTML5 文档类型和字符集是？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=”UTF-8″&gt;</span><br></pre></td></tr></table></figure><h4 id="2、HTML5-中如何嵌入音频？"><a href="#2、HTML5-中如何嵌入音频？" class="headerlink" title="2、HTML5 中如何嵌入音频？"></a>2、HTML5 中如何嵌入音频？</h4><blockquote><p>HTML5 支持 MP3、Wav 和 Ogg 格式的音频。</p></blockquote><h4 id="3、HTML5-中如何嵌入视频？"><a href="#3、HTML5-中如何嵌入视频？" class="headerlink" title="3、HTML5 中如何嵌入视频？"></a>3、HTML5 中如何嵌入视频？</h4><blockquote><p>HTML5支持 MP4、WebM 和 Ogg 格式的视频</p></blockquote><h4 id="4、除了-audio-和-video，HTML5-还有哪些媒体标签？"><a href="#4、除了-audio-和-video，HTML5-还有哪些媒体标签？" class="headerlink" title="4、除了 audio 和 video，HTML5 还有哪些媒体标签？"></a>4、除了 audio 和 video，HTML5 还有哪些媒体标签？</h4><ul><li>\<embed> ：标签定义嵌入的内容，比如插件。</li><li>\<source>：对于定义多个数据源很有用。</li><li>\<track>：具体用于播放带有字幕的视频。</li></ul><h4 id="5、HTML5-Canvas-元素有什么用？"><a href="#5、HTML5-Canvas-元素有什么用？" class="headerlink" title="5、HTML5 Canvas 元素有什么用？"></a>5、HTML5 Canvas 元素有什么用？</h4><blockquote><p>Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在  HTML 上进行图形操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=”canvas1″ width=”300″ height=”100″&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><h4 id="6、HTML5-存储类型有什么区别？"><a href="#6、HTML5-存储类型有什么区别？" class="headerlink" title="6、HTML5 存储类型有什么区别？"></a>6、HTML5 存储类型有什么区别？</h4><blockquote><p>HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。</p></blockquote><ul><li><strong>localStorage</strong> ： 用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。</li><li><strong>sessionStorage</strong>： 同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 <code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。</li></ul><h4 id="7、HTML5-废弃了哪些-HTML4-标签？"><a href="#7、HTML5-废弃了哪些-HTML4-标签？" class="headerlink" title="7、HTML5 废弃了哪些 HTML4 标签？"></a>7、HTML5 废弃了哪些 HTML4 标签？</h4><ul><li>frame</li><li>frameset</li><li>noframe</li><li>applet</li><li>big</li><li>center</li><li>basefront</li></ul><h4 id="8、HTML5-应用程序缓存和浏览器缓存有什么区别？"><a href="#8、HTML5-应用程序缓存和浏览器缓存有什么区别？" class="headerlink" title="8、HTML5 应用程序缓存和浏览器缓存有什么区别？"></a>8、HTML5 应用程序缓存和浏览器缓存有什么区别？</h4><blockquote><p>应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML、CSS、图片以及 JavaScript。这个特性可以提高网站性能，它的实现借助于 manifest 文件。与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;H5 的新特性有哪些呢？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【事件循环】</title>
    <link href="http://yoursite.com/2019/06/14/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/14/前端进阶深入系列之【事件循环】/</id>
    <published>2019-06-14T11:32:21.425Z</published>
    <updated>2019-06-21T23:39:34.419Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深入 JS 内部的事件循环机制！</p><a id="more"></a><h3 id="一、为什么会有-EventLoop"><a href="#一、为什么会有-EventLoop" class="headerlink" title="一、为什么会有 EventLoop ?"></a>一、为什么会有 EventLoop ?</h3><blockquote><p>由于 JS 的代码是单线程执行的，所以为了保证 js 代码的执行顺序，以及异步代码的执行顺序，内部引入了事件循环机制。</p></blockquote><h3 id="二、深入事件循环"><a href="#二、深入事件循环" class="headerlink" title="二、深入事件循环"></a>二、深入事件循环</h3><blockquote><p>事件循环的执行过程。</p></blockquote><h4 id="1、微观任务和宏观任务"><a href="#1、微观任务和宏观任务" class="headerlink" title="1、微观任务和宏观任务"></a>1、微观任务和宏观任务</h4><blockquote><p><strong>宏观任务：</strong>从浏览器的角度看，宏观任务就是代表一个离散的、独立工作单元。如：各种事件、执行主线程、setTimeout、解析 HTML 等。</p><p><strong>微观任务：</strong>所谓的微观任务就是更小的任务，主要是为了更新应用程序的状态，必须保证它在页面重新渲染 UI 之前执行。如:promise。</p></blockquote><h4 id="2、事件循环队列"><a href="#2、事件循环队列" class="headerlink" title="2、事件循环队列"></a>2、事件循环队列</h4><blockquote><p>事件循环至少需要两个队列，一个是<strong>微观任务队列</strong>，另一个是<strong>宏观任务队列</strong>。</p></blockquote><h4 id="3、事件循环的两个原则"><a href="#3、事件循环的两个原则" class="headerlink" title="3、事件循环的两个原则"></a>3、事件循环的两个原则</h4><ul><li>一次处理一个任务。</li><li>一个任务开始后直到运行完成，不会被其他任务中断。</li></ul><h4 id="4、事件循环原理"><a href="#4、事件循环原理" class="headerlink" title="4、事件循环原理"></a>4、事件循环原理</h4><blockquote><p>事件每循环一次就是一次迭代循环，每一次迭代循环最多在宏观任务队列中取出一个宏观任务执行，完成后就会执行微观队列中的任务，直到微观队列中的微观任务全部执行完成才会新渲染一次UI，然后进入下一次的迭代循环中。</p></blockquote><ul><li>两个任务队列都是独立于事件循环的。否则任何添加事件都会被忽略。</li><li>js 时单线程执行的，所以两类任务都是逐个执行的，任务执行中不能被其他任务中断。</li><li>每个微任务都会在下一次渲染 UI 之前执行完成，为了保证渲染前更新应用程序状态。</li><li>浏览器每秒渲染 60 次页面，达到每秒 60 帧的速度，比如动画，所以说必须在 16 ms内执行完单个任务和附带的微观任务，否则会影响平滑流畅度，甚至页面会产生无响应。</li></ul><h4 id="5、事件循环的执行顺序"><a href="#5、事件循环的执行顺序" class="headerlink" title="5、事件循环的执行顺序"></a>5、事件循环的执行顺序</h4><ul><li><p>实例一：仅含宏任务的执行过程</p></li><li><p>实例二：同时含有宏任务和微任务的执行过程</p></li></ul><h3 id="三、两种计时器"><a href="#三、两种计时器" class="headerlink" title="三、两种计时器"></a>三、两种计时器</h3><blockquote><p>延迟计时器可以可以延迟一段代码的执行，可以将长时间运行的任务分解为不阻塞事件循环的小任务，以阻止浏览器渲染，浏览器的过程会使得程序运行缓慢、没有反应。</p></blockquote><ul><li>延迟计时器（setTimeout)</li><li>间隔计时器（setInterval）</li></ul><h4 id="1、延迟计时器（setTimeout）"><a href="#1、延迟计时器（setTimeout）" class="headerlink" title="1、延迟计时器（setTimeout）"></a>1、延迟计时器（setTimeout）</h4><blockquote><p>延迟计时器会在设定的时间内延迟执行回调函数。</p></blockquote><p><strong>注意：</strong></p><p>① 由于 javascript 是单线程执行的，只能控制计时器何时被加入队列，而无法控制计时器何时执行。</p><p>② 使用 0ms 作为超时时间并不代表将在 0 ms 执行回调，这意味着使用 0ms 尽快执行回调，在回调之前可以进行 UI 渲染的。</p><h4 id="2、间隔计时器（setInterval）"><a href="#2、间隔计时器（setInterval）" class="headerlink" title="2、间隔计时器（setInterval）"></a>2、间隔计时器（setInterval）</h4><blockquote><p>每一间隔就会执行一次回调。</p></blockquote><h4 id="3、H5-新增定时器"><a href="#3、H5-新增定时器" class="headerlink" title="3、H5 新增定时器"></a>3、H5 新增定时器</h4><blockquote><p>传统的动画是由 setTimeout 或者 setInterval 完成的，但是存在两个问题：</p></blockquote><ul><li>动画的循环时间间隔不好确定，设置过长动画不够平滑，过短不够浏览器重绘达到瓶颈。</li><li>定时器设置的时间只是加入队列的时间，而不是立即执行的时间。</li></ul><p>所以 H5 新增加了 requestAnimationFrame 。</p><h6 id="▉-优点"><a href="#▉-优点" class="headerlink" title="▉ 优点"></a>▉ 优点</h6><p>1、 requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</p><p>2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量</p><p>3、requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销</p><h3 id="四、处理复杂任务"><a href="#四、处理复杂任务" class="headerlink" title="四、处理复杂任务"></a>四、处理复杂任务</h3><blockquote><p>在开发中，js 单线程的特性是最大的问题，因为当 js 忙于执行时，浏览器和用户的交互会变的很迟钝，甚至无响应，这是由于 js 执行任务时，重新更新 UI 渲染就会暂停，导致浏览器出现卡顿现象。可以通过 setTimeout 将大任务分割成小块任务循环渲染 UI 转化为非阻塞的操作。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rowCount = <span class="number">2000</span>; <span class="comment">// 行</span></span><br><span class="line"><span class="keyword">const</span> divdeInto = <span class="number">4</span>;   <span class="comment">// 分 4 个阶段渲染</span></span><br><span class="line"><span class="keyword">const</span> chunkSize = rowCount / divdeInto; <span class="comment">// 每个阶段渲染 500 行</span></span><br><span class="line"><span class="keyword">let</span> iteration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> table = <span class="built_in">document</span>.querySelectorAll(<span class="string">'tbody'</span>)[<span class="number">0</span>];</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">generateRows</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 计算上次渲染的位置</span></span><br><span class="line">    <span class="keyword">const</span> base = chunkSize * iteration;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; chunkSize; i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> tr = <span class="built_in">document</span>.createElement(<span class="string">"tr"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> t = <span class="number">0</span>; t &lt; <span class="number">6</span>;t++)&#123;</span><br><span class="line">            <span class="keyword">const</span> td = <span class="built_in">document</span>.createElement(<span class="string">"td"</span>);</span><br><span class="line">            td.appendChild(<span class="built_in">document</span>.createTextNode((i + base) + <span class="string">","</span> + t + <span class="string">","</span> + iteration));</span><br><span class="line">            tr.appendChild(td);</span><br><span class="line">        &#125;</span><br><span class="line">        table.appendChild(tr)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    iteration ++;</span><br><span class="line">    <span class="keyword">if</span>(iteration &lt; divdeInto)&#123;</span><br><span class="line">        setTimeout(generateRows,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="五、处理事件"><a href="#五、处理事件" class="headerlink" title="五、处理事件"></a>五、处理事件</h3><p><a href="[http://luxiangqiang.xn--6qq986b3xl/2019/04/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%91/](http://luxiangqiang.xn--6qq986b3xl/2019/04/28/前端面试之道[事件绑定]/">点击查看事件绑定文章</a>)</p><blockquote><p>事件的注册是通过 addEventListener 方法注册单击事件的。</p></blockquote><h4 id="1、注册事件"><a href="#1、注册事件" class="headerlink" title="1、注册事件"></a>1、注册事件</h4><blockquote><p>事件的的注册内部的 this 是指向注册元素的，事件中的 target 属性指的是发生事件的元素。</p></blockquote><h4 id="2、事件代理"><a href="#2、事件代理" class="headerlink" title="2、事件代理"></a>2、事件代理</h4><blockquote><p>事件的处理顺序是根据不同的事件模型来确定的，事件模型分为两种：</p></blockquote><ul><li><strong>事件捕获</strong>（从顶部开始到发生事件的目标元素）</li><li><strong>事件冒泡</strong>（从发生的目标元素到文档对象的顶部）—— 默认事件</li></ul><h5 id="▉-注意："><a href="#▉-注意：" class="headerlink" title="▉ 注意："></a>▉ 注意：</h5><blockquote><p>1、事件注册的元素不一定事件的发生元素。</p><p>2、通过 dom 树的事件代理可以减少编写消耗内存的代码。</p></blockquote><h3 id="六、自定义事件"><a href="#六、自定义事件" class="headerlink" title="六、自定义事件"></a>六、自定义事件</h3><blockquote><p>我们可以通过自定义事件模拟真实的事件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target: 事件目标对象</span></span><br><span class="line"><span class="comment">// eventType: 事件类型（自定义）</span></span><br><span class="line"><span class="comment">// eventDetail: 事件信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">triggerEvent</span>(<span class="params">target, eventType, eventDetail</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(eventType,&#123;</span><br><span class="line">        detail:eventDetail</span><br><span class="line">    &#125;);</span><br><span class="line">    target.dispathEvent(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入 JS 内部的事件循环机制！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【变量类型】</title>
    <link href="http://yoursite.com/2019/06/10/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/10/前端进阶深入系列之【变量类型】/</id>
    <published>2019-06-10T12:23:14.364Z</published>
    <updated>2019-06-10T13:42:03.585Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深入探究 javascript 变量类型！</p><a id="more"></a><h3 id="一、变量的分类"><a href="#一、变量的分类" class="headerlink" title="一、变量的分类"></a>一、变量的分类</h3><blockquote><p>在 javascript 中，我们通常使用三个关键字来定义变量：var、let、const。我们从两个角度对这三个变量进行分类：可变性和词法环境。</p></blockquote><h4 id="1、分类一：可变性"><a href="#1、分类一：可变性" class="headerlink" title="1、分类一：可变性"></a>1、分类一：可变性</h4><blockquote><p>可变性表示的是变量一旦声明，后续是否是可变的，分为两组，分别为 {const} 和 {let、var}。</p></blockquote><h6 id="▉-const-特性一："><a href="#▉-const-特性一：" class="headerlink" title="▉ const 特性一："></a>▉ const 特性一：</h6><blockquote><p>const 声明的是静态变量，一旦声明并赋予初始值，就不允许重新赋值，否则 javascript 就会抛出异常。</p></blockquote><h6 id="▉-const-特性二："><a href="#▉-const-特性二：" class="headerlink" title="▉ const 特性二："></a>▉ const 特性二：</h6><blockquote><p>虽然不可以对变量进行赋值，但是可以对 const 声明的对象进行重新修改。</p></blockquote><h6 id="▉-const-特性三："><a href="#▉-const-特性三：" class="headerlink" title="▉ const 特性三："></a>▉ const 特性三：</h6><blockquote><p>用 const 声明的数组也是一样的，不能重新赋值但是可以进行修改。</p></blockquote><h4 id="2、分类二：词法环境（作用域）"><a href="#2、分类二：词法环境（作用域）" class="headerlink" title="2、分类二：词法环境（作用域）"></a>2、分类二：词法环境（作用域）</h4><blockquote><p>按照词法环境进行分类，其实就是按照作用域进行分类，分为两组分别为 {var} 和 {let，const}。</p></blockquote><h6 id="▉-关键词-var"><a href="#▉-关键词-var" class="headerlink" title="▉ 关键词 var"></a>▉ 关键词 var</h6><blockquote><p>该关键词是在距离最近的<strong>函数内部</strong>或<strong>全局的作用域</strong>（变量将挂载到 <code>window</code> 对象上）中定义的（忽略块级作用域）。—— 在块级作用域外可以访问到块级作用域内的变量。</p></blockquote><h6 id="▉-关键词-let-和-const"><a href="#▉-关键词-let-和-const" class="headerlink" title="▉ 关键词 let 和 const"></a>▉ 关键词 let 和 const</h6><blockquote><p>let 和 const 直接在最近的作用域中定义变量（包括块级作用域、函数内、全局作用域）。</p></blockquote><h3 id="二、词法环境中注册标识符"><a href="#二、词法环境中注册标识符" class="headerlink" title="二、词法环境中注册标识符"></a>二、词法环境中注册标识符</h3><blockquote><p>这部分内容是变量提升的真正原理。变量的声明提升至函数的顶部，函数的声明提升至全局代码的顶部。真正的原理是，代码在执行前，先在词法环境中进行了注册。</p></blockquote><h4 id="1、标识符的注册过程"><a href="#1、标识符的注册过程" class="headerlink" title="1、标识符的注册过程"></a>1、标识符的注册过程</h4><blockquote><p>javascript 代码执行是分成两个阶段的，<strong>一但创建新的词法环境，就会执行第一阶段。</strong></p></blockquote><ul><li><p><strong>第一阶段：</strong>javascript 引擎会访问并注册当前词法环境（作用域）中的所有变量和函数。</p></li><li><p><strong>第二阶段：</strong>本阶段的执行主要取决于<strong>变量的类型</strong>（let、var、const）和<strong>环境类型</strong>（全局环境、局部环境、块级作用域）。</p><blockquote><p>1）如果创建的是一个函数环境，那么就创建形参及函数参数的默认值（非函数环境则跳过）。</p><p>2）扫描当前代码进行函数声明（只扫描当前的函数环境内）。如果创建的是全局或函数环境，</p><p>（<strong>注意：</strong>此过程不会扫描<strong>函数表达式</strong>和<strong>箭头函数</strong>）。对于找到的函数声明，将创建该函数，并将标识符绑定到当前环境中相同的标识符上。若已经存在，则将覆盖。</p><p>3）扫描当前代码进行进行变量声明。在函数或全局作用域中，找到当前函数以及其他函数之外 var 声明的变量。并找到其他函数或代码块之外 let 或 const 声明的变量。</p><p>4）在块级作用域中，仅查找当前块中通过 let 或 const 声明的变量。</p><p>5）对于所查找到的变量，若标识符不存在，则标识为 undefined ，否则存储当前的值。</p></blockquote></li></ul><h6 id="▉-函数声明之前调用函数"><a href="#▉-函数声明之前调用函数" class="headerlink" title="▉ 函数声明之前调用函数"></a>▉ 函数声明之前调用函数</h6><blockquote><p>若函数是作为函数声明定义的，则可以在声明之前调用函数。如果以函数表达式或箭头函数定义的，则不可以在声明之前访问函数。</p></blockquote><h6 id="▉-函数的重载"><a href="#▉-函数的重载" class="headerlink" title="▉ 函数的重载"></a>▉ 函数的重载</h6><blockquote><p>函数的重载之所以出现下面这种原因，是直接由标识符的注册导致的，也就是人们所说的变量提升。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun) <span class="comment">// “function”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun) <span class="comment">// “number”</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1、在处理过程中，通过函数声明定义的函数在代码执行之前定义过了，所以 fun 已经有值的。</p><p>2、在处理变量的声明时，当前环境中未声明的变量将会注册为 undefined，因为 fun 早已经注册过了，所以当执行代码执行到 fun 等于 1 时，就会改变。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入探究 javascript 变量类型！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>玩转 ES6 之【Generator生成器】</title>
    <link href="http://yoursite.com/2019/06/09/%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90Generator%E7%94%9F%E6%88%90%E5%99%A8%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/09/玩转 ES6 之【Generator生成器】/</id>
    <published>2019-06-09T11:46:25.468Z</published>
    <updated>2019-06-10T01:30:56.659Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用 ES6 的生成器可以优雅的实现异步操作！</p><a id="more"></a><h3 id="一、生成器函数"><a href="#一、生成器函数" class="headerlink" title="一、生成器函数"></a>一、生成器函数</h3><blockquote><p>1、使用生成器函数可以生成一组值的序列，每个值的生成是基于每次请求的，并不同于标准函数立即生成。</p><p>2、调用生成器不会直接执行，而是通过叫做<strong>迭代器</strong>的对象控制生成器执行。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"3"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> WeaponGenerator())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><h3 id="二、使用迭代器控制生成器"><a href="#二、使用迭代器控制生成器" class="headerlink" title="二、使用迭代器控制生成器"></a>二、使用迭代器控制生成器</h3><h4 id="2-1-迭代器的使用"><a href="#2-1-迭代器的使用" class="headerlink" title="2.1 迭代器的使用"></a>2.1 迭代器的使用</h4><p>1、通过调用生成器返回一个迭代器对象，用来控制生成器的执行。</p><p>2、调用迭代器的 next 方法向生成器请求一个值。</p><p>3、请求的结果返回一个对象，对象中包含一个 value 值和 done 布尔值，告诉我们生成器是否还会生成值。</p><p>4、如果没有可执行的代码，生成器就会返回一个 undefined 值，表示整个生成器已经完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"3"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = WeaponGenerator();</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br></pre></td></tr></table></figure><h4 id="2-2-生成器的状态"><a href="#2-2-生成器的状态" class="headerlink" title="2.2 生成器的状态"></a>2.2 生成器的状态</h4><p>1、每当代码执行到 yield 属性，就会生成一个中间值，返回一个对象。</p><p>2、每当生成一个值后，生成器就会非阻塞的挂起执行，等待下一次值的请求。</p><p>3、再次调用 next 方法，将生成器从挂起状态唤醒，中断执行的生成器从上次离开的位置继续执行。</p><p>4、直到遇到下一个 yield ，生成器挂起。</p><p>5、 当执行到没有可执行代码了，就会返回一个结果对象，value 的值为 undefined , done 的值为 true，生成器执行完成。</p><h4 id="2-3-将执行权交给下一个生成器"><a href="#2-3-将执行权交给下一个生成器" class="headerlink" title="2.3 将执行权交给下一个生成器"></a>2.3 将执行权交给下一个生成器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"4"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"5"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"6"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"3"</span>;</span><br><span class="line">    <span class="keyword">yield</span> *XiaoLuGenerator(); <span class="comment">// 将执行权交给另一个生成器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> WeaponGenerator())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、生成器的应用"><a href="#三、生成器的应用" class="headerlink" title="三、生成器的应用"></a>三、生成器的应用</h3><h4 id="1、为对象赋唯一-ID-标识"><a href="#1、为对象赋唯一-ID-标识" class="headerlink" title="1、为对象赋唯一 ID 标识"></a>1、为对象赋唯一 ID 标识</h4><blockquote><p>当创建某些对象时，需要为对象赋一个唯一的 ID 值。通常使用一个全局计时器变量，但是这种写法很容易使代码变的混乱。所以使用生成器可以实现这个功能。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span>* <span class="title">IdGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">         <span class="keyword">yield</span> ++id;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> idIterator = IdGenerator();</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj4 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br><span class="line"><span class="keyword">const</span> obj5 = &#123; <span class="attr">id</span>: idIterator.next().value &#125;</span><br></pre></td></tr></table></figure><h4 id="2、遍历-DOM-树"><a href="#2、遍历-DOM-树" class="headerlink" title="2、遍历 DOM 树"></a>2、遍历 DOM 树</h4><blockquote><p>通常遍历 DOM 树最简单的方法是使用递归，但是使用生成器也可以进行遍历代码。很多情况下，使用迭代器比使用递归更要自然。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"xiaolu"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Spam<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">DomTraversal</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1、打印当前元素</span></span><br><span class="line">    <span class="keyword">yield</span> element;</span><br><span class="line">    <span class="comment">// 2、寻找当前元素的子元素</span></span><br><span class="line">    element = element.firstElementChild;</span><br><span class="line">    <span class="comment">// 3、循环遍历子元素（子元素可能多个）</span></span><br><span class="line">    <span class="keyword">while</span> (element) &#123;</span><br><span class="line">        <span class="comment">// 4、子元素可能还有子元素（递归）</span></span><br><span class="line">        <span class="keyword">yield</span>* DomTraversal(element);</span><br><span class="line">        <span class="comment">// 5、遍历兄弟元素的子元素</span></span><br><span class="line">        element = element.nextElementSibling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subTree = <span class="built_in">document</span>.getElementById(<span class="string">"xiaolu"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> node <span class="keyword">of</span> DomTraversal(subTree))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、生成器数据交互"><a href="#四、生成器数据交互" class="headerlink" title="四、生成器数据交互"></a>四、生成器数据交互</h3><blockquote><p>生成器中可以进行双向通信，通过 yield 可以返回值，也可以通过 next 传入值。</p><p><strong>注意：</strong>如果没有等待的 yield 表达式，也就是没有值可以应用，所以第一次的 yield 无法传值。</p></blockquote><h4 id="1、构造函数的初始化"><a href="#1、构造函数的初始化" class="headerlink" title="1、构造函数的初始化"></a>1、构造函数的初始化</h4><blockquote><p>生成器可以像其他函数一样接受标准的参数，并在生成器内使用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="keyword">yield</span> (<span class="string">"4"</span>+action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = XiaoLuGenerator(<span class="string">"3333"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br></pre></td></tr></table></figure><h4 id="2、next-方法传递值"><a href="#2、next-方法传递值" class="headerlink" title="2、next 方法传递值"></a>2、next 方法传递值</h4><blockquote><p>next 传递的参数是作为上一执行的结果返回。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = <span class="keyword">yield</span> (<span class="string">"4"</span>+action);</span><br><span class="line">    <span class="keyword">yield</span> (<span class="string">"next"</span> + n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = XiaoLuGenerator(<span class="string">"3333"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next());</span><br><span class="line"><span class="built_in">console</span>.log(weapon.next(<span class="string">"嘿嘿"</span>));</span><br><span class="line"><span class="comment">// &#123;value: "43333", done: false&#125;</span></span><br><span class="line"><span class="comment">// &#123;value: "next嘿嘿", done: false&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3、抛出异常"><a href="#3、抛出异常" class="headerlink" title="3、抛出异常"></a>3、抛出异常</h4><blockquote><p>生成器除了有一个 next 方法，还有一个 throw 方法来抛出异常，当生成器内部发生错误时，我们可以通过抛出异常来抛出错误。抛出的错误就会被 try-catch 捕获。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">XiaoLuGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> n = <span class="keyword">yield</span> <span class="string">"4"</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"抛出错误！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weapon = XiaoLuGenerator(<span class="string">"3333"</span>);</span><br><span class="line">weapon.next()</span><br><span class="line">weapon.throw(<span class="string">"错误!"</span>)</span><br></pre></td></tr></table></figure><h3 id="五、生成器的内部结构"><a href="#五、生成器的内部结构" class="headerlink" title="五、生成器的内部结构"></a>五、生成器的内部结构</h3><blockquote><p>生成器更像是一个状态运动的状态机。</p></blockquote><ul><li>挂起开始状态——创建一个生成器处于未执行状态。</li><li>执行状态——生成器的执行状态。</li><li>挂起让渡状态——生成器执行遇到第一个 yield 表达式。</li><li>完成状态——代码执行到 return 全部代码就会进入全部状态。</li></ul><h4 id="1、执行上下文跟踪生成器函数"><a href="#1、执行上下文跟踪生成器函数" class="headerlink" title="1、执行上下文跟踪生成器函数"></a>1、执行上下文跟踪生成器函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">WeaponGenerator</span>(<span class="params">action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"1"</span>+action;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"3"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Iterator = WeaponGenerator(<span class="string">"xiaolu"</span>);</span><br><span class="line"><span class="keyword">let</span> result1 = Iterator.next()</span><br><span class="line"><span class="keyword">let</span> result2 = Iterator.next()</span><br><span class="line"><span class="keyword">let</span> result3 = Iterator.next()</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>① 在调用生成器之前的状态——只有全局执行上下文，全局环境中除了生成器变量的引用，其他的变量都为 undefined。</p><p>② 调用生成器并没有执行函数，而是返回一个 Iterator 迭代器对象并指向当前生成器的上下文。</p><p>③ 一般函数调用完成上下文弹出栈，然后被摧毁。当生成器的函数调用完成之后，当前生成器的上下文出栈，但是在全局的迭代器对象还与保持着与生成器执行上下文引用，且生成器的词法环境还存在。</p><p>④ 执行 next 方法，一般的函数会重新创建执行上下文。而生成器会重新激活对应的上下文并推入栈中（这也是为什么标准函数重复调用时，重新从头执行的原因所在。与标准函数相比较，生成器暂时会挂起并将来恢复）。</p><p>⑤ 当遇到 yield 关键字的时候，生成器上下文出栈，但是迭代器还是保持引用，处于非阻塞暂时挂起的状态。</p><p>⑥ 如果遇到 next 指向方法继续在原位置继续 执行，直到遇到 return 语句，并返回值结束生成器的执行，生成器进入结束状态。</p><table><thead><tr><th style="text-align:center">执行上下文栈</th><th style="text-align:center">当前环境</th><th>变量</th></tr></thead><tbody><tr><td style="text-align:center">全局执行上下文</td><td style="text-align:center">全局环境</td><td>WeaponGenerator:function*(){}<br>Iterator: undefined<br>result1: undefined<br>result2: undefined<br>result3: undefined</td></tr></tbody></table><p>从未执行状态变为执行状态：</p><table><thead><tr><th style="text-align:center">执行上下文栈</th><th style="text-align:center">当前环境</th><th>变量</th></tr></thead><tbody><tr><td style="text-align:center">全局执行上下文</td><td style="text-align:center">全局环境</td><td>WeaponGenerator:function*(){}<br>Iterator: Iterator<br>result1: undefined<br>result2: undefined<br>result3: undefined</td></tr><tr><td style="text-align:center">WeaponGenerator <br>上下文</td><td style="text-align:center">WeaponGenerator<br>环境</td><td>action: xiaolu</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 ES6 的生成器可以优雅的实现异步操作！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/ES6/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【闭包和作用域】</title>
    <link href="http://yoursite.com/2019/06/09/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E9%97%AD%E5%8C%85%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/09/前端进阶深入系列之【闭包和作用域】/</id>
    <published>2019-06-09T00:55:28.201Z</published>
    <updated>2019-06-12T13:05:51.300Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深入闭包以及闭包的应用！</p><a id="more"></a><h3 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h3><p><strong>1、作用域：</strong>限定变量和函数的可用性的范围叫做<strong>作用域</strong>。</p><p><strong>2、作用域链：</strong>保证对<strong>执行函数</strong>有权访问的所有变量和函数的<strong>有序访问</strong>。</p><h3 id="二、理解闭包？"><a href="#二、理解闭包？" class="headerlink" title="二、理解闭包？"></a>二、理解闭包？</h3><h4 id="1、什么是闭包？"><a href="#1、什么是闭包？" class="headerlink" title="1、什么是闭包？"></a>1、什么是闭包？</h4><blockquote><p>闭包是在函数内可以访问并操作函数外部的变量。只要变量或函数存在于声明的函数的作用域内，闭包就可以使用函数访问到这些变量。</p></blockquote><h4 id="2、如何理解闭包？"><a href="#2、如何理解闭包？" class="headerlink" title="2、如何理解闭包？"></a>2、如何理解闭包？</h4><blockquote><p> 在外部函数声明内部函数的时候，就创建了一个闭包。闭包包含了当前声明的函数作用域中所有的函数和变量。只要声明的函数存在，当前闭包就会存在。</p></blockquote><h6 id="▉-注意一："><a href="#▉-注意一：" class="headerlink" title="▉ 注意一："></a>▉ 注意一：</h6><blockquote><p>每一个通过闭包访问变量的函数都具有一个作用域链，作用域链包含闭包的全部信息。</p></blockquote><h6 id="▉-注意二："><a href="#▉-注意二：" class="headerlink" title="▉ 注意二："></a>▉ 注意二：</h6><blockquote><p>闭包不能过度使用，因为闭包所有的变量都存在内存中，直到不会被使用到（页面卸载）时才会被垃圾回收，多度的使用闭包会影响性能。</p></blockquote><h3 id="三、闭包的应用"><a href="#三、闭包的应用" class="headerlink" title="三、闭包的应用"></a>三、闭包的应用</h3><h4 id="1、应用一：封装私有变量"><a href="#1、应用一：封装私有变量" class="headerlink" title="1、应用一：封装私有变量"></a>1、应用一：封装私有变量</h4><blockquote><p>由于原生的 JavaScript 不支持私有变量，所以只能通过闭包的方式来实现。</p></blockquote><ul><li><p>在构造函数中的外部是无法访问到函数内部的变量的，只能通过闭包的形式访问内部的变量。</p></li><li><p>通过 new 的方式创建一个新对象，改变函数内 this 的指向，为实例对象添加新属性，返回一个新对象，通过对象的方式可以访问到构造函数内部的属性。</p></li><li>通过闭包内部的方法获取到私有变量的值，但是不能直接进行访问私有变量，有效的阻止了对变量不可控的修改。</li></ul><h4 id="2、应用二：回调函数"><a href="#2、应用二：回调函数" class="headerlink" title="2、应用二：回调函数"></a>2、应用二：回调函数</h4><blockquote><p>由于处理回调函数是一种异步的调用函数，需要在回调函数中频繁的访问外部的数据，所以用闭包来解决这个问题。</p></blockquote><ul><li><p>闭包解决问题回调可以有效的防止污染全局变量。当不使用闭包的时候，所有的变量全部都在全局作用域下，多个异步操作同时对变量进行读或取，那么就会发生冲突，就污染到了全局的作用域。</p></li><li><p>如果没有闭包，一次性做许多事情就会变得非常的困难，例如：事件绑定、动画甚至服务器请求。</p></li><li><p>闭包不是存在于创建的那一时刻，而是一个真实状态的封装，只要闭包存在，就可以对变量就行修改。</p></li></ul><h3 id="四、闭包与作用域的关系"><a href="#四、闭包与作用域的关系" class="headerlink" title="四、闭包与作用域的关系"></a>四、闭包与作用域的关系</h3><blockquote><p>闭包和作用域是强相关的，JavaScript 的作用域有一定的规则以及 javaScript 的内部运行机制。</p><p>1）javascript 引擎是如何跟踪函数执行又回到函数的位置？</p></blockquote><h4 id="1、javaScript-的执行上下文跟踪函数"><a href="#1、javaScript-的执行上下文跟踪函数" class="headerlink" title="1、javaScript 的执行上下文跟踪函数"></a>1、javaScript 的执行上下文跟踪函数</h4><blockquote><p>因为 JavaScript 的运行机制是基于单线程的，某个特定的时刻只能执行特定的代码，所以要通过执行上下文栈来确定函数的执行顺序。</p></blockquote><h6 id="▉-基本概念"><a href="#▉-基本概念" class="headerlink" title="▉ 基本概念"></a>▉ 基本概念</h6><ul><li><p>js 代码类型分为两种：<strong>全局代码</strong>，在所有函数的外部定义；<strong>局部代码</strong>，在函数的内部定义。</p></li><li><p>每个函数的执行都会在一个特定的执行上下文中。<strong>全局执行上下文</strong>只有一个（每个页面只有一个）；而<strong>函数执行上下文</strong>是每当执行一个函数时，就会先创建一个函数执行上下文。</p></li><li><strong>注意：</strong>this 访问函数上下文和函数执行上下文是两个不同的概念。</li></ul><h6 id="▉-跟踪过程"><a href="#▉-跟踪过程" class="headerlink" title="▉ 跟踪过程"></a>▉ 跟踪过程</h6><blockquote><p>1）程序开始运行只有执行上下文栈中只有全局执行上下文。</p><p>2）当调用函数的时候，当前函数就会创建一个新的执行上下文入栈，就说明当前的函数正在执行。</p><p>3）如果当前的函数执行完毕，所创建的执行上下文就会出栈，将控制权教给上一级。</p><p>4）直到所有有执行上下文出栈，全局执行上下文恢复执行。</p></blockquote><h4 id="2、javascript-引擎跟踪词法环境"><a href="#2、javascript-引擎跟踪词法环境" class="headerlink" title="2、javascript 引擎跟踪词法环境"></a>2、javascript 引擎跟踪词法环境</h4><blockquote><p>词法环境是每个（函数）执行上下文中所有变量和函数存储的环境。词法环境是 JavaScript 内部的实现机制，通常称为作用域。</p></blockquote><h6 id="▉-词法环境的作用"><a href="#▉-词法环境的作用" class="headerlink" title="▉ 词法环境的作用"></a>▉ 词法环境的作用</h6><blockquote><p>词法环境主要是 JavaScript 引擎用来<strong>如何跟踪变量</strong>以及如果<strong>判断变量的可访问性</strong>。</p></blockquote><h6 id="▉-关联性"><a href="#▉-关联性" class="headerlink" title="▉ 关联性"></a>▉ 关联性</h6><blockquote><p>词法环境与 JavaScript 的代码就够进行关联，如：函数、代码片段等是相互关联的。</p></blockquote><h4 id="2-1-代码嵌套"><a href="#2-1-代码嵌套" class="headerlink" title="2.1 代码嵌套"></a>2.1 代码嵌套</h4><blockquote><p>词法环境主要与代码嵌套（代码嵌套的结构）相关联的，每执行代码，代码结构就会获取与之相关联的词法环境，用来确保内部环境可访问外部环境。</p></blockquote><h4 id="2-2-代码嵌套与词法环境的关系"><a href="#2-2-代码嵌套与词法环境的关系" class="headerlink" title="2.2 代码嵌套与词法环境的关系"></a>2.2 代码嵌套与词法环境的关系</h4><blockquote><p>词法环境查询变量时，根据执行上下文对应的词法环境由内而外依次进行查找，直到查找到最外层的全局作用域。</p></blockquote><h6 id="▉-函数-执行上下文-词法环境的关系"><a href="#▉-函数-执行上下文-词法环境的关系" class="headerlink" title="▉ 函数 - 执行上下文 - 词法环境的关系"></a>▉ 函数 - 执行上下文 - 词法环境的关系</h6><p>1、每个执行上下文都对应一个词法环境（函数的局部作用域）；</p><p>2、每个局部函数中的内部属性 [[Environment]] 与创建的执行上下文相关联（所在当前函数的执行上下文）；</p><h3 id="五、闭包的工作原理"><a href="#五、闭包的工作原理" class="headerlink" title="五、闭包的工作原理"></a>五、闭包的工作原理</h3><h4 id="1、闭包模拟私有变量"><a href="#1、闭包模拟私有变量" class="headerlink" title="1、闭包模拟私有变量"></a>1、闭包模拟私有变量</h4><blockquote><p>闭包模拟 js 的私有变量时，会 new 一个实例对象，实例对象就会通过闭包获取或改变构造函数内的局部变量模拟面向对象。每次调用构造函数，都会创建一个新的词法环境，该词法环境会保持着构造函数内部的局部变量。</p></blockquote><h6 id="▉-内部实现步骤"><a href="#▉-内部实现步骤" class="headerlink" title="▉ 内部实现步骤"></a>▉ 内部实现步骤</h6><blockquote><p>1）new 一个实例对象。</p><p>2）进入构造函数，为<strong>构造函数创建一个新的词法环境</strong>，它始终保持着对局部变量的引用。</p><p>3）然后为空对象添加两个函数，这两个函数 [[Envrionment]] 都保持着对<strong>新创建函数的词法环境</strong>的引用，返回新对象。、</p><p>4）当调用对象的函数时，就会创建新的执行上下文推入执行栈中，这回引起创建的新的词法环境（内部函数）。</p><p>5）js 引擎会检查当前函数的词法环境中有没有想要的变量，如果没有，则会到外部变量（构造函数的词法环境）中去查找，查找到了就返回。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入闭包以及闭包的应用！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【异步编程】</title>
    <link href="http://yoursite.com/2019/06/05/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/05/前端进阶深入系列之【异步编程】/</id>
    <published>2019-06-05T09:00:41.299Z</published>
    <updated>2019-06-16T01:22:17.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JavaScript 所有的异步编程知识点都在这里！</p><a id="more"></a><h3 id="一、为什么-js-会有异步编程？"><a href="#一、为什么-js-会有异步编程？" class="headerlink" title="一、为什么 js 会有异步编程？"></a>一、为什么 js 会有异步编程？</h3><blockquote><p><strong>原因：</strong>由于  <code>JavaScript</code> 语言的执行环境是“单线程”的，一次只能执行一个任务，多余的任务需要在后边排队等候。</p><p><strong>发展：</strong>异步编程的语法目标，就是怎样让它更像同步编程。</p></blockquote><h4 id="1、单线程的优点"><a href="#1、单线程的优点" class="headerlink" title="1、单线程的优点"></a>1、单线程的优点</h4><blockquote><p>JavaScript 单线程的优点在于实现起来简单，环境相对单纯。</p></blockquote><h4 id="2、单线程的缺点"><a href="#2、单线程的缺点" class="headerlink" title="2、单线程的缺点"></a>2、单线程的缺点</h4><blockquote><p>其中一个任务一旦时间耗时很长，后边的任务必须排队等候，会导致整个程序的执行，会出现浏览器无响应，出现卡死状态，其他任务无法执行。</p></blockquote><h4 id="3、新模式（同步-异步）"><a href="#3、新模式（同步-异步）" class="headerlink" title="3、新模式（同步+异步）"></a>3、新模式（同步+异步）</h4><blockquote><p>为了弥补上边的缺点，JavaScript 决定将执行模式分为两种：<strong>同步（Synchronous）和异步（Asynchronous）。</strong></p></blockquote><h6 id="▉-同步模式"><a href="#▉-同步模式" class="headerlink" title="▉ 同步模式"></a>▉ 同步模式</h6><blockquote><p>同步的模式为许多任务需要排队、顺序处理。</p></blockquote><h6 id="▉-异步模式"><a href="#▉-异步模式" class="headerlink" title="▉ 异步模式"></a>▉ 异步模式</h6><p>1、每个任务有一个或多个回调函数（callback）「，每当任务执行完毕，都会执行任务的回调函数，任务的开始和结束互不影响。</p><p>2、在浏览器端，耗时的操作都应该异步执行，避免浏览器失去响应（如：AJAX）。</p><h3 id="二、四种异步编程模式"><a href="#二、四种异步编程模式" class="headerlink" title="二、四种异步编程模式"></a>二、四种异步编程模式</h3><h4 id="1、回调函数"><a href="#1、回调函数" class="headerlink" title="1、回调函数"></a>1、回调函数</h4><blockquote><p>将一个函数作为另一个函数的参数传入，传入的函数就是回调函数，当前函数执行完之后，就会调用回调函数。</p></blockquote><h6 id="▉-优点"><a href="#▉-优点" class="headerlink" title="▉ 优点"></a>▉ 优点</h6><blockquote><p>简单、容易理解和部署。</p></blockquote><h6 id="▉-缺点"><a href="#▉-缺点" class="headerlink" title="▉ 缺点"></a>▉ 缺点</h6><p><strong>1、不利于代码的阅读和维护，各部分之间的耦合度高，流程混乱，每个任务只能指定一个回调函数。</strong></p><p><strong>2、不能使用 <code>try-catch</code> 捕获错误。</strong></p><blockquote><p>这跟浏览器的执行机制相关，异步任务由 EventLoop 加入任务队列，取出并入栈执行，当异步任务执行的时候，捕获异常的函数已经在栈内退出了，所以异常无法被捕获。</p></blockquote><p><strong>3、不能直接 <code>return</code>。</strong></p><p><strong>4、容易产生回调地狱问题。</strong></p><ul><li><strong>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身。</strong></li><li><strong>嵌套函数一多，就很难处理错误</strong></li></ul><blockquote><p>回调地狱问题就是我们想要通过异步请求得到数据做某些事情的话，需要将代码写到回调中去，如果涉及到多个这样的异步操作，就会形成回调地狱问题。</p></blockquote><h4 id="2、事件监听"><a href="#2、事件监听" class="headerlink" title="2、事件监听"></a>2、事件监听</h4><blockquote><p>还可以使用<strong>事件驱动模式</strong>，任务的执行不取决于代码的顺序，而是取决于某个事件是否发生。</p></blockquote><h6 id="▉-思路"><a href="#▉-思路" class="headerlink" title="▉ 思路"></a>▉ 思路</h6><blockquote><p>为某一程序绑定一个事件，当程序运行到此时，就会触发事件的执行。</p></blockquote><h6 id="▉-优点-1"><a href="#▉-优点-1" class="headerlink" title="▉ 优点"></a>▉ 优点</h6><blockquote><p>容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，可以去耦合，实现模块化。</p></blockquote><h6 id="▉-缺点-1"><a href="#▉-缺点-1" class="headerlink" title="▉ 缺点"></a>▉ 缺点</h6><blockquote><p>整个程序就会变成事件驱动型，运行的流程会变得不清晰。</p></blockquote><h4 id="3、Generator"><a href="#3、Generator" class="headerlink" title="3、Generator"></a>3、Generator</h4><p><a href="[http://luxiangqiang.xn--6qq986b3xl/2019/06/09/%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90Generator%E7%94%9F%E6%88%90%E5%99%A8%E3%80%91/](http://luxiangqiang.xn--6qq986b3xl/2019/06/09/玩转 ES6 之[Generator生成器]/">玩转ES6之Generator</a>)</p><h4 id="4、promise"><a href="#4、promise" class="headerlink" title="4、promise"></a>4、promise</h4><p><a href="[http://luxiangqiang.xn--6qq986b3xl/2019/03/21/%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90promise%E5%AF%B9%E8%B1%A1%E3%80%91/](http://luxiangqiang.xn--6qq986b3xl/2019/03/21/玩转 ES6 之[promise对象]/">玩转ES6之Promise</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 所有的异步编程知识点都在这里！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【Event Loop】</title>
    <link href="http://yoursite.com/2019/06/05/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E4%B9%8B%E3%80%90Event%20Loop%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/05/前端面试之道之【Event Loop】/</id>
    <published>2019-06-05T06:52:28.237Z</published>
    <updated>2019-06-24T00:56:10.299Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>了解前端事件循环！</p><a id="more"></a><h4 id="一、进程与线程区别？"><a href="#一、进程与线程区别？" class="headerlink" title="一、进程与线程区别？"></a>一、进程与线程区别？</h4><ul><li><strong>进程：</strong>进程是 CPU <strong>资源分配</strong>的最小单位，系统会为每个进程进行分配内存空间。比如一个 Tab 页面就是一个进程。</li><li><strong>线程：</strong>线程是 CPU <strong>调度</strong>的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程由多个线程组成，比如：渲染线程、Js 引擎线程、HTTP 请求线程等）。</li></ul><h4 id="二、JS-单线程带来的好处？"><a href="#二、JS-单线程带来的好处？" class="headerlink" title="二、JS 单线程带来的好处？"></a>二、JS 单线程带来的好处？</h4><p>1、对于 js 引擎线程和渲染线程来说，在 js 运行的时候可能会阻止 UI 渲染，可以得出两个线程是互斥的。</p><p>2、如果在 js 修改 DOM 的时候，UI 线程还在渲染，会导致不能安全的渲染 UI。</p><p>3、JS 单线程的好处可以达到节省内存空间，节约上下文切换时间，没有锁的问题。</p><h4 id="三、什么是执行栈？"><a href="#三、什么是执行栈？" class="headerlink" title="三、什么是执行栈？"></a>三、什么是执行栈？</h4><blockquote><p>执行栈就是一个存储函数调用的栈结构，具有先进后出的特点。根据这个特定，函数之间的调用会遵循后执行的函数先弹出栈。</p></blockquote><h4 id="四、异步代码执行顺序？"><a href="#四、异步代码执行顺序？" class="headerlink" title="四、异步代码执行顺序？"></a>四、异步代码执行顺序？</h4><p>1、我们知道 js 代码的调用是在执行栈中的同步执行的，如果遇到了异步代码时，此时就将异步代码挂起加入到 <code>Task</code> 的队列中。</p><p>2、当执行栈为空时，<code>Event Loop</code> 就会从 Task 队列中拿出需要执行的异步代码放入到执行栈中，我认为本质上 js 异步还算是一种同步的行为。</p><p>3、不同的任务源分配到不同的 <code>Task</code> 队列中，任务源分为微任务（<code>microtask</code>）和宏任务（<code>macrotask</code>），在 ES6 规范中分别叫 <code>jobs，task</code>。</p><h4 id="五、说下一-js-中的-Event-Loop-？"><a href="#五、说下一-js-中的-Event-Loop-？" class="headerlink" title="五、说下一 js 中的 Event Loop ？"></a>五、说下一 js 中的 Event Loop ？</h4><p><a href="[http://luxiangqiang.xn--6qq986b3xl/2019/06/14/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E3%80%91/](http://luxiangqiang.xn--6qq986b3xl/2019/06/14/前端进阶深入系列之[事件循环]/">JS 的事件循环</a>)</p><h4 id="六、Node-中的事件循环"><a href="#六、Node-中的事件循环" class="headerlink" title="六、Node 中的事件循环"></a>六、Node 中的事件循环</h4><blockquote><p>Node.js 是基于事件驱动型、非阻塞的 IO 模型。</p><p>1）所谓的事件驱动模型，当服务器接受到请求时，将其关闭进行处理，然后去接受下一个请求。当这个请求执行完成，就会被放到消息队列，当达到队列头部的时候，就会将结果返回给用户。</p><p>3）所谓的非阻塞 IO 操作，因为 webserver 一直接受请求而不等待任何读写操作。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解前端事件循环！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶深入系列之【浏览器的运行机制】</title>
    <link href="http://yoursite.com/2019/06/02/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E3%80%91/"/>
    <id>http://yoursite.com/2019/06/02/前端进阶深入系列之【浏览器的运行机制】/</id>
    <published>2019-06-02T06:02:01.187Z</published>
    <updated>2019-06-05T06:51:52.376Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深入浅出 JS 的运行机制！</p><a id="more"></a><h3 id="一、区分进程和线程"><a href="#一、区分进程和线程" class="headerlink" title="一、区分进程和线程"></a>一、区分进程和线程</h3><blockquote><p>CPU 的作用是主要是解释计算机的指令以及处理计算机软件中的数据。</p></blockquote><ul><li><p><strong>进程：</strong>进程是 CPU <strong>资源分配</strong>的最小单位，系统会为每个进行分配内存空间。</p></li><li><p><strong>线程：</strong>线程是 CPU <strong>调度</strong>的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程由多个线程组成）。</p></li></ul><h3 id="二、浏览器是多进程的"><a href="#二、浏览器是多进程的" class="headerlink" title="二、浏览器是多进程的"></a>二、浏览器是多进程的</h3><blockquote><p>1、浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）。</p><p>2、浏览器是多进程的，每打开一个 Tab 页，相当于创建了一个独立的浏览器进程。</p><p>3、浏览器有时可以将多个进程合并，比如打开多个空白页，将这些空白页合成一个进程。</p></blockquote><h4 id="1、浏览器有哪些进程？"><a href="#1、浏览器有哪些进程？" class="headerlink" title="1、浏览器有哪些进程？"></a>1、浏览器有哪些进程？</h4><ul><li><p><strong>Browser 进程：</strong></p><blockquote><p>浏览器的主进程（负责协调、主控），只有一个</p></blockquote><ul><li>负责浏览器界面显示，与用户交互。如前进，后退等；</li><li>负责各个页面的管理，创建和销毁其他进程；</li><li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上；</li><li>网络资源的管理，下载等</li></ul></li><li><p><strong>第三方插件进程：</strong></p><blockquote><p>每种类型的插件对应一个进程，仅当使用该插件时才创建。</p></blockquote></li><li><p><strong>GPU 进程：</strong></p><blockquote><p>用于 3D 绘制等；</p></blockquote></li><li><p><strong>浏览器渲染进程（浏览器内核）：</strong></p><blockquote><p>默认每个Tab页面一个进程，互不影响。</p></blockquote><ul><li>页面渲染，脚本执行，事件处理等</li></ul></li></ul><h4 id="2、浏览器多进程的优势？"><a href="#2、浏览器多进程的优势？" class="headerlink" title="2、浏览器多进程的优势？"></a>2、浏览器多进程的优势？</h4><blockquote><p>多进程的浏览器资源消耗有点大，难道空间换时间思想。<strong>如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；</strong></p></blockquote><ul><li>避免单个页面崩溃影响整个浏览器；</li><li>避免第三方插件崩溃影响整个浏览器；</li><li>多进程利用多核优势；</li><li>……</li></ul><h4 id="3、重点：浏览器的内核（渲染进程）"><a href="#3、重点：浏览器的内核（渲染进程）" class="headerlink" title="3、重点：浏览器的内核（渲染进程）"></a>3、重点：浏览器的内核（渲染进程）</h4><blockquote><p>前端浏览器最重要的点就是<strong>渲染进程</strong>，而且渲染进程是是多线程的。页面的渲染、js 的执行、时间的想都会在这个进程内进行。</p></blockquote><p>渲染进程包括哪些线程：</p><h5 id="①-GUI-渲染线程"><a href="#①-GUI-渲染线程" class="headerlink" title="① GUI 渲染线程"></a>① GUI 渲染线程</h5><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。</li><li>GUI渲染线程与JS引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</li></ul><h5 id="②-JS-引擎线程"><a href="#②-JS-引擎线程" class="headerlink" title="② JS 引擎线程"></a>② JS 引擎线程</h5><ul><li>也称为 JS 内核，负责处理 Javascript 脚本程序（V8 引擎）。</li><li>JS 引擎线程负责解析 Javascript 脚本，运行代码。</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。</li><li>GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><h5 id="③-事件触发线程"><a href="#③-事件触发线程" class="headerlink" title="③ 事件触发线程"></a>③ 事件触发线程</h5><ul><li>属于浏览器的线程而不是 js 引擎，用来控制事件循环。</li><li>当 JS 引擎执行代码块如 setTimeOut 时，会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。</li><li>由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。</li></ul><h5 id="④-定时触发器线程"><a href="#④-定时触发器线程" class="headerlink" title="④ 定时触发器线程"></a>④ 定时触发器线程</h5><ul><li><code>setInterval</code>与<code>setTimeout</code>所在线程。</li><li>浏览器定时计数器并不是由 JavaScript 引擎计数的（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）。</li><li>通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）。</li><li>W3C在HTML标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</li></ul><h5 id="⑤-异步-http-请求线程"><a href="#⑤-异步-http-请求线程" class="headerlink" title="⑤ 异步 http 请求线程"></a>⑤ 异步 http 请求线程</h5><ul><li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入浅出 JS 的运行机制！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="前端深入系列" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>浏览器如何工作的之【工作流程】</title>
    <link href="http://yoursite.com/2019/05/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B9%8B%E3%80%90%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/22/浏览器是如何工作的之【工作流程】/</id>
    <published>2019-05-22T09:09:59.814Z</published>
    <updated>2019-06-03T12:28:49.996Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浏览器是如何工作的？</p><a id="more"></a><p>[TOC]</p><h2 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="headerlink" title="浏览器的工作原理"></a>浏览器的工作原理</h2><h3 id="一、整个浏览器的工作流程"><a href="#一、整个浏览器的工作流程" class="headerlink" title="一、整个浏览器的工作流程"></a>一、整个浏览器的工作流程</h3><blockquote><p>整个过程都是流式处理，同步进行。</p></blockquote><p>1、DNS 查询。</p><p>2、浏览器通过 HTTP 请求服务器。（HTTP 请求的过程是怎么样的？）</p><p>3、构建 DOM 树。（解析 HTML 代码，构建 DOM 树）</p><p>4、计算 CSS属性。（如何将 CSS 属性挂载在 DOM 树）</p><p>5、排版 。（浏览器确定每个元素的位置）</p><p>6、渲染 。（模型变成位图的过程，将在内存每个元素渲染成图形）</p><p>7、合成 。</p><p>8、绘制。（位图绘制到图像上）</p><h3 id="二、DNS-查询"><a href="#二、DNS-查询" class="headerlink" title="二、DNS 查询"></a>二、DNS 查询</h3><blockquote><p>DNS 查询主要是通过访问的域名查询出它的 IP 地址。</p></blockquote><h4 id="2-1-查询内容"><a href="#2-1-查询内容" class="headerlink" title="2.1 查询内容"></a>2.1 查询内容</h4><p>通过 DNS 查询工具得出的一下六段内容:</p><p>1、第一段：查询参数和统计。</p><p>2、第二段：查询内容。</p><p>3、第三段：DNS服务器的答复。</p><blockquote><p>显示 A (adress) 记录，即域名对应的所有 IP 地址。<code>math.stackexchange.com</code>有四个<code>A</code>记录，即四个 IP 地址。<code>600</code>是 TTL 值（Time to live 的缩写），表示缓存时间，即 600 秒之内不用重新查询。</p></blockquote><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061504.png" alt="img"></p><p>4、第四段：显示域名的 NS 记录（Name Server），即哪些服务器负责管理该域名的 DNS 记录。</p><blockquote><p><code>stackexchange.com</code>共有四条 NS 记录，即四个域名服务器，向其中任一台查询就能知道<code>math.stackexchange.com</code> 的 IP 地址是什么。</p></blockquote><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061505.png" alt="img"></p><p>5、第五段：管理域名的服务器的 IP 地址跟随着返回。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016061506.png" alt="img"></p><p>6、第六段：DNS 服务器的一些传输信息。</p><h4 id="2-2-DNS-服务器"><a href="#2-2-DNS-服务器" class="headerlink" title="2.2 DNS 服务器"></a>2.2 DNS 服务器</h4><p>1、本机知道 DNS 服务器的 IP 地址，通过请求 DNS 服务器才可以查询到该域名的 IP 地址。</p><p>2、DNS 服务器的 IP 地址，有可能是动态的，每次上网时由网关分配，这叫做 <strong>DHCP 机制</strong>；也有可能是事先指定的固定地址</p><h4 id="2-3-域名的层级"><a href="#2-3-域名的层级" class="headerlink" title="2.3 域名的层级"></a>2.3 域名的层级</h4><blockquote><p>DNS 服务器通过<strong>分级查询</strong>得到每个域名的 IP 地址。</p></blockquote><h6 id="▉-域名的层级结构"><a href="#▉-域名的层级结构" class="headerlink" title="▉ 域名的层级结构"></a>▉ 域名的层级结构</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主机名.次级域名.顶级域名.根域名</span><br></pre></td></tr></table></figure><ul><li>根域名 (root) ：所有域名是一样的。</li><li>顶级域名（.com .net）。</li><li>次级域名 ：用户可以注册的。 </li><li>主机名（host）：如 www，又称三级域名。用户在自己域里为服务器任意分配的名称。</li></ul><h4 id="2-4-根域名服务器"><a href="#2-4-根域名服务器" class="headerlink" title="2.4 根域名服务器"></a>2.4 根域名服务器</h4><blockquote><p> 每一集域名都有自己的 NS 记录，NS 记录是指向该级域名服务器，该服务器知道下一级域名的各种记录。</p></blockquote><h6 id="▉-分级查询"><a href="#▉-分级查询" class="headerlink" title="▉ 分级查询"></a>▉ 分级查询</h6><blockquote><p>从根域名开始查询每一级的 NS 记录，直到查到最终的 IP 地址。”根域名服务器”的 NS 记录和IP地址一般是不会变化的，它是<strong>内置在 DNS 服务器里面的</strong>。</p></blockquote><ul><li><p>从”根域名服务器”查到”顶级域名服务器”的 NS 记录和 A 记录（IP 地址）。</p></li><li><p>从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（IP 地址）。</p></li><li><p>从”次级域名服务器”查出”主机名”的 IP 地址。</p></li></ul><h4 id="2-5-DNS-整个查询过程"><a href="#2-5-DNS-整个查询过程" class="headerlink" title="2.5 DNS 整个查询过程"></a>2.5 DNS 整个查询过程</h4><p>1、本机通过本地设置的 DNS 服务器请求域名的 IP 地址。</p><p>2、DNS 服务器开始进行分层查询。</p><p>3、先是通过内置的根域名（.root）服务器查到顶级域名服务器” 的 NS 记录和 A 记录。</p><p>4、然后从 “顶级域名服务器（com.）” 查到 “次级域名服务器” 的 NS 记录和 A 记录。</p><p>5、再通过从 “次级域名服务器（用户注册的域名）” 查出 “主机名（www.）” 的 IP 地址。</p><h4 id="三、浏览器通过-HTTP-请求服务器。"><a href="#三、浏览器通过-HTTP-请求服务器。" class="headerlink" title="三、浏览器通过 HTTP 请求服务器。"></a>三、浏览器通过 HTTP 请求服务器。</h4><blockquote><p>浏览器使用 HTTP 协议或者 HTTPS 协议，向服务器发送请求。</p></blockquote><h4 id="四、构建-DOM-树。"><a href="#四、构建-DOM-树。" class="headerlink" title="四、构建 DOM 树。"></a>四、构建 DOM 树。</h4><blockquote><p>获取 HTTP 的 Request 的 body 中字符串（字符流）的 HTML 文本，进行解析并构建 DOM 树。</p></blockquote><p><img src="C:\Users\10405\AppData\Roaming\Typora\typora-user-images\1559028002988.png" alt="1559028002988"></p><h5 id="1、状态机解析代码"><a href="#1、状态机解析代码" class="headerlink" title="1、状态机解析代码"></a>1、状态机解析代码</h5><blockquote><p>HTML 词法状态机的作用就是将字符流解析成词（token)。状态机每读入一个字符就要做一次决策，这些决策和当前的状态有关。</p></blockquote><p>① 字符流进入状态机对每个字符进行解析，每判断一个字符，就为一个状态。根据当前状态来确定下一字符确定的下一个状态。</p><p>② 用状态机做词法分析，将每个词的 “特征状态” 逐个拆开成独立状态，然后把所有的特征字符链合并起来，形成一个联通图结构。</p><p>③ 状态机涉及到编译原理，用 <code>javascript</code> 来讲解。可以设计函数，每个函数为一个状态，参数接受字符串，返回的是下一个状态函数。</p><h5 id="2、构建-DOM-树"><a href="#2、构建-DOM-树" class="headerlink" title="2、构建 DOM 树"></a>2、构建 DOM 树</h5><blockquote><p>要把上边状态机解析的词通过栈这种结构来构建 DOM 树。</p></blockquote><p>① 在接收状态机解析的词的同时，就开始通过构建 DOM 树算法构建 DOM 树，当接受完所有输入的时候，栈顶就是最后的根节点，DOM 树的产出，就是 stack 的第一项，</p><p>② 构建 DOM 树，需要一个 Node 类，构建 DOM 树的所有结点都是这个 Node 类的实例。不一样的 HTML 结点对应不一样的 Node 子类（如 Element、Text等，如果基于 OOP 的话，需要抽象工厂来创建类）。</p><p>③ 在词中，开始标签和结束标签需要成对匹配的（在编译原理中，正是利用了栈匹配开始和结束标签的方案）。</p><p>④ 如果遇到 Text 结点，把相邻的 Text 结点合并起来。入栈，检查栈顶，若栈顶为 Text 结点，就合并 Text 结点。</p><p>⑤ 构建 DOM 的全过程</p><ul><li>栈顶为当前元素；</li><li>遇到属性就添加当前节点；</li><li>遇到文本点，如果当前节点是文本节点，则跟文本节点合并，否则入栈为当前的子节点；</li><li>遇到注释节点，作为节点的子节点；</li><li>遇到开始标签就入栈一个节点，当前节点就是这个节点的父节点；</li><li>遇到结束标签就出栈一个节点（检查是否匹配）。</li></ul><h4 id="五、计算-CSS-属性"><a href="#五、计算-CSS-属性" class="headerlink" title="五、计算 CSS 属性"></a>五、计算 CSS 属性</h4><blockquote><p>上阶段构造的 DOM 树只有节点和属性，没有包含任何的 CSS 样式。这一节点将 CSS 规则应用到样式中去，为 DOM 树添加 CSS 属性。DOM 树构造到父节点的时候，还不知道它有没有子节点，所以算不出来 CSS。</p></blockquote><h5 id="1、选择器的出现顺序"><a href="#1、选择器的出现顺序" class="headerlink" title="1、选择器的出现顺序"></a>1、选择器的出现顺序</h5><blockquote><p>选择器出现的顺序必定跟 DOM 树的顺序一致，这是 CSS 设计的一个原则。即保证选择器在 DOM 构建到当前节点时，已经可以准确判断是否匹配了，不需要后续节点信息。</p></blockquote><h5 id="2、CSS-分析"><a href="#2、CSS-分析" class="headerlink" title="2、CSS 分析"></a>2、CSS 分析</h5><blockquote><p>① CSS 需经过词法分析和语法分析，变成计算机可以理解的结构（属于编译原理的知识），解析之后变成一颗可用的抽象语法树。</p><p>② 一个 complex-selector 是检查一个元素的规则，一个复合选择器是由数个 complex-selector 通过连接符（combinator）组成。</p></blockquote><h5 id="3、连接符的匹配规则"><a href="#3、连接符的匹配规则" class="headerlink" title="3、连接符的匹配规则"></a>3、连接符的匹配规则</h5><h6 id="▉-后代选择器-——-“空格”"><a href="#▉-后代选择器-——-“空格”" class="headerlink" title="▉ 后代选择器 —— “空格”"></a>▉ 后代选择器 —— “空格”</h6><blockquote><p>① 匹配到 a#b 元素时，开始检查所有的子代是否匹配 .cls。 </p><p>② 当遇到 \ 时，使规则退一步，才会时第三个不会被匹配到。</p><p><strong>※ 总结：</strong>后代选择器的作用范围是父节点的所有子节点，一次规则是在匹配到本地标签的结束时回退的。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-id">#b</span> <span class="selector-class">.cls</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">cls</span>&gt;</span>2<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">cls</span>&gt;</span>3<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="▉-后继选择器-——-“-”"><a href="#▉-后继选择器-——-“-”" class="headerlink" title="▉ 后继选择器 —— “~”"></a>▉ 后继选择器 —— “~”</h6><blockquote><p>后继选择器的匹配规则是不能再使用闭合标签规则，而是带父元素的规则。（带父元素规则，就不会匹配后继的子节点了）</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.cls~* &#123;</span><br><span class="line">    border:solid 1px green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">cls</span>&gt;</span>2<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    3</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="▉-子代选择器-——-“-gt-”"><a href="#▉-子代选择器-——-“-gt-”" class="headerlink" title="▉ 子代选择器 —— “&gt;”"></a>▉ 子代选择器 —— “&gt;”</h6><blockquote><p>也是使用父元素作为约束条件进行匹配。</p></blockquote><h6 id="▉-其他"><a href="#▉-其他" class="headerlink" title="▉ 其他"></a>▉ 其他</h6><blockquote><p>其他选择器包括逗号，表示“或”的关系。编译器当做两条规则来处理。</p></blockquote><h5 id="3、计算-css-完成"><a href="#3、计算-css-完成" class="headerlink" title="3、计算 css 完成"></a>3、计算 css 完成</h5><blockquote><p>CSS 计算把 CSS 规则应用到 DOM 树上，为 DOM 树添加了相关的属性过程，最后得到了一个带有 CSS 属性的树。</p></blockquote><h4 id="六、排版"><a href="#六、排版" class="headerlink" title="六、排版"></a>六、排版</h4><blockquote><p>上一阶段确定了 CSS 属性得到一颗带有 CSS 属性的 DOM 树，而且构建 DOM 树和计算 CSS 属性两个节点产出的是一个一个的元素，那么这一阶段是浏览器确定每个元素的位置。</p></blockquote><h5 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h5><p>① 浏览器最基本的排版方案是正常流排版，浏览器的正常流是唯一<strong>文字和盒模型</strong>混排的排版方式，并遵循公认的文字排版规范。</p><p>② 文字排版规定了行模型和文字在行模型中的排布（行模型规定了行顶、行底、行高、文字区域、基线等对齐方式）。</p><p>③ 浏览器还支持元素和文字混排，元素是一个长方形区域，也就是所谓的盒模型。</p><h5 id="2、正常流文字排版"><a href="#2、正常流文字排版" class="headerlink" title="2、正常流文字排版"></a>2、正常流文字排版</h5><p>① 浏览器中的环境和显示中书写文字的环境差不多相同，但是浏览器支持改变排版的方向。我们把文字书写的方向叫做主方向，换行延伸的方向叫做交叉轴方向。</p><p>② 从字体中获取相关信息，其中一个重要属性为主轴的前后距离。文字排版还会受到一些 CSS 属性的影响，line-height、letter-spacing等。</p><p>③ 正常流中多数元素都是以盒来排版； <code>display</code> 为 <code>inline</code> 属性的元素，是拆成文本来排版的，会直接排入文档流中，主轴方向的 <code>margin</code> 属性和 border 属性也会计算进排版前进举例当中。</p><blockquote><p>可以根据 display 属性可分为两类：</p></blockquote><ul><li><p>内部排版（文本排版）</p></li><li><p>是否为 <code>inline</code>（带有 <code>inline-</code> 前缀的盒子，称为行内级盒子）</p></li></ul><p>④ 当没有指定文字书写方向的时候，从左到右文字中插入从右到左文字，会形成一个双向文字盒。</p><p>⑤ 即使没有元素包裹，混合书写方向也会形成盒结构。在排版时，遇到这样双向文字盒，会先排完盒内再排盒外。</p><h5 id="3、正常流中的盒"><a href="#3、正常流中的盒" class="headerlink" title="3、正常流中的盒"></a>3、正常流中的盒</h5><blockquote><p>正常流中 <code>display</code> 不为 <code>inline</code> 的元素，以盒的形式跟文字一起进行排版。</p></blockquote><p>① 主轴方向上的占据的空间是由 margin、border、padding、with/height 等属性和决定的，交叉轴方向是由 vertical-align 决定的，也会影响实际的行高。</p><p>② 浏览器对行的排版，先行内布局， 然后再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。</p><p>③ 块级盒子单独占据一整行，计算出交叉轴方向的高度即可。</p><h5 id="4、绝对定位元素"><a href="#4、绝对定位元素" class="headerlink" title="4、绝对定位元素"></a>4、绝对定位元素</h5><blockquote><p><code>position</code> 属性为 <code>absolute</code> 的元素，根据包含它块来确定元素。因为这是跟正常流无关的一种独立排版模式，逐级找到父级的 <code>position</code> 非 <code>static</code> 即可。</p></blockquote><h5 id="5、浮动元素排版"><a href="#5、浮动元素排版" class="headerlink" title="5、浮动元素排版"></a>5、浮动元素排版</h5><p>① 浏览器对 float 的处理事先排入正常流，在移动到排版宽度的最左/最右（主轴方向）。</p><p>② 移动后，float 元素占据一块空间，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。</p><p>③ float 元素排布完成后，float 元素所在的行需要重新确定位置。 </p><h5 id="6、其它排版"><a href="#6、其它排版" class="headerlink" title="6、其它排版"></a>6、其它排版</h5><blockquote><p>CSS 每个排版都有复杂的规定，实现形式各不同。如 Flex 排版，支持 flex 属性，将每一行后的剩余空间平均分配给主轴方向的 width/height 属性。</p></blockquote><h4 id="七、渲染"><a href="#七、渲染" class="headerlink" title="七、渲染"></a>七、渲染</h4><blockquote><p>确定了每个元素的位置之后，根据样式信息和大小信息，为内存中的每个元素渲染出它的图形。在图形学中的意思是将模型变成位图的过程称为渲染。</p></blockquote><h5 id="1、位图"><a href="#1、位图" class="headerlink" title="1、位图"></a>1、位图</h5><blockquote><p>位图就是内存中的一个二维表格，把每张图片的像素对应的颜色保存进去。（位图信息是DOM树中占据浏览器中内存最多的信息，内存优化主要考虑这点）</p></blockquote><h5 id="2、渲染过程"><a href="#2、渲染过程" class="headerlink" title="2、渲染过程"></a>2、渲染过程</h5><blockquote><p>浏览器渲染过程主要是将每个元素（Html元素/伪元素）的盒模型变成位图，inline 元素可能占据多行，每个盒对应一张位图。渲染过程分为两大类：</p></blockquote><ul><li>图形渲染 </li><li>文字渲染 </li></ul><h6 id="▉-图形渲染"><a href="#▉-图形渲染" class="headerlink" title="▉ 图形渲染"></a>▉ 图形渲染</h6><blockquote><p>盒的背景、边框、SVG元素、阴影等特性，都为绘制的图形类，需要一个底层库的支持。</p></blockquote><h6 id="▉-文字渲染"><a href="#▉-文字渲染" class="headerlink" title="▉ 文字渲染"></a>▉ 文字渲染</h6><blockquote><p>盒中的文字的绘制也会要一个底层库来支持，叫做字体库（目前常见的字体库为 Freetype）。字体库提供读取文字文件的基本能力，它会根据字符的码点抽取出字形。字形分为两种：</p></blockquote><ul><li>像素字形</li><li>矢量字形</li></ul><p>通常字体会在小字体（小于6px、8px）提供像素字形，比较大的尺寸提供矢量字形（本身需要经过渲染才能继续渲染到元素的位图上去）。</p><h6 id="▉-渲染过程"><a href="#▉-渲染过程" class="headerlink" title="▉ 渲染过程"></a>▉ 渲染过程</h6><p>① 渲染过程生成的位图跟排版中占据的尺寸是相同的，但是现实中确有很大的差距，因为很多属性会影响渲染位图的大小，如阴影。为了优化，将阴影作为一个单独的盒子来处理。</p><p>② 渲染过程不会把子元素会知道渲染的位图上，当父元素和子元素发生相对位置变化时，可以保证渲染的结果最大程度被缓存，减少重新渲染。</p><h4 id="八、合成"><a href="#八、合成" class="headerlink" title="八、合成"></a>八、合成</h4><blockquote><p>合成并非浏览器必要执行的一环，实际上是一个性能的考量。</p></blockquote><p><strong>合成可以这样理解：</strong>合成的元素的意思是合成之后，通过 js 动态改变其他元素，合成的这部分元素，就不会重新渲染从而提高了性能。</p><h5 id="1、合成的过程"><a href="#1、合成的过程" class="headerlink" title="1、合成的过程"></a>1、合成的过程</h5><p>① 渲染过程不会把子元素渲染到位图上面，合成的过程，就是要创建一个合成层，把一部分子元素渲染到合成的位图上面。 </p><h5 id="2、为哪些元素创建合成后的位图，哪些元素应该渲染到合成层上？"><a href="#2、为哪些元素创建合成后的位图，哪些元素应该渲染到合成层上？" class="headerlink" title="2、为哪些元素创建合成后的位图，哪些元素应该渲染到合成层上？"></a>2、为哪些元素创建合成后的位图，哪些元素应该渲染到合成层上？</h5><blockquote><p>合成的目标是提高性能，建立的原则就是最大限度减少绘制次数原则。好的合成策略是“猜测”可能变化的元素，把他排除到合成之外。</p></blockquote><p>①    主流的浏览器一般根据 position、transform 等属性来决定合成策略，来猜测这些元素未来的变化。</p><p>②    以上猜测的准确性有限，所以新的 CSS 标准中，规定了 will-width 属性，可以由业务代码来提示浏览器的合成策略。</p><h4 id="九、绘制"><a href="#九、绘制" class="headerlink" title="九、绘制"></a>九、绘制</h4><blockquote><p>绘制是把位图绘制到屏幕上，变成肉眼可见的图像的过程。一般最终显示的位图位于显存中，，有的情况只需把内存中的一张位图交给显示驱动或操作系统就 ok，这个将位图合成最终的位图叫做绘制。</p></blockquote><h5 id="1、重排和重绘"><a href="#1、重排和重绘" class="headerlink" title="1、重排和重绘"></a>1、重排和重绘</h5><blockquote><p>所说的“重排”和“重绘”，所谓的重排是排版，重绘则是绘制过程。实际上，“绘制”过程发生的频率非常高，比如：鼠标滑过浏览器的显示区域，鼠标每次移动，都要造成重新绘制，如果不重新绘制，就会产生大量的鼠标残影。</p></blockquote><h5 id="2、怎样减少重绘？"><a href="#2、怎样减少重绘？" class="headerlink" title="2、怎样减少重绘？"></a>2、怎样减少重绘？</h5><blockquote><p>限制绘制面积可以提高性能，如果鼠标只在某个覆盖的区域滑动，我们只需重新绘制这个区域就可以了。</p></blockquote><h5 id="3、解决办法"><a href="#3、解决办法" class="headerlink" title="3、解决办法"></a>3、解决办法</h5><blockquote><p>“脏矩形”算法，把屏幕分成若干个矩形区域。</p></blockquote><p>① 当鼠标移动导致绘制时，只重绘它影响到的几个矩形区域就够了。最小的影响区域只会涉及 4 个矩形，大型元素则覆盖多个矩形。</p><p>② 设置合适的矩形区域大小，可以很好的控制绘制时的消耗。设置过大会造成绘制面积增大，设置过小的矩形会造成计算复杂。</p><p>③ 重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交际部分绘制即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器是如何工作的？&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端 CSS 之【响应式】</title>
    <link href="http://yoursite.com/2019/05/20/%E5%89%8D%E7%AB%AF%20CSS%20%E4%B9%8B%E3%80%90%E5%93%8D%E5%BA%94%E5%BC%8F%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/20/前端 CSS 之【响应式】/</id>
    <published>2019-05-20T11:37:12.064Z</published>
    <updated>2019-05-20T12:37:02.809Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>响应式设计！</p><a id="more"></a><h3 id="一、浏览器视口"><a href="#一、浏览器视口" class="headerlink" title="一、浏览器视口"></a>一、浏览器视口</h3><blockquote><p>通过 CSS 像素（不等于无力像素，和物理像素成比例）来合理利用视口空间。</p></blockquote><p>1、理想视口：与设备自身尺寸接近的视口称为理想视口。</p><p>2、默认视口：模拟一个大的视口，然后缩小页面进行显示，称为默认视口。</p><p>3、可见视口：显示网页的矩形区域称为可见视口（减去浏览器中的按钮、滚动条等）。</p><p>4、布局视口：约束整个页面时视口为布局视口。</p><h3 id="二、配置视口"><a href="#二、配置视口" class="headerlink" title="二、配置视口"></a>二、配置视口</h3><blockquote><p>让默认视口的设备都具有理想视口，需要进行声明 meta 标签。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用当前的设备的理想尺寸作为视口的宽度，以及与理想视口的缩放程度相匹配的缩放级别</span></span><br><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-with,initial-scale=1"</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="三、媒体类型和媒体查询"><a href="#三、媒体类型和媒体查询" class="headerlink" title="三、媒体类型和媒体查询"></a>三、媒体类型和媒体查询</h3><h4 id="3-1、媒体类型"><a href="#3-1、媒体类型" class="headerlink" title="3.1、媒体类型"></a>3.1、媒体类型</h4><blockquote><p>媒体类型分为 screen(屏幕显示) 和 print (打印机)。</p></blockquote><p><strong>应用方式：</strong></p><p>① HTML 方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta rel=<span class="string">"stylesheet"</span> href=<span class="string">"main.css"</span> media=<span class="string">"screen,print"</span>&gt;</span><br></pre></td></tr></table></figure><p>② CSS 方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> print&#123;</span><br><span class="line"><span class="selector-class">.smallprint</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">11pt</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2、媒体查询"><a href="#3-2、媒体查询" class="headerlink" title="3.2、媒体查询"></a>3.2、媒体查询</h4><blockquote><p>应用方式有两种，一种是标签的形式，另一种是 css 的形式。标签的形式由于可能有的浏览器会将外部文件下载影响性能，所以通常使用 css 的形式。</p><p>① 可以忽略媒体类型，相当于用 all 代替。</p><p>②  only 关键字为了避免旧版本浏览器的误解。所有旧版本的浏览器遇到 only 关键字。都会跳过媒题查询应用下的样式。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="comment">/* 这里写规则 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、响应式设计"><a href="#四、响应式设计" class="headerlink" title="四、响应式设计"></a>四、响应式设计</h3><h4 id="4-1-移动端优先"><a href="#4-1-移动端优先" class="headerlink" title="4.1 移动端优先"></a>4.1 移动端优先</h4><blockquote><p>我们通常设计响应式以移动端优先设计，因为移动端屏幕小、通常处理器和硬件配置比电脑要低，便于人们携带。之所以首先设计移动端，为了能够考虑到很多限制因素。如果开发桌面的程序，我们可以进行其扩展。如果我们相反，将已有的功能塞进一个有限的平台，难度会更大。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;响应式设计！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之道之【面试汇总】</title>
    <link href="http://yoursite.com/2019/05/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E4%B9%8B%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/20/前端面试之道之【面试题汇总】/</id>
    <published>2019-05-20T08:36:20.851Z</published>
    <updated>2019-06-05T01:06:11.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前端 js、css、vue等面试题解答汇总。</p><a id="more"></a><p>[TOC]</p><h2 id="一、CSS-篇"><a href="#一、CSS-篇" class="headerlink" title="一、CSS 篇"></a>一、CSS 篇</h2><h4 id="1、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？"><a href="#1、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？" class="headerlink" title="1、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？"></a>1、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？</h4><blockquote><p>① 标准盒子模型：宽度 = 内容的宽度<code>（content）+ border + padding + margin</code><br>② 低版本 IE 盒子模型：宽度 = 内容宽度<code>（content+border+padding）+ margin</code></p></blockquote><h4 id="2、-box-sizing属性？"><a href="#2、-box-sizing属性？" class="headerlink" title="2、 box-sizing属性？"></a>2、 box-sizing属性？</h4><blockquote><p>用来控制元素的盒子模型的解析模式，默认为 <code>content-box</code>。</p></blockquote><p>① <code>context-box：</code> W3C 的标准盒子模型，设置元素的 <code>height/width</code> 属性指的是 <code>content</code> 部分的高/宽<br>② <code>border-box：</code> IE 传统盒子模型。设置元素的 <code>height/width</code> 属性指的是 <code>border + padding + content</code> 部分的高/宽</p><h4 id="3、-CSS-选择器有哪些？哪些属性可以继承？"><a href="#3、-CSS-选择器有哪些？哪些属性可以继承？" class="headerlink" title="3、 CSS 选择器有哪些？哪些属性可以继承？"></a>3、 CSS 选择器有哪些？哪些属性可以继承？</h4><p><strong>① 选择器：</strong></p><ul><li><p>ID 选择器、类选择器、标签选择器；</p></li><li><p>相邻选择器（+）、子元素选择器（&gt;）、兄弟选择器（~）、后代选择器（ul li）、通配符选择器（*）；</p></li><li>属性选择器（a[href=”…l”]）；</li><li>伪类选择器（a:hover, li:nth-child）</li></ul><p><strong>② 可继承属性：</strong>font-size、font-family、color。</p><p><strong>③ 不可继承属性：</strong>border、padding、 margin、 width、height</p><p><strong>④ 优先级：</strong>important &gt; 内嵌样式 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪元素 &gt; 继承 &gt; 通配符</p><blockquote><p>注意：important 提高 css 样式的权重，在 IE 中失效。</p></blockquote><h4 id="4、说说你对伪类和伪元素的了解，分别举出五个例子。"><a href="#4、说说你对伪类和伪元素的了解，分别举出五个例子。" class="headerlink" title="4、说说你对伪类和伪元素的了解，分别举出五个例子。"></a>4、说说你对伪类和伪元素的了解，分别举出五个例子。</h4><p><strong>① 伪类和伪元素</strong></p><p>伪类：伪类用于某些<strong>选择器</strong>添加特殊效果。</p><p>伪元素：为某些<strong>元素</strong>添加特殊效果。</p><p><strong>② 两者区别：</strong></p><ul><li>伪元素相当于添加元素设置元素，而伪类是在元素添加效果。两者都不存在于 dom 树中，是文档流之外的东西。</li><li>伪类没有数量上的限制，只要两个伪类不相互排斥，可同时使用在同一元素上。</li></ul><p><strong>③ 伪元素</strong></p><ul><li>:: before</li><li><p>:: after</p></li><li><p>:: first-line</p></li><li>:: first-letter</li><li>:: last-letter</li></ul><p><strong>④ 伪类</strong></p><ul><li>: first-child</li><li>: visitive</li><li>: hover</li><li>: active</li><li>: focus</li><li>: lang</li></ul><p><strong>⑤ CSS3 新增伪类</strong></p><ul><li>p:first-of-type: 选择父元素的首个元素。</li><li>p:last-of-type: 选择属于其父元素的最后一个元素。</li><li>p:nth-child(2): 选择其父元素的第二个子元素。</li><li>p:only-of-type: 选择属于其父元素没有兄弟节点唯一元素。</li><li>p:first-child: p:last-child 选择父元素的第一个元素或最后一个元素</li><li>div:not(div2)  除 div2 的所有元素（否定伪类选择器）。</li><li>:enabled  disabled 表单控件的禁用状态。</li><li>:checkd 单选框或复选框被选中。</li></ul><h4 id="5、-CSS-优先级怎么计算？"><a href="#5、-CSS-优先级怎么计算？" class="headerlink" title="5、 CSS 优先级怎么计算？"></a>5、 CSS 优先级怎么计算？</h4><blockquote><p><strong>特指度：</strong>表示一个 css 选择器表达式的重要程度，<strong>哪个的计算结果大，浏览器就会以哪个为优先。</strong></p></blockquote><p><strong>① 计算方法</strong></p><ul><li><p>通用选择器（*）、子元素选择器（&gt;）、相邻兄弟选择器（+）  +0</p></li><li><p>element 元素选择器：+1；</p></li><li>class 选择器、伪类选择器、属性选择器：+10；</li><li>id 选择器：+100；</li><li>内联样式 +1000</li></ul><p><strong>② 计算规则</strong></p><ul><li>!important 声明的样式优先级最高，如果冲突再进行计算。</li><li>如果优先级相同，则选择最后出现的样式。</li><li>继承得到的样式优先级最低。</li></ul><h4 id="6、-display有哪些值？说明他们的作用"><a href="#6、-display有哪些值？说明他们的作用" class="headerlink" title="6、 display有哪些值？说明他们的作用?"></a>6、 display有哪些值？说明他们的作用?</h4><ul><li><p>inline：内联（默认值）；</p></li><li><p>none：隐藏（不占空间）；</p></li><li><p>block：块显示；</p></li><li><p>block-inline：内联块级元素呈现；</p></li><li><p>table：表格显示。</p></li></ul><h4 id="7、position的值？"><a href="#7、position的值？" class="headerlink" title="7、position的值？"></a>7、position的值？</h4><ul><li>static：（默认）按正常文档流排序；</li><li>relative：相对定位。不脱离文档流，通过静态位置top、left、right、bottom定位；</li><li><p>absolute：绝对定位。参考距其最近一个不为 static 的父级元素通过 top、bottom、left、right 定位。</p></li><li><p>fixed：固定定位。所固定的参照对象是<strong>可视窗口</strong>。</p></li></ul><h4 id="8、纯CSS实现三角形原理"><a href="#8、纯CSS实现三角形原理" class="headerlink" title="8、纯CSS实现三角形原理"></a>8、纯CSS实现三角形原理</h4><blockquote><p>均分原理。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.triangle&#123;</span><br><span class="line">    width: <span class="number">0</span>;</span><br><span class="line">    height: <span class="number">0</span>;</span><br><span class="line">    border-top: <span class="number">40</span>px solid transparent;</span><br><span class="line">    border-left: <span class="number">40</span>px solid transparent;</span><br><span class="line">    border-right: <span class="number">40</span>px solid transparent;</span><br><span class="line">    border-bottom: 40px solid #ff0000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"><a href="#9、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？" class="headerlink" title="9、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"></a>9、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h4><p>① 如何居中一个 div？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">margin:<span class="number">0</span> auto;</span><br></pre></td></tr></table></figure><p>② 如何居中一个浮动元素？</p><blockquote><p>flexbox 居中</p></blockquote><p>③ 如何让绝对定位的 div 居中？</p><blockquote><p>flexbox 居中</p></blockquote><h4 id="10、谈一下你对-Flexbox-的了解，以及适用场景？"><a href="#10、谈一下你对-Flexbox-的了解，以及适用场景？" class="headerlink" title="10、谈一下你对 Flexbox 的了解，以及适用场景？"></a>10、谈一下你对 Flexbox 的了解，以及适用场景？</h4><blockquote><p>Flex 布局提供了更高效的对容器进行布局、对齐和分配空间。传统的布局，block 垂直从上到下布局；而 inline 布局则是水平方向排列。Flex 没有在方向上的限制，可自由操作。</p></blockquote><h4 id="11、为什么要初始化CSS样式？"><a href="#11、为什么要初始化CSS样式？" class="headerlink" title="11、为什么要初始化CSS样式？"></a>11、为什么要初始化CSS样式？</h4><blockquote><p>由于浏览器的兼容性问题，不同浏览器的某些标签的默认值是不相同的，如果没有对 CSS 初始化，往往会出现浏览器之间的页面显示差异。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 淘宝初始化统一规范</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">hr</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">li</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">legend</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125; </span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span>tahoma, arial, \<span class="number">5</span>b8b\<span class="number">4</span>f53; &#125; </span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>&#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125; </span><br><span class="line"><span class="selector-tag">address</span>, <span class="selector-tag">cite</span>, <span class="selector-tag">dfn</span>, <span class="selector-tag">em</span>, <span class="selector-tag">var</span> &#123; <span class="attribute">font-style</span>:normal; &#125; </span><br><span class="line"><span class="selector-tag">code</span>, <span class="selector-tag">kbd</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">samp</span> &#123; <span class="attribute">font-family</span>:couriernew, courier, monospace; &#125; </span><br><span class="line"><span class="selector-tag">small</span>&#123; <span class="attribute">font-size</span>:<span class="number">12px</span>; &#125; </span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123; <span class="attribute">list-style</span>:none; &#125; </span><br><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">text-decoration</span>:none; &#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>:underline; &#125; </span><br><span class="line"><span class="selector-tag">sup</span> &#123; <span class="attribute">vertical-align</span>:text-top; &#125; </span><br><span class="line"><span class="selector-tag">sub</span>&#123; <span class="attribute">vertical-align</span>:text-bottom; &#125; </span><br><span class="line"><span class="selector-tag">legend</span> &#123; <span class="attribute">color</span>:<span class="number">#000</span>; &#125; </span><br><span class="line"><span class="selector-tag">fieldset</span>, <span class="selector-tag">img</span> &#123; <span class="attribute">border</span>:<span class="number">0</span>; &#125; </span><br><span class="line"><span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125; </span><br><span class="line"><span class="selector-tag">table</span> &#123; <span class="attribute">border-collapse</span>:collapse; <span class="attribute">border-spacing</span>:<span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="12、CSS-里的-visibility-属性有个-collapse-属性值？在不同浏览器下以后什么区别？"><a href="#12、CSS-里的-visibility-属性有个-collapse-属性值？在不同浏览器下以后什么区别？" class="headerlink" title="12、CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？"></a>12、CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？</h4><p>① 在谷歌浏览器中，使用 collapse 属性值和使用 hidden 没有区别。</p><p>② 在火狐以及 opera 和  IE 中，使用 collapse 的值和使用 display：none 没有什么区别。 </p><h4 id="13、display-none-与-visibility：hidden-的区别？"><a href="#13、display-none-与-visibility：hidden-的区别？" class="headerlink" title="13、display:none 与 visibility：hidden 的区别？"></a>13、display:none 与 visibility：hidden 的区别？</h4><ul><li>display: none 不显示对应的元素，在文档流中<strong>不分配空间</strong>。（回流+重绘）</li><li>visibility: hidden 隐藏对应元素，在文档中仍然<strong>保留原来的空间</strong>。（重绘）</li></ul><h4 id="14、对-BFC-的理解？"><a href="#14、对-BFC-的理解？" class="headerlink" title="14、对 BFC 的理解？"></a>14、对 BFC 的理解？</h4><blockquote><p>BFC 称为块级格式化上下文，是一个独立的容器，容器里边的内容不会影响到外边的内容，这个隐藏的属性需要被触发。    </p></blockquote><p><strong>①  触发 BFC 的条件：</strong></p><ul><li>根元素（html）;</li><li>float 的值不为 none ;</li><li>overflow 的值不为默认的 visible ;</li><li>display 的值为 inline-block、table-cell、table-caption ;</li><li>position 的值为 absolute 或 fixed。</li></ul><p><strong>② BFC 的规则</strong>‘</p><blockquote><p>1）在一个块级排版上下文中，盒子是从包含块顶部开始，垂直的一个接一个的排列的。每个盒子的左外边是触碰到包含块的左边的（对于从右向左的排版，则相反）。</p><p>2）相邻两个盒子之间的垂直的间距是被 margin属性所决定的，在一个块级排版上下文中相邻的两个块级盒之间的垂直 margin 是折叠的。—— margin 上下折叠问题</p><p>3）BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。—— margin 高度塌陷</p></blockquote><h4 id="15、浮动带来的问题？以及清除浮动的方式？"><a href="#15、浮动带来的问题？以及清除浮动的方式？" class="headerlink" title="15、浮动带来的问题？以及清除浮动的方式？"></a>15、浮动带来的问题？以及清除浮动的方式？</h4><p><strong>① 浮动问题：</strong></p><ul><li>父容器的高度无法撑开。</li><li>覆盖后边跟随的元素。</li></ul><p><strong>② 清理浮动：</strong></p><ul><li>overflow:hiddle(当子元素超出父元素，就会出现问题)</li><li>clear: both 属性解决。</li><li>利用伪元素（::after）的方法。</li></ul><h4 id="16、上下-margin-重叠问题？margin-塌陷问题？以及怎么解决？"><a href="#16、上下-margin-重叠问题？margin-塌陷问题？以及怎么解决？" class="headerlink" title="16、上下 margin 重叠问题？margin 塌陷问题？以及怎么解决？"></a>16、上下 margin 重叠问题？margin 塌陷问题？以及怎么解决？</h4><p><strong>① margin 折叠问题：</strong></p><blockquote><p>当两个盒子的垂直外边距 margin 是邻接的（相接触的），两个盒子就会使用一个外边距，外边距以高度最大值为准。（同一 BFC 中）</p><ul><li>兄弟元素折叠</li><li>父子元素折叠</li></ul></blockquote><p><strong>解决：</strong>处在不同的 BFC 中。</p><p><strong>1、 兄弟元素折叠解决办法</strong></p><ul><li>将元素设置为浮动 float:left;。 </li><li>在设置 margin-top/bottom 值时统一设置上或下。</li><li>元素的 position 的值为 absolute/fixed。</li></ul><p><strong>2、父子折叠解决办法：将两个 margin 隔离开，不直接相接触。</strong></p><ul><li>父元素设置 border；</li><li>父元素设置 padding；</li><li>父元素设置 overflow（父元素就为BFC，BFC 特性之一为内外不相互影响）；</li></ul><p><strong>② margin 塌陷问题：</strong></p><blockquote><p><strong>高度塌陷：</strong>浮动的子元素无法撑开父元素的高度，导致父元素高度塌陷（浮动元素为一个 BFC ，所以不影响其他 BFC 外元素）。</p><p><strong>嵌套塌陷：</strong>父盒子和子盒子存在嵌套关系的时候，子盒子和父盒子共用一个 margin。</p></blockquote><p><strong>解决：</strong></p><p>1、高度塌陷解决办法：</p><ul><li>清除浮动的方法。</li><li>父元素设置 overflow 属性（此时父元素也为 BFC，让浮动的元素正常溜排列，不能脱离文档流）</li></ul><h4 id="17、移动端的布局用过媒体查询吗？"><a href="#17、移动端的布局用过媒体查询吗？" class="headerlink" title="17、移动端的布局用过媒体查询吗？"></a>17、移动端的布局用过媒体查询吗？</h4><blockquote><p>通过媒介查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应设备上的显示。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、在 head 标签中</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"xx.css"</span> <span class="attr">media</span>=<span class="string">"only screen and (max-device-width:480px)"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、在 <span class="selector-tag">css</span> 中设置</span><br><span class="line">@<span class="keyword">media</span> only screen and (max-device-width:<span class="number">480px</span>)&#123;</span><br><span class="line">    // css样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18、css-预处理器"><a href="#18、css-预处理器" class="headerlink" title="18、css 预处理器"></a>18、css 预处理器</h4><ul><li>Less 是一个动态 CSS 语言框架，Less 扩展了 CSS 的动态特性。（变量、混入、嵌套、函数）。</li><li>SASS 是一种 CSS 的开发工具，提供了许多便利的写法。</li></ul><h4 id="19、margin-和-padding-分别适合什么场景使用？"><a href="#19、margin-和-padding-分别适合什么场景使用？" class="headerlink" title="19、margin 和 padding 分别适合什么场景使用？"></a>19、margin 和 padding 分别适合什么场景使用？</h4><p>① 什么时候使用 margin?</p><ul><li>需要在 border 外侧添加空白；</li><li>空白处不需要背景颜色；</li><li>上下相连的两个盒子之间的空白，需要相互抵消时。</li></ul><p>② 什么时候使用 padding？</p><ul><li>需要在 border 内侧添加空白</li><li>空白处需要背景颜色</li><li>上下相连的两个盒子的空白，希望为两者之和</li></ul><h4 id="20、display-inline-block-什么时候会显示间隙？"><a href="#20、display-inline-block-什么时候会显示间隙？" class="headerlink" title="20、display:inline-block 什么时候会显示间隙？"></a>20、display:inline-block 什么时候会显示间隙？</h4><ul><li>有空格时候会有间隙解决：移除空格</li><li>margin 正值的时候 解决：margin使用负值</li></ul><h4 id="21、-CSS属性overflow属性定义溢出元素内容区的内容会如何处理"><a href="#21、-CSS属性overflow属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="21、 CSS属性overflow属性定义溢出元素内容区的内容会如何处理?"></a>21、 CSS属性overflow属性定义溢出元素内容区的内容会如何处理?</h4><ul><li>scroll：出现滚动条。</li><li>auto：子元素内容大于父元素内容出现滚动条。</li><li>visible：溢出内容出现在父元素之外。</li><li>hidden：溢出隐藏。</li></ul><h4 id="22、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#22、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="22、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>22、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h4><p>① 响应式设计网站是一个网站能够兼容多个终端。</p><p>② 基本原理：通过媒介查询检测不同设备屏幕尺寸做处理。</p><p>③ 兼容 IE：头部必须有 meta 声明的 viewport。</p><h2 id="JavaScript-篇"><a href="#JavaScript-篇" class="headerlink" title="JavaScript 篇"></a>JavaScript 篇</h2><h4 id="1、原始类型"><a href="#1、原始类型" class="headerlink" title="1、原始类型"></a>1、原始类型</h4><blockquote><p>定义：原始类型都是存储的值，没有函数可以调用，共有六种原始类型。</p></blockquote><ul><li>string</li><li>number</li><li>boolean</li><li>undefined</li><li>null</li><li>symbol</li></ul><h4 id="2、关于-null-和-undefined-的区别？"><a href="#2、关于-null-和-undefined-的区别？" class="headerlink" title="2、关于 null 和 undefined 的区别？"></a>2、关于 null 和 undefined 的区别？</h4><p>① <code>null</code> 表示”没有对象”，即该处不应该有值。</p><p>② <code>undefined</code> 表示”缺少值”，就是此处应该有一个值</p><h4 id="3、对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？"><a href="#3、对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？" class="headerlink" title="3、对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？"></a>3、对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？</h4><p>① 原始类型存储的是指针，对象类型存储的是地址。</p><p>② 对象之间的赋值，是地址的赋值，改变对象的值，导致两个变量的值都会发生改变。</p><h4 id="4、typeof-是否能正确判断类型？instanceof-能正确判断对象的原理是什么？"><a href="#4、typeof-是否能正确判断类型？instanceof-能正确判断对象的原理是什么？" class="headerlink" title="4、typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？"></a>4、typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？</h4><p><strong>①  <code>typeof</code></strong></p><blockquote><p> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>         <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span>       <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>      <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()  <span class="comment">// 'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>      <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;        <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log()<span class="comment">// 'fuction'</span></span><br></pre></td></tr></table></figure><p><strong>②  <code>instanceof</code></strong></p><blockquote><p>判断一个对象的正确类型，可以使用 <code>intanceof</code> ，因为内部机制是<strong>通过原型链来判断的</strong>。<strong><code>instanceof</code></strong> 检测左侧的 <code>__proto__</code> 原型链上，是否存在右侧的 <code>prototype</code> 原型。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// p1._proto_._proto_ 原型链上是否存在 Person.prototype</span></span><br><span class="line">p1 <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="5、类型转换"><a href="#5、类型转换" class="headerlink" title="5、类型转换"></a>5、类型转换</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16716dec14421e47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h4 id="①-转换-Boolean-类型"><a href="#①-转换-Boolean-类型" class="headerlink" title="① 转换 Boolean 类型"></a>① 转换 Boolean 类型</h4><blockquote><p><code>undefined</code>、<code>null</code>、<code>false</code>、<code>NAN</code>、<code>‘ ’</code>、<code>0</code>、<code>-0</code> 值为 false，其他值都为 true。</p></blockquote><h4 id="②-对象转原始类型"><a href="#②-对象转原始类型" class="headerlink" title="② 对象转原始类型"></a>② 对象转原始类型</h4><blockquote><p>对象转换类型的时候，会调用内置的  [[ToPrimitive]]  函数，该函数的逻辑为：</p></blockquote><ul><li>如果为原始类型，就不转换；</li><li><p>需要转字符串，调用  <code>x.toString()</code>  方法。不是字符串类型就用 <code>x.valueOf()</code> 方法。</p></li><li><p>如果都没有返回原始类型，就会报错;</p></li></ul><blockquote><p><strong>补充：</strong>x.toString 和 x.valueOf() 的区别？</p></blockquote><ul><li>x.toString：将转化的类型用字符串表示。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'3'</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> d = &#123;<span class="attr">test</span>:<span class="string">'123'</span>,<span class="attr">example</span>:<span class="number">123</span>&#125;</span><br><span class="line"><span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'example'</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> f = [<span class="string">'test'</span>,<span class="string">'example'</span>];</span><br><span class="line"></span><br><span class="line">a.toString();<span class="comment">// "3"</span></span><br><span class="line">b.toString();<span class="comment">// "3"</span></span><br><span class="line">c.toString();<span class="comment">// "true"</span></span><br><span class="line">d.toString();<span class="comment">// "[object Object]"</span></span><br><span class="line">e.toString();<span class="comment">// "function ()&#123;console.log('example');&#125;"</span></span><br><span class="line">f.toString();<span class="comment">// "test,example"</span></span><br></pre></td></tr></table></figure><ul><li>x.valueOf：将返回自身的值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'3'</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> d = &#123;<span class="attr">test</span>:<span class="string">'123'</span>,<span class="attr">example</span>:<span class="number">123</span>&#125;</span><br><span class="line"><span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'example'</span>);&#125;</span><br><span class="line"><span class="keyword">var</span> f = [<span class="string">'test'</span>,<span class="string">'example'</span>];</span><br><span class="line"></span><br><span class="line">a.valueOf();<span class="comment">// 3</span></span><br><span class="line">b.valueOf();<span class="comment">// "3"</span></span><br><span class="line">c.valueOf();<span class="comment">// true</span></span><br><span class="line">d.valueOf();<span class="comment">// &#123;test:'123',example:123&#125;</span></span><br><span class="line">e.valueOf();<span class="comment">// function()&#123;console.log('example');&#125;</span></span><br><span class="line">f.valueOf();<span class="comment">// ['test','example']</span></span><br></pre></td></tr></table></figure><h4 id="6、四则运算符"><a href="#6、四则运算符" class="headerlink" title="6、四则运算符"></a>6、四则运算符</h4><ul><li>其中一个为字符串，另一个就会转化为字符串。</li><li>其中一方不是数字，就会转换字符串。</li><li>除了加法运算外，只要一方为数字，另一方也会转换为数字。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> * [] <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li><code>+ &#39;b&#39;</code> 等于 <code>NaN</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span> + + <span class="string">'b'</span> <span class="comment">// -&gt; "aNaN"</span></span><br></pre></td></tr></table></figure><h4 id="7、比较运算符"><a href="#7、比较运算符" class="headerlink" title="7、比较运算符"></a>7、比较运算符</h4><ul><li><p>如果是对象，就通过 valueOf 转化原始类型再比较。</p></li><li><p>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a &gt; <span class="number">-1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="8、逻辑运算符（-amp-amp-与-）"><a href="#8、逻辑运算符（-amp-amp-与-）" class="headerlink" title="8、逻辑运算符（&amp;&amp; 与 ||）"></a>8、逻辑运算符（&amp;&amp; 与 ||）</h4><blockquote><p>默认情况下返回布尔类型，但是也可以返回一个操作数。</p></blockquote><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">语法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">逻辑与（<code>&amp;&amp;</code>）</td><td style="text-align:left"><code>expr1 &amp;&amp; expr2</code></td><td style="text-align:left">若 <code>expr1</code> 可转换为 <code>true</code>，则返回 <code>expr2</code>；否则，返回 <code>expr1</code>。</td></tr><tr><td style="text-align:left">逻辑或（`</td><td style="text-align:left"></td><td style="text-align:left">`）</td><td>`expr1</td><td></td><td>expr2`</td><td>若 <code>expr1</code> 可转换为 <code>true</code>，则返回 <code>expr1</code>；否则，返回 <code>expr2</code>。</td></tr><tr><td style="text-align:left">逻辑非（<code>!</code>）</td><td style="text-align:left"><code>!expr</code></td><td style="text-align:left">若 <code>expr</code> 可转换为 <code>true</code>，则返回 <code>false</code>；否则，返回 <code>true</code>。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a5 = <span class="string">"Cat"</span> &amp;&amp; <span class="string">"Dog"</span>     <span class="comment">// t &amp;&amp; t 返回 "Dog"</span></span><br><span class="line">a6 = <span class="literal">false</span> &amp;&amp; <span class="string">"Cat"</span>     <span class="comment">// f &amp;&amp; t 返回 false</span></span><br><span class="line">a7 = <span class="string">"Cat"</span> &amp;&amp; <span class="literal">false</span>     <span class="comment">// t &amp;&amp; f 返回 false</span></span><br><span class="line">a8 = <span class="string">''</span>    &amp;&amp; <span class="literal">false</span>     <span class="comment">// f &amp;&amp; f 返回 ""</span></span><br><span class="line">a9 = <span class="literal">false</span> &amp;&amp; <span class="string">''</span>        <span class="comment">// f &amp;&amp; f 返回 false</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o5 = <span class="string">"Cat"</span> || <span class="string">"Dog"</span>     <span class="comment">// t || t 返回 "Cat"</span></span><br><span class="line">o6 = <span class="literal">false</span> || <span class="string">"Cat"</span>     <span class="comment">// f || t 返回 "Cat"</span></span><br><span class="line">o7 = <span class="string">"Cat"</span> || <span class="literal">false</span>     <span class="comment">// t || f 返回 "Cat"</span></span><br><span class="line">o8 = <span class="string">''</span>    || <span class="literal">false</span>     <span class="comment">// f || f 返回 false</span></span><br><span class="line">o9 = <span class="literal">false</span> || <span class="string">''</span>        <span class="comment">// f || f 返回 ""</span></span><br></pre></td></tr></table></figure><h4 id="8、运算符的优先级"><a href="#8、运算符的优先级" class="headerlink" title="8、运算符的优先级"></a>8、运算符的优先级</h4><table><thead><tr><th style="text-align:center">操作符分类</th><th style="text-align:center">操作符</th></tr></thead><tbody><tr><td style="text-align:center">算 术 操 作 符</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">++</td><td style="text-align:center">(自增)</td></tr><tr><td style="text-align:center">––</td><td style="text-align:center">(自减)</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">(乘法)</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">(除法)</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">(求余)</td></tr><tr><td style="text-align:center"><strong>&amp;&amp;</strong></td><td style="text-align:center"><strong>（逻辑与）</strong></td></tr><tr><td style="text-align:center">**\</td><td style="text-align:center">\</td><td>**</td><td><strong>(逻辑或)</strong></td></tr><tr><td style="text-align:center"><strong>!</strong></td><td style="text-align:center"><strong>(逻辑非)</strong></td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">(左移) 将第一操作数的二进制形式的每一位向左移位，所移位的数目由第二操作数指定。右面的空位补零。</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">(算术右移) 将第一操作数的二进制形式的每一位向右移位，所移位的数目由第二操作数指定。忽略被移出的位。</td></tr><tr><td style="text-align:center">&gt;&gt;&gt;</td><td style="text-align:center">(逻辑右移) 将第一操作数的二进制形式的每一位向右移位，所移位的数目由第二操作数指定。忽略被移出的位，左面的空位补零。</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">赋值操作符</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">相等的话返回真</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">如果操作数不相等的话则返回真。</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">如果左操作数大于右操作数的话则返回真。</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">如果左操作数大于等于右操作数的话则返回真。</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">如果左操作数小于右操作数的话则返回真。</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">如果左操作数小于等于右操作数的话则返回真。</td></tr></tbody></table><h4 id="8、如何正确判断-this？箭头函数的-this-是什么？"><a href="#8、如何正确判断-this？箭头函数的-this-是什么？" class="headerlink" title="8、如何正确判断 this？箭头函数的 this 是什么？"></a>8、如何正确判断 this？箭头函数的 this 是什么？</h4><p>① 三种 this 场景：</p><ul><li>全局调用函数，内部的 this 永远指向 windows 。</li><li>对象调用函数，谁调用 this ，this 就指向谁。</li><li>new 的方式，this 永远绑定在 new 出的对象。</li></ul><p>② 箭头函数中的 this：</p><ul><li>箭头函数中是没有 this 的。</li><li>箭头函数中的 this 是指向包裹箭头函数的第一个函数的。</li></ul><p>③ bind 中的 this：</p><ul><li><code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.bind(a) <span class="comment">// 函数.bind(参数)</span></span><br></pre></td></tr></table></figure><p>④ 多种规则出现的优先级</p><blockquote><p>箭头函数一旦绑定了 this，就不会被人和方式所改变。</p></blockquote><p>new ——&gt; bind ——&gt; obj.foo() ——&gt; 全局调用。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16717eaf3383aae8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h4 id="8、call-、apply、bind-的区别"><a href="#8、call-、apply、bind-的区别" class="headerlink" title="8、call 、apply、bind 的区别"></a>8、call 、apply、bind 的区别</h4><blockquote><p>三者可以方便理解为：第一个参数调用了该方法，并将第二个参数作为该方法的参数传入。</p></blockquote><p><strong>共同点：</strong></p><p>① apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的；</p><p>② apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；</p><p>③ apply 、 call 、bind 三者都可以利用后续参数传参；</p><p><strong>不同点：</strong></p><p>①  call 顺序传参，而 apply 是数组传参。</p><p>② bind 的 <code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</p><p>③ bind 是返回对应函数（<strong>需要加一对花括号进行调用</strong>），便于稍后调用；apply 、call 则是立即调用 。</p><h4 id="9、call、apply-及-bind-函数内部实现是怎么样的？"><a href="#9、call、apply-及-bind-函数内部实现是怎么样的？" class="headerlink" title="9、call、apply 及 bind 函数内部实现是怎么样的？"></a>9、call、apply 及 bind 函数内部实现是怎么样的？</h4><h6 id="▉-Call-的内部实现"><a href="#▉-Call-的内部实现" class="headerlink" title="▉ Call 的内部实现"></a>▉ Call 的内部实现</h6><ul><li>首先 <code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></li><li>接下来给 <code>context</code> 创建一个 <code>fn</code> 属性，并将值设置为需要调用的函数</li><li>因为 <code>call</code> 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来</li><li>然后调用函数并将对象上的函数删除</li></ul><blockquote><p><strong>※ 手写一个 call 方法：</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this 为调用的函数</span></span><br><span class="line"><span class="comment">// context 是参数对象</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断调用者是否为函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不传参默认为 window</span></span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">// 新增 fn 属性,将值设置为需要调用的函数</span></span><br><span class="line">    context.fn = <span class="keyword">this</span> </span><br><span class="line">    <span class="comment">// 将 arguments 转化为数组将 call 的传参提取出来  [...arguments]</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 传参调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">    <span class="comment">// 删除函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">" "</span>+age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'小鹿'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数的 call 方法</span></span><br><span class="line">print.myCall(obj,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h6 id="▉-apply-的内部实现"><a href="#▉-apply-的内部实现" class="headerlink" title="▉ apply 的内部实现"></a>▉ apply 的内部实现</h6><ul><li>首先 <code>context</code> 为可选参数，如果不传的话默认上下文为 <code>window</code></li><li>接下来给 <code>context</code> 创建一个 <code>fn</code> 属性，并将值设置为需要调用的函数</li><li>因为 <code>apply</code> 传参是数组传参，所以取得数组，将其剥离为顺序参数进行函数调用</li><li>然后调用函数并将对象上的函数删除</li></ul><blockquote><p><strong>※ 手写一个 apply 方法：</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写一个 apply 方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断调用者是否为函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不传参默认为 window</span></span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">// 新增 fn 属性,将值设置为需要调用的函数</span></span><br><span class="line">    context.fn = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="comment">// 判断是否有参数传入</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">        result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = context.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除函数</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="comment">// 返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">age,age2,age3</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">" "</span>+ age + <span class="string">" "</span>+ age2+<span class="string">" "</span>+age3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'小鹿'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数的 call 方法</span></span><br><span class="line">print.myApply(obj,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h6 id="▉-apply-的内部实现-1"><a href="#▉-apply-的内部实现-1" class="headerlink" title="▉ apply 的内部实现"></a>▉ apply 的内部实现</h6><ul><li>判断调用者是否为函数。</li><li>截取参数，注意：这里有两种形式传参。</li><li>返回一个函数，判断外部哪种方式调用了该函数（new | 直接调用）</li></ul><blockquote><p> <strong>※ 手写一个 bind方法：</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写一个 bind 函数</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断调用者是否为函数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 截取传递的参数</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// _this 指向调用的函数</span></span><br><span class="line">    <span class="keyword">const</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">        <span class="comment">// 对于 new 的情况来说，不会被任何方式改变 this</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(...args,...arguments)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _this.apply(context,args.concat(...arguments))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// new 的方式调用 bind 参数输出换做 [...arguments]</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'小鹿'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数的 call 方法</span></span><br><span class="line"><span class="keyword">let</span> F = print.myBind(obj,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 返回对象</span></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> F();</span><br><span class="line"><span class="built_in">console</span>.log(obj1);</span><br></pre></td></tr></table></figure><h4 id="10、-和-有什么区别？"><a href="#10、-和-有什么区别？" class="headerlink" title="10、== 和 === 有什么区别？"></a>10、== 和 === 有什么区别？</h4><blockquote><p>== 如果类型不相同，则先进行类型转换。=== 判断两者的<strong>类型和值</strong>是否相同。</p></blockquote><p><strong>① == 比较规则</strong></p><ul><li>若类型相同，则直接比较大小；类型不同，先进行转换。</li><li>判断 null == undefined 返回 true。</li><li>判断 string 和 number 时，将字符换转化为 number。</li><li>判断其中一方为 boolean 值时，将 boolean 转化为 number。</li><li>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/19/167c4a2627fe55f1?imageslim" alt="img"></p><h4 id="11、闭包有关面试题？"><a href="#11、闭包有关面试题？" class="headerlink" title="11、闭包有关面试题？"></a>11、闭包有关面试题？</h4><blockquote><p>要想完全掌握闭包，一定要清楚函数作用域、内存回收机制、作用域继承</p></blockquote><p><strong>① 什么是闭包？</strong></p><blockquote><p><strong>闭包</strong>是有权限访问其他函数作用域内的变量的一个函数。</p></blockquote><p><strong>② 闭包为什么可以有权访问到？</strong></p><blockquote><p>在 js 中，变量的作用域属于函数域，当函数执行完毕时，作用域就会被清理，内存被回收。但是闭包是建立在一个函数的内部的子函数，可以访问上级作用域，上级函数执行完后，作用域不会销毁，所以闭包可以访问上级作用域的权限，上级函数执行完后作用域内的值也不会销毁。</p></blockquote><p><strong>③ 闭包解决了什么？</strong></p><blockquote><p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的 Ajax 成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p></blockquote><p><strong>④ 闭包有哪些应用场景？</strong></p><blockquote><p>闭包随处可见，一个 Ajax 请求的成功回调，一个事件绑定的回调方法，一个 setTimeout 的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p></blockquote><p><strong>⑤ 经典面试题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(j)&#125;,j*<span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12、立即执行函数"><a href="#12、立即执行函数" class="headerlink" title="12、立即执行函数"></a>12、立即执行函数</h4><p><strong>① 什么是立即执行函数</strong></p><blockquote><p>声明一个匿名函数，并立即执行。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一：</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'我是匿名函数'</span>)&#125;)()</span><br><span class="line"><span class="comment">// 写法二：</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'我是匿名函数'</span>)&#125;())</span><br></pre></td></tr></table></figure><p><strong>② 立即执行函数有什么作用？</strong></p><blockquote><p>js 没有块级作用域，创建一个独立的作用域，用来隔离作用域避免污染。</p></blockquote><p><strong>③ 经典面试题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13、什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？"><a href="#13、什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？" class="headerlink" title="13、什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？"></a>13、什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？</h4><blockquote><p>对象赋值其实复制了地址，一方改动会导致另一方的值也改动。可以通过浅拷贝来解决这个问题。</p></blockquote><p><strong>① 浅拷贝 </strong></p><h6 id="▉-Object-assign"><a href="#▉-Object-assign" class="headerlink" title="▉ Object.assign()"></a>▉ Object.assign()</h6><blockquote><p>Object.assign()  可以实现一个浅拷贝，将 <code>source</code> 的所有属性值拷贝到 <code>target</code> 新对象中。如果属性是对象的话，拷贝的是地址。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="▉-扩展运算符"><a href="#▉-扩展运算符" class="headerlink" title="▉ ... 扩展运算符"></a>▉ <code>...</code> 扩展运算符</h6><blockquote><p>扩展运算符也可以实现一个浅拷贝。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123; ...a &#125;</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h6 id="▉实现一个浅克隆"><a href="#▉实现一个浅克隆" class="headerlink" title="▉实现一个浅克隆"></a>▉<strong>实现一个浅克隆</strong></h6><blockquote><p>自己实现一个浅拷贝，和上边的两种实现没什么差别。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 实现浅克隆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> o)&#123;</span><br><span class="line">        obj[i] = o[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② 深克隆</strong></p><blockquote><p>对于多层嵌套的对象，浅克隆就是失去了作用。</p></blockquote><h6 id="▉-序列-反序列化（parse-stringify）"><a href="#▉-序列-反序列化（parse-stringify）" class="headerlink" title="▉ 序列/反序列化（parse/stringify）"></a>▉ 序列/反序列化（parse/stringify）</h6><p><strong>序列化：</strong>把变量从内存中变成可存储或传输的过程称之为序列化。stringify 方法可以将 JS 对象序列化成 JSON 字符串。</p><p><strong>反序列化：</strong>把变量内容从序列化的对象重新读到内存里称之为反序列化。JSON对象parse 方法可以将 JSON 字符串反序列化成 JS 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(oldObj));</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><p>1、无法实现对函数、RegExp 等特殊对象的克隆。</p><p>2、会抛弃对象的 constructor，所有的构造函数会指向 Object。</p><p>3、对象有循环引用，会报错。</p><h6 id="▉-实现一个深克隆函数"><a href="#▉-实现一个深克隆函数" class="headerlink" title="▉ 实现一个深克隆函数"></a>▉ 实现一个深克隆函数</h6><blockquote><p>序列/反序列化不可能实现了，所以实现一个对象类型判断函数。要面对不同的对象(正则、数组、Date等)要采用不同的处理方式。推荐使用 lodash 函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isType = <span class="function">(<span class="params">obj, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> typeString = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line">  <span class="keyword">let</span> flag;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Array'</span>:</span><br><span class="line">      flag = typeString === <span class="string">'[object Array]'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Date'</span>:</span><br><span class="line">      flag = typeString === <span class="string">'[object Date]'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'RegExp'</span>:</span><br><span class="line">      flag = typeString === <span class="string">'[object RegExp]'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(isType(arr, <span class="string">'Array'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="14、Object-和-Function-的关系"><a href="#14、Object-和-Function-的关系" class="headerlink" title="14、Object 和 Function 的关系"></a>14、Object 和 Function 的关系</h4><blockquote><p>① 所有的构造函数的 <code>_proto_</code>  包括 <code>Object</code> 和 <code>Function</code> 本身都指向 <code>Function.prototype</code>。（可以理解为所有的构造函数都是 <code>Function</code> 的实例）。</p><p>② 因为所有的对象实例的 <code>_proto_</code> 都指向 <code>Object.prototype</code> ，又因为所有的原型对象都是 Object 的实例，包括 <code>Function</code> 的原型 <code>Function.prototype</code> ，所以 <code>Function.prototype</code> 也指向 <code>Object.prototype</code>。</p><p>③ <code>Object.prototype</code> 的 <code>_proto_</code> 最终指向 <code>null</code>。</p></blockquote><p>er<img src="https://img-blog.csdn.net/20151118103413727?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="JavascriptçPrototype,Function,Object,__proto__å³ç³»ç¤ºæå¾"></p><h4 id="15、你理解的原型是什么？"><a href="#15、你理解的原型是什么？" class="headerlink" title="15、你理解的原型是什么？"></a>15、你理解的原型是什么？</h4><blockquote><p>每个 JS 对象都有一个 _proto_ 属性，这个属性指向了原型。原型中定义了很多属性和函数，其中的 <code>constructor</code> 属性指向构造函数，构造函数又通过 <code>prototype</code> 属性指回原型，这个属性和  <code>_proto_</code> 属性指向是同一原型。并不是所有的函数都具有 <code>prototype</code> 的属性，<code>bind</code>函数就没有。</p></blockquote><h4 id="16、如何理解原型链？"><a href="#16、如何理解原型链？" class="headerlink" title="16、如何理解原型链？"></a>16、如何理解原型链？</h4><blockquote><p>所谓的原型链就是多个对象通过  <code>__proto__</code> 的方式连接了起来形成一条链。</p></blockquote><h4 id="17、说说-js-中的继承？"><a href="#17、说说-js-中的继承？" class="headerlink" title="17、说说 js 中的继承？"></a>17、说说 js 中的继承？</h4><blockquote><h6 id="ES5-中的继承："><a href="#ES5-中的继承：" class="headerlink" title="ES5 中的继承："></a>ES5 中的继承：</h6></blockquote><h5 id="1、经典继承（构造函数）"><a href="#1、经典继承（构造函数）" class="headerlink" title="1、经典继承（构造函数）"></a>1、经典继承（构造函数）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/ 详细解析</span><br><span class="line"><span class="comment">//1、当用调用 call 方法时，this 带边 son 。</span></span><br><span class="line"><span class="comment">//2、此时 Father 构造函数中的 this 指向 son。</span></span><br><span class="line"><span class="comment">//3、也就是说 son 有了 colors 的属性。</span></span><br><span class="line"><span class="comment">//4、每 new 一个 son ，都会产生不同的对象，每个对象的属性都是相互独立的。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// this 是通过 new 操作内部的新对象 &#123;&#125; ，</span></span><br><span class="line">    <span class="comment">// 此时 Father 中的 this 就是为 Son 中的新对象&#123;&#125;</span></span><br><span class="line">    <span class="comment">// 新对象就有了新的属性，并返回得到 new 的新对象实例</span></span><br><span class="line">    <span class="comment">// 继承了Father,且向父类型传递参数</span></span><br><span class="line">Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(s.color)</span><br></pre></td></tr></table></figure><p>① 基本思想：在子类的构造函数的内部调用父类的构造函数。</p><p>② 优点：</p><ul><li><p>保证了原型链中引用类型的独立，不被所有实例共享。</p></li><li><p>子类创建的时候可以向父类进行传参。</p></li></ul><p>③ 缺点:</p><ul><li>继承的方法都在构造函数中定义，构造函数不能够复用了（因为构造函数中存在子类的特殊属性，所以构造函数中复用的属性不能复用了）。</li><li>父类中定义的方法对于子类型而言是不可见的（子类所有的属性都定义在父类的构造函数当中）。</li></ul><h5 id="2、组合继承"><a href="#2、组合继承" class="headerlink" title="2、组合继承"></a>2、组合继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法定义在原型对象上（共享）</span></span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 子类继承父类的属性  </span></span><br><span class="line">Father.call(<span class="keyword">this</span>,name);     <span class="comment">//继承实例属性，第一次调用 Father()</span></span><br><span class="line">    <span class="comment">// 每个实例都有自己的属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类和父类共享的方法（实现了父类属性和方法的复用）                              </span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();   <span class="comment">//继承父类方法,第二次调用 Father()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类实例对象共享的方法</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"louis"</span>,<span class="number">5</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();<span class="comment">//louis</span></span><br><span class="line">instance1.sayAge();<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son(<span class="string">"zhai"</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green"</span></span><br><span class="line">instance1.sayName();<span class="comment">//zhai</span></span><br><span class="line">instance1.sayAge();<span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>① 基本思想：</p><ul><li>使用<strong>原型链</strong>实现对<strong>「原型对象属性和方法」</strong>的继承。</li><li>通过借用<strong>构造函数</strong>来实现对<strong>「实例属性」</strong>的继承。</li></ul><p>② 优点：</p><ul><li>在原型对象上定义的方法实现了函数的复用。</li><li>每个实例都有属于自己的属性。</li></ul><p>③ 缺点：</p><ul><li>组合继承调用了两次父类的构造函数，造成了不必要的消耗。</li></ul><h5 id="3、原型继承"><a href="#3、原型继承" class="headerlink" title="3、原型继承"></a>3、原型继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">F.prototype = o;</span><br><span class="line">    <span class="comment">// 每次返回的 new 是不同的</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">friends : [<span class="string">"Van"</span>,<span class="string">"Louis"</span>,<span class="string">"Nick"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例 1</span></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例 2</span></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Style"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都添加至原型对象的属性(所共享)</span></span><br><span class="line">alert(person.friends); <span class="comment">// "Van,Louis,Nick,Rob,Style"</span></span><br></pre></td></tr></table></figure><p><strong>① 基本思想：</strong>创建临时性的构造函数（无任何属性），将传入的对象作为该构造函数的原型对象，然后返回这个新构造函数的实例。</p><p><strong>② 浅拷贝：</strong></p><blockquote><p><code>object</code> 所产生的对象是不相同的，但是原型对象都是 <code>person</code> 对象，所改变存在原型对象的属性所有生成的实例所共享，不仅被 <code>Person</code> 所拥有，而且被子类生成的实例所共享。</p></blockquote><p>③ <strong>object.create()：</strong>在 ECMAScript5 中,通过新增 <strong>object.create()</strong> 方法规范化了上面的原型式继承.。</p><ul><li>参数一：新对象的原型的对象。</li><li>参数二：先对象定义额外的属性（可选）。</li></ul><h5 id="4、寄生式继承"><a href="#4、寄生式继承" class="headerlink" title="4、寄生式继承"></a>4、寄生式继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用object函数创建一个新对象</span></span><br><span class="line">clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>① 基本思想：</strong>同样调用 object 函数，将返回的对象和对象的额外的方法和属性封装成一个函数进行返回。</p><p><strong>② 缺点：</strong>寄生式继承将对象封装起来，导致不能做到函数的复用，使得效率降低。</p><h5 id="5、寄生组合式继承"><a href="#5、寄生组合式继承" class="headerlink" title="5、寄生组合式继承"></a>5、寄生组合式继承</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数分别为子类和父类的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass,superClass</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> prototype = object(superClass.prototype);<span class="comment">//创建对象</span></span><br><span class="line">    <span class="comment">// 下面这两部为子类的构造函数指定原型对象</span></span><br><span class="line">    <span class="comment">// 让原型对象的 constructor 指向子类</span></span><br><span class="line">prototype.constructor = subClass;</span><br><span class="line">    <span class="comment">// 为子类构造函数指定原型对象</span></span><br><span class="line">subClass.prototype = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 基本思想：不必为了指定子类型的原型而调用超类型的构造函数（避免第二次调用的构造函数）。</p><p>② 优点：寄生组合式继承就是为了解决组合继承中两次调用构造函数的开销。</p><h4 id="19、new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？以及-new-和-Object-create-null-创建对象的区别？"><a href="#19、new-的原理是什么？通过-new-的方式创建对象和通过字面量创建有什么区别？以及-new-和-Object-create-null-创建对象的区别？" class="headerlink" title="19、new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？以及 new 和 Object.create(null) 创建对象的区别？"></a>19、new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？以及 new 和 Object.create(null) 创建对象的区别？</h4><blockquote><p>new 操作符的过程其实就是一个创建空对象，为空对象添加属性，为对象链接原型链，返回对象。</p></blockquote><h6 id="▉-new-的原理："><a href="#▉-new-的原理：" class="headerlink" title="▉ new 的原理："></a>▉ new 的原理：</h6><p>① 新生成一个对象；</p><p>② 链接到原型；</p><p>③ 绑定 this；</p><p>④ 返回新对象。</p><h6 id="▉-new-创建对象和字面量创建对象的区别"><a href="#▉-new-创建对象和字面量创建对象的区别" class="headerlink" title="▉  new 创建对象和字面量创建对象的区别"></a>▉  new 创建对象和字面量创建对象的区别</h6><p><strong>共同点：</strong></p><ul><li>对于对象，其实都是通过 <code>new Object()</code> 产生的。</li></ul><p><strong>不同点：</strong></p><blockquote><p>推荐使用字面量的方式创建对象，简单，方便。</p></blockquote><ul><li>通过 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层的找到 <code>Object</code> 。</li><li>字面量的方式创建对象就没有以上问题。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// function 就是个语法糖</span></span><br><span class="line"><span class="comment">// 内部等同于 new Function()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 这个字面量内部也是使用了 new Object()</span></span><br></pre></td></tr></table></figure><h6 id="▉-Object-create-null-创建对象"><a href="#▉-Object-create-null-创建对象" class="headerlink" title="▉ Object.create(null) 创建对象"></a>▉ Object.create(null) 创建对象</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(proto, [propertiesObject]);</span><br></pre></td></tr></table></figure><ul><li>proto：新创建对象的原型对象。</li><li>propertiesObject：（可选）可为创建的新对象设置属性和值。</li></ul><h6 id="▉-Object-create-一般用于继承"><a href="#▉-Object-create-一般用于继承" class="headerlink" title="▉  Object.create() 一般用于继承"></a>▉  Object.create() 一般用于继承</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> People = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">People.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  People.call(<span class="keyword">this</span>, name);  <span class="comment">// 使用call，实现了People属性的继承</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Object.create()方法，实现People原型方法的继承，并且修改了constructor指向</span></span><br><span class="line">Person.prototype = <span class="built_in">Object</span>.create(People.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: Person,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Person.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'person1'</span>, <span class="number">25</span>);</span><br><span class="line"> </span><br><span class="line">p1.sayName();  <span class="comment">//'person1'</span></span><br><span class="line">p1.sayAge();   <span class="comment">//25</span></span><br></pre></td></tr></table></figure><h6 id="▉-new-字面量-与-Object-create-创建对象的区别"><a href="#▉-new-字面量-与-Object-create-创建对象的区别" class="headerlink" title="▉  new/字面量 与 Object.create() 创建对象的区别"></a>▉  new/字面量 与 Object.create() 创建对象的区别</h6><ul><li>new  和 字面量创建的对象的原型指向 Object.prototype，会继承Object的属性和方法。</li><li>而通过 Object.create(null) 创建的对象，其原型指向 null，null作为原型链的顶端，没有也不会继承任何属性和方法。</li></ul><h6 id="▉-手写实现一个-new-操作符"><a href="#▉-手写实现一个-new-操作符" class="headerlink" title="▉  手写实现一个 new 操作符"></a>▉  手写实现一个 new 操作符</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 生成对象的过程</span></span><br><span class="line"><span class="comment">// 1、生成新对象</span></span><br><span class="line"><span class="comment">// 2、链接到原型</span></span><br><span class="line"><span class="comment">// 3、绑定 this</span></span><br><span class="line"><span class="comment">// 4、返回新对象</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// 1、Con: 接收一个构造函数</span></span><br><span class="line"><span class="comment">// 2、args：传入构造函数的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">Con, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建空对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 设置空对象的原型(链接对象的原型)</span></span><br><span class="line">    obj._proto_ = Con.prototype;</span><br><span class="line">    <span class="comment">// 绑定 this 并执行构造函数(为对象设置属性)</span></span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj,args)</span><br><span class="line">    <span class="comment">// 如果 result 没有其他选择的对象，就返回 obj 对象</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ?  result : obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个 new 操作符</span></span><br><span class="line"><span class="keyword">const</span> a = create(Test,<span class="string">'小鹿'</span>,<span class="string">'23'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.age)</span><br></pre></td></tr></table></figure><h4 id="20、instanceof-的原理是什么？"><a href="#20、instanceof-的原理是什么？" class="headerlink" title="20、instanceof 的原理是什么？"></a>20、instanceof 的原理是什么？</h4><blockquote><p><code>instanceof</code> 可以正确的判断<strong>对象的类型</strong>，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p></blockquote><h6 id="▉-手写实现一个-instanceof"><a href="#▉-手写实现一个-instanceof" class="headerlink" title="▉ 手写实现一个 instanceof"></a>▉ 手写实现一个 instanceof</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span> || left === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (prototype === left)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="21、为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#21、为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="21、为什么 0.1 + 0.2 != 0.3？如何解决这个问题？"></a>21、为什么 0.1 + 0.2 != 0.3？如何解决这个问题？</h4><h6 id="▉-原因"><a href="#▉-原因" class="headerlink" title="▉ 原因"></a>▉ 原因</h6><p>① 因为 JS 采用的是 IEEE 754 双精度版本（64）位，采用该版本的语言都存在问题。</p><p>② 计算机是通过二进制来存储东西的，那么 0.1 会在二进制内表示的是无限循环的一些数，不只是 0.1 。还有很多的十进制小数用二进制表示的是无限循环的。</p><p>③ 但是 js 采用的是浮点数标准却会裁减掉循环的数据而失去精度。也就造成了 <code>0.1</code> 不再是 <code>0.1</code> 了。而是变成了 <code>0.100000000000000002</code>。</p><p>④ 那么同样的，<code>0.2</code> 在二进制也是无限循环的，被裁剪后也失去了精度变成了 <code>0.200000000000000002</code>。</p><p>⑤ 所以这两者相加不等于 <code>0.3</code> 而是 <code>0.300000000000000004</code>。</p><p>⑥ 既然 <code>0.1</code> 不是 <code>0.1</code>，那为什么 <code>console.log(0.1)</code> 却是正确的呢？在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// (0011) 表示循环</span><br><span class="line">0.1 = 2^-4 * 1.10011(0011)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.100000000000000002</span> === <span class="number">0.1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h6 id="▉-解决问题"><a href="#▉-解决问题" class="headerlink" title="▉ 解决问题"></a>▉ 解决问题</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).toFixed(<span class="number">10</span>)) === <span class="number">0.3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="ES6-知识点总结"><a href="#ES6-知识点总结" class="headerlink" title="ES6 知识点总结"></a>ES6 知识点总结</h2><h4 id="1、什么是提升？什么是暂时性死区？var、let-及-const-区别？"><a href="#1、什么是提升？什么是暂时性死区？var、let-及-const-区别？" class="headerlink" title="1、什么是提升？什么是暂时性死区？var、let 及 const 区别？"></a>1、什么是提升？什么是暂时性死区？var、let 及 const 区别？</h4><p><strong>※ 答✔：什么是提升？</strong></p><p>1）所谓的提升就是虽然变量没有声明，但是可以使用这个未声明的变量。</p><p>2）函数也有提升并且优先于变量的提升。函数提升会把整个函数挪到作用域顶部。</p><p>3）<code>var</code> 的变量会被提升到作用域的顶部。</p><p><strong>※ 答✔：什么是暂时性死区？</strong></p><p>1）如果使用 <code>let</code>、<code>const</code> 声明变量，在声明之前就是用了变量就会报错，报错的原因就是暂时性死区。这里的提升和 <code>var</code> 是有区别的，虽然变量在编译的环节中被告知在这块作用域中可以访问，但是访问是受限制的。</p><p><strong>※ 答✔：var、let 及 const 区别？</strong></p><p>1）<code>var</code> 在全局作用域下声明变量会导致变量挂载在 <code>window</code> 上，其他两者不会</p><p>2）<code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值。</p><p><strong>※ 扩展✔：为什么或存在提升？</strong></p><p>1）根本原因就是为了解决函数间互相调用的情况。</p><h4 id="2、原型如何实现继承？Class-如何实现继承？Class-本质是什么？"><a href="#2、原型如何实现继承？Class-如何实现继承？Class-本质是什么？" class="headerlink" title="2、原型如何实现继承？Class 如何实现继承？Class 本质是什么？"></a>2、原型如何实现继承？Class 如何实现继承？Class 本质是什么？</h4><p><strong>※ 答✔：原型如何实现继承？</strong></p><p>1）组合继承、寄生组合继承、Class 继承  原文链接：<a href="http://luxiangqiang.xn--6qq986b3xl/2019/04/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF%E3%80%91/" target="_blank" rel="noopener">JavaScript 中的原型链和继承</a></p><p><strong>※ 答✔：Class 如何实现继承？</strong></p><p>1）<code>Class</code> 实现继承主要使用 <code>extends</code> 来明确继承自哪个父类，并且再子类中调用 <code>super</code>，可以将这段代码看做 <code>Parent.call(this,value)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>※ 答✔：Class 本质是什么？</strong></p><p>1）js 中并不存在类，Class 只是语法糖，Class 的本质还是函数。</p><h4 id="3、什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？"><a href="#3、什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？" class="headerlink" title="3、什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？"></a>3、什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</h4><p><strong>※ 答✔：为什么使用模块化？</strong></p><blockquote><p>通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。 </p></blockquote><ul><li>解决命名冲突</li><li>提供复用性</li><li>提高代码可维护性</li></ul><p><strong>※ 答✔：都有哪几种方式可以实现模块化？</strong></p><p><strong>① 立即执行函数（IIFE）</strong></p><blockquote><p>立即执行函数中的匿名函数中有独立的 词法作用域，避免了外界访问此作用域的变量。<strong>通过函数作用域解决了命名冲突、污染全局作用域的问题</strong> 。</p></blockquote><p><strong>② AMD 和 CMD</strong></p><ul><li><p><strong>AMD</strong> </p><blockquote><p>AMD 采用异步的加载方式，加载之后不影响它后面语句的运行。require.js 实现 AMD 规范的模块化 ， <code>require.config()</code> 指定引用路径等，用 <code>define()</code> 定义模块，用 <code>require()</code> 加载模块。</p></blockquote></li><li><p><strong>CMD </strong></p><blockquote><p>CMD 的不同点在于推崇依赖前置、提前执行，CDM 推崇依赖就近、延迟执行。</p></blockquote></li></ul><p><strong>③ CommonJS</strong></p><ul><li><p><code>CommonJS</code> 的规范主要用在 <code>Node.js</code> 中，为模块提供了四个接口：<code>module、exports、require、global</code>。</p></li><li><p><code>CommonJS</code> 用同步的方式加载模块（服务器端），在浏览器端使用的是异步加载模块。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对外暴露接口</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载外部模块</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter);  <span class="comment">// 3</span></span><br><span class="line">mod.incCounter();</span><br><span class="line"><span class="comment">// 原始类型的值被缓存，所以就没有被改变（commonJS 不会随着执行而去模块随时调用）</span></span><br><span class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>④ ES6 模块</strong></p><blockquote><p>ES6 实现的模块非常简单，用于浏览器和服务器端。<code>mport</code>命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码 .主要有两个命令组成：<code>export</code>和<code>import</code>:</p></blockquote><ul><li><code>export</code>命令用于规定模块的<strong>对外接口</strong>。</li><li><code>import</code>命令引入其他模块的功能。 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定指定的值暴露对外的接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块中的某个值</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="comment">// ES6 模块不同的是，静态加载完毕之后，每执行到模块中的方法，就去模块内调用（外部的变量总是与模块进行绑定的），而且值不会被缓存。</span></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong>⑤ ES6 模块与 CommonJS 模块的区别</strong></p><p><strong>1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong></p><ul><li>所谓值的拷贝，原始类型的值被缓存，不随模块内部的改变而改变。</li><li>ES6 模块是<strong>动态引用</strong>，<strong>不缓存值</strong>，模块内外是<strong>绑定</strong>的，而且是<strong>只读引用</strong>，不能修改值。ES6 的 js 引擎对脚本静态分析的时候，遇到加载命令模块 <code>import</code> ，就会生成一个只读引用，当真正用到模块里边的值的时候，就会去模块内部去取。</li></ul><p><strong>2、CommonJS 模块是运行时加载，ES6 模块是编译时加载输出接口。</strong></p><ul><li><strong>运行时加载</strong>：<code>CommonJS</code> 模块就是对象；是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 </li><li><strong>编译时加载：</strong>ES6 模块不是对象，而是通过 <code>export</code> 命令「显式指定输出的代码」。<code>import</code> 时采用静态命令的形式，即在<code>import</code>指定「加载某个输出值」，而「不是加载整个模块」，这种加载称为“编译时加载”。 </li></ul><p><strong>⑥ 总结</strong></p><ul><li>CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</li><li>AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li><li>CMD 规范与 AMD  规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重。</li><li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</strong>。</li></ul><h4 id="4、map、filter、reduce-各自有什么作用？"><a href="#4、map、filter、reduce-各自有什么作用？" class="headerlink" title="4、map、filter、reduce 各自有什么作用？"></a>4、map、filter、reduce 各自有什么作用？</h4><p><strong>※ map 有什么作用？</strong> </p><blockquote><p>map 的作用是 map 中传入一个函数，该函数会遍历该数组，对每一个元素做变换之后返回新数组。</p></blockquote><h6 id="1）该函数存在三个参数："><a href="#1）该函数存在三个参数：" class="headerlink" title="1）该函数存在三个参数："></a>1）该函数存在三个参数：</h6><ul><li>element :  对应数组的每个元素。</li><li>index : 数组元素的下标。</li><li>arr : 原数组。</li></ul><h6 id="2）代码实现"><a href="#2）代码实现" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">arr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">element,index,arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index]+<span class="number">1</span>;</span><br><span class="line">&#125;) <span class="comment">// [3,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>※ filter 有什么作用？</strong> </p><blockquote><p><code>filter</code> 的作用是也是生成一个数组，传入的函数返回值确实布尔类型，返回值为 true 的元素放入新数组，通常来筛选删除不需要的元素。</p></blockquote><h6 id="1）该函数存在三个参数：-1"><a href="#1）该函数存在三个参数：-1" class="headerlink" title="1）该函数存在三个参数："></a>1）该函数存在三个参数：</h6><ul><li>element :  对应数组的每个元素。</li><li>index : 数组元素的下标。</li><li>arr : 原数组。</li></ul><h6 id="2）代码实现-1"><a href="#2）代码实现-1" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr = array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> element != <span class="number">6</span>;</span><br><span class="line">&#125;)<span class="comment">// [1,2,4]</span></span><br></pre></td></tr></table></figure><p><strong>※ reduce 有什么作用？</strong> </p><blockquote><p>reduce 可以将数组中的元素通过回调函数最终转换为一个值。</p></blockquote><h6 id="1）传入-reduce-两个参数："><a href="#1）传入-reduce-两个参数：" class="headerlink" title="1）传入 reduce 两个参数："></a>1）传入 reduce 两个参数：</h6><ul><li>回调函数<ul><li>accum：累计值(第一次的值代表初始化的值)。</li><li>element：当前元素。</li><li>index：当前索引。</li><li>arr：原数组。</li></ul></li><li>初始值</li></ul><h6 id="2）代码实现-2"><a href="#2）代码实现-2" class="headerlink" title="2）代码实现"></a>2）代码实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">acc,element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> acc + element;</span><br><span class="line">&#125;,<span class="number">0</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h6 id="3）reduce-的执行过程"><a href="#3）reduce-的执行过程" class="headerlink" title="3）reduce 的执行过程"></a>3）reduce 的执行过程</h6><ul><li>初始值为 0 ，该值会传入第一次回调函数。</li><li>回到函数接收四个值，第一个值是累计值。</li><li>第一次执行回调函数将「初始值」和「当前值」做运算。</li><li>然后将结果值传入第二次执行的回调函数。</li><li>第二次回调函数会和当前值再做运算。</li></ul><h4 id="5、Proxy-可以实现什么功能？"><a href="#5、Proxy-可以实现什么功能？" class="headerlink" title="5、Proxy 可以实现什么功能？"></a>5、Proxy 可以实现什么功能？</h4><blockquote><p>Proxy 中文意思代理，可以用来自定义对象中的操作。</p><p>① 如果设置了拦截操作，那么访问目标对象时被拦截。</p><p>② 如果没有设置拦截操作，但是生成了 Proxy 的实例，那么可以正常访问到原始值。</p></blockquote><h6 id="▉-格式"><a href="#▉-格式" class="headerlink" title="▉ 格式"></a>▉ 格式</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><ul><li>target：所要拦截的目标对象。</li><li>handle：设置拦截的行为。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端 js、css、vue等面试题解答汇总。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法之递归系列</title>
    <link href="http://yoursite.com/2019/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/12/数据结构与算法之递归系列/</id>
    <published>2019-05-12T00:38:25.297Z</published>
    <updated>2019-05-28T12:37:37.985Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据结构与算法之递归系列，题目详细解析！</p><a id="more"></a><h2 id="数据结构与算法之递归系列"><a href="#数据结构与算法之递归系列" class="headerlink" title="数据结构与算法之递归系列"></a>数据结构与算法之递归系列</h2><p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几个月之前就想写这样一篇文章分享给大家，由于自己有心而力不足，没有把真正的学到的东西沉淀下来，所以一直在不断的自学。可能是因为在一所三流大学，资源也比较少，只能自己在网搜索相关资料，在互联网上遇到了一些朋友的帮助下去深入理解，然后自己抽出大量时间做题总结、归纳，才会把已有的知识概念所被自己吸收和理解，形成了自己的技术思想体系。</p><p>然后自己又了用了一个星期的时间去整理、分类，才有了这篇 8000 字有关递归的分享，希望能够帮助正在学习递归的小伙伴们。而且有了这篇文章的支撑和动力，往后还会写出关于数据结构与算法一些难懂的概念简单化。如果文章中有错误的地方，希望大家指正，能够为他人分享出更有质量的文章！</p><h2 id="为什么要写这篇递归文章"><a href="#为什么要写这篇递归文章" class="headerlink" title="为什么要写这篇递归文章"></a>为什么要写这篇递归文章</h2><p>看了很多关于递归的文章，也总结了很多递归的文章，也看了多篇文章下方读者的评论。有的读者评论到文章清晰易懂，有的却喷作者写的存在很多错误，埋怨作者写出来很垃圾，还不如不写。我想从理性的角度说一下，创作者写文章的最初好意是能够帮助别人对此知识点有进一步的了解，并不代表一定能够满足每个人的要求。</p><p>另一方面，每篇文章的作者可能理解的不够透彻，很多地方可能存在许多错误，包括理解上的错误，笔误等，这也是写文章的第二个目的，能够让别人挑出自己文章中的不足，能够达到与别人共同进步的目的，一举两得，两全其美。</p><p>接下来分享的文章是关于递归的，这篇文章不单单分享递归的一切，我觉得更重要的是向每位读者传递一个思想。思想？对的，没错！这篇文章不能说包含递归的边边角角，但是通过自己的理论上的学习和实践，有了自己的一套递归思想。</p><p>什么问题该用递归，什么问题用递归简洁，什么问题就不能使用递归解决，以及对于特定的问题用递归解决的陷阱，能不能进一步对递归进行二次优化，这些都是今天小鹿分享的内容。</p><h2 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h2><blockquote><p>递归，顾名思义，有递有归才叫递归，有递无归，有归无递那叫 “耍流氓” 。</p></blockquote><h2 id="为什么要学习递归？"><a href="#为什么要学习递归？" class="headerlink" title="为什么要学习递归？"></a>为什么要学习递归？</h2><p>我们学习一门技术也好，编程语言也好，首先学习之前我们知道它将能给我们带来什么，能帮助我们解决什么样的问题，这也是激励我们去学习它的动力所在。</p><p>从数组到链表、散列表，再到基本算法等，直到遇到递归之后，感觉非常的难理解。我相信每个人都有这种感觉，一开始觉得非常难，经历了九九八十一难之后，还是没有弄懂递归里边的猫腻，然后就自然而然的跳过了。</p><p>后来我就开始刷了一个月的 LeetCode 题，发现递归在数据结构与算法中有着一席之地，统治着江山。大部分的题都可以用递归去解决，如：二叉树的遍历、回溯算法、0-1 背包问题、深度优先遍历、回溯算法等等，我整理了至少二三十到关于递归的题，才发现递归的重要性，所以不得不重新深入递归学习，所有有了今天这篇文章。</p><h2 id="怎么理解递归的过程？"><a href="#怎么理解递归的过程？" class="headerlink" title="怎么理解递归的过程？"></a>怎么理解递归的过程？</h2><blockquote><p>上方我对递归“耍流氓”式的定义并不能让你准确的理解递归是什么，那么我们就来活生生的举个生活中的例子。</p></blockquote><h4 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h4><blockquote><p>比如你和小鹿我一样，在大学里喜欢插队打饭（作为一个三好学生，我怎么能干这种事呢？哈哈），那么队伍后边的同学本数着自己前边还有 5 个同学就改轮到自己了，由于前边同学不断的插队，这时他发现，怎么觉得自己离着打饭的窗口越来越远呢？这时如果他想知道自己在队队列中的的第几个（前提是前边不再有人插队），用递归思想来解决，我们怎么做呢？</p></blockquote><h4 id="2、“递”"><a href="#2、“递”" class="headerlink" title="2、“递”"></a>2、“递”</h4><blockquote><p>于是他问前边的同学是第几位，前边的同学也不只到呀，于是前边的同学问他前边的同学是第几位，直到前边第二个同学问到第一个正在打饭的同学是队伍的第几个（有点小尴尬）。打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？<strong>这个过程其实是就是一个递归中“递”的过程</strong>。</p></blockquote><h4 id="3、“归”"><a href="#3、“归”" class="headerlink" title="3、“归”"></a>3、“归”</h4><blockquote><p>然后前边打饭的第二个同学不耐烦的又告诉第三个同学，我是第二个，没看单我前边有个家伙正在打饭吗？然后第三个传给第四个，以后往后传，直到那位逐渐远离窗口的同学的前一个人告诉他是第几个之后，他知道了自己目前在队伍中的第几个位置。<strong>这个过程我们可以理解为递归中“归”的过程</strong>。</p></blockquote><h4 id="4、终止条件"><a href="#4、终止条件" class="headerlink" title="4、终止条件"></a>4、终止条件</h4><blockquote><p>“打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？”，在递归中，我们称为<strong>终止条件</strong>。</p></blockquote><h4 id="5、怎么理解递归？"><a href="#5、怎么理解递归？" class="headerlink" title="5、怎么理解递归？"></a>5、怎么理解递归？</h4><blockquote><p>1）问题虽然是层层递归的分析，但是用程序表示的时候，不要层层的在大脑中调用递归代码去想，这样可能会使你完全陷入到 “递” 的过程中去，“归” 的时候，归不出来了，这些都是我们交给计算机干的事情。</p><p>2）那我们在写程序的时候怎么理解递归呢？我们只找问题之间存在的关系，<strong>屏蔽掉递归的细节</strong>，具体看（五）分析。</p></blockquote><h2 id="满足递归的三个条件"><a href="#满足递归的三个条件" class="headerlink" title="满足递归的三个条件"></a>满足递归的三个条件</h2><blockquote><p>通过上方的例子，我们可以很容易的总结出满足递归的三个条件。</p></blockquote><h4 id="1、一个问题能不能分解成多个子问题来解决"><a href="#1、一个问题能不能分解成多个子问题来解决" class="headerlink" title="1、一个问题能不能分解成多个子问题来解决"></a>1、一个问题能不能分解成多个子问题来解决</h4><blockquote><p>想知道自己在队伍中的位置，将其问题分解为“每个人所处队伍中的位置”这样的多个子问题。</p></blockquote><h4 id="2、该问题是否和子问题的解决思路相同"><a href="#2、该问题是否和子问题的解决思路相同" class="headerlink" title="2、该问题是否和子问题的解决思路相同"></a>2、该问题是否和子问题的解决思路相同</h4><blockquote><p>想要知道自己当前的位置，就要问前边人所处的位置。那么前边人想要知道自己所处的位置，就要知道他前边人的位置。所以说，该问题和子问题的解决思路相同，满足第二个条件。</p></blockquote><h4 id="3、该问题是否有终止条件"><a href="#3、该问题是否有终止条件" class="headerlink" title="3、该问题是否有终止条件"></a>3、该问题是否有终止条件</h4><blockquote><p>第一个正在打饭的同学说自己是队伍中的第一人，这就是所谓的终止条件，找到终止条件之后就开始进行“归”的过程。</p></blockquote><h2 id="怎么编写递归代码？"><a href="#怎么编写递归代码？" class="headerlink" title="怎么编写递归代码？"></a>怎么编写递归代码？</h2><blockquote><p>如果你对递归有了一定的了解，上边的例子对你来说小菜一碟，下边还有更大的难度来进行挑战。那么问题分析清楚了，怎么根据问题编写出递归代码来呢？</p></blockquote><h4 id="1、写出递推公式"><a href="#1、写出递推公式" class="headerlink" title="1、写出递推公式"></a>1、写出递推公式</h4><blockquote><p>写递归公式最重要的一点就是找到该问题和子问题的关系，怎么找到之间存在的关系呢？这里我要强调注意的一点就是不要让大脑试图去想层层的递归过程，毕竟大脑的思考方式是顺势思考的（一开始学习递归总是把自己绕绕进去，归的时候，就完全乱套的）。那怎么找到每个子问题之间存在的某种关系呢？</p></blockquote><p>我们只想其中一层（第一层关系），以上述为例，如果我想知道当前队伍的位置，所以我要之前前一个人的位置，然后 <code>+1</code> 就是我的位置了。对于他在什么位置，我丝毫不用关系，而是让递归去解决他的位置。我们可以写出递推公式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(n) 代表当前我在队伍中的位置</span></span><br><span class="line"><span class="comment">// f(n-1) 代表我前边那个人的位置</span></span><br><span class="line"><span class="comment">// 递推公式</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>※ 注意：</strong>这个式子的含义就是 <code>f(n)</code> 求当前 n 这个人的位置， <code>f(n-1) + 1</code> 代表的就是前一个人的位置 <code>+ 1</code> 就是 <code>n</code> 的位置。</p></blockquote><h4 id="2、找到终止条件"><a href="#2、找到终止条件" class="headerlink" title="2、找到终止条件"></a>2、找到终止条件</h4><blockquote><p>递推公式我们很轻松的写出来了，但是没有终止条件的递推公式会永远的执行下去的，所以我们要有一个终止条件终止程序的运行。那么怎么找到终止条件呢？</p></blockquote><p>所谓的终止条件就是已知的条件，比如上述的排队打饭的例子中，第一个人正在窗口打饭，他的前边是没有人的，所以他是第一个。第一个人的位置为 1，我们应该怎么表示呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>※ 注意：</strong>有的问题终止条件不止一个哦，比如：斐波那契数列。具体问题具体分析。</p></blockquote><h4 id="3、转换递归代码"><a href="#3、转换递归代码" class="headerlink" title="3、转换递归代码"></a>3、转换递归代码</h4><blockquote><p>递推公式和终止条件我们分析出来了，那么将递推公式转化为递归代码非常容易了。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) retun <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line"><span class="keyword">return</span> f(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归的分类"><a href="#递归的分类" class="headerlink" title="递归的分类"></a>递归的分类</h2><blockquote><p>通过做大量的题，根据递归解决不同的问题，引申出来的几种解决和思考的方式。之所以将其分类，是为了能够更好的理解递归在不同的问题下起着什么作用，如：每层递归之间存在的关系、计算，以及递归枚举所有情况和面临选择性问题的递归。虽然分为了几类，但是递归的本质是一成不变的。</p></blockquote><h4 id="分类一：递归计算型"><a href="#分类一：递归计算型" class="headerlink" title="分类一：递归计算型"></a>分类一：递归计算型</h4><blockquote><p>将哪一类用递归解决的问题作为计算型呢？我简单总结了为两点，<strong>层层计算和并列计算</strong>。</p></blockquote><h5 id="1、层层计算"><a href="#1、层层计算" class="headerlink" title="1、层层计算"></a>1、层层计算</h5><blockquote><p>层层计算，顾名思义，能够用递归解决的问题都可以分为多个子问题，我们把每个子问题可以抽象成一层，子问题之间的关系可以表示为层与层之间的关系。我们通过层与层之间的计算关系用递推公式表达出来做计算，经过层层的递归，最终得到结果值。</p></blockquote><p><strong>▉ 例子：</strong></p><blockquote><p>我们再那上方排队打饭的例子来说明，我们的子问题已经分析出来了，就是我想知道当前在队伍中的位置，就是去问我前边人的位置加一就是我当前队伍的位置，这为一层。而前边这个人想知道当前自己的位置，需要用同样的解决思路，作为另一层。</p></blockquote><p>层与层之间的关系是什么（我当前队伍中的位置与前边人的位置存在什么样的关系）？这时你会说，当前是 <code>+1</code>。这个大部分人都很容易找出，既然关系确定了，然后通过递推公式很容易写出递归代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(n) 为我所在的当前层</span></span><br><span class="line"><span class="comment">// f(n-1) 为我前边的人所在的当前层</span></span><br><span class="line"><span class="comment">// + 1 是层与层之间的计算关系</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>▉ 总结：</strong></p><blockquote><p>我将以上一类递归问题命名为「递归计算型」的「层层计算类型」。</p></blockquote><p><strong>▉ 举一反三：</strong></p><blockquote><p>求年龄的问题也是层层计算类型的问题，自己尝试分析一下（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。</p><p><strong>问题一：</strong>有 5 个人坐在一起，问第 5 个人多少岁，他说比第 4 个人大 2 岁。问第 4 个人多少岁，他说比第 3 个人大2岁。问第 3 人多少岁，他说比第 2个 人大 2 岁。问第2个人多少岁，他说比第 1 个人大 2 岁。最后问第 1 个人，他说他是 10 岁。编写程序，当输入第几个人时求出其对应的年龄。</p><p><strong>问题二：</strong>单链表从尾到头一次输出结点值，用递归实现。</p></blockquote><h5 id="2、并列计算"><a href="#2、并列计算" class="headerlink" title="2、并列计算"></a>2、并列计算</h5><blockquote><p>并列计算，顾名思义，问题的解决方式是通过递归的并列计算来得到结果的。层与层之间并没有一定的计算关系，而只是简单的改变输入的参数值。</p></blockquote><p><strong>▉ 例子：</strong></p><blockquote><p>最经典的题型就是<strong>斐波那契数列</strong>。观察这样一组数据0、 1、1、2、3、5、8、13、21、34…，去除第一个和第二个数据外，其余的数据等于前两个数据之和（如：<code>2 = 1 + 1</code>，<code>8 = 3 + 5</code>，<code>34 = 21 + 13</code>）。你可以尝试着根据「满足递归的三个条件」以及「怎么写出递归代码」的步骤自己动手动脑亲自分析一下。</p></blockquote><p>我也在这里稍微做一个分析。</p><p>1）第一步：首先判断能不能将问题分解为多个子问题，上边我也分析过了，除了第一个和第二个数据，其他数据是前两个数据之和。那么前两个数据怎么知道呢？同样的解决方式，是他们前两个数之和。</p><p>2）第二步：找到终止条件，如果不断的找到前两个数之和，直到最前边三个数据 <code>0、1、1</code> 。如果递归求第一个 1 时，前边的数据不够，所以这也是我们找到的终止条件。</p><p>3）第三步：既然我们终止条件和关系找到了，递推公式也就不难写出 <code>f(n) = f(n-1) + f(n-2)</code>（n 为要求的第几个数字的值）。</p><p>4）转化为递归代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>▉ 总结：</strong></p><blockquote><p>我将上方的问题总结为并列计算型。也可以归属为层层计算的一种，只不过是 + 1 改成了加一个 f 函数自身的递归（说白了，递归的结果也是一个确切的数值）。之所谓并列计算 <code>f(n-1)</code> 和 <code>f(n-2)</code> 互不打扰，各自递归计算各的值。最后我们将其计算的结果值相加是我们最想要的结果。</p></blockquote><p><strong>▉ 举一反三：</strong></p><blockquote><p>青蛙跳台阶的问题也是一种并列计算的一种，自己尝试着根据上边的思路分析一下，实践出真知（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。</p><p><strong>问题：</strong></p><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。</p></blockquote><h4 id="分类二：递归枚举型"><a href="#分类二：递归枚举型" class="headerlink" title="分类二：递归枚举型"></a>分类二：递归枚举型</h4><blockquote><p>递归枚举型最多的应用就是回溯算法，枚举出所有可能的情况，怎么枚举所有情况呢？通过递归编程技巧进行枚举。那什么是回溯算法？比如走迷宫，从入口走到出口，如果遇到死胡同，需要回退，退回上一个路口，然后走另一岔路口，重复上述方式，直到找到出口。</p></blockquote><p>回溯算法最经典的问题又深度优先遍历、八皇后问题等，应用非常广泛，下边以八皇后问题为例子，展开分析，其他利用递归枚举型的回溯算法就很简单了。</p><h5 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h5><blockquote><p>在 8 X 8 的网格中，放入八个皇后（棋子），满足的条件是，任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，问有多少种摆放方式？</p></blockquote><p>【图片】</p><p><strong>▉ 问题分析：</strong></p><blockquote><p>要想满足任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，需要一一枚举皇后（棋子）的所有摆放情况，然后设定条件，筛选出满足条件的情况。</p></blockquote><p><strong>▉ 算法思路：</strong></p><blockquote><p>我们把问题分析清楚了之后，怎么通过递归实现回溯算法枚举八个皇后（棋子）出现的所有情况呢？</p><p>1）我们在 8 X 8 的网格中，先将第一枚皇后（棋子）摆放到第一行的第一列的位置（也就是坐标: (0,0)）。</p><p>2）然后我们在第二行安置第二个皇后（棋子），先放到第一列的位置，然后判断同一行、同一列、同一斜线是否存在另一个皇后？如果存在，则该位置不合适，然后放到下一列的位置，然后在判断是否满足我们设定的条件。</p><p>3）第二个皇后（棋子）找到合适的位置之后，然后在第三行放置第三枚棋子，依次将八个皇后放到合适的位置。</p><p>4）这只是一种可能，因为我设定的第一个皇后是固定位置的，在网格坐标的（0,0） 位置，那么怎么枚举所有的情况呢？然后我们不断的改变第一个皇后位置，第二个皇后位置…… ，就可以枚举出所有的情况。如果你和我一样，看了这个题之后，如果还有点懵懵懂懂，那么直接分析代码吧。</p></blockquote><p><strong>▉ 代码实现：</strong></p><blockquote><p>虽然是用 <code>javascript</code> 实现的代码，相信学过编程的小伙伴基本的代码逻辑都可以看懂。根据上方总结的递归分析满足的三个条件以及怎么写出递归代码的步骤，一步步来分析八皇后问题。</p></blockquote><p>1、将问题分解为多个子问题</p><blockquote><p>在上述的代码分析和算法思路分析中，我们可以大体知道怎么分解该问题了，枚举出八个皇后（棋子）所有的满足情况可以分解为，先寻找每一种满足的情况这种子问题。比如，每个子问题的算法思路就是上方列出的四个步骤。</p></blockquote><p>2、找出终止条件</p><blockquote><p>当遍历到第八行的时候，递归结束。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">if</span>(row === <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// 打印第 n 种满足的情况</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、写出递推公式</p><blockquote><p><code>isOkCulomn()</code> 函数判断找到的该位置是否满足条件（不能处于同一行、同一列或同一斜线上）。如果满足条件，我们返回 <code>true</code>，进入 <code>if</code> 判断，<code>row</code>行数加一传入进行递归下一行的皇后位置。直至递归遇到终止条件位置，<code>column ++</code>，将第一行的皇后放到下一位置，进行继续递归，枚举出所有可能的摆放情况。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一列的判断</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++)&#123;</span><br><span class="line">    <span class="comment">// 判断当前的列位置是否合适</span></span><br><span class="line">    <span class="keyword">if</span>(isOkCulomn(row,column))&#123;</span><br><span class="line">        <span class="comment">// 保存皇后的位置</span></span><br><span class="line">        result[row] = column;</span><br><span class="line">        <span class="comment">// 对下一行寻找数据</span></span><br><span class="line">        cal8queens(row + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前列是否合适</span></span><br><span class="line"><span class="keyword">const</span> isOkCulomn = <span class="function">(<span class="params">row,column</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 左上角列的位置</span></span><br><span class="line">    <span class="keyword">let</span> leftcolumn = column - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右上角列的位置</span></span><br><span class="line">    <span class="keyword">let</span> rightcolumn = column + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 判断当前格子正上方是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] === column) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格子左上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === leftcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格式右上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === rightcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历</span></span><br><span class="line">        leftcolumn --;</span><br><span class="line">        rightcolumn ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、转换为递归代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="comment">// result 为数组，下标为行，数组中存储的是每一行中皇后的存储的列的位置。</span></span><br><span class="line"><span class="comment">// row 行  </span></span><br><span class="line"><span class="comment">// column 列</span></span><br><span class="line"><span class="comment">// n 计数满足条件的多少种</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> cal8queens = <span class="function">(<span class="params">row</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(row === <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每一列的判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++)&#123;</span><br><span class="line">        <span class="comment">// 判断当前的列位置是否合适</span></span><br><span class="line">        <span class="keyword">if</span>(isOkCulomn(row,column))&#123;</span><br><span class="line">            <span class="comment">// 保存皇后的位置</span></span><br><span class="line">            result[row] = column;</span><br><span class="line">            <span class="comment">// 对下一行寻找数据</span></span><br><span class="line">            cal8queens(row + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前列是否合适</span></span><br><span class="line"><span class="keyword">const</span> isOkCulomn = <span class="function">(<span class="params">row,column</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 设置左上角</span></span><br><span class="line">    <span class="keyword">let</span> leftcolumn = column - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> rightcolumn = column + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 判断当前格子正上方是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] === column) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格子左上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === leftcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格式右上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === rightcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历</span></span><br><span class="line">        leftcolumn --;</span><br><span class="line">        rightcolumn ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归打印所有情况</span></span><br><span class="line"><span class="keyword">const</span> print = <span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === j)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'Q'</span> + <span class="string">' '</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'*'</span> + <span class="string">' '</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">cal8queens(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br></pre></td></tr></table></figure><p><strong>▉ 总结</strong></p><blockquote><p>上述八皇后的问题就是用递归来枚举所有情况，然后再从中设置条件，只筛选满足条件的选项。上述代码建议多看几遍，亲自动手实践一下。一开始解决八皇后问题，我自己看了好长时间才明白的，以及递归如何发挥技巧作用的。</p></blockquote><p><strong>▉ 举一反三：</strong></p><blockquote><p>如果你想练练手，可以自己实现以下图的深度优先遍历，这个理解起来并不难，可以自己动手尝试着写一写，我把代码传到我的 <code>Github</code> 上了。</p></blockquote><h4 id="分类三：递归选择型"><a href="#分类三：递归选择型" class="headerlink" title="分类三：递归选择型"></a>分类三：递归选择型</h4><blockquote><p>所谓的递归选择型，每个子问题都要面临选择，求最优解的情况。有的小伙伴会说，求最优解动态规划最适合，对的，没错，但是递归通过选择型枚举所有情况，设置条件，求得问题的最优解也是可以实现的，所有我呢将其这一类问题归为递归选择型问题。</p></blockquote><h5 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0 -1 背包问题"></a>0 -1 背包问题</h5><blockquote><p><code>0 - 1</code> 背包问题，了解过的小伙伴也是很熟悉的了。其实这个问题也属于回溯算法的一种，废话不多说，直接上问题。有一个背包，背包总的承载重量是 <code>Wkg</code>。现在我们有 <code>n</code> 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p></blockquote><p><strong>▉ 问题分析：</strong></p><blockquote><p>如果你对该问题看懵了，没关系，我们一点点的分析。假如每个物品我们有两种状态，总的装法就有 <code>2^n</code>种，怎么才能不重复的穷举这些可能呢？</p></blockquote><p><strong>▉ 算法思路：</strong></p><blockquote><p>我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p></blockquote><p>▉ <strong>代码实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来存储背包中承受的最大重量</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Number</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">// i: 对第 i 个物品做出选择</span></span><br><span class="line"><span class="comment">// currentw: 当前背包的总重量</span></span><br><span class="line"><span class="comment">// goods：数组，存储每个物品的质量</span></span><br><span class="line"><span class="comment">// n: 物品的数量</span></span><br><span class="line"><span class="comment">// weight: 背包应承受的重量</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">i, currentw, goods, n, weight</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(currentw === weight || i === n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(currentw &gt; max)&#123;</span><br><span class="line">            max = currentw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择跳过当前物品不装入背包</span></span><br><span class="line">    f(i+<span class="number">1</span>, currentw, goods, n, weight)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前物品装入背包</span></span><br><span class="line">    <span class="comment">// 判断当前物品装入背包之前是否超过背包的重量,如果已经超过当前背包重量，就不要就继续装了</span></span><br><span class="line">    <span class="keyword">if</span>(currentw + goods[i] &lt;= weight)&#123;</span><br><span class="line">        f(i+<span class="number">1</span> ,currentw + goods[i], goods, n, weight)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">f(<span class="number">0</span>,<span class="number">0</span>,a,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(max)</span><br></pre></td></tr></table></figure><h2 id="递归的缺点"><a href="#递归的缺点" class="headerlink" title="递归的缺点"></a>递归的缺点</h2><blockquote><p>虽然递归的使用非常的简洁，但是也有很多缺点，也是我们在使用中需要额外注意的地方和优化的地方。</p></blockquote><h4 id="1、递归警惕堆栈溢出"><a href="#1、递归警惕堆栈溢出" class="headerlink" title="1、递归警惕堆栈溢出"></a>1、递归警惕堆栈溢出</h4><blockquote><p>你可能会问，递归和系统中的堆栈有什么关联？不要急，听我慢慢细说。</p></blockquote><h5 id="▉-理解堆栈溢出"><a href="#▉-理解堆栈溢出" class="headerlink" title="▉ 理解堆栈溢出"></a>▉ 理解堆栈溢出</h5><blockquote><p>1）递归的本质就是重复调用本身的过程，本身是什么？当然是一个函数，那好，函数中有参数以及一些局部的声明的变量，相信很多小伙伴只会用函数，而不知道函数中的变量是怎么存储的吧。没关系，等你听我分析完，你就会了。</p><p>2）函数中变量是存储到系统中的栈中的，栈数据结构的特点就是先进后出，后进先出。一个函数中的变量的使用情况就是随函数的声明周期变化的。当我们执行一个函数时，该函数的变量就会一直不断的压入栈中，当函数执行完毕销毁的时候，栈内的元素依次出栈。还是不懂，没关系，看下方示意图。</p><p>3）我们理解了上述过程之后，回到递归上来，我们的递归调用是在函数里调用自身，且当前函数并没有销毁，因为当前函数在执行自身层层递归进去了，所以递归的过程，函数中的变量一直不断的压栈，由于我们系统栈或虚拟机栈空间是非常小的，当栈压满之后，再压时，就会导致堆栈溢出。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【图】</p><h5 id="▉-解决办法"><a href="#▉-解决办法" class="headerlink" title="▉ 解决办法"></a>▉ 解决办法</h5><blockquote><p>那么遇到这种情况，我们怎么解决呢？</p></blockquote><p>通常我们设置递归深度，简单的理解就是，如果递归超过我们设置的深度，我们就退出，不再递归下去。</p><h4 id="2、递归警惕重复元素"><a href="#2、递归警惕重复元素" class="headerlink" title="2、递归警惕重复元素"></a>2、递归警惕重复元素</h4><blockquote><p>有些递归问题中，存在重复计算问题，比如求斐波那契数列，我们画一下递归树如下图，我们会发现有很多重复递归计算的值，重复计算会导致程序的时间复杂度很高，而且是指数级别的，导致我们的程序效率低下。</p></blockquote><p>【递归树图】</p><h5 id="▉-解决办法-1"><a href="#▉-解决办法-1" class="headerlink" title="▉ 解决办法"></a>▉ 解决办法</h5><blockquote><p>重复计算问题，我们应该怎么解决？有的小伙伴想到了，我们把已经计算过的值保存起来，每次递归计算之前先检查一下保存的数据有没有该数据，如果有，我们拿出来直接用。如果没有，我们计算出来保存起来。一般我们用散列表来保存。（所谓的散列表就是键值对的形式，如 map ）</p></blockquote><p>【代码实现】</p><h4 id="3、递归高空间复杂度"><a href="#3、递归高空间复杂度" class="headerlink" title="3、递归高空间复杂度"></a>3、递归高空间复杂度</h4><blockquote><p>因为递归时函数的变量的存储需要额外的栈空间，当递归深度很深时，需要额外的内存占空间就会很多，所以递归有非常高的空间复杂度。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法之递归系列，题目详细解析！&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Webpack成神之路之插件配置【处理CSS3属性前缀_11】</title>
    <link href="http://yoursite.com/2019/05/09/Webpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90%E5%A4%84%E7%90%86CSS3%E5%B1%9E%E6%80%A7%E5%89%8D%E7%BC%80_11%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/09/Webpack成神之路之插件配置【处理CSS3属性前缀_11】/</id>
    <published>2019-05-09T06:52:32.787Z</published>
    <updated>2019-05-09T07:44:00.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>处理 CSS3 属性前缀！</p><a id="more"></a><h2 id="CSS进阶：自动处理CSS3属性前缀"><a href="#CSS进阶：自动处理CSS3属性前缀" class="headerlink" title="CSS进阶：自动处理CSS3属性前缀"></a>CSS进阶：自动处理CSS3属性前缀</h2><blockquote><p>CSS3 是前段必会的技能，但是通常需要添加像 <code>-webkit,-ms,-o,-moz</code> 这些前缀，为了能够在不同浏览器上都可已顺利的运行。为了能够自动添加这些繁琐的前缀，我们借助插件来实现。</p></blockquote><p>1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;处理 CSS3 属性前缀！&lt;/p&gt;
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/webpack/"/>
    
    
      <category term="前端工具" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>吃透 javascript 之【完整篇】</title>
    <link href="http://yoursite.com/2019/05/08/%E5%90%83%E9%80%8F%20JavaScript%20%E4%B9%8B%E3%80%90%E5%AE%8C%E6%95%B4%E7%AF%87%E3%80%91%20/"/>
    <id>http://yoursite.com/2019/05/08/吃透 JavaScript 之【完整篇】 /</id>
    <published>2019-05-08T11:19:46.959Z</published>
    <updated>2019-05-08T11:19:46.962Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Javascript 的重点学习路线完整篇。</p><a id="more"></a><p>[TOC]</p><h3 id="一、JavaScript-简介"><a href="#一、JavaScript-简介" class="headerlink" title="一、JavaScript 简介"></a>一、JavaScript 简介</h3><h4 id="1、诞生"><a href="#1、诞生" class="headerlink" title="1、诞生"></a>1、诞生</h4><blockquote><p>最早期网景公司开启 web 时代的第一代互联网，早起网景公司只是做静态页面，为了能够在静态页面添加一些动态的效果，所以叫Brendan Eich 这两个人两星期之内设计出 javascript ，不出所料，这两人只用了短短的10天时间。为了使其能够借助 java 的盛行，所以起名 javascript。</p></blockquote><h4 id="2、ECMAScript"><a href="#2、ECMAScript" class="headerlink" title="2、ECMAScript"></a>2、ECMAScript</h4><blockquote><p>网景开发了 javascript 之后，微软也模仿开发了 Jscript，为了能够让 javascript 称为全球的开发标准，所以几个公司联合发布了 ECMA 标准。ECMAScript 是一种语言标准，而网景公司开发的 javascript 是这一标准的实现。</p></blockquote><h4 id="3、版本"><a href="#3、版本" class="headerlink" title="3、版本"></a>3、版本</h4><blockquote><p>因为 javascript 的标准在短时间实现的，其中存在很多的缺陷，所以 javascript 的标准 ECMAScript 不断发展，到目前的 ES6 版本 2015 年发布。这里的 javascript 版本一般说的就是实现了 ECMAScript 哪个版本。</p></blockquote><h3 id="二、数据类型和变量"><a href="#二、数据类型和变量" class="headerlink" title="二、数据类型和变量"></a>二、数据类型和变量</h3><h4 id="1、-和-的区别？"><a href="#1、-和-的区别？" class="headerlink" title="1、== 和 ===的区别？"></a>1、<code>==</code> 和 <code>===</code>的区别？</h4><blockquote><p>== 是 javascript 的设计缺陷，一般使用 === 来比较。</p><p><code>==</code> : 两种之间比较需要先进行转换，然后进行比较，有时候出现很奇怪的情况。</p><p><code>===</code> :  先比较类型，如果类型相等，然后在比较值。</p></blockquote><h4 id="2、NAN-是-Number-特殊的值"><a href="#2、NAN-是-Number-特殊的值" class="headerlink" title="2、NAN 是 Number 特殊的值"></a>2、NAN 是 Number 特殊的值</h4><blockquote><p>NAN 与任何值都不相等，包括它本身自己。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN === NaN; // false</span><br></pre></td></tr></table></figure><blockquote><p>唯一能判断 <code>NaN</code> 的方法是通过 <code>isNaN()</code> 函数 </p></blockquote><h4 id="3、浮点型之间的比较"><a href="#3、浮点型之间的比较" class="headerlink" title="3、浮点型之间的比较"></a>3、浮点型之间的比较</h4><blockquote><p><strong>问题</strong>：浮点型在运算会产生误差，导致计算机无法准确表示无限循环小数，所以导致比较不相等。</p><p><strong>解决：</strong>要比较浮点型之间的大小，要比较两个浮点型之差的绝对值是否小于某一个阈值。</p></blockquote><h4 id="4、null-和-undefined"><a href="#4、null-和-undefined" class="headerlink" title="4、null 和 undefined"></a>4、null 和 undefined</h4><blockquote><p><code>NULL</code> 表示“空”。<code>undefined</code> 表示未定义。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。 </p></blockquote><h4 id="5、严格模式是什么？"><a href="#5、严格模式是什么？" class="headerlink" title="5、严格模式是什么？"></a>5、严格模式是什么？</h4><blockquote><p><strong>缘由：</strong>初期，为了方便，不强制要求 var 声明变量，所以会导致未被 var 声明的变量自动声明为全局变量，如果同一页面不同 js 文件都用到了 js 文件的相同变量，导致变量之间相互影响，也就是我们所说的污染全局环境变量。</p><p><strong>strict模式：</strong>不用<code>var</code>申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。 </p></blockquote><h3 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h3><h4 id="1、多行字符串"><a href="#1、多行字符串" class="headerlink" title="1、多行字符串"></a>1、多行字符串</h4><blockquote><p>多行字符串用 <code></code> 反引号来表示，ES6 新增加语法。</p></blockquote><h4 id="2、字符串拼接"><a href="#2、字符串拼接" class="headerlink" title="2、字符串拼接"></a>2、字符串拼接</h4><blockquote><p>关于字符串拼接用 ${name} 引用，ES6 新增加语法。</p></blockquote><h3 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h3><h4 id="1、indexof"><a href="#1、indexof" class="headerlink" title="1、indexof"></a>1、indexof</h4><blockquote><p>搜索一个指定的元素的位置 。</p></blockquote><h4 id="2、slice"><a href="#2、slice" class="headerlink" title="2、slice"></a>2、slice</h4><blockquote><p>字符串截取。单参数为从参数起到结束，双参数为中间元素（不包括尾元素），返回新数组。</p></blockquote><h4 id="3、push-和-pop"><a href="#3、push-和-pop" class="headerlink" title="3、push 和 pop"></a>3、push 和 pop</h4><blockquote><p>末尾添加元素和末尾删除元素。</p></blockquote><h4 id="4、unshift-和-shift"><a href="#4、unshift-和-shift" class="headerlink" title="4、unshift 和 shift"></a>4、unshift 和 shift</h4><blockquote><p>头部添加元素和头部删除元素。</p></blockquote><h4 id="5、sort"><a href="#5、sort" class="headerlink" title="5、sort"></a>5、sort</h4><blockquote><p>对当前数组进行排序。</p></blockquote><h4 id="6、reverse"><a href="#6、reverse" class="headerlink" title="6、reverse"></a>6、reverse</h4><blockquote><p>将数组元素反转。</p></blockquote><h4 id="7、splice"><a href="#7、splice" class="headerlink" title="7、splice"></a>7、splice</h4><blockquote><p>可以删除元素也可以删除同时添加元素。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;);</span><br></pre></td></tr></table></figure><h4 id="8、concat"><a href="#8、concat" class="headerlink" title="8、concat"></a>8、concat</h4><blockquote><p>合并两个数组，返回新数组。</p></blockquote><h4 id="9、join"><a href="#9、join" class="headerlink" title="9、join"></a>9、join</h4><blockquote><p>指定字符连接数组中的元素。</p></blockquote><h3 id="五、Map-和-Set"><a href="#五、Map-和-Set" class="headerlink" title="五、Map 和 Set"></a>五、Map 和 Set</h3><h4 id="1、Map"><a href="#1、Map" class="headerlink" title="1、Map"></a>1、Map</h4><blockquote><p>一组键值对，键必须为字符串类型。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;);</span><br><span class="line">m.set(&apos;Bob&apos;,59)</span><br><span class="line">m.delete(&apos;Adam&apos;);</span><br></pre></td></tr></table></figure><h4 id="2、Set"><a href="#2、Set" class="headerlink" title="2、Set"></a>2、Set</h4><blockquote><p>一组 key 的集合，不存储 value。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set([1, 2, 3]);</span><br><span class="line">s.add(4);</span><br><span class="line">s.delete(3);</span><br></pre></td></tr></table></figure><h3 id="六、iterable"><a href="#六、iterable" class="headerlink" title="六、iterable"></a>六、iterable</h3><h6 id="▉-普通-for-循环"><a href="#▉-普通-for-循环" class="headerlink" title="▉ 普通 for 循环"></a>▉ 普通 for 循环</h6><blockquote><p>当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率 。</p></blockquote><h6 id="▉-foreach-循环"><a href="#▉-foreach-循环" class="headerlink" title="▉ foreach 循环"></a>▉ foreach 循环</h6><blockquote><p><strong>功能：</strong>可以获取到 key 和 value 数组的本身。</p><p><strong>缺点：</strong></p><ul><li>不能用 break，continue 语句跳出循环。</li><li>函数内不能使用 return 语句。</li></ul><p><strong>注意：</strong>在不同浏览器下测试的结果都是 forEach 的速度不如 for 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//item 为数组元素</span></span><br><span class="line"><span class="comment">//index 为索引下标</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item,index,arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item,index,arr)</span><br><span class="line">&#125;,<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h6 id="▉-for…in-循环"><a href="#▉-for…in-循环" class="headerlink" title="▉  for…in 循环"></a>▉  for…in 循环</h6><blockquote><p><strong>for-in 循环遍历的是对象的属性。</strong>而不是数组的索引 ，除了遍历数组也可以遍历对象。</p><p><strong>缺点：</strong></p><ul><li>for-in 遍历的顺序并不是确定的。</li><li>它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。 </li><li>for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性 （Array 中的 length 不能遍历到），for-in 不适合遍历 Array 。【链接】：<a href="https://juejin.im/entry/5a1654e951882554b8373622" target="_blank" rel="noopener">https://juejin.im/entry/5a1654e951882554b8373622</a></li></ul></blockquote><h6 id="▉-for…of-循环"><a href="#▉-for…of-循环" class="headerlink" title="▉  for…of 循环"></a>▉  for…of 循环</h6><blockquote><p>ES6 新增语法。</p><p><strong>优点：</strong></p><ul><li>以正确响应 break, continue, return。 </li><li>for-of 循环不仅支持数组，还支持大多数类数组对象。</li><li>for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。</li><li>for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历 </li></ul></blockquote><h3 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h3><blockquote><p>在函数中如果没有 <code>return</code> 语句，函数执行完返回 <code>undefined</code>。</p></blockquote><h4 id="1、arguments"><a href="#1、arguments" class="headerlink" title="1、arguments"></a>1、arguments</h4><blockquote><p>此关键字只在函数内部起作用，并且永远指向当前函数调用者传入的所有参数。</p><p>1、即使函数不定义参数，也是可以通过 arguments 对象拿到传入的参数的。</p><p>2、通常用来判断传入参数的个数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x = '</span> + x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'arg '</span> + i + <span class="string">' = '</span> + <span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><h4 id="2、reset-参数（ES6）"><a href="#2、reset-参数（ES6）" class="headerlink" title="2、reset 参数（ES6）"></a>2、reset 参数（ES6）</h4><blockquote><p>由于 arguments 获取额外的传参非常的别扭，所以 ES6 新增了 rest 参数用来处理额外的参数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a,b,...rest</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入多余两个参数</span></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// Array[3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传入少于定义参数的个数</span></span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//Array[] 空数组</span></span><br></pre></td></tr></table></figure><h4 id="3、注意-return-语句"><a href="#3、注意-return-语句" class="headerlink" title="3、注意 return  语句"></a>3、注意 return  语句</h4><blockquote><p>javascript 引擎会有一个行末添加分号的机制。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为&#123;表示语句尚未结束</span></span><br><span class="line">        name: <span class="string">'foo'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>   <span class="comment">//这一行会可能被引擎自动加分号</span></span><br><span class="line">       &#123; <span class="attr">name</span>: <span class="string">'foo'</span>&#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、变量作用域和解构赋值"><a href="#4、变量作用域和解构赋值" class="headerlink" title="4、变量作用域和解构赋值"></a>4、变量作用域和解构赋值</h4><h6 id="▉-全局作用域"><a href="#▉-全局作用域" class="headerlink" title="▉ 全局作用域"></a>▉ 全局作用域</h6><blockquote><p>javascript 只有一个全局作用域，如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报<code>ReferenceError</code>错误。 </p></blockquote><h6 id="▉-命名空间"><a href="#▉-命名空间" class="headerlink" title="▉ 命名空间"></a>▉ 命名空间</h6><blockquote><p>全局变量会绑定到 windows 上，不同的 javascript 文件使用相同的全局变量会产生命名冲突，我们很难发现，所以一般减少冲突的方法就是所有变量和函数全部绑定到一个全局变量中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></span><br><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他变量:</span></span><br><span class="line">MYAPP.name = <span class="string">'myapp'</span>;</span><br><span class="line">MYAPP.version = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数:</span></span><br><span class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>许多 js 库都是这么干的，jQuery，YUI等。</p></blockquote><h6 id="▉-局部作用域"><a href="#▉-局部作用域" class="headerlink" title="▉ 局部作用域"></a>▉ 局部作用域</h6><blockquote><p>所谓的 js 作用域是在函数内部的，for 循环等语句块中是无法定义具有局部作用域变量的。ES6 引用了 let 代替 var 声明块级作用域变量。</p></blockquote><h6 id="▉-对多个变量同时赋值"><a href="#▉-对多个变量同时赋值" class="headerlink" title="▉ 对多个变量同时赋值"></a>▉ 对多个变量同时赋值</h6><blockquote><p>使用 ES6 新增加的解构赋值。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>];</span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><p>1、交换两个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>,y = <span class="number">2</span>;</span><br><span class="line">[x,y] = [y,x]</span><br></pre></td></tr></table></figure><p>2、快速获取当前页面的域名和路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;<span class="attr">hostname</span>:domain, <span class="attr">pathname</span>:path&#125; = location;</span><br></pre></td></tr></table></figure><p>3、函数接受对象的属性为参数</p><blockquote><p>用解构直接将对象的属性绑定到变量中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildDate</span>(<span class="params">&#123;year, month, day, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(year + <span class="string">'-'</span> + month + <span class="string">'-'</span> + day + <span class="string">' '</span> + hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second);</span><br><span class="line">&#125;</span><br><span class="line">buildDate(&#123; <span class="attr">year</span>: <span class="number">2017</span>, <span class="attr">month</span>: <span class="number">1</span>, <span class="attr">day</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="5、方法"><a href="#5、方法" class="headerlink" title="5、方法"></a>5、方法</h4><h6 id="▉-this-指针"><a href="#▉-this-指针" class="headerlink" title="▉ this 指针"></a>▉ this 指针</h6><blockquote><p>如果以对象的方法形式调用，比如<code>xiaoming.age()</code>，该函数的<code>this</code>指向被调用的对象，也就是<code>xiaoming</code>。如果单独调用函数，比如<code>getAge()</code>，此时，该函数的<code>this</code>指向全局对象，也就是<code>window</code>。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25, 正常结果</span></span><br><span class="line">getAge(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></span><br><span class="line">fn(); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><blockquote><p>以上是 js 的设计错误，ECMA决定，在 strict 模式下让函数的<code>this</code>指向<code>undefined</code> 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="keyword">this</span>.birth; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>报错了，<code>this</code>  指针只在 <code>age</code> 方法的函数内指向 <code>xiaoming</code> 在函数内部定义的函数 ，this 指针指向 undefined ，他重新指向全局变量。</p></blockquote><p>改进方法，用 that 进行捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h6 id="▉-apply-方法"><a href="#▉-apply-方法" class="headerlink" title="▉ apply() 方法"></a>▉ apply() 方法</h6><blockquote><p><strong>作用： </strong>指针函数的 this 指向哪个对象。</p><p><strong>使用：</strong></p><ul><li>参数一：需要绑定的 this 变量。</li><li>参数二：传入的是 Array，表示函数本身的参数。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure><h6 id="▉-call-方法"><a href="#▉-call-方法" class="headerlink" title="▉ call() 方法"></a>▉ call() 方法</h6><blockquote><p>把参数按照顺序传入。</p></blockquote><h6 id="▉-装饰器"><a href="#▉-装饰器" class="headerlink" title="▉ 装饰器"></a>▉ 装饰器</h6><blockquote><p>利用<code>apply()</code>，我们还可以动态改变函数的行为。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6、高阶函数"><a href="#6、高阶函数" class="headerlink" title="6、高阶函数"></a>6、高阶函数</h4><blockquote><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为<strong>高阶函数 </strong>。 </p></blockquote><h6 id="▉-map-对元素自身进行计算"><a href="#▉-map-对元素自身进行计算" class="headerlink" title="▉ map 对元素自身进行计算"></a>▉ map 对元素自身进行计算</h6><blockquote><p><code>map()</code> 方法定义在 JavaScript 的 <code>Array</code> 中 ,对数组中的每个数据做处理。</p><p><code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"><span class="built_in">console</span>.log(results);</span><br></pre></td></tr></table></figure><h6 id="▉-reduce-所有元素进行累加计算"><a href="#▉-reduce-所有元素进行累加计算" class="headerlink" title="▉ reduce 所有元素进行累加计算"></a>▉ reduce 所有元素进行累加计算</h6><blockquote><p>Array的<code>reduce()</code>把一个函数作用在这个<code>Array</code>的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><h6 id="▉-filter-过滤元素"><a href="#▉-filter-过滤元素" class="headerlink" title="▉ filter 过滤元素"></a>▉ filter 过滤元素</h6><blockquote><p>用于把  <code>Array</code>的某些元素过滤掉，然后返回剩下的元素。 和 <code>map()</code> 不同的是，<code>filter()</code> <strong>把传入的函数依次作用于每个元素，然后根据返回值是 <code>true</code> 还是 <code>false</code> 决定保留还是丢弃该元素。</strong> </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个Array中，删掉偶数，只保留奇数</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">r; <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure><p><strong>● 回调函数</strong></p><blockquote><p>filter 有多个参数。</p><p><strong>1、一个参数：</strong>仅使用一个表示 Array 的某个元素。</p><p><strong>2、三个参数：</strong>回调函数可以接受另外两个参数，表示元素的<strong>位置</strong>和<strong>数组本身</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除重复元素依靠的是 indexOf 总是返回第一个元素的位置，后续的重复元素位置与 indexOf 返回的位置不相等，因此被 filter 滤掉了。</span></span><br><span class="line"><span class="keyword">var</span> r,</span><br><span class="line">arr = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'orange'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="▉-sort-排序"><a href="#▉-sort-排序" class="headerlink" title="▉ sort 排序"></a>▉ sort 排序</h6><blockquote><p>1、比较字符或者字符串，根据 ASCLL 码进行排序的。</p><p>2、比较数字，先将数组中的数字转换成字符串，然后再进行排序。</p></blockquote><p>sort 是一个高阶函数，可以传入函数来进行自定义的比较：</p><ul><li>数字比较</li></ul><blockquote><p>传入一个比较函数，-返回值为 1，-1，0；</p><p><strong>注意：</strong>sort 直接对 Array 进行修改，结果返回 Array。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="comment">//经断点调试，更像是一种插入排序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//变</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不变</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure><h4 id="6、闭包"><a href="#6、闭包" class="headerlink" title="6、闭包"></a>6、闭包</h4><blockquote><p>将闭包和 Java 类中的 get 获取内部私有变量做对比。</p></blockquote><h6 id="▉-什么是闭包？"><a href="#▉-什么是闭包？" class="headerlink" title="▉ 什么是闭包？"></a>▉ 什么是闭包？</h6><blockquote><p>只有函数内部的子函数才能读取局部变量，定义在一个函数内部的函数 。</p></blockquote><h6 id="▉-作用"><a href="#▉-作用" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>1）在函数的外部也可以获取到函数内部的局部变量。</p><p>2）让这些局部变量值始终保存在内存中，保证不会被 js “垃圾回收机制”回收。</p></blockquote><h6 id="▉-使用闭包注意事项"><a href="#▉-使用闭包注意事项" class="headerlink" title="▉ 使用闭包注意事项"></a>▉ 使用闭包注意事项</h6><blockquote><p>1）闭包会被保存到内存中，内存消耗很大，会造成网页性能问题，在 IE 会导致内存泄漏。在退出函数之前，将不适用的局部变量全部删除。</p></blockquote><h4 id="7、垃圾回收机制"><a href="#7、垃圾回收机制" class="headerlink" title="7、垃圾回收机制"></a>7、垃圾回收机制</h4><h6 id="▉-生命周期"><a href="#▉-生命周期" class="headerlink" title="▉ 生命周期"></a>▉ 生命周期</h6><blockquote><p>1）分配内存： javascript 自动完成内存的分配</p><p>2）使用内存（读或写）：使用值的过程实际上是对分配内存进行读取与写入的操作 </p><p>3）释放内存：在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。所以高级语言潜入垃圾回收机制。</p></blockquote><h6 id="▉-垃圾回收机制"><a href="#▉-垃圾回收机制" class="headerlink" title="▉ 垃圾回收机制"></a>▉ 垃圾回收机制</h6><blockquote><p>主要工作是跟踪内存的<strong>分配</strong>和<strong>使用</strong>，以便当分配的内存不再使用时，自动释放它。</p></blockquote><p><strong>1）引用</strong></p><blockquote><p>垃圾回收算法主要依赖于引用的概念 ，一个对象访问另一个对象就叫做引用。</p></blockquote><p><strong>2）引用计数垃圾收集</strong></p><blockquote><p>初级的垃圾回收算法，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p></blockquote><p><strong>3）限制：循环引用</strong></p><blockquote><p>当该函数调用完成离开作用域之后，可以被回收了，但是两个对象相互引用，所以不会被回收。（IE 6, 7对 DOM 结点进行计数垃圾回收）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）标记—清除算法</strong></p><blockquote><p>针对于“对象是否不再需要”。</p><p>1）算法假设有一个根对象（全局对象），垃圾回收器从根开始找所有从根开始引用的对象。</p><p>2）垃圾回收器将找到所有<strong>可以获得的对象</strong>和收集所有<strong>不能获得的对象</strong>。 （零引用总不可获得的）</p></blockquote><p><strong>5）限制：那些无法从根对象查询到的对象都将被清除</strong></p><h4 id="8、箭头函数"><a href="#8、箭头函数" class="headerlink" title="8、箭头函数"></a>8、箭头函数</h4><h6 id="▉-箭头中的-this"><a href="#▉-箭头中的-this" class="headerlink" title="▉ 箭头中的 this"></a>▉ 箭头中的 this</h6><blockquote><p>由于之前的函数中 this 绑定的错误处理，this 在箭头函数中被修复了。<strong>this 总是与词法作用域绑定</strong>（函数的作用域在函数定义的时候就决定了 ），由上下文确定 ，外层调用者 <code>obj</code>.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向window 或 undefined</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="▉-注意"><a href="#▉-注意" class="headerlink" title="▉ 注意"></a>▉ 注意</h6><blockquote><p>由于<code>this</code>在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>调用箭头函数时，无法对<code>this</code>进行绑定，即传入的第一个参数被忽略。</p></blockquote><h4 id="9、generator-生成器"><a href="#9、generator-生成器" class="headerlink" title="9、generator 生成器"></a>9、generator 生成器</h4><h6 id="▉-定义"><a href="#▉-定义" class="headerlink" title="▉ 定义"></a>▉ 定义</h6><blockquote><p>整个 Generator 函数封装了异步任务。 标注 yield 地方都是异步需要暂停的地方（yield 将任务分为几个阶段）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-过程"><a href="#▉-过程" class="headerlink" title="▉ 过程"></a>▉ 过程</h6><blockquote><p><strong>1）</strong>调用 Generator 会返回一个指针对象（<strong>遍历器对象</strong> ），调用指针对象的的 next 方法，会移动指针的位置（异步任务的第一阶段），也就是指向遇到第一个 yield  的位置。 </p><p><strong>2）</strong>next 方法会返回一个当前阶段的对象，表示当前阶段的信息（value:当前阶段的值，yield：布尔值 ）表示 generator 是否执行完毕。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h6 id="▉-数据交换"><a href="#▉-数据交换" class="headerlink" title="▉ 数据交换"></a>▉ 数据交换</h6><blockquote><p>除了能够暂停、恢复之外，还可以作为函数体内外的数据交换。</p><p>1、不带有参数的 next 方法可以输出返回值。</p><p>2、带有参数的方法可以将参数作为上一阶段异步任务的返回结果，也就是输入。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><h6 id="▉-错误处理"><a href="#▉-错误处理" class="headerlink" title="▉ 错误处理"></a>▉ 错误处理</h6><blockquote><p>Generator 内部可以部署错误处理代码，捕获函数体外抛出的错误。</p><p>1、在函数外用指针的throw抛出的错误，被函数体内的  try … catch  代码块进行捕获。</p><p>2、实现了出错代码和处理错误的代码时间和空间上的分离。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw（<span class="string">'出错了'</span>）;</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><h6 id="▉-作用-1"><a href="#▉-作用-1" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>异步回调代码变成“同步”代码。</p></blockquote><h3 id="八、标准对象"><a href="#八、标准对象" class="headerlink" title="八、标准对象"></a>八、标准对象</h3><blockquote><p>总结一下，有这么几条规则需要遵守：</p></blockquote><ul><li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li><li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li><li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li><li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li><li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li><li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li><li>判断<code>null</code>请使用<code>myVar === null</code>；</li><li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li><li>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code>。</li></ul><blockquote><p>任何对象都有<code>toString()</code>方法吗？<code>null</code>和<code>undefined</code>就没有！确实如此，这两个特殊值要除外，虽然<code>null</code>还伪装成了<code>object</code>类型。</p></blockquote><h4 id="1、Date"><a href="#1、Date" class="headerlink" title="1、Date"></a>1、Date</h4><blockquote><p> JavaScript的 Date 对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure><h3 id="九、面向对象编程"><a href="#九、面向对象编程" class="headerlink" title="九、面向对象编程"></a>九、面向对象编程</h3><h4 id="1、继承设计思想"><a href="#1、继承设计思想" class="headerlink" title="1、继承设计思想"></a>1、继承设计思想</h4><h6 id="▉-js-的诞生"><a href="#▉-js-的诞生" class="headerlink" title="▉ js 的诞生"></a>▉ js 的诞生</h6><blockquote><p>为了让静态页面进行交互，设计一种语言完成不需要借助服务器完成的操作，如：表单验证。</p></blockquote><h6 id="▉-模仿其他-oop-进行设计"><a href="#▉-模仿其他-oop-进行设计" class="headerlink" title="▉  模仿其他 oop 进行设计"></a>▉  模仿其他 oop 进行设计</h6><blockquote><p>js 不像其他语言是面向对象语言有类的概念，为了能够即不引入类又能实现继承，所以 js 设计者模仿 oop 语言进行设计。</p><p>1、其他语言通过 new 来生成实例，所以 js 也通过 new 生成实例。</p><p>2、其他语言有类可以通过 new 来实现，js 并没有类，所以借助 new 构造函数来生成实例。</p><p>3、不同对象有不同的属性，也有相同的属性，对于每个对象相同的属性都需要在内存中开辟多个空间存储。能否使相同的属性只存一个呢？然后拥有该属性的对象都去引用它。</p></blockquote><h6 id="▉-prototype-属性"><a href="#▉-prototype-属性" class="headerlink" title="▉  prototype 属性"></a>▉  <strong>prototype</strong> 属性</h6><blockquote><p>我们就给构造函数设计一个 prototype 属性，用来存储不同对象相同的属性，共享的属性都存到这里边，不共享的属性就存放到构造函数中。其实 prototype 属性存储的就是一个对象，构造函数里边存放的都是变量，具体看变量和对象在内存中的引用。</p></blockquote><h6 id="▉-继承"><a href="#▉-继承" class="headerlink" title="▉  继承"></a>▉  继承</h6><blockquote><p>所有构造函数生成的对象都具有 prototype 对象里边的共享属性，就像是所有实例对象继承了 prototype 对象一样。</p></blockquote><h4 id="2、封装"><a href="#2、封装" class="headerlink" title="2、封装"></a>2、封装</h4><blockquote><p>其他语言因为有类的概念，对对象的封装是非常方便的，那么 js 是怎么封装对象的呢？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//猫对象</span></span><br><span class="line"><span class="keyword">var</span> Cat = &#123;</span><br><span class="line">    name : <span class="string">''</span>,</span><br><span class="line">    color : <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-原始模式"><a href="#▉-原始模式" class="headerlink" title="▉  原始模式"></a>▉  原始模式</h6><blockquote><p>下面简单的进行两个不同对象的封装，就会有两个问题：</p><p><strong>问题：</strong></p><p>1）生成多个实例对象写起来非常麻烦。</p><p>2）实例对象和原型对象之间没什么联系。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = &#123;&#125;; <span class="comment">// 创建一个空对象</span></span><br><span class="line">cat1.name = <span class="string">"大毛"</span>; <span class="comment">// 按照原型对象的属性赋值</span></span><br><span class="line">cat1.color = <span class="string">"黄色"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat2 = &#123;&#125;;</span><br><span class="line">cat2.name = <span class="string">"二毛"</span>;</span><br><span class="line">cat2.color = <span class="string">"黑色"</span>;</span><br></pre></td></tr></table></figure><h6 id="▉-原始模式改进"><a href="#▉-原始模式改进" class="headerlink" title="▉  原始模式改进"></a>▉  原始模式改进</h6><blockquote><p>用函数来解决代码重复的问题。</p><p><strong>问题：</strong></p><p>1）但是不能反映他们来自于同一个原型对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name:name,</span><br><span class="line">        color:color</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成实例对象</span></span><br><span class="line"><span class="keyword">var</span> cat1 = Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = Cat(<span class="string">"二毛"</span>,<span class="string">"黑色"</span>);</span><br></pre></td></tr></table></figure><h6 id="▉-构造函数模式"><a href="#▉-构造函数模式" class="headerlink" title="▉  构造函数模式"></a>▉  构造函数模式</h6><blockquote><p>为了解决原型对象生成实例的问题，引入构造函数模式。</p><p>1）构造函数就是一个普通函数。</p><p>2）内部使用 this 变量，对构造函数使用 new 就能生成实例对象，内部的 this 指针就会指向实例对象。</p><p>3）每个实例对象都有 constructor 属性，并指向他们的构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.color=color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2）</span></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>,<span class="string">"黑色"</span>);</span><br><span class="line"><span class="comment">//3)</span></span><br><span class="line">alert(cat1.constructor == Cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>问题：</strong></p><p>1）对于每个实例共享的属性，存在浪费内存的问题。</p></blockquote><h6 id="▉-原型模式（prototype-模式）"><a href="#▉-原型模式（prototype-模式）" class="headerlink" title="▉  原型模式（prototype 模式）"></a>▉  原型模式（prototype 模式）</h6><blockquote><p>每个构造函数都有一个 prototype 属性指向原型对象，我们将共享的属性存放到原型对象上，所有实例的共享属性其实都是同一个内存地址，指向<code>prototype</code>对象，因此就提高了运行效率。</p><p><strong>验证方法：</strong></p><p><strong>1）isPrototypeOf()</strong> ：验证实例与原型对象之间的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(Cat.prototype.isPrototypeOf(cat1)); //true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>2）hasOwnProperty()</strong>：判断某个属性来自本地还是原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(cat1.hasOwnProperty(&quot;name&quot;)); // true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>3）in运算符</strong>：判断某个实例是否拥有某个属性。以及遍历某个实例的所有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; alert(&quot;name&quot; in cat1); // true</span><br><span class="line">&gt; for(var prop in cat1) &#123; alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="2、原型继承"><a href="#2、原型继承" class="headerlink" title="2、原型继承"></a>2、原型继承</h4><h4 id="3、构造函数继承（五种）"><a href="#3、构造函数继承（五种）" class="headerlink" title="3、构造函数继承（五种）"></a>3、构造函数继承（五种）</h4><blockquote><p>两个构造函数。怎么让猫继承动物？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动物构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//猫的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第一种：构造函数的绑定"><a href="#▉-第一种：构造函数的绑定" class="headerlink" title="▉  第一种：构造函数的绑定"></a>▉  第一种：构造函数的绑定</h6><blockquote><p>用 call 或 apply 方法将父对象的构造函数绑定到子对象的构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//改变 this 的绑定</span></span><br><span class="line">    Animal.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第二种：原型模式"><a href="#▉-第二种：原型模式" class="headerlink" title="▉  第二种：原型模式"></a>▉  第二种：原型模式</h6><blockquote><p>让猫构造函数的 prototype 等于 Animal 的实例，Animal 的实例拥有 Animal  的所有属性，所以相当于猫构造函数的 prototype 指向 Animal 实例了， 所有的猫的实例共享 Animal  里的属性了。</p><p>1) 每个实例都有 construct 属性，每个 prototype 也都有 construct 属性。</p><p>2）实例中的 construct 指向与 prototype 对象中 construct 指向同一个构造函数。也就是说改变 Cat 的原型对象之后，Cat 的实例对象 construct 属性指向的是 Animal 实例对象的 construct 属性，也就是 Animal 原型对象的 construct 属性，也就是构造函数 Animal 。</p><p>3）猫的实例对象是由 Cat 生成的，怎么能指向 Animal 呢，所以手动修改过来。</p><p>4）如果更换了 prototype对象 ，一定将 construct 属性修改过来。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><h6 id="▉-第三种：直接继承原型"><a href="#▉-第三种：直接继承原型" class="headerlink" title="▉  第三种：直接继承原型"></a>▉  第三种：直接继承原型</h6><blockquote><p>第二种方式的改进，跳过 Animal 的实例，直接将 Animal 的原型对象赋值给 Cat.prototype;</p><p><strong>优点：</strong>效率更高（不用执行和建立Animal的实例了 ）</p><p><strong>缺点：</strong><code>Cat.prototype</code> 和 <code>Animal.prototype</code> 现在指向了同一个对象，那么任何对 <code>Cat.prototype</code> 的修改，都会反映到 <code>Animal.prototype</code>。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = Animal.prototype;</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><h6 id="▉-第四种：空对象作为中介"><a href="#▉-第四种：空对象作为中介" class="headerlink" title="▉  第四种：空对象作为中介"></a>▉  第四种：空对象作为中介</h6><blockquote><p>对于第三种的缺点，第四种作为改进。F是空对象，所以几乎不占内存。 </p><p><strong>优点：</strong>修改Cat的prototype对象，就不会影响到Animal的prototype对象。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = Animal.prototype;</span><br><span class="line">Cat.prototype = <span class="keyword">new</span> F();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br></pre></td></tr></table></figure><p>将其封装成方法:</p><blockquote><p>这个 extend 函数，就是 YUI 库如何实现继承的方法。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　<span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">　　　　F.prototype = Parent.prototype;</span><br><span class="line">　　　　Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">　　　　Child.prototype.constructor = Child;</span><br><span class="line">　　　　Child.uber = Parent.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第五种：拷贝继承"><a href="#▉-第五种：拷贝继承" class="headerlink" title="▉  第五种：拷贝继承"></a>▉  第五种：拷贝继承</h6><blockquote><p>如果把父对象的 prototype 所有属性和方法，拷贝进子对象的 prototype 中 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend2</span>(<span class="params">Child, Parent</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> p = Parent.prototype;</span><br><span class="line">　　　　<span class="keyword">var</span> c = Child.prototype;</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　　　c[i] = p[i];</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　c.uber = p;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h4 id="4、非构造函数继承"><a href="#4、非构造函数继承" class="headerlink" title="4、非构造函数继承"></a>4、非构造函数继承</h4><blockquote><p>让医生继承中国。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//父对象</span><br><span class="line">var Chinese = &#123;</span><br><span class="line">nation:&apos;中国&apos;</span><br><span class="line">&#125;;</span><br><span class="line">//子对象</span><br><span class="line">var Doctor =&#123;</span><br><span class="line">career:&apos;医生&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第一种：object-方法"><a href="#▉-第一种：object-方法" class="headerlink" title="▉  第一种：object()方法"></a>▉  第一种：object()方法</h6><blockquote><p>让中国成为医生的原型对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="▉-第二种：浅拷贝"><a href="#▉-第二种：浅拷贝" class="headerlink" title="▉  第二种：浅拷贝"></a>▉  第二种：浅拷贝</h6><blockquote><p>把父对象的属性，全部拷贝给子对象，也能实现继承。 拷贝继承分为浅拷贝和深拷贝。</p><p><strong>问题：</strong></p><p>1）如果父对象的属性等于数组或另一个对象，子对象获得的只是一个内存地址 ，子对象改变，父对象的属性也将改变。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function extendCopy(p) &#123;</span><br><span class="line">    var c = &#123;&#125;;</span><br><span class="line">    for (var i in p) &#123; </span><br><span class="line">    c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    c.uber = p;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-第二种：深拷贝"><a href="#▉-第二种：深拷贝" class="headerlink" title="▉  第二种：深拷贝"></a>▉  第二种：深拷贝</h6><blockquote><p>弥补浅拷贝出现的问题，真正的将对象和数组及逆行拷贝，只要递归调用”浅拷贝”就行了 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">p, c</span>) </span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> c = c || &#123;&#125;;</span><br><span class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) &#123;</span><br><span class="line">　　　　　　<span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">　　　　　　　　c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line">　　　　　　　　deepCopy(p[i], c[i]);</span><br><span class="line">　　　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　　　　c[i] = p[i];</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> c;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><blockquote><p>jQuery库使用的就是这种继承方法。 </p></blockquote><h4 id="5、class-继承"><a href="#5、class-继承" class="headerlink" title="5、class 继承"></a>5、class 继承</h4><blockquote><p>class 的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用 class 的好处就是极大地简化了原型链代码。</p></blockquote><h3 id="十、浏览器"><a href="#十、浏览器" class="headerlink" title="十、浏览器"></a>十、浏览器</h3><h4 id="1、浏览器对象"><a href="#1、浏览器对象" class="headerlink" title="1、浏览器对象"></a>1、浏览器对象</h4><h6 id="▉-window"><a href="#▉-window" class="headerlink" title="▉ window"></a>▉ window</h6><blockquote><p><code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'window inner size: '</span> + <span class="built_in">window</span>.innerWidth + <span class="string">' x '</span> + <span class="built_in">window</span>.innerHeight);</span><br></pre></td></tr></table></figure><h6 id="▉-navigator"><a href="#▉-navigator" class="headerlink" title="▉ navigator"></a>▉ navigator</h6><blockquote><p><code>navigator</code>对象表示浏览器的信息，最常用的属性包括： </p></blockquote><ul><li>navigator.appName：浏览器名称；</li><li>navigator.appVersion：浏览器版本；</li><li>navigator.language：浏览器设置的语言；</li><li>navigator.platform：操作系统类型；</li><li>navigator.userAgent：浏览器设定的<code>User-Agent</code>字符串。</li></ul><h6 id="▉-screen"><a href="#▉-screen" class="headerlink" title="▉ screen"></a>▉ screen</h6><blockquote><p><code>screen</code>对象表示屏幕的信息，常用的属性有： </p></blockquote><ul><li>screen.width：屏幕宽度，以像素为单位；</li><li>screen.height：屏幕高度，以像素为单位；</li><li>screen.colorDepth：返回颜色位数，如8、16、24。</li></ul><h6 id="▉-location"><a href="#▉-location" class="headerlink" title="▉ location"></a>▉ location</h6><blockquote><p><code>location</code>对象表示当前页面的URL信息。 </p><p><strong>加载新页面：</strong>location.assign() 。</p><p><strong>重新加载：</strong>location.reload() 。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</span></span><br><span class="line"><span class="comment">//可以用location.href获取</span></span><br><span class="line">location.protocol; <span class="comment">// 'http'</span></span><br><span class="line">location.host; <span class="comment">// 'www.example.com'</span></span><br><span class="line">location.port; <span class="comment">// '8080'</span></span><br><span class="line">location.pathname; <span class="comment">// '/path/index.html'</span></span><br><span class="line">location.search; <span class="comment">// '?a=1&amp;b=2'</span></span><br><span class="line">location.hash; <span class="comment">// 'TOP'</span></span><br></pre></td></tr></table></figure><h6 id="▉-document"><a href="#▉-document" class="headerlink" title="▉ document"></a>▉ document</h6><blockquote><p><code>document</code> 对象表示当前页面。由于 HTML 在浏览器中以 DOM 形式表示为树形结构，<code>document</code> 对象就是整个 DOM 树的根节点。 </p></blockquote><p><strong>Cookie</strong></p><blockquote><p>1) Cookie 是由服务器发送的 key-value 标示符。因为 HTTP 协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用 Cookie 来区分 。</p><p>2) 当一个用户成功登录后，服务器发送一个 Cookie 给浏览器，例如 <code>user=ABC123XYZ(加密的字符串)...</code>，此后，浏览器访问该网站时，会在请求头附上这个 Cookie，服务器根据 Cookie 即可区分出用户。<em>**</em></p><p><strong>安全性：</strong> </p><p>如果引入的第三方库存在恶意代码，则被第三方直接获取到用户登录信息。为了解决这个问题，服务器在设置 Cookie 的时候使用 <strong>httpOnly</strong>，设置的 Cookie 不能被 Javascript 读取。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie; <span class="comment">// 'v=123; remember=true; prefer=zh'</span></span><br></pre></td></tr></table></figure><h6 id="▉-history"><a href="#▉-history" class="headerlink" title="▉ history"></a>▉ history</h6><blockquote><p><code>history</code>对象保存了浏览器的历史记录，JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。 </p></blockquote><h4 id="2、操作-DOM"><a href="#2、操作-DOM" class="headerlink" title="2、操作 DOM"></a>2、操作 DOM</h4><h6 id="▉-更新-DOM"><a href="#▉-更新-DOM" class="headerlink" title="▉ 更新 DOM"></a>▉ 更新 DOM</h6><p><strong>1）<code>innerHtml</code>属性</strong></p><blockquote><p>修改文本。用<code>innerHTML</code>时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，<strong>要注意对字符编码来避免XSS攻击。</strong> </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p-id'</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC'</span>; <span class="comment">// &lt;p id="p-id"&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.innerHTML = <span class="string">'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ'</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure><p><strong>2) 修改 innerText 或 textContent 属性</strong></p><blockquote><p>可以自动对字符串进行HTML编码，保证无法设置任何HTML标签： </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.innerText = <span class="string">'&lt;script&gt;alert("Hi")&lt;/script&gt;'</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br></pre></td></tr></table></figure><p><strong>3) 两者区别 </strong></p><blockquote><p>读取属性，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本。另外注意 <strong>IE &lt; 9</strong> 支持<code>textContent</code>。 </p></blockquote><p><strong>4）设置 CSS 样式 </strong></p><blockquote><p>DOM节点的<code>style</code>属性对应所有的 CSS 。CSS允许<code>font-size</code>这样的名称使用驼峰命名法（fontSize）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.style.fontSize = &apos;20px&apos;;</span><br></pre></td></tr></table></figure><h6 id="▉-插入-DOM"><a href="#▉-插入-DOM" class="headerlink" title="▉ 插入 DOM"></a>▉ 插入 DOM</h6><p><strong>1）使用 <code>appendChild</code> 把一个子节点添加到父节点的最后一个子节点。 </strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>),</span><br><span class="line">    haskell = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">    haskell.id = <span class="string">'haskell'</span>;</span><br><span class="line">    haskell.innerText = <span class="string">'Haskell'</span>;</span><br><span class="line">    list.appendChild(haskell);</span><br></pre></td></tr></table></figure><p><strong>2) insertBefore 插入指定位置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 将子节点插入到 referenceElement 之前</span><br><span class="line">parentElement.insertBefore(newElement, referenceElement);</span><br></pre></td></tr></table></figure><h6 id="▉-删除-DOM"><a href="#▉-删除-DOM" class="headerlink" title="▉ 删除 DOM"></a>▉ 删除 DOM</h6><blockquote><p>parentElement () 得到删除节点的父节点，然后 removeChild() 删除节点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">'to-be-removed'</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">var</span> parent = self.parentElement;</span><br><span class="line"><span class="comment">// 删除:</span></span><br><span class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>1、删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 </p><p>2、parent.children[0] 删除节点的时候注意下标。</p></blockquote><h4 id="3、操作表单"><a href="#3、操作表单" class="headerlink" title="3、操作表单"></a>3、操作表单</h4><p>HTML表单的输入控件主要有以下几种： </p><ul><li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li><li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li><li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li><li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li><li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li><li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li></ul><h6 id="▉-获取值"><a href="#▉-获取值" class="headerlink" title="▉ 获取值"></a>▉ 获取值</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;input type="text" id="email"&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>);</span><br><span class="line">input.value; <span class="comment">// '用户输入的值'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;</span></span><br><span class="line">mon.value; <span class="comment">// '1'</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure><h6 id="▉-提交表单"><a href="#▉-提交表单" class="headerlink" title="▉ 提交表单"></a>▉ 提交表单</h6><p><strong>方法一：</strong></p><blockquote><p>响应一个 button 方法。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test-form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"doSubmitForm()"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'test-form'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 提交form:</span></span></span><br><span class="line"><span class="undefined">    form.submit();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><blockquote><p>onsubmit 事件。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login-form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkForm()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"input-password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"md5-password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'input-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">'md5-password'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line"><span class="undefined">    md5_pwd.value = toMD5(input_pwd.value);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="4、操作文件"><a href="#4、操作文件" class="headerlink" title="4、操作文件"></a>4、操作文件</h4><blockquote><p>在表单提交文件时，from 表单的 enctype  属性应该使用 <code>multipart/form-data</code>  不对文件数据进行编码才能上传，其他数据默认 <code>application/x-www-form-urlencoded</code>  编码再提交。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//input 的 ID</span><br><span class="line">var f = document.getElementById(&apos;test-file-upload&apos;);</span><br><span class="line">var filename = f.value; // &apos;C:\fakepath\test.png&apos;</span><br><span class="line">if (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) &#123;</span><br><span class="line">    alert(&apos;Can only upload image file.&apos;);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="▉-File-API-操作文件"><a href="#▉-File-API-操作文件" class="headerlink" title="▉ File API 操作文件"></a>▉ File API 操作文件</h6><blockquote><p>HTML5的File API提供了 <code>File</code> 和 <code>FileReader</code> 两个主要对象，可以获得文件信息并读取文件。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">            fileInput = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-file'</span>),</span><br><span class="line">            info = <span class="built_in">document</span>.getElementById(<span class="string">'test-file-info'</span>),</span><br><span class="line">            preview = <span class="built_in">document</span>.getElementById(<span class="string">'test-image-preview'</span>);</span><br><span class="line">            <span class="comment">// 监听change事件:</span></span><br><span class="line">            fileInput.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 清除背景图片:</span></span><br><span class="line">                preview.style.backgroundImage = <span class="string">''</span>;</span><br><span class="line">                <span class="comment">// 检查文件是否选择:</span></span><br><span class="line">                <span class="keyword">if</span> (!fileInput.value) &#123;</span><br><span class="line">                    info.innerHTML = <span class="string">'没有选择文件'</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取File引用:</span></span><br><span class="line">                <span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 获取File信息:</span></span><br><span class="line">                info.innerHTML = <span class="string">'文件: '</span> + file.name + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                                <span class="string">'大小: '</span> + file.size + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">                                <span class="string">'修改: '</span> + file.lastModifiedDate;</span><br><span class="line">                <span class="keyword">if</span> (file.type !== <span class="string">'image/jpeg'</span> &amp;&amp; file.type !== <span class="string">'image/png'</span> &amp;&amp; file.type !== <span class="string">'image/gif'</span>) &#123;</span><br><span class="line">                    alert(<span class="string">'不是有效的图片文件!'</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 读取文件:</span></span><br><span class="line">                <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">                <span class="comment">//异步操作的回调函数</span></span><br><span class="line">                reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span></span><br><span class="line">                        data = e.target.result; <span class="comment">// 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'            </span></span><br><span class="line">                    preview.style.backgroundImage = <span class="string">'url('</span> + data + <span class="string">')'</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">// 以DataURL的形式读取文件:(异步操作)</span></span><br><span class="line">                reader.readAsDataURL(file);</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h4 id="5、AJAX"><a href="#5、AJAX" class="headerlink" title="5、AJAX"></a>5、AJAX</h4><blockquote><p>需要注意的几点：</p><p>1、通过检测<code>window</code>对象是否有<code>XMLHttpRequest</code>属性来确定浏览器是否支持标准的<code>XMLHttpRequest</code> </p><p>2、先设置<code>onreadystatechange</code>的回调函数。在回调函数中，通常我们只需通过<code>readyState === 4</code>判断请求是否完成 </p><p>3、<code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数，分别为请求方式、URL地址、是否使用异步。</p><p>4、send 发送，Get 不需要参数，Post 需要把 body 部分以字符串或者 FormData 对象传进去。</p><p>关于 FromData 请查看：<a href="https://wangdoc.com/javascript/bom/form.html#formdata-%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">FormData</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = <span class="string">'Error code: '</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">//现代浏览器</span></span><br><span class="line">    request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//低版本 IE 浏览器</span></span><br><span class="line">    request = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</span><br></pre></td></tr></table></figure><h4 id="6、Cookie"><a href="#6、Cookie" class="headerlink" title="6、Cookie"></a>6、Cookie</h4><h6 id="▉-定义-1"><a href="#▉-定义-1" class="headerlink" title="▉ 定义"></a>▉ 定义</h6><blockquote><p>1）概念：Cookie 小段文本信息，存储于计算机硬盘中，大小只有 4 k。</p><p>2）特点：每个 Cookie 文件都对应一个域名，同一域名下的所以页面可以共享 Cookie，不能跨域名访问。</p><p>3）使用：通常从 document 中提取 cookie 属性提供给 javascript，然后进行创建或发送 cookie 到服务器。</p></blockquote><h6 id="▉-作用-2"><a href="#▉-作用-2" class="headerlink" title="▉ 作用"></a>▉ 作用</h6><blockquote><p>cookie 是存在用户硬盘中，用户每次访问站点时，Web应用程序都可以读取 Cookie 包含的信息。当用户再次访问这个站点时，<strong>浏览器就会在本地硬盘上查找与该 URL 相关联的 <code>Cookie</code></strong>。如果该 Cookie 存在，浏览器就将它添加到 <code>request header</code> 的 <code>Cookie</code> 字段中，与 <code>http请求</code> 一起发送到该站点。 </p></blockquote><h6 id="▉-缺点"><a href="#▉-缺点" class="headerlink" title="▉ 缺点"></a>▉ 缺点</h6><ul><li>安全性：由于cookie在HTTP中是明文传递的，其中包含的数据都可以被他人访问，可能会被篡改、盗用。</li><li>大小限制：cookie的大小限制在4KB左右，若要做大量存储显然不是理想的选择。</li><li>增加流量：cookie每次请求都会被自动添加到Request Header中，无形中增加了流量。cookie信息越大，对服务器请求的时间也越长。</li></ul><h6 id="▉-用途"><a href="#▉-用途" class="headerlink" title="▉ 用途"></a>▉ 用途</h6><blockquote><p>Cookie 一般用于保存网页访问者的信息。</p><p>1）保存用户登录信息。在一些登录网站选择下次自动登录，登录成功后，后台对用户名和密码进行加密返回数据，客户端就会将数据存储到 Cookie 中。当用户下一次进行登录时，判断 Cookie 中否存在值，存在则将Cookie 信息加到 HTTP 头部发送到服务器，实现自动登录。</p><p>2）创建购物车。通常将选择的物品放入 Cookie 中，同一域名下页面实现 Cookie 共享，提交订单将 Cookie 传到后台。</p><p>3）跟踪用户。用 Cookie 记录用户的偏好信息，然后推广小广告，在侧边栏经常是我们之前搜索过的内容。</p></blockquote><h6 id="▉-其他存储机制"><a href="#▉-其他存储机制" class="headerlink" title="▉ 其他存储机制"></a>▉ 其他存储机制</h6><blockquote><p><strong>1）web存储机制 </strong> </p><ul><li>sessionStorage：用于一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除 </li><li>localStorage ：用于跨会话持久化地存储数据。</li></ul><p><strong>2）indexedDB </strong></p><ul><li>是 indexed Database API 的简称，是在浏览器中保存结构化数据的一种「数据库」，它类似SQL数据库的结构化数据存储机制 ， 它能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。 </li></ul></blockquote><h4 id="7、-同源跨域问题"><a href="#7、-同源跨域问题" class="headerlink" title="7、 同源跨域问题"></a>7、 同源跨域问题</h4><p>请查看另一篇：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript 的重点学习路线完整篇。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack成神之路之插件配置【CSS 图片处理_08】</title>
    <link href="http://yoursite.com/2019/05/08/Webpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90CSS%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86_08%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/08/Webpack成神之路之插件配置【CSS图片处理_08】/</id>
    <published>2019-05-08T08:25:02.150Z</published>
    <updated>2019-05-09T06:52:09.523Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>webpack 处理 CSS 中的图片！</p><a id="more"></a> <h2 id="01-CSS-中的图片处理"><a href="#01-CSS-中的图片处理" class="headerlink" title="01|CSS 中的图片处理"></a>01|CSS 中的图片处理</h2><h4 id="1、图片准备"><a href="#1、图片准备" class="headerlink" title="1、图片准备"></a>1、图片准备</h4><blockquote><p>通常我们保存的图片早 <code>src</code> 中的 <code>images</code> 文件夹下。</p></blockquote><h4 id="2、安装解析图片的-loader"><a href="#2、安装解析图片的-loader" class="headerlink" title="2、安装解析图片的 loader"></a>2、安装解析图片的 loader</h4><blockquote><p>1）当我们直接用 <code>webpack</code> 命令时，就会报错，报错的原因就是无法解析 <code>CSS</code> 中的图片。之前解析 <code>CSS</code> 文件使用的 <code>loader</code> ，所以我们要添加专门解析图片用的 <code>loader</code>。</p><p>2）<code>webpack</code> 打包将各个模块打包成一个文件，所以我们的样式文件 <code>url</code> 是相对于 <code>CSS</code> 文件的，当我们打包成一个文件，<code>url</code>  的路径是相对于 <code>html</code> 而言的，导致原来的 <code>css</code> 文件引入的路径就会导致找不到原来的图片位置。</p><p>3）图片过多，导致有很多的 http 请求，降低页面的性能。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br></pre></td></tr></table></figure><ul><li><strong>file-loader：</strong>这个模块主要解决上述 （2）的问题。<code>file-loader</code> 可以解析项目中的 <code>ur</code> l引入（不仅限于 <code>css</code> ），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。</li><li><strong>url-loader：</strong>这个模块主要解决上述 （3）的问题。<code>url-loader</code> 会将引入的图片编码，生成 <code>dataURl</code>。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此 <code>url-loader</code> 提供了一个 <code>limit</code> 参数，小于 <code>limit</code> 字节的文件会被转为 <code>DataURl</code>，大于 <code>limit</code> 的还会使用 <code>file-loader</code> 进行 <code>copy</code>.。</li></ul><h4 id="3、配置-loader"><a href="#3、配置-loader" class="headerlink" title="3、配置 loader"></a>3、配置 loader</h4><blockquote><ul><li><code>test:/.(png|jpg|gif)/：</code>是匹配图片文件后缀名称。</li><li><code>use：</code>是指定使用的 <code>loader</code> 和 <code>loader</code> 的配置参数。</li><li><code>imit：</code>是把小于 <code>500000B</code> 的文件打成 <code>Base64</code> 的格式，写入JS。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpg|gif)/</span>,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    options:&#123;</span><br><span class="line">                        limit: <span class="number">500000</span>,</span><br><span class="line">                        outputPath:<span class="string">'images/'</span>, <span class="comment">// 将图片放到规定的目录下</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125; </span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="4、url-loader-和-file-loader-的关系"><a href="#4、url-loader-和-file-loader-的关系" class="headerlink" title="4、url-loader 和 file-loader 的关系"></a>4、url-loader 和 file-loader 的关系</h4><blockquote><p><code>url-loader</code>封装了 <code>file-loader</code>，配置中的 <code>limit</code> ，<code>url-loader</code> 会调用  <code>file-loader</code>进行处理。</p></blockquote><h2 id="02-CSS分离与图片路径处理"><a href="#02-CSS分离与图片路径处理" class="headerlink" title="02|CSS分离与图片路径处理"></a>02|CSS分离与图片路径处理</h2><blockquote><p>1）把 <code>CSS</code> 从J <code>avasScript</code> 代码中分离出来 。</p><p>2）如何处理分离出来后 <code>CSS</code> 中的图片路径不对问题 。</p></blockquote><h4 id="1、CSS-分离"><a href="#1、CSS-分离" class="headerlink" title="1、CSS 分离"></a>1、CSS 分离</h4><blockquote></blockquote><h4 id="2、安装插件（extract-text-webpack-plugin）"><a href="#2、安装插件（extract-text-webpack-plugin）" class="headerlink" title="2、安装插件（extract-text-webpack-plugin）"></a>2、安装插件（extract-text-webpack-plugin）</h4><blockquote><p>注意版本号，我 webpack3.0 使用的是 2.0.1 版本的插件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin@<span class="number">2.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h4 id="3、配置文件"><a href="#3、配置文件" class="headerlink" title="3、配置文件"></a>3、配置文件</h4><blockquote><p>1）引入插件。</p><p>2）new 出插件对象。</p><p>3）修改 <code>style-loader</code> 和 <code>css-loader</code>。 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入插件</span></span><br><span class="line"><span class="keyword">const</span> extractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>); </span><br><span class="line"><span class="comment">// 此路径是分离的 CSS 文件路径</span></span><br><span class="line"><span class="keyword">new</span> extractTextPlugin(<span class="string">"/css/index.css"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">        use:extractTextPlugin.extract(&#123;</span><br><span class="line">            fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">            use: <span class="string">"css-loader"</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="4、路径失效问题"><a href="#4、路径失效问题" class="headerlink" title="4、路径失效问题"></a>4、路径失效问题</h4><h2 id="03-处理-HTML-中的图片"><a href="#03-处理-HTML-中的图片" class="headerlink" title="03|处理 HTML 中的图片"></a>03|处理 HTML 中的图片</h2><blockquote><p>通常我们会在 HTML 中引入图片，需要对 HTML 中的图片进行打包。</p></blockquote><h4 id="1、安装-Loader"><a href="#1、安装-Loader" class="headerlink" title="1、安装 Loader"></a>1、安装 Loader</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br></pre></td></tr></table></figure><h4 id="2、配置-Loader"><a href="#2、配置-Loader" class="headerlink" title="2、配置 Loader"></a>2、配置 Loader</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(htm|html)$/i</span>,</span><br><span class="line">     use:[ <span class="string">'html-withimg-loader'</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack 处理 CSS 中的图片！&lt;/p&gt;
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/webpack/"/>
    
    
      <category term="前端工具" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之【CSS 常用布局】</title>
    <link href="http://yoursite.com/2019/05/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90CSS%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E3%80%91/"/>
    <id>http://yoursite.com/2019/05/06/前端面试之道【CSS常用布局】/</id>
    <published>2019-05-05T23:43:01.094Z</published>
    <updated>2019-06-19T23:15:02.266Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CSS 中常用的几种布局方式！</p><a id="more"></a><h2 id="三种最基本的布局方式"><a href="#三种最基本的布局方式" class="headerlink" title="三种最基本的布局方式"></a>三种最基本的布局方式</h2><h3 id="1、流式布局"><a href="#1、流式布局" class="headerlink" title="1、流式布局"></a>1、流式布局</h3><blockquote><p>流动布局模型就是<strong>默认的</strong>网页布局模式。</p></blockquote><ul><li><strong>块级元素</strong>都会在所处的最近父级容器元素内<strong>自上而下</strong>按顺序垂直顺延分布，块元素的宽度一般为 100%，也就是父元素的宽度。</li><li><strong>内联元素</strong>一般<strong>从左到右</strong>依次分布显示。</li></ul><h3 id="2、浮动布局"><a href="#2、浮动布局" class="headerlink" title="2、浮动布局"></a>2、浮动布局</h3><blockquote><p>流式布局的元素基本都是在整个文档流中的，如果使用浮动布局，需要给某一元素设置浮动属性，脱离当前文档流。</p></blockquote><h3 id="3、层级布局"><a href="#3、层级布局" class="headerlink" title="3、层级布局"></a>3、层级布局</h3><blockquote><p>层级布局指的是通过<strong>相对定位</strong>以及<strong>绝对定位</strong>以及<strong>固定定位</strong>的方式来进行布局。</p><p>1）通过设置 top、left、right、bottom 来记性定位元素。</p><p>2）缺点：对于相应式的布局，该布局方式还有很多不便之处。</p></blockquote><ul><li><strong>fixed 定位：</strong>固定定位，相对于浏览器窗口进行定位，不随窗口滚动，可以和其他元素重叠，不占据空间。</li><li><strong>relative 定位：</strong>相对定位，相对于正常位置进行定位，原本的空间不会改变。</li><li><strong>absolute 定位：</strong>绝对定位，是相对于已经定位的父元素进行定位，如果没有父元素，就相当于 <code>&lt;html&gt;</code> ，不占据任何空间，定位元素可以和其他元素进行重叠。</li></ul><h2 id="弹性布局（Flex）"><a href="#弹性布局（Flex）" class="headerlink" title="弹性布局（Flex）"></a>弹性布局（Flex）</h2><h2 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h2><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><h2 id="两种自适应布局"><a href="#两种自适应布局" class="headerlink" title="两种自适应布局"></a>两种自适应布局</h2><h3 id="1、双飞翼布局"><a href="#1、双飞翼布局" class="headerlink" title="1、双飞翼布局"></a>1、双飞翼布局</h3><h3 id="2、圣杯布局"><a href="#2、圣杯布局" class="headerlink" title="2、圣杯布局"></a>2、圣杯布局</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 中常用的几种布局方式！&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
