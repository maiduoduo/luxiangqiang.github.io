<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机网络原理之【TCP三次和四次握手】]]></title>
    <url>%2F2019%2F07%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E3%80%90TCP%E4%B8%89%E6%AC%A1%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[关于 TCP 的三次握手和四次挥手！ 一、TCP 的三次握手1.1 握手作用 1、为了确认双方的接收与发送能力是否正常。 2、指定自己的初始化序列号，为后面的可靠传送做准备。 3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。 1.2 握手过程1、初始状态：客户端处于 closed 状态，服务器处于 listen 状态。 2、第一次握手：客户端给服务端发送一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。 3、第二次握手：服务端收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为答应，并且也指定了自己的初始化序列号 ISN(s),同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到客户端的 SYN，此时服务器处于 SYN_REVD 的状态。 4、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。 5、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。 1.3 初始化序列号(ISN) 是固定的吗？ 1、三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。 2、如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。 1.4 什么是半连接队列 服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 1.5 三次握手过程中可以携带数据吗？ 第一次、第二次不可以携带数据的，第三次握手是可以携带数据的。 原因： 1、因为第一次握手可以携带数据的话，攻击者就会在 SYN 的报文中放入大量的数据，攻击者不会理会服务器的接受、发送能力，所以疯狂的发送 SYN 报文，导致服务器花很长时间、内存空间来接受这些报文，如果第一次握手可以放数据的话，第一个原因就是让服务器更加容易受到攻击。 2、对于第三次握手，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了。 1.6 HTTPS 的认证过程 二、TCP 的四次挥手四次挥手过程1、初始化状态：刚开始双方都处于 establised 状态，客户端发起关闭请求。 2、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于CLOSED_WAIT1状态。 3、第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT2状态。 4、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 5、第四次挥手：号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。 6、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 TIME_WAIT 状态 1、为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。 2、至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
      <tags>
        <tag>网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶深入系列之【this上下文】]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90this%20%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%91%2F</url>
    <content type="text"><![CDATA[函数的调用 arguments 和 this、函数的调用方式、函数上下文方式！ 一、this 和 arguments1、this 执行上下文 this 表示被调用函数上下文对象。 2、argumments 参数 表示函数调用过程中传递的所有参数。arguments 是个类数组结构，并不能当数组使用 。 1arguments[2] 二、函数调用 函数的上下文 this 取决于函数的调用方式！，函数的调用一共四种： 直接调用； 对象调用； 构造函数调用（new）； apply、call 调用； 1、直接调用 直接调用的三种方式：this 的指向，在非严格模式下，this 指向 window，在严格模式下，this 指向 undefined。 函数定义调用； 函数表达式调用； 立即执行函数调用； 2、对象调用 某个对象调用函数，this 将会执行调用的对象，并且可以在函数内部访问到。 3、 构造函数调用 通过 new 操作符调用函数，生成一个实例化对象。 注意： 1）如果构造函数返回一个对象，则该对象作为整个表达式的值返回，而传入构造函数的 this 将被丢弃。 2）如果构造函数返回的是非对象类型，则忽略返回值，返回新创建的对象。 1）创建一个空对象； 2）将该对象作为 this 参数传递给构造函数，称为构造函数的上下文； 3）构造函数将新对象返回。 4、 Call 调用▉ Call 的内部实现 首先 context 为可选参数，如果不传的话默认上下文为 window； 接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数； 因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来； 然后调用函数并将对象上的函数删除。 ▉ ※ 手写一个 call 方法： 123456789101112131415161718192021222324252627282930// this 为调用的函数// context 是参数对象Function.prototype.myCall = function(context)&#123; // 判断调用者是否为函数 if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125; // 不传参默认为 window context = context || window // 新增 fn 属性,将值设置为需要调用的函数 context.fn = this // 将 arguments 转化为数组将 call 的传参提取出来 [...arguments] const args = Array.from(arguments).slice(1) // 传参调用函数 const result = context.fn(...args) // 删除函数 delete context.fn // 返回执行结果 return result;&#125;// 普通函数function print(age)&#123; console.log(this.name+" "+age);&#125;// 自定义对象var obj = &#123; name:'小鹿'&#125;// 调用函数的 call 方法print.myCall(obj,1,2,3) 5、apply 调用▉ apply 的内部实现 首先 context 为可选参数，如果不传的话默认上下文为 window 接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数 因为 apply 传参是数组传参，所以取得数组，将其剥离为顺序参数进行函数调用 然后调用函数并将对象上的函数删除 ▉ ※ 手写一个 apply 方法： 12345678910111213141516171819202122232425262728293031323334// 手写一个 apply 方法Function.prototype.myApply = function(context)&#123; // 判断调用者是否为函数 if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125; // 不传参默认为 window context = context || window // 新增 fn 属性,将值设置为需要调用的函数 context.fn = this // 返回执行结果 let result; // 判断是否有参数传入 if(arguments[1])&#123; result = context.fn(...arguments[1]) &#125;else&#123; result = context.fn() &#125; // 删除函数 delete context.fn // 返回执行结果 return result;&#125;// 普通函数function print(age,age2,age3)&#123; console.log(this.name+" "+ age + " "+ age2+" "+age3);&#125;// 自定义对象var obj = &#123; name:'小鹿'&#125;// 调用函数的 call 方法print.myApply(obj,[1,2,3]) 4、补充 三者可以方便理解为：第一个参数调用了该方法，并将第二个参数作为该方法的参数传入。 共同点： ① apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的； ② apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文； ③ apply 、 call 、bind 三者都可以利用后续参数传参； 不同点： ① call 顺序传参，而 apply 是数组传参。 ② bind 的 this 取决于第一个参数，如果第一个参数为空，那么就是 window。 ③ bind 是返回对应函数（需要加一对花括号进行调用），便于稍后调用；apply 、call 则是立即调用 。 三、 箭头函数 之前的 this 的上下问问题会与预期不否(如：事件处理器)，但是可以通过 apply 、call 绕过。还有另外两种解决办法： 箭头函数 bind 函数 1、箭头函数 箭头函数可以规避上下文问题。箭头函数没有单独的 this 值。箭头函数的 this 与声明所在的上下文的 this 相同（调用箭头函数，不会隐士的传入 this 参数，而是从定义时的函数继承上下文）。 ▉ 箭头函数和对象字面量 1）箭头函数在创建的时候就已经确定了 this 的指向。 2）字面量中的箭头函数指向全局的 window 对象。 2、bind 函数▉ bind 的内部实现 判断调用者是否为函数。 截取参数，注意：这里有两种形式传参。 返回一个函数，判断外部哪种方式调用了该函数（new | 直接调用） ▉ ※ 手写一个 bind方法：12345678910111213141516171819202122232425262728293031323334353637// 手写一个 bind 函数Function.prototype.myBind = function (context) &#123; // 判断调用者是否为函数 if(typeof this !== &apos;function&apos;)&#123; throw new TypeError(&apos;Error&apos;) &#125; // 截取传递的参数 const args = Array.from(arguments).slice(1) // _this 指向调用的函数 const _this = this; // 返回一个函数 return function F()&#123; // 因为返回了一个函数，我们可以 new F()，所以需要判断 // 对于 new 的情况来说，不会被任何方式改变 this if(this instanceof F)&#123; return new _this(...args,...arguments) &#125;else&#123; return _this.apply(context,args.concat(...arguments)) &#125; &#125;&#125;// 普通函数function print()&#123; // new 的方式调用 bind 参数输出换做 [...arguments] console.log(this.name); &#125;// 自定义对象var obj = &#123; name:&apos;小鹿&apos;&#125;// 调用函数的 call 方法let F = print.myBind(obj,1,2,3);// 返回对象let obj1 = new F();console.log(obj1);]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>前端深入系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>前端深入系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端框架之Vue【生命周期】]]></title>
    <url>%2F2019%2F07%2F10%2F%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8BVue%E3%80%90%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%91%2F</url>
    <content type="text"><![CDATA[Vue 的生命周期！]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序之【生命周期】]]></title>
    <url>%2F2019%2F07%2F05%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E3%80%90%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%91%2F</url>
    <content type="text"><![CDATA[微信小程序的生命周期！ 一、小程序的生命周期1234567891011121314151617181920//app.js//功能：注册小程序（小程序的生命周期）App(&#123; // 小程序的启动，全局只调用一次 onLaunch:function(e)&#123; console.log(e+"初始化成功") &#125;, // 监听小程序页面显示——从后台进入前台 onShow:function()&#123; console.log("显示") &#125;, // 监听小程序隐藏——从前台进入后台 onHide:function()&#123; console.log("隐藏") &#125;, // 当小程序发生脚本错误时调用 onError: function (msg)&#123; console.log(“报错”); &#125;&#125;) #### 二、页面的生命周期12345678910111213141516171819202122Page(&#123; // 生命周期函数--监听页面加载 onLoad: function (options) &#123; console.log("page ---onLoad---"); &#125;, // 生命周期函数--监听页面初次渲染完成 onReady: function () &#123; console.log("page ---onReady---"); &#125;, // 生命周期函数--监听页面显示——后台进入前台 onShow: function () &#123; console.log("page ---onShow---"); &#125;, // 生命周期函数--监听页面隐藏——前台进入后台 onHide: function () &#123; console.log("page ---onHide---"); &#125;, // 生命周期函数--监听页面卸载——页面销毁 onUnload: function () &#123; console.log("page ---onUnload---"); &#125;&#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之道【设计模式】]]></title>
    <url>%2F2019%2F07%2F03%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[前端所用到的设计模式！ 发布-订阅者模式 发布-订阅者模式也叫做观察者模式。这是一种一对一或一对多的依赖关系，对象相当于发布方，当对象发生改变时，订阅方都会受到通知。 1、应用 MVC 模型中的 Model 与 View 之间的关系就是观察者模式。 Vue 中的响应式也是用到了该模式。 按钮的点击事件也属于该模式。 1234567&lt;ul id="ul"&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelector('#ul') ul.addEventListener('click', (event) =&gt; &#123; console.log(event.target); &#125;)&lt;/script&gt; 策略模式 定义一系列的算法，把它们封装起来，并且可以相互替换。 1、由来 在多种算法相似的情况下，使用 if-else 所带来的的复杂和难以维护。 2、适用条件 一个系统有多了类，区分它们的只是直接的行为。 3、优缺点 优点：算法自由切换、避免重复使用判断条件、扩展性好 缺点：策略类会增多、所有的类都会暴露接口 4、应用 MVC 中 View 与 Controller 之间的关系就是策略模式。 5、实例 计算器的加减乘除运算。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之道之框架【MVC/MVP/MVVM】]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E4%B9%8B%E6%A1%86%E6%9E%B6%E3%80%90MVVM%E3%80%91%2F</url>
    <content type="text"><![CDATA[什么是MVC/MVP/MVVM？ MVC 使用了两种模式，观察者模式和策略模式。 Model 和 View 之间使用的是观察者模式; View 和 Controller 之间采用的是策略模式; Controller 是 View 和 Model 之间的连接的枢纽。 一、Model 模型层 模型层主要封装了应用程序以及业务逻辑所使用到数据和处理数据的方法。Model 和 View 之间使用的是观察者模式，View 事先在 Model 上进行注册，一旦 Model 的数据发生改变，就会做出相应的改变。 二、View 视图层 视图层主要是负责数据的展示。View 和 Controller 之间采用的是策略模式，不同的 View 引用不同的 Controller 的实例来实现了特定的响应策略（比如点击事件）。 三、Controller 控制层 控制层主要用来连接 Model 和 View 。使用控制层来对用户界面的用户输入响应，连接模型层，用于控制对数据的改变，所有的业务逻辑主要集中在控制层。 MVP MVP 主要加大了 Model 和 View 解耦， View 不能直接获取 Model 层的数据，而是通过 Presenter 提供给 View 接口，负责将 View 和 Model 的数据进行手动同步。 MVVM MVVM 主要用框架封装了 MVP 中的 Presenter 的手动操作，主要实现了自动化的数据绑定，只要告诉 View 显示的数据是 Model 的哪一部分就可以了。 一、MVVM 出现的原因？ 1、由于前端开发混合了 HTML 、CSS、Javacript 众多页面，所以代码的组织和维护变的更加复杂，所以就出现了 MVVM 模式的原因。 2、MVVM 最早是微软提出来的，其实借鉴了桌面应用程序的 MVC 设计思想。 二、什么是 MVVM ？ MVVM 就是 Model-View-ViewMoudel 的缩写。 Model 就用纯 JavaScript 对象表示，View 负责显示，两者做到了极大限度的分离。把 Model 和 View 关联起来就是 ViewModel。ViewModel 主要负责把 Model 的数据同步到 View 显示，还负责把 View 修改的数据同步回 Model。 1、Model Model 视图层，只关注视图本身，可以理解成 json 对象。 2、View MVVM 中的 View 通过使用模板语法声明式的渲染 DOM，当 ViewModel 对 Model 进行更新的时候，通过数据绑定更新到 View。 3、ViewModel 与 MVP 不同的是，没有了 View 为 Presente 提供的接口，之前由 Presenter 负责的 View 和 Model之间的数据同步交给了 ViewModel 中的数据绑定进行处理，当 Model 发生变化，ViewModel 就会自动更新；ViewModel 变化，Model 也会更新。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 JS 基础篇之【浏览器中的高度】]]></title>
    <url>%2F2019%2F06%2F30%2F%E5%89%8D%E7%AB%AF%20HTML%20%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%AB%98%E5%BA%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[浏览器中的高度由内而外分为页面、窗口、屏幕！ 浏览器相关高度一、页面尺寸 1、Body 的总高度/总宽度 页面的可滚动的高度也算。 body.offsetHeight body.offsetWidth 2、Body 的可见区域高度/宽度 只展现出的可视化页面高度/宽度。 body.clientHeight body.clientWidth 3、滚动条的高度1window.Height - body.clientHeight = 滚动条的高度 二、浏览器尺寸 1、浏览器的高度 整个浏览器（内容+工具栏+滚动条）的高度/宽度。 window.outerHeight window.outerWidth 2、页面可用高度 除去工具栏只有（显示内容区域内容+滚动条）。 window.innerHeight window.innerWidth 可求出工具栏的高度： 1window.outerHeight - window.innerHeight 三、屏幕的尺寸 1、屏幕高度 整个屏幕的高度（内容+任务栏）。 screen.Height screen.Width 2、屏幕可用高度 除去任务栏的屏幕可用高度。 screen.availHeight screen.availWidth]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之道【浏览器缓存机制】]]></title>
    <url>%2F2019%2F06%2F30%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[浏览器的缓存机制涉及到性能优化领域！ 浏览器缓存机制 缓存是性能优化中最高效的一种方式，可以较少网络传输所带来的损耗。 一个数据请求分为三个阶段，发起网络请求、后台处理、浏览器响应。浏览器的缓存优化主要是在网络请求和浏览器响应这两个步骤中优化性能。第一种情况，直接使用缓存，不发起请求；第二种情况，发起请求，发现后端存储的数据和前端一致，就没必要传回来了。 一、缓存位置 缓存位置分为大体分为四种，会依次查看当前数据是否在缓存中，如果没有则会请求网络。 Service Worker Memory Cache Disk Cache Push Cache 网络请求 1、Service Worker Service 是运行在浏览器背后独立的线程，一般可用来实现缓存功能。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保证安全。 ▉ 如何使用？ 注册 Service Worker，然后监听到 install 事件之后就可以缓存需要的文件，用户在下次访问的时候就会拦截请求，然后查询是否已缓存，缓存的话就直接读取缓存文件，否则就去请求数据。 12345678910111213141516171819202122232425262728293031323334// index.js// 注册 Service Workerif (navigator.serviceWorker) &#123; navigator.serviceWorker .register('sw.js') .then(function(registration) &#123; console.log('service worker 注册成功') &#125;) .catch(function(err) &#123; console.log('servcie worker 注册失败') &#125;)&#125;// sw.js// 监听 `install` 事件，回调中缓存所需文件self.addEventListener('install', e =&gt; &#123; e.waitUntil( caches.open('my-cache').then(function(cache) &#123; return cache.addAll(['./index.html', './index.js']) &#125;) )&#125;)// 拦截所有请求事件// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据self.addEventListener('fetch', e =&gt; &#123; e.respondWith( caches.match(e.request).then(function(response) &#123; if (response) &#123; return response &#125; console.log('fetch source') &#125;) )&#125;)]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之浏览器【数据存储】]]></title>
    <url>%2F2019%2F06%2F26%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%90%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[浏览器的数据存储！ 浏览器中的存储功能 有四种存储功能：cookie、localStorage、sessionStorage、indexDB。 一、各个存储方式的区别？▉ 数据生命周期 cookie 一般由服务器生成，可以设置过期时间。 localStorage 除非被清理，否则一直存在。 sessionStorage 页面关闭就清理。 indexDB 除非被清理，否则一直存在。 ▉ 数据存储大小 cookie 4K localStorage 5M sessionStorage 5M indexDB 无限 ▉ 与服务器通信 cookie 每次都会携带在 header 中，对于请求性能影响 localStorage 不参与 sessionStorage 不参与 indexDB 不参与 二、谈谈 Cookie1、Cookie 的由来 因为 Http 是不保存状态的协议，所以在请求中插入一个 token 作为标识，但是这种方式易出错，所以有了 Cookie 的出现。 2、Cookie 的原理 第一次访问网站，浏览器发出请求，服务器响应之后，将 Cookie 放到响应中。当浏览器发送第二次请求的时候，就会携带 Cookie 用于辨别用户身份，服务器收到信息之后就会辨别用户的信息，做出相应的回应。 3、不可跨域性 在不同的域名下，每个 Cookie 会绑定单一的域名。 4、Cookie 的属性 name: 代表 cookie 的名字，不同的 name 会被覆盖掉。 value: 代表 cookie 的值。由于cookie规定是名称/值是不允许包含分号，逗号，空格的，所以为了不给用户到来麻烦，考虑服务器的兼容性，任何存储 cookie 的数据都应该被 URL 编码。 domain: 代表当前 Cookie 绑定的域名。统一域名的二级域名是不能交换 Cookie 的。 path: 默认设置为 ‘/’ ，否则会将路径路由绑定 Cookie。 expires：Cookie 的有效期，已经逐渐被 Max-Age 逐渐取代。默认的配置是当关闭浏览器，Cookie自动会被删除。该字段是以秒为单位的，整数时，过了多少秒之后就会被删除。为 0 时，删除 Cookie。为负数时，就会当浏览器窗口关闭时，Cookie 的就会消失。 secure：当这个属性设置为true时，此cookie只会在 https 和 ssl 等安全协议下传输。 HttpOnly: 如果设置为 true，就不能通过 js 脚本获取，有效防止 XSS 攻击。 5、设置 Cookie1document.cookie = &apos;myname=laihuamin;path=/;domain=.baidu.com&apos;;]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之道之【浏览器知识汇总】]]></title>
    <url>%2F2019%2F06%2F26%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E3%80%91%2F</url>
    <content type="text"><![CDATA[浏览器的相关必会的知识！ 一、浏览器的工作原理1、浏览器的工作原理 面试题：说一说浏览器工作的基本流程？ 浏览器的工作原理) 2、浏览器的渲染原理 面试题：说一说浏览器的渲染原理？ 浏览器的渲染原理) 3、浏览器的事件机制 面试题：事件的触发过程是怎么样的？ 4、浏览器的事件代理(委托) 面试题：知道什么是事件代理嘛？ 事件委托) 5、浏览器的运行机制(Event Loop) 面试题：浏览器的运行机制包括哪些？ 浏览器的运行机制) 二、浏览器跨域问题 面试题：什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求嘛？ 浏览器的跨域问题) 三、浏览器器的数据存储 面试题：有几种方式可以实现存储功能，分别有什么优缺点？ 四、浏览器的缓存机制 五、Service Worker 面试题：什么是 Service Worker？]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端框架之【Vue全家桶】]]></title>
    <url>%2F2019%2F06%2F24%2F%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B9%8B%E3%80%90Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E3%80%91%2F</url>
    <content type="text"><![CDATA[Vue 全家桶（Vue-router、Vuex ）浅入浅出！ Vue一、生命周期1、created 一般会在下边这个钩子函数中初始化页面的数据。 1234// 做服务器请求什么的created：&#123; &#125; 2、computed DOM 加载完成进行渲染，计算属性，实时响应，根据data中的值实时做出处理，就用 computed。 12345computed:&#123; 方法（）&#123; return ； // 通过方法返回值来使页面的数据进行变换 &#125;&#125; 二、指令1、v-show 用于控制控件的显示。 2、v-model 用于数据双向绑定，一般用于 input。 3、v-for 用于循环渲染数据。 4、@click 用于事件绑定。 三、组件 所有的组件存放到文件夹中，然后再 App.vue 进行导入。 1、公共组件 公共组件写到一个公共的文件夹中。 Vue-router 路由主要实现一级页面的跳转，二级页面跳转，三级页面跳转。 12// 安装路由npm install vue-router --save 1、导入/使用路由 新建一个路由文件夹，新建 router.js 文件，导入路由，使用路由。 12import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos; 1Vue.use(Router) 2、实例化路由对象 新建一个路由对象，然后暴露接口，在 Vue 的对象中去使用。 1234export default new Router(&#123; mode:&apos;history&apos;, routes: []&#125;) 123456new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) 3、配置路由的跳转路径 配置路由跳转对象，有三个参数： path：跳转路径。 name：路由的名字。 component ：跳转的组件。 12import Menu from &apos;@/components/Menu&apos;&#123;path: &apos;/menu&apos;,name: &apos;MenuLink&apos;,component: Menu&#125; 4、在跳转的组件上设置跳转 使用 router-link 标签进行设置跳转。 123456789101112131415161718// tag：替换的标签 :to : 使用的路由跳转对象（可以是由 path 也可以指定路由对象）// 方式一：静态绑定路由&lt;router-link to=&quot;/&quot;&gt;新闻&lt;/router-link&gt;// 方式二：动态绑定路由&lt;router-link :to=&quot;homeLink&quot;&gt;新闻&lt;/router-link&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; homeLink:&apos;/&apos; &#125; &#125;&#125;&lt;/script&gt;// 方式三：使用路由名字绑定路由&lt;router-link tag=&quot;div&quot; :to=&quot;&#123;name:&apos;historyLink&apos;&#125;&quot;&gt;新闻&lt;/router-link&gt; ▉ 默认跳转页面 如果输入错误的 URL 需要设置默认的跳转页面。 12// 错误路径跳转根目录&#123;path: &apos;*&apos;,redirect:&apos;/&apos;&#125;, ▉ 路由跳转方法123456789101112// 跳转上次浏览页面// this.$router.go(-1)// 指定跳转地址// this.$router.replace(&apos;/menu&apos;)// 指定跳转路由的名字下// this.$router.replace(&#123;name:&apos;MenuLink&apos;&#125;)// 通过push进行跳转(常用)this.$router.push(&apos;/menu&apos;)this.$router.push(&#123;name:&apos;MenuLink&apos;&#125;) 5、在页面使用路由 全局的 Vue.app 下使用路由的。 1&lt;router-view&gt;&lt;/router-view&gt; 6、二级路由和三级路由 在路由文件中配置二级路由和三级路由。然后在对应的组件进行绑定路由名，和在二级或三级组件下进行显示跳转页面。 1234567891011// 二级路由&#123;path: &apos;/about&apos;,name: &apos;AboutLink&apos;,component: About,children:[ &#123;&#125;, // 三级路由 &#123;&#125;,children:[ &#123;&#125;, &#123;&#125;, ]&#125;, &#123;&#125;, &#123;&#125;, ]&#125;, 7、进入默认显示页面 已进入二三级页面，要默认显示一个页面，而不是空白。 1redirect:&apos; &apos;// 默认显示的组件路径 8、全局守卫 全局守卫就是当进入整个路由页面时，要在进入之前做一些处理，比如弹框请先登录。 123456789router.beforeEach((to, from, next) =&gt; &#123; // 判断如果是登录页面或注册页面直接进入,否则提示登录 if(to.path == &quot;/login&quot; || to.path == &quot;/register&quot;)&#123; next(); &#125;else&#123; alert(&quot;您还没有登录,请先登录！&quot;) next(&quot;/login&quot;) // 将用户引导到登录页面中 &#125;&#125;) 9、后置钩子10、路由独享守卫 与全局守卫不同的是只作用于规定的路由页面。 1234&#123;path: &apos;/admin&apos;,name: &apos;AdminLink&apos;,component: Admin,beforeEnter:(to, from, next)=&gt;&#123; alert(&apos;非登陆状态进制访问！&apos;) next();&#125;&#125;, 11、组件守卫 在组件内使用，进入组件之前和离开组件之后进行做处理。 12345678910111213141516// 组件内守卫(进入/离开组件时应该做的事情) beforeRouteEnter:(to, from, next) =&gt; &#123; // 页面的渲染顺序是先渲染组件内守卫，然后渲染data,所以在守卫里边直接拿不到data里的数据，所以要使用next回调函数 next((vm) =&gt;&#123; alert("Hellow "+vm.name) &#125;) &#125;, // 离开组件时的守卫 beforeRouteLeave:(to, from, next) =&gt; &#123; if(confirm("确定要离开本页面吗？") == true)&#123; next(); &#125;else&#123; next(false) &#125; &#125; 12、组件复用 想要在当前页面下复用其他组件，必须在相对应的路由中进行配置，components。 123456789// 想在根目录的主页中复用组件，所以在对应的路由中进行配置。&#123;path: &apos;/&apos;,name: &apos;HomeLink&apos;,components:&#123; // 默认显示组件 default:Home, // 组件复用 &quot;history&quot;:History, &quot;delivery&quot;:Delivery, &quot;orderingGuilde&quot;:OrderingGuilde &#125;&#125;, 13、滚动行为 滚动路由直接定位页面要展现的位置。 Vuex Vuex 可以很好的实现组件间的数据共享。 1、本地安装 vuex1npm install vuex --save 2、在 src 下新建 store 文件夹以及文件 store.js3、在文件中引入 Vuex12import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos; 4、使用 Vuex1Vue.use(Vuex) 5、暴露出 Vuex 实例1234567891011121314151617export const store = new Vuex.Store(&#123; state:&#123; // 设置属性 &#125;, getters:&#123; // 获取属性的状态 &#125;, mutations:&#123; // 改变属性的状态 &#125;, actions:&#123; // 应用 mutations &#125;&#125;) 6、在 main.js 全局中的 Vue 实例中导入使用12345678import &#123;store&#125; from &apos;./store/store.js&apos;new Vue(&#123; el: &apos;#app&apos;, router, store, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) 7、必须通过 mutations 改变 state 中的属性123456mutations:&#123; // 改变属性的状态 setMenuItem(state,data)&#123; state.menuItems = data &#125; &#125;, 8、将数据存入 store（存入状态） 通过在组件中调用 mutations 的方法就可以将值传入. 1this.$store.commit(&quot;setMenuItem&quot;,data) //全局调用 store 中的 commit 方法 9、在 store 取出数据（取出状态） 在组件中获取状态通过全局调用 store.state 就可以。如果页面响应数据实时变化，可以将方法写在 computed 中。 ▉ 第一种方式：12// 这样获取有个缺点，直接将属性暴露在外部了this.$store.state.menuItems; // 全局获取 store 中的数据 ▉ 第二种方式：12// 通过 getter 获取this.$store.getters.getMenuItems; // 调用 getters 里边的方法 模块化分离 将 Vuex 中的各功能部分进行分离。分别建立独立文件，然后实现模块化。 1、四种状态进行分离12export const 功能import * as getters from &apos;./getters&apos; 123456789101112export const store = new Vuex.Store(&#123; state:&#123; // 设置属性 menuItems:&#123;&#125;, // Menu 菜单 menuItems2:&#123;&#125;, // Admin 菜单 username:null, // 当前用户名 isLogin:false // 当前的登录状态 &#125;, getters, mutations, actions&#125;) 2、使用 Moudle 优化分离12345678910111213141516171819202122const state = &#123; &#125;const getters = &#123; &#125;const mutations = &#123; &#125;const actions = &#123; &#125;export default&#123; state, getters, mutations, actions&#125; 12345678import users from &apos;./Module/users&apos;export const store = new Vuex.Store(&#123; modules:&#123; menu, status, users &#125;&#125;)]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之道【浏览器渲染原理】]]></title>
    <url>%2F2019%2F06%2F21%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E3%80%91%2F</url>
    <content type="text"><![CDATA[浏览器的渲染原理！ 一、浏览器的渲染原理 JS 代码执行有自己的 JS 引擎，而浏览器的渲染也有一个引擎叫做渲染引擎。Firefox 的渲染引擎叫做 Gecko，Chrome 和 Safari 中都是基于 WebKit 开发的。 1、DOM 树的构建 ① 当我们在网页中向服务器请求对应的 HTML 时，服务器将 HTML、CSS、JS 文件转化为 0,1字节数据在网络中传输给浏览器。 ② 浏览器将接收到的字节数据转化为字符串。 ③ 转化为字符串之后，浏览器再将这些字符串通过词法分析转化为标记（token）—— 代码的最小单位,这一过程叫做标记化。 ④ 结束标记化后，将这些标记转化为 Node 结点，浏览器根据不同的结点构建为一棵 DOM 树。 2、构建 CSSOM 树 ① 将 CSS 文件转化为 CSSOM 树。这个过程和上述过程是类似的，但是有一点不同，浏览器为了确定结点的样式，这个过程是非常耗时的。 ② 浏览器通过递归的方式 DOM 树为结点设置样式。通过过先找到具体的标签，然后递归找到设置的上级标签，最后确定选择器选择的所选标签的样式。 ③ 所以应该避免书写过于具体的 CSS 选择器，少一些添加无意义的 HTML 标签，有利于提高习页面的性能。 3、DOM + CSSOM 生成渲染树 将生成的 DOM 树和 CSSOM 树进行合并生成渲染树（Render Tree）。 ① 两者并不是简单的合并，而是渲染树只会包括需要显示的结点，如果某个节点是 display: none 的，那么就不会在渲染树中显示。 ② 浏览器生成渲染树的时候，就会根据渲染树进行布局（回流），调用 GPU 绘制，合成图层，显示在屏幕上。这一部分属于底层操作。 二、浏览器的渲染流程 由于我们屏幕的刷新率为每秒 60 次，也就是 16.7 ms 一次，所有说在刷新一次之间页面重新绘制两次是没有意义的，只会影响性能。 1、渲染帧的流程 渲染帧指的是一次完整绘制的过程。所以在 16.7 ms 一帧内渲染完成才会保证不会掉帧，否则页面会有卡顿感。（屏幕都渲染完成了，你的动画确还没有变化） 一帧需要完成以下操作： ① 脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等； ② 样式计算（CSS Object Model）：级联地生成每个节点的生效样式； ③ 布局（Layout）：计算布局，执行渲染算法； ④ 重绘（Paint）：各层分别进行绘制（比如 3D 动画）； ⑤ 合成（Composite）：合成各层的渲染结果； 2、耗时的 JS 会阻塞渲染 可以观察到虽然每秒都会写一次 DOM，但在 5s 结束后才会全部渲染出来，明显耗时脚本阻塞了渲染。 123456789101112131415161718// &lt;div id="message"&gt;&lt;/div&gt;&lt;script&gt;var then = Date.now()var i = 0var el = document.getElementById('message')while (true) &#123; var now = Date.now() if (now - then &gt; 1000) &#123; if (i++ &gt;= 5) &#123; break; &#125; el.innerText += 'hello!\n' console.log(i) then = now &#125;&#125;&lt;/script&gt; 三、为什么操作 DOM 慢 因为操作 DOM 是属于渲染引擎的东西，而 JS 属于 JS 引擎的东西，所以我们通过 JS 操作 DOM 的时候，这个过程涉及到两个线程的通信，那就回带来一些性能上的损耗。如果操作 DOM 次数过多，就相当于两个线程之间一直通信，并且操作 DOM 会导致重绘回流的情况，性能就会有所下降。 1、插入几万 DOM 怎么实现页面不卡顿？ 两种解决方案： 1）第一种通过 requestAnimationFrame 的方式循环插入 DOM。 2）第二种方式是通过虚拟滚动。 2、两种实现方式 requestAnimationFrame 实现。 123456789101112131415161718192021222324252627const total = 30000; // 总 DOM 数const size = 100; // 每次渲染的 DOM 数const bathCount = total / size; // 一共处理 300 次var countDone = 0; // 已经处理完的多少次const ul = document.querySelector('ul');function addItems()&#123; const fragment = document.createDocumentFragment(); // 一次渲染 100 个DOM for (var i = 0; i &lt; size; i++) &#123; var li = document.createElement('li'); li.innerText = 'item ' + (countDone * size + i); fragment.appendChild(li); &#125; // 每次插入 100 个结点就修改 DOM 一次 ul.appendChild(fragment); // 已经完成插入的次数 countDone++; // 判断是否处理完成 if(countDone &lt; bathCount)&#123; window.requestAnimationFrame(addItems); &#125;&#125;addItems(); 虚拟滚动实现： 12 四、什么情况阻塞渲染1、阻塞的原因 1）渲染的前提是生成渲染树才能下一步的渲染，所以生成渲染树的过程也就是加载 HTML 和 CSS 肯定会阻塞渲染。（js 阻塞渲染也会阻塞解析，而CSS 只会阻塞渲染，不会阻塞解析） 2）当浏览器在解析 script 标签的时候会暂停 DOM，完成后会在从暂停的地方重新开始。 2、减少阻塞 1）要想渲染的越快，就必须降低渲染文件的大小，优化选择器。 2）想要第一次加载页面加载的快，所以将 JS 文件标签放在 body 底部。 3）当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。 4）对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。 补充： async 异步下载脚本，下载完执行执行，在 onload 事件触发之前，不会阻塞页面但是不能保证脚本出现的顺序执行。 defer 属性也会异步下载，但是会按照页面脚本的执行顺序下载，脚本的执行是按照页面脚本顺序执行的。而且是在 DOM 解析完成和 onload 触发之前执行。 五、重绘（Repaint）和回流(Reflow) 回流必将引起重绘，重绘不一定会引起回流。 1、重绘 在文档流中的位置并未发生改变，重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘。 2、回流 在文档流中为止发生改变，回流是布局或者几何属性需要改变就称为回流。 3、重绘/回流与EventLoop① 当 EventLoop 执行完微任务后，会判断 document 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次； ② 然后判断是否有 resize 或者 scroll 事件，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能； ③ 判断是否触发了 media query； ④ 更新动画并且发送事件； ⑤ 判断是否有全屏操作事件； ⑥ 执行 requestAnimationFrame 回调； ⑦ 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好； ⑧ 更新界面； ⑨ 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。 4、如何减少重绘和回流① 使用 transform 替代 top； ② 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）; ③ 不要把节点的属性值放在一个循环里当成循环里的变量; ④ 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局; ⑤ 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame; ⑥ CSS 选择符从右往左匹配查找，避免节点层级过多; ⑦ 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之【CSS3的新特性】]]></title>
    <url>%2F2019%2F06%2F20%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90CSS3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%91%2F</url>
    <content type="text"><![CDATA[CSS3 的有哪些新特性？ 一、CSS3新增选择器 p:first-of-type | p:last-of-type ` 选择所有父元素该元素出现的第一个(最后一个)元素。 p:nth-child(2) 选择父元素的第二个元素。 p:first-child | p:last-child 选择父元素的第一个元素或最后一个元素。 p:only-of-type 选择父元素唯一没有兄弟节点的元素。 :enabled :disabled 选择表单禁用状态的输入框。 :checked 选择单选按钮或复选框被选择状态的。 二、文本 text-shadow:参数1 参数2 参数3 参数4 向右偏移 向下偏移 渐变像素 渐变颜色； white-space: nowrap; 禁止文字换行； text-overflow: ellipsis 文字溢出部分显示省略号（必须隐藏元素overflow:hidden）； clip:文字溢出部分剪切掉。 word-wrap: 对长的不可分割的单词进行分割并换行到下一行 三、边框 border-radius:圆角边框 border-shaow:盒阴影 border-shadow: 右偏移 下偏移 模糊程度 阴影颜色 border-images-*: source 图片路径 slice 向内偏移 width 边框宽度 outset边框区域超出边框的量 repeat : repeat/round/stretch 是否平铺/铺满/拉伸 四、背景 background-image:背景图片 background-size：指定背景图片的大小 cover : 缩放不变 /contain：保持最大大小 background-origin：定位背景图片的位置 content-box/border-box/padding-box background-clip：规定背景的绘制区域 五、渐变 渐变分为线性渐变（Linear-gradient）和径向渐变(Radial-gradient) 1、线性渐变 background:linear-gradient (起始位置，起始颜色，终止颜色); top bottom left right 以及对角线组合; 自定义角度（30deg）— 顺时针; 颜色可多个组合; 透明度渐变(rgba CSS3新属性); repeating-linear-gradient() 函数用于重复线性渐变; 2、径向渐变 background: radial-gradient(center, shape size, start-color, ..., last-color); center 渐变中心 指定渐变颜色大小 size （不均匀分布） 第一参数：设置形状（circle、ellipse椭圆） 也可以设置成尺寸 repeating-radial-gradient() 函数用于重复线性渐变; 六、过渡七、动画、旋转]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶深入系列之【垃圾回收机制】]]></title>
    <url>%2F2019%2F06%2F19%2F%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E3%80%91%2F</url>
    <content type="text"><![CDATA[JS 引擎以及 V8 引擎的垃圾回收机制是怎么样的？ s### 内存泄漏#### 1、什么是内存泄漏？&gt; 不再用到的内存，没有及时释放，就叫做内存泄漏。内存泄漏是指我们已经无法再通过js代码来引用到某个对象，但垃圾回收器却认为这个对象还在被引用，因此在回收的时候不会释放它。导致了分配的这块内存永远也无法被释放出来。如果这样的情况越来越多，会导致内存不够用而系统崩溃。#### 2、怎么解决内存泄漏？&gt; 很多编程语言需要手动释放内存，但是很多开发者喜欢系统提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”。### 一、为什么有垃圾回收机制？&gt; js 中的字符串、对象、数组等只有确定固定大小时，才会动态分配内存，只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃### 二、js 的垃圾回收机制&gt; JavaScript 与其他语言不同，它具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。### 三、垃圾回收机制原理&gt; 找出那些不再继续使用的变量，然后释放其内存。垃圾回收器会按照固定的时间间隔，周期性的执行该垃圾回收操作。### 四、两种垃圾回收策略&gt; js 中最常用的就是标记清除法。垃圾收集器必须跟踪哪个变量有用哪个没用，对于没有用的变量打上标记，以备将来收集其内存。- 标记清除法- 引用计数法#### 1、标记清除法&gt; 垃圾回收器会在运行的时候，会给存储在内存中的所有变量都加上标记，然后它会去掉环境中变量以及被环境中的变量引用的变量的标记。剩下的就视为即将要删除的变量，原因是在环境中无法访问到这些变量了。最后垃圾回收器完成内存清除操作。###### ▉ 实现原理&gt; 通过判断一个变量是否在执行环境中被引用，来进行标记删除。###### ▉ 标记清除的缺陷&gt; 其实标记清除和引用计数的缺陷相同的，因为都是判断变量在执行环境中的引用来确定该变量是否应该被回收，当保持着引用时，改变变量会一直在内存中存储。#### 2、引用计数法&gt; 引用计数的垃圾收集策略不常用，引用计数的最基本含义就是跟踪记录每个值被引用的次数。###### ▉ 实现原理&gt; 当声明变量并将一个引用类型的值赋值给该变量时，则这个值的引用次数加 1，同一值被赋予另一个变量，该值的引用计数加 1 。当引用该值的变量被另一个值所取代，则引用计数减 1，当计数为 0 的时候，说明无法在访问这个值了，所有系统将会收回该值所占用的内存空间。###### ▉ 引用计数的缺陷&gt; 两个对象的相互循环引用，在函数执行完成的时候，两个对象相互的引用计数并未归 0 ，而是依然占据内存，无法回收，当该函数执行多次时，内存占用就会变多，导致大量的内存得不到回收。举例：最常见的就是在 IE BOM 和 DOM 中，使用的对象并不是 js 对象，所以垃圾回收是基于计数策略的。但是在 IE9 已经将 BOM 和 DOM 真正的转化为了 js 对象，所以循环引用的问题得到解决。#### 3、管理内存&gt; 虽然说是 js 的内存都是自动管理的，但是对于 js 还是存在一些问题的，最主要的一个问题就是分配给 Web 浏览器的可用内存数量通常比分配给桌面应用程序的少。###### ▉ 主要原因&gt; 也是为了安全方面考虑，防止运行 js 网页将系统内存耗尽，导致整个系统崩溃。内存限制问题不仅影响到了给变量分配内存，还会影响调用栈以及线程同时执行的语句数量。###### ▉ 解决方案&gt; 为了能够让页面获得最好的性能，必须确保 js 变量占用最少的内存，最好的方式就是将不用的变量引用释放掉，也叫做解除引用。- 对于局部变量来说，函数执行完成离开环境变量，变量将自动解除。- 对于全局变量我们需要进行手动解除。（注意：解除引用并不意味被收回，而是将变量真正的脱离执行环境，下一次垃圾回收将其收回）123var a = 20; // 在堆内存中给数值变量分配空间alert(a + 100); // 使用内存var a = null; // 使用完毕之后，释放内存空间 补充：因为通过上边的垃圾回收机制的标记清除法的原理得知，只有与环境变量失去引用的变量才会被标记回收，所用上述例子通过将对象的引用设置为 null ，此变量也就失去了引用，等待被垃圾回收器回收。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>前端深入系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>前端深入系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之道【网络攻击】]]></title>
    <url>%2F2019%2F06%2F19%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E4%B9%8B%E3%80%90H5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%91%2F</url>
    <content type="text"><![CDATA[H5 的新特性有哪些呢？ H5 的新特性有哪些？ 语义化标签 多媒体 用于绘画的 canvas 离线 &amp; 存储。对本地离线存储的更好的支持,local Store,Cookies。 一、新增标签1、结构标签（10个） \ ：标记一篇文章。 \ ：标记一个页面的头部或一个区域的头部。 \：标记定义导航链接。 \：标记定义一个区域。 \：标记定义页面内容部分的侧边栏。 \：标记定义文件中的一个区块的相关信息。 \：标记定义一组媒体内容以及它们的标题。 \：标记定义 figure元素的标题。 \：标记定义一个页面或一个区域的底部。 \：标记定义一个对话框类似微信。 2、多媒体标签（5个） video：定义一个视频。 audio：定义音频内容。 source：定义媒体资源。 canvas：画布。 12345//对于不是 mp4 格式的视频，使用 source 来解决&lt;video src=" " autoplay="autoplay" width="" height="" controls=""&gt; //需要进行转码 &lt;source src=" " type="video/mp4" /&gt;&lt;/video &gt; 12345//对于不是 mp3 格式的音频，使用 source 来解决&lt;audio autoplay=" "&gt; //需要进行转码 &lt;source src=" " type="audio/mpeg" /&gt;&lt;/audio&gt; 3、应用标签（5个）▉ 状态标签 &lt;meter&gt;：状态标签（实时状态显示：气压、气温） &lt;progress&gt;：状态标签（任务过程：安装、加载) 12&lt;meter value="380" min="20" max="380" low="200" high="240" optimum="220"&gt;&lt;/meter&gt;&lt;meter value="0.75"&gt;75%&lt;/meter&gt; 12&lt;progress value=&quot;30&quot; max=&quot;100&quot;&gt; &lt;/progress&gt;&lt;progress max=&quot;100&quot;&gt; ▉ 列表标签 &lt;datalist&gt;：为 input 添加下拉列表。 &lt;details&gt;：隐藏、显示详细内容。 123456789// 兼容性：Firefox、Opera&lt;input placeholder="请选择您喜欢的手机品牌" list="phoneList"/&gt;&lt;datalist id="phoneList"&gt; &lt;option value="iphone"&gt;&lt;/option&gt; &lt;option value="sumsung"&gt;&lt;/option&gt; &lt;option value="HUawei"&gt;&lt;/option&gt; &lt;option value="HTC"&gt;&lt;/option&gt; &lt;option value="Meizu"&gt;&lt;/option&gt;&lt;/datalist&gt; 123456789101112// 浏览器兼容 ：Chrome。&lt;details&gt; &lt;summary&gt;问候&lt;/summary&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;&lt;/details&gt; 二、新增属性 Input 标签 表单属性 链接属性 其它属性 1、Input 标签 1）针对于 iphone 手机端：email /url /tel /number/Date Pickers 2）针对于客户端：Range / Search /Color email类型：针对于手机端，出现特殊的键盘，电子邮件 Input 类型。 url 类型：只应用于苹果手机端，特殊键盘。 tel 类型：出现特殊的电话号码键盘。 number 类型：出现数字运算键盘。 Data Pickers 类型：日期类型，手机端只应用于 iphone** Date —— 选取日、月、年。 Month —— 选取月年。 Week —— 选取周和年。 Time —— 选取时间（小时和分钟）。 Datetime —— 选取时间、日、月、年（UTC 时间）。 Datetime-local —— 选取时间、日、月、年（本地时间）。 Datetime 和 Datetime-local 的区别？ 1)兼容性。Datetime类型只有 Safire 和Opera浏览器兼容；而 Datetime-local兼容 Chrome 、 Safire和 Opera。 2) 返回类型不同。local 返回本地时间，而 Date 返回时区。 2、表单属性 autocomplete 属性：当重新加载页面时，输入框重置，是否提示。autocomplete=”on/off” aotufocus 属性：页面加载时，自动获取属性。 multiple 属性：规定输入域可选择多个值。一般应用于上传文件（file）和邮件 （email ）输入框。 placeholder 属性：提供一种提示（hint）。 require 属性：主要用来进行输入域验证（不能为空），必填字段 12345&lt;form action="" autocomplete="on"&gt; &lt;input type="text" name="text"&gt; &lt;input type="email" name="email" autocomplete="off"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 1&lt;input type=&quot;text&quot; name=&quot;text&quot; autofocus=&quot;autofocus&quot;&gt; 1&lt;input type=&quot;text&quot; name=&quot;text&quot; placeholder=&quot;请输入您的用户名&quot;&gt; 12//填写完整才能进行提交&lt;input type=&quot;email&quot; name=&quot;email&quot; required=&quot;required&quot;&gt; 3、链接属性 sizes 属性：根据屏幕不同的分辨率来调整不同的sizes。 target 属性：base标签写在 \ 之间。 超链接 1&lt;link rel=&quot;icon&quot; href=&quot;icon.gif&quot; type=&quot;image/gif&quot; size=&quot;16X16&quot;&gt; 12//控制所有的页面的超链接默认选择新窗口。&lt;base href=&quot;http://localhost/&quot; target=&quot;_blank&quot;&gt; 123a：media=&quot;&quot;//表示对设备进行优化，handhelp对手持设备进行支持，tv 对“电视”设备进行支持。a:hreflang=&quot;zh&quot;//设置语言，这里设置的中文a:rel=&quot;external&quot; //这里的超链接为外部链接 4、其它属性 script 标签： defer 属性：（只兼容 IE 浏览器）加载完浏览器之后，再加载 js 外部文件夹。 async 属性：（兼容一切浏览器）加载页面的同时也加载外部文件。 ol 标签： Start —— 起始值：有序列表的起始值。 Reversed —— 有序列表倒序输出。 html 标签： 1&lt;html mainifest=&quot;index.mainifest&quot;&gt;&lt;/html&gt; H5 提供的新的API canvas。可以画出很多绚丽的图形，甚至可以直接做出伪3D游戏。 媒体控制。直译就是回放功能，假如只用 html5.0 以下的标签写，以前的音乐播放是不可能实现滚动条的。 离线网页程序。在无网络的情况下也可以查看网页，可以把资源文件完全缓存在客户端，并且通过js的一些方法清空缓存 manifest 属性。 拖动。可以将文件拖动到某些区域上传。 跨文档请求。websocket，一种更加高效的通讯方式。 客户端数据存储。localstoage、sessionstoage。 H5 最常用考面试题1、新的 HTML5 文档类型和字符集是？1&lt;!doctype html&gt; 1&lt;meta charset=”UTF-8″&gt; 2、HTML5 中如何嵌入音频？ HTML5 支持 MP3、Wav 和 Ogg 格式的音频。 3、HTML5 中如何嵌入视频？ HTML5支持 MP4、WebM 和 Ogg 格式的视频 4、除了 audio 和 video，HTML5 还有哪些媒体标签？ \ ：标签定义嵌入的内容，比如插件。 \：对于定义多个数据源很有用。 \：具体用于播放带有字幕的视频。 5、HTML5 Canvas 元素有什么用？ Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。 1&lt;canvas id=”canvas1″ width=”300″ height=”100″&gt;&lt;/canvas&gt; 6、HTML5 存储类型有什么区别？ HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。 localStorage ： 用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。 sessionStorage： 同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 7、HTML5 废弃了哪些 HTML4 标签？ frame frameset noframe applet big center basefront 8、HTML5 应用程序缓存和浏览器缓存有什么区别？ 应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML、CSS、图片以及 JavaScript。这个特性可以提高网站性能，它的实现借助于 manifest 文件。与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶深入系列之【事件循环】]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[深入 JS 内部的事件循环机制！ 什么是进程和线程？※ 答✔：进程和线程的区别是什么？ 1）进程：进程是 CPU 资源分配的最小单位，系统会为每个进程进行分配内存空间。比如一个 Tab 页面就是一个进程。 2）线程：线程是 CPU 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程由多个线程组成，比如：渲染线程、Js 引擎线程、HTTP 请求线程等）。 为什么 JS 会选择单线程？※ 答✔：js为什么会用单线程？ 1）js 单线程的特点就是同一时刻只能执行一个任务，js 的任务基本都是与用户互动，以及操作 DOM，所以使用单线程，否则会带来复杂的同步问题。 2）如果为多线程，多个线程同时操作 DOM 就会造成浏览器不知道以哪个为标准的问题。 3）如果执行同步问题的话，多线程需要加锁，执行任务造成非常的繁琐。 4）H5 新的规定。允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。 为什么会有事件循环?※ 答✔：为什么会有事件循环？ 由于 JS 的代码是单线程执行的，所以为了保证 js 同步代码的执行顺序以及异步代码的执行顺序，内部引入了事件循环机制。 什么是微观任务和宏观任务？ 宏观任务：从浏览器的角度看，宏观任务就是代表一个离散的、独立工作单元。如：各种事件、执行主线程、setTimeout、解析 HTML 等。 微观任务：所谓的微观任务就是更小的任务，主要是为了更新应用程序的状态，必须保证它在页面重新渲染 UI 之前执行。如:promise。 事件循环的运行机制（具体实现）？※ 答✔：事件循环的运行机制（具体实现）？ 1）所有同步任务都在主线程上执行，形成一个执行栈。 2）主线程之外，还存在一个”任务队列”。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 3）不同的任务源分配到不同的 Task 队列中，任务源分为微任务和宏任务。 4）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 5）只要主线程空了，就会去读取”任务队列”。 4、事件循环原理※ 答✔：事件循环的原理？ 1）当主线程没有执行任务时，事件迭代循环去任务队列查看是否有已完成的异步任务。 2）事件每循环一次就是一次迭代循环，每一次迭代循环最多在宏观任务队列中取出一个宏观任务加入到执行栈中执行，完成后就会执行微观队列中的任务，直到微观队列中的微观任务全部执行完成才会新渲染一次UI，然后进入下一次的迭代循环中。 3）每个微任务都会在下一次渲染 UI 之前执行完成，为了保证渲染前更新应用程序状态 4）浏览器每秒渲染 60 次页面，达到每秒 60 帧的速度，也就是说每 16 ms 完成一次刷新，所以执行单个宏任务和附带的微任务不能超过这个时间，否则会影响平滑流畅度，甚至页面会产生无响应。 三、Node 中的事件循环 Node.js 是基于事件驱动型、非阻塞的 IO 模型。 1）所谓的事件驱动模型，当服务器接受到请求时，将其关闭进行处理，然后去接受下一个请求。当这个请求执行完成，就会被放到消息队列，当达到队列头部的时候，就会将结果返回给用户。 3）所谓的非阻塞 IO 操作，因为 webserver 一直接受请求而不等待任何读写操作。 四、两种计时器 延迟计时器可以可以延迟一段代码的执行，可以将长时间运行的任务分解为不阻塞事件循环的小任务，以阻止浏览器渲染，浏览器的过程会使得程序运行缓慢、没有反应。 延迟计时器（setTimeout) 间隔计时器（setInterval) 1、延迟计时器（setTimeout） 延迟计时器会在设定的时间内延迟执行回调函数。 注意： ① 由于 javascript 是单线程执行的，只能控制计时器何时被加入队列，而无法控制计时器何时执行。 ② 使用 0 ms 作为超时时间并不代表将在 0 ms 执行回调，这意味着使用 0 ms 尽快执行回调，在回调之前可以进行 UI 渲染的。 2、间隔计时器（setInterval） 每一间隔就会执行一次回调。 3、H5 新增定时器 传统的动画是由 setTimeout 或者 setInterval 完成的，但是存在两个问题： 动画的循环时间间隔不好确定，设置过长动画不够平滑，过短不够浏览器重绘达到瓶颈。 定时器设置的时间只是加入队列的时间，而不是立即执行的时间。 所以 H5 新增加了 requestAnimationFrame。 ▉ 优点1、 requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量。 3、requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销。 常用定时器面试题 面试题：setTimeout、setInterval、requestAnimationFrame 各有什么特点？ ※ 答✔：setTimeout 的特点？ setTimeout 并不是设置了多久执行就是多久执行，因为 js 是单线程的，如果前边的任务执行的时间长，就会导致setTimeout 不会按期执行。 ※ 答✔：setInterval的特点？ setInterval 该函数是每隔一段时间执行一次回调函数。通常来说不建议使用 setInterval，因为 第一，不能保证在预期的时间执行任务。 第二，它存在执行累积的问题：如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。 补充：如果有循环定时器的需求，其实完全可以通过 requestAnimationFrame 来实现。 ※ 答✔：requestAnimationFrame 的特点？点击查看详细教程 1、ruestAnimationFrame 是浏览器用于定时循环操作的一个接口，主要用途是按帧对网页进行重绘。设置这个API的目的是为了让各种网页动画效果能够有一个统一IDE刷新机制，节省资源，提高系统的性能。 2、requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题。 五、处理复杂任务 在开发中，js 单线程的特性是最大的问题，因为当 js 忙于执行时，浏览器和用户的交互会变的很迟钝，甚至无响应，这是由于 js 执行任务时，重新更新 UI 渲染就会暂停，导致浏览器出现卡顿现象。可以通过 setTimeout 将大任务分割成小块任务循环渲染 UI 转化为非阻塞的操作。 ▉ setTimeout 解决12345678910111213141516171819202122232425const rowCount = 2000; // 行const divdeInto = 4; // 分 4 个阶段渲染const chunkSize = rowCount / divdeInto; // 每个阶段渲染 500 行let iteration = 0;let table = document.querySelectorAll('tbody')[0];setTimeout(function generateRows()&#123; // 计算上次渲染的位置 const base = chunkSize * iteration; for(let i = 0; i &lt; chunkSize; i++)&#123; const tr = document.createElement("tr"); for(let t = 0; t &lt; 6;t++)&#123; const td = document.createElement("td"); td.appendChild(document.createTextNode((i + base) + "," + t + "," + iteration)); tr.appendChild(td); &#125; table.appendChild(tr) &#125; iteration ++; if(iteration &lt; divdeInto)&#123; setTimeout(generateRows,0) &#125;&#125;,0) ▉ 虚拟滚动解决12]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>前端深入系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>前端深入系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶深入系列之【变量类型】]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[深入探究 javascript 变量类型！ 一、变量的分类 在 javascript 中，我们通常使用三个关键字来定义变量：var、let、const。我们从两个角度对这三个变量进行分类：可变性和词法环境。 1、分类一：可变性 可变性表示的是变量一旦声明，后续是否是可变的，分为两组，分别为 {const} 和 {let、var}。 ▉ const 特性一： const 声明的是静态变量，一旦声明并赋予初始值，就不允许重新赋值，否则 javascript 就会抛出异常。 ▉ const 特性二： 虽然不可以对变量进行赋值，但是可以对 const 声明的对象进行重新修改。 ▉ const 特性三： 用 const 声明的数组也是一样的，不能重新赋值但是可以进行修改。 2、分类二：词法环境（作用域） 按照词法环境进行分类，其实就是按照作用域进行分类，分为两组分别为 {var} 和 {let，const}。 ▉ 关键词 var 该关键词是在距离最近的函数内部或全局的作用域（变量将挂载到 window 对象上）中定义的（忽略块级作用域）。—— 在块级作用域外可以访问到块级作用域内的变量。 ▉ 关键词 let 和 const let 和 const 直接在最近的作用域中定义变量（包括块级作用域、函数内、全局作用域）。 二、词法环境中注册标识符 这部分内容是变量提升的真正原理。变量的声明提升至函数的顶部，函数的声明提升至全局代码的顶部。真正的原理是，代码在执行前，先在词法环境中进行了注册。 1、标识符的注册过程 javascript 代码执行是分成两个阶段的，一但创建新的词法环境，就会执行第一阶段。 第一阶段：javascript 引擎会访问并注册当前词法环境（作用域）中的所有变量和函数。 第二阶段：本阶段的执行主要取决于变量的类型（let、var、const）和环境类型（全局环境、局部环境、块级作用域）。 1）如果创建的是一个函数环境，那么就创建形参及函数参数的默认值（非函数环境则跳过）。 2）扫描当前代码进行函数声明（只扫描当前的函数环境内）。如果创建的是全局或函数环境， （注意：此过程不会扫描函数表达式和箭头函数）。对于找到的函数声明，将创建该函数，并将标识符绑定到当前环境中相同的标识符上。若已经存在，则将覆盖。 3）扫描当前代码进行进行变量声明。在函数或全局作用域中，找到当前函数以及其他函数之外 var 声明的变量。并找到其他函数或代码块之外 let 或 const 声明的变量。 4）在块级作用域中，仅查找当前块中通过 let 或 const 声明的变量。 5）对于所查找到的变量，若标识符不存在，则标识为 undefined ，否则存储当前的值。 ▉ 函数声明之前调用函数 若函数是作为函数声明定义的，则可以在声明之前调用函数。如果以函数表达式或箭头函数定义的，则不可以在声明之前访问函数。 ▉ 函数的重载 函数的重载之所以出现下面这种原因，是直接由标识符的注册导致的，也就是人们所说的变量提升。 1234567console.log(typeof fun) // “function”var fun = 1;console.log(typeof fun) // “number”function fun()&#123;&#125; 1、在处理过程中，通过函数声明定义的函数在代码执行之前定义过了，所以 fun 已经有值的。 2、在处理变量的声明时，当前环境中未声明的变量将会注册为 undefined，因为 fun 早已经注册过了，所以当执行代码执行到 fun 等于 1 时，就会改变。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>前端深入系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>前端深入系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【Generator生成器】]]></title>
    <url>%2F2019%2F06%2F09%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90Generator%E7%94%9F%E6%88%90%E5%99%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[使用 ES6 的生成器可以优雅的实现异步操作！ 一、生成器函数 1、使用生成器函数可以生成一组值的序列，每个值的生成是基于每次请求的，并不同于标准函数立即生成。 2、调用生成器不会直接执行，而是通过叫做迭代器的对象控制生成器执行。 123456789101112function* WeaponGenerator()&#123; yield "1"; yield "2"; yield "3";&#125;for(let item of WeaponGenerator())&#123; console.log(item);&#125;//1//2//3 二、使用迭代器控制生成器2.1 迭代器的使用1、通过调用生成器返回一个迭代器对象，用来控制生成器的执行。 2、调用迭代器的 next 方法向生成器请求一个值。 3、请求的结果返回一个对象，对象中包含一个 value 值和 done 布尔值，告诉我们生成器是否还会生成值。 4、如果没有可执行的代码，生成器就会返回一个 undefined 值，表示整个生成器已经完成。 12345678910function* WeaponGenerator()&#123; yield "1"; yield "2"; yield "3";&#125;let weapon = WeaponGenerator();console.log(weapon.next());console.log(weapon.next());console.log(weapon.next()); 2.2 生成器的状态1、每当代码执行到 yield 属性，就会生成一个中间值，返回一个对象。 2、每当生成一个值后，生成器就会非阻塞的挂起执行，等待下一次值的请求。 3、再次调用 next 方法，将生成器从挂起状态唤醒，中断执行的生成器从上次离开的位置继续执行。 4、直到遇到下一个 yield ，生成器挂起。 5、 当执行到没有可执行代码了，就会返回一个结果对象，value 的值为 undefined , done 的值为 true，生成器执行完成。 2.3 将执行权交给下一个生成器12345678910111213141516function* XiaoLuGenerator()&#123; yield "4"; yield "5"; yield "6";&#125;function* WeaponGenerator()&#123; yield "1"; yield "2"; yield "3"; yield *XiaoLuGenerator(); // 将执行权交给另一个生成器&#125;for(let item of WeaponGenerator())&#123; console.log(item);&#125; 三、生成器的应用1、为对象赋唯一 ID 标识 当创建某些对象时，需要为对象赋一个唯一的 ID 值。通常使用一个全局计时器变量，但是这种写法很容易使代码变的混乱。所以使用生成器可以实现这个功能。 12345678910111213 function* IdGenerator()&#123; let id = 0; while (true)&#123; yield ++id; &#125; &#125;const idIterator = IdGenerator();const obj1 = &#123; id: idIterator.next().value &#125;const obj2 = &#123; id: idIterator.next().value &#125;const obj3 = &#123; id: idIterator.next().value &#125;const obj4 = &#123; id: idIterator.next().value &#125;const obj5 = &#123; id: idIterator.next().value &#125; 2、遍历 DOM 树 通常遍历 DOM 树最简单的方法是使用递归，但是使用生成器也可以进行遍历代码。很多情况下，使用迭代器比使用递归更要自然。 1234567&lt;div id="xiaolu"&gt; &lt;form&gt; &lt;input type="text"&gt; &lt;/form&gt; &lt;p&gt;Paragraph&lt;/p&gt; &lt;span&gt;Spam&lt;/span&gt;&lt;/div&gt; 123456789101112131415161718function* DomTraversal(element)&#123; // 1、打印当前元素 yield element; // 2、寻找当前元素的子元素 element = element.firstElementChild; // 3、循环遍历子元素（子元素可能多个） while (element) &#123; // 4、子元素可能还有子元素（递归） yield* DomTraversal(element); // 5、遍历兄弟元素的子元素 element = element.nextElementSibling; &#125;&#125;const subTree = document.getElementById("xiaolu");for(let node of DomTraversal(subTree))&#123; console.log(node)&#125; 四、生成器数据交互 生成器中可以进行双向通信，通过 yield 可以返回值，也可以通过 next 传入值。 注意：如果没有等待的 yield 表达式，也就是没有值可以应用，所以第一次的 yield 无法传值。 1、构造函数的初始化 生成器可以像其他函数一样接受标准的参数，并在生成器内使用。 123456function* XiaoLuGenerator(action)&#123; const n = yield ("4"+action);&#125;let weapon = XiaoLuGenerator("3333");console.log(weapon.next()); 2、next 方法传递值 next 传递的参数是作为上一执行的结果返回。 12345678910function* XiaoLuGenerator(action)&#123; const n = yield ("4"+action); yield ("next" + n)&#125;let weapon = XiaoLuGenerator("3333");console.log(weapon.next());console.log(weapon.next("嘿嘿"));// &#123;value: "43333", done: false&#125;// &#123;value: "next嘿嘿", done: false&#125; 3、抛出异常 生成器除了有一个 next 方法，还有一个 throw 方法来抛出异常，当生成器内部发生错误时，我们可以通过抛出异常来抛出错误。抛出的错误就会被 try-catch 捕获。 1234567891011function* XiaoLuGenerator()&#123; try&#123; const n = yield "4"; &#125;catch(e)&#123; console.log("抛出错误！") &#125;&#125;let weapon = XiaoLuGenerator("3333");weapon.next()weapon.throw("错误!") 五、生成器的内部结构 生成器更像是一个状态运动的状态机。 挂起开始状态——创建一个生成器处于未执行状态。 执行状态——生成器的执行状态。 挂起让渡状态——生成器执行遇到第一个 yield 表达式。 完成状态——代码执行到 return 全部代码就会进入全部状态。 1、执行上下文跟踪生成器函数12345678910function* WeaponGenerator(action)&#123; yield "1"+action; yield "2"; yield "3";&#125;let Iterator = WeaponGenerator("xiaolu");let result1 = Iterator.next()let result2 = Iterator.next()let result3 = Iterator.next() 执行过程： ① 在调用生成器之前的状态——只有全局执行上下文，全局环境中除了生成器变量的引用，其他的变量都为 undefined。 ② 调用生成器并没有执行函数，而是返回一个 Iterator 迭代器对象并指向当前生成器的上下文。 ③ 一般函数调用完成上下文弹出栈，然后被摧毁。当生成器的函数调用完成之后，当前生成器的上下文出栈，但是在全局的迭代器对象还与保持着与生成器执行上下文引用，且生成器的词法环境还存在。 ④ 执行 next 方法，一般的函数会重新创建执行上下文。而生成器会重新激活对应的上下文并推入栈中（这也是为什么标准函数重复调用时，重新从头执行的原因所在。与标准函数相比较，生成器暂时会挂起并将来恢复）。 ⑤ 当遇到 yield 关键字的时候，生成器上下文出栈，但是迭代器还是保持引用，处于非阻塞暂时挂起的状态。 ⑥ 如果遇到 next 指向方法继续在原位置继续 执行，直到遇到 return 语句，并返回值结束生成器的执行，生成器进入结束状态。 执行上下文栈 当前环境 变量 全局执行上下文 全局环境 WeaponGenerator:function*(){}Iterator: undefinedresult1: undefinedresult2: undefinedresult3: undefined 从未执行状态变为执行状态： 执行上下文栈 当前环境 变量 全局执行上下文 全局环境 WeaponGenerator:function*(){}Iterator: Iteratorresult1: undefinedresult2: undefinedresult3: undefined WeaponGenerator 上下文 WeaponGenerator环境 action: xiaolu]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶深入系列之【闭包和作用域】]]></title>
    <url>%2F2019%2F06%2F09%2F%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E9%97%AD%E5%8C%85%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%91%2F</url>
    <content type="text"><![CDATA[深入闭包以及闭包的应用！ 一、作用域1、作用域：限定变量和函数的可用性的范围叫做作用域。 2、作用域链：保证对执行函数有权访问的所有变量和函数的有序访问。 二、理解闭包？1、什么是闭包？ 闭包是在函数内可以访问并操作函数外部的变量。只要变量或函数存在于声明的函数的作用域内，闭包就可以使用函数访问到这些变量。 2、如何理解闭包？ 在外部函数声明内部函数的时候，就创建了一个闭包。闭包包含了当前声明的函数作用域中所有的函数和变量。只要声明的函数存在，当前闭包就会存在。 ▉ 注意一： 每一个通过闭包访问变量的函数都具有一个作用域链，作用域链包含闭包的全部信息。 ▉ 注意二： 闭包不能过度使用，因为闭包所有的变量都存在内存中，直到不会被使用到（页面卸载）时才会被垃圾回收，多度的使用闭包会影响性能。 三、闭包的应用1、应用一：封装私有变量 由于原生的 JavaScript 不支持私有变量，所以只能通过闭包的方式来实现。 在构造函数中的外部是无法访问到函数内部的变量的，只能通过闭包的形式访问内部的变量。 通过 new 的方式创建一个新对象，改变函数内 this 的指向，为实例对象添加新属性，返回一个新对象，通过对象的方式可以访问到构造函数内部的属性。 通过闭包内部的方法获取到私有变量的值，但是不能直接进行访问私有变量，有效的阻止了对变量不可控的修改。 2、应用二：回调函数 由于处理回调函数是一种异步的调用函数，需要在回调函数中频繁的访问外部的数据，所以用闭包来解决这个问题。 闭包解决问题回调可以有效的防止污染全局变量。当不使用闭包的时候，所有的变量全部都在全局作用域下，多个异步操作同时对变量进行读或取，那么就会发生冲突，就污染到了全局的作用域。 如果没有闭包，一次性做许多事情就会变得非常的困难，例如：事件绑定、动画甚至服务器请求。 闭包不是存在于创建的那一时刻，而是一个真实状态的封装，只要闭包存在，就可以对变量就行修改。 四、闭包与作用域的关系 闭包和作用域是强相关的，JavaScript 的作用域有一定的规则以及 javaScript 的内部运行机制。 1）javascript 引擎是如何跟踪函数执行又回到函数的位置？ 1、javaScript 的执行上下文跟踪函数 因为 JavaScript 的运行机制是基于单线程的，某个特定的时刻只能执行特定的代码，所以要通过执行上下文栈来确定函数的执行顺序。 ▉ 基本概念 js 代码类型分为两种：全局代码，在所有函数的外部定义；局部代码，在函数的内部定义。 每个函数的执行都会在一个特定的执行上下文中。全局执行上下文只有一个（每个页面只有一个）；而函数执行上下文是每当执行一个函数时，就会先创建一个函数执行上下文。 注意：this 访问函数上下文和函数执行上下文是两个不同的概念。 ​ ▉ 跟踪过程 1）程序开始运行只有执行上下文栈中只有全局执行上下文。 2）当调用函数的时候，当前函数就会创建一个新的执行上下文入栈，就说明当前的函数正在执行。 3）如果当前的函数执行完毕，所创建的执行上下文就会出栈，将控制权教给上一级。 4）直到所有有执行上下文出栈，全局执行上下文恢复执行。 2、javascript 引擎跟踪词法环境 词法环境是每个（函数）执行上下文中所有变量和函数存储的环境。词法环境是 JavaScript 内部的实现机制，通常称为作用域。 ▉ 词法环境的作用 词法环境主要是 JavaScript 引擎用来如何跟踪变量以及如果判断变量的可访问性。 ▉ 关联性 词法环境与 JavaScript 的代码就够进行关联，如：函数、代码片段等是相互关联的。 2.1 代码嵌套 词法环境主要与代码嵌套（代码嵌套的结构）相关联的，每执行代码，代码结构就会获取与之相关联的词法环境，用来确保内部环境可访问外部环境。 2.2 代码嵌套与词法环境的关系 词法环境查询变量时，根据执行上下文对应的词法环境由内而外依次进行查找，直到查找到最外层的全局作用域。 ▉ 函数 - 执行上下文 - 词法环境的关系1、每个执行上下文都对应一个词法环境（函数的局部作用域）； 2、每个局部函数中的内部属性 [[Environment]] 与创建的执行上下文相关联（所在当前函数的执行上下文）； 五、闭包的工作原理1、闭包模拟私有变量 闭包模拟 js 的私有变量时，会 new 一个实例对象，实例对象就会通过闭包获取或改变构造函数内的局部变量模拟面向对象。每次调用构造函数，都会创建一个新的词法环境，该词法环境会保持着构造函数内部的局部变量。 ▉ 内部实现步骤 1）new 一个实例对象。 2）进入构造函数，为构造函数创建一个新的词法环境，它始终保持着对局部变量的引用。 3）然后为空对象添加两个函数，这两个函数 [[Envrionment]] 都保持着对新创建函数的词法环境的引用，返回新对象。 4）当调用对象的函数时，就会创建新的执行上下文推入执行栈中，这回引起创建的新的词法环境（内部函数）。 5）js 引擎会检查当前函数的词法环境中有没有想要的变量，如果没有，则会到外部变量（构造函数的词法环境）中去查找，查找到了就返回。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>前端深入系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>前端深入系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶深入系列之【浏览器的运行机制】]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E3%80%91%2F</url>
    <content type="text"><![CDATA[深入浅出 JS 的运行机制！ 一、区分进程和线程 CPU 的作用是主要是解释计算机的指令以及处理计算机软件中的数据。 进程：进程是 CPU 资源分配的最小单位，系统会为每个进行分配内存空间。 线程：线程是 CPU 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程由多个线程组成）。 二、浏览器是多进程的 1、浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）。 2、浏览器是多进程的，每打开一个 Tab 页，相当于创建了一个独立的浏览器进程。 3、浏览器有时可以将多个进程合并，比如打开多个空白页，将这些空白页合成一个进程。 1、浏览器有哪些进程？ Browser 进程： 浏览器的主进程（负责协调、主控），只有一个 负责浏览器界面显示，与用户交互。如前进，后退等； 负责各个页面的管理，创建和销毁其他进程； 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上； 网络资源的管理，下载等 第三方插件进程： 每种类型的插件对应一个进程，仅当使用该插件时才创建。 GPU 进程： 用于 3D 绘制等； 浏览器渲染进程（浏览器内核）： 默认每个Tab页面一个进程，互不影响。 页面渲染，脚本执行，事件处理等 2、浏览器多进程的优势？ 多进程的浏览器资源消耗有点大，难道空间换时间思想。如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器； 避免单个页面崩溃影响整个浏览器； 避免第三方插件崩溃影响整个浏览器； 多进程利用多核优势； …… 3、重点：浏览器的内核（渲染进程） 前端浏览器最重要的点就是渲染进程，而且渲染进程是是多线程的。页面的渲染、js 的执行、时间的想都会在这个进程内进行。 渲染进程包括哪些线程： ① GUI 渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。 GUI渲染线程与JS引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。 ② JS 引擎线程 也称为 JS 内核，负责处理 Javascript 脚本程序（V8 引擎）。 JS 引擎线程负责解析 Javascript 脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序。 GUI 渲染线程与 JS 引擎线程是互斥的，所以如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 ③ 事件触发线程 属于浏览器的线程而不是 js 引擎，用来控制事件循环。 当 JS 引擎执行代码块如 setTimeOut 时，会将对应任务添加到事件线程中。 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。 由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）。 ④ 定时触发器线程 setInterval与setTimeout所在线程。 浏览器定时计数器并不是由 JavaScript 引擎计数的（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）。 通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）。 W3C在HTML标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。 ⑤ 异步 http 请求线程 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>前端深入系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>前端深入系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器如何工作的之【工作流程】]]></title>
    <url>%2F2019%2F05%2F22%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B9%8B%E3%80%90%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[浏览器是如何工作的？ [TOC] 浏览器的工作原理一、整个浏览器的工作流程 整个过程都是流式处理，同步进行。 1、DNS 查询。 2、浏览器通过 HTTP 请求服务器。（HTTP 请求的过程是怎么样的） 3、构建 DOM 树。（解析 HTML 代码，构建 DOM 树） 4、计算 CSS属性。（如何将 CSS 属性挂载在 DOM 树） 5、排版 。（浏览器确定每个元素的位置） 6、渲染 。（模型变成位图的过程，将在内存每个元素渲染成图形） 7、合成 。 8、绘制。（位图绘制到屏幕上） 二、DNS 查询 DNS 查询主要是通过访问的域名查询出它的 IP 地址。 2.1 查询内容 通过 DNS 查询工具得出的一下六段内容: 1、第一段：查询参数和统计。 2、第二段：查询内容。 3、第三段：DNS服务器的答复。 显示 A (adress) 记录，即域名对应的所有 IP 地址。math.stackexchange.com有四个A记录，即四个 IP 地址。600是 TTL 值（Time to live 的缩写），表示缓存时间，即 600 秒之内不用重新查询。 4、第四段：显示域名的 NS 记录（Name Server），即哪些服务器负责管理该域名的 DNS 记录。 stackexchange.com共有四条 NS 记录，即四个域名服务器，向其中任一台查询就能知道math.stackexchange.com 的 IP 地址是什么。 5、第五段：管理域名的服务器的 IP 地址跟随着返回。 6、第六段：DNS 服务器的一些传输信息。 2.2 DNS 服务器1、本机知道 DNS 服务器的 IP 地址，通过请求 DNS 服务器才可以查询到该域名的 IP 地址。 2、DNS 服务器的 IP 地址，有可能是动态的，每次上网时由网关分配，这叫做 DHCP 机制；也有可能是事先指定的固定地址 2.3 域名的层级 DNS 服务器通过分级查询得到每个域名的 IP 地址。 ▉ 域名的层级结构1主机名.次级域名.顶级域名.根域名 根域名 (root) ：所有域名是一样的。 顶级域名（.com .net）。 次级域名 ：用户可以注册的。 主机名（host）：如 www，又称三级域名。用户在自己域里为服务器任意分配的名称。 2.4 根域名服务器 每一集域名都有自己的 NS 记录，NS 记录是指向该级域名服务器，该服务器知道下一级域名的各种记录。 ▉ 分级查询 从根域名开始查询每一级的 NS 记录，直到查到最终的 IP 地址。”根域名服务器”的 NS 记录和IP地址一般是不会变化的，它是内置在 DNS 服务器里面的。 从”根域名服务器”查到”顶级域名服务器”的 NS 记录和 A 记录（IP 地址）。 从”顶级域名服务器”查到”次级域名服务器”的 NS 记录和 A 记录（IP 地址）。 从”次级域名服务器”查出”主机名”的 IP 地址。 2.5 DNS 整个查询过程1、本机通过本地设置的 DNS 服务器请求域名的 IP 地址。 2、DNS 服务器开始进行分层查询。 3、先是通过内置的根域名（.root）服务器查到顶级域名服务器” 的 NS 记录和 A 记录。 4、然后从 “顶级域名服务器（com.）” 查到 “次级域名服务器” 的 NS 记录和 A 记录。 5、再通过从 “次级域名服务器（用户注册的域名）” 查出 “主机名（www.）” 的 IP 地址。 三、浏览器通过 HTTP 请求服务器。 浏览器使用 HTTP 协议或者 HTTPS 协议，向服务器发送请求。 四、构建 DOM 树。 获取 HTTP 的 Request 的 body 中字符串（字符流）的 HTML 文本，进行解析并构建 DOM 树。 1、状态机解析代码 HTML 词法状态机的作用就是将字符流解析成词（token)。状态机每读入一个字符就要做一次决策，这些决策和当前的状态有关。 ① 字符流进入状态机对每个字符进行解析，每判断一个字符，就为一个状态。根据当前状态来确定下一字符确定的下一个状态。 ② 用状态机做词法分析，将每个词的 “特征状态” 逐个拆开成独立状态，然后把所有的特征字符链合并起来，形成一个联通图结构。 ③ 状态机涉及到编译原理，用 javascript 来讲解。可以设计函数，每个函数为一个状态，参数接受字符串，返回的是下一个状态函数。 2、构建 DOM 树 要把上边状态机解析的词通过栈这种结构来构建 DOM 树。 ① 在接收状态机解析的词的同时，就开始通过构建 DOM 树算法构建 DOM 树，当接受完所有输入的时候，栈顶就是最后的根节点，DOM 树的产出，就是 stack 的第一项， ② 构建 DOM 树，需要一个 Node 类，构建 DOM 树的所有结点都是这个 Node 类的实例。不一样的 HTML 结点对应不一样的 Node 子类（如 Element、Text等，如果基于 OOP 的话，需要抽象工厂来创建类）。 ③ 在词中，开始标签和结束标签需要成对匹配的（在编译原理中，正是利用了栈匹配开始和结束标签的方案）。 ④ 如果遇到 Text 结点，把相邻的 Text 结点合并起来。入栈，检查栈顶，若栈顶为 Text 结点，就合并 Text 结点。 ⑤ 构建 DOM 的全过程 栈顶为当前元素； 遇到属性就添加当前节点； 遇到文本点，如果当前节点是文本节点，则跟文本节点合并，否则入栈为当前的子节点； 遇到注释节点，作为节点的子节点； 遇到开始标签就入栈一个节点，当前节点就是这个节点的父节点； 遇到结束标签就出栈一个节点（检查是否匹配）。 五、计算 CSS 属性 上阶段构造的 DOM 树只有节点和属性，没有包含任何的 CSS 样式。这一节点将 CSS 规则应用到样式中去，为 DOM 树添加 CSS 属性。DOM 树构造到父节点的时候，还不知道它有没有子节点，所以算不出来 CSS。 1、选择器的出现顺序 选择器出现的顺序必定跟 DOM 树的顺序一致，这是 CSS 设计的一个原则。即保证选择器在 DOM 构建到当前节点时，已经可以准确判断是否匹配了，不需要后续节点信息。 2、CSS 分析 ① CSS 需经过词法分析和语法分析，变成计算机可以理解的结构（属于编译原理的知识），解析之后变成一颗可用的抽象语法树。 ② 一个 complex-selector 是检查一个元素的规则，一个复合选择器是由数个 complex-selector 通过连接符（combinator）组成。 3、连接符的匹配规则▉ 后代选择器 —— “空格” ① 匹配到 a#b 元素时，开始检查所有的子代是否匹配 .cls。 ② 当遇到 \ 时，使规则退一步，才会时第三个不会被匹配到。 ※ 总结：后代选择器的作用范围是父节点的所有子节点，一次规则是在匹配到本地标签的结束时回退的。 123a#b .cls &#123; width: 100px;&#125; 12345&lt;a id=b&gt; &lt;span&gt;1&lt;span&gt; &lt;span class=cls&gt;2&lt;span&gt;&lt;/a&gt;&lt;span class=cls&gt;3&lt;span&gt; ▉ 后继选择器 —— “~” 后继选择器的匹配规则是不能再使用闭合标签规则，而是带父元素的规则。（带父元素规则，就不会匹配后继的子节点了） 123456789101112.cls~* &#123; border:solid 1px green;&#125;&lt;div&gt;&lt;span&gt;1&lt;span&gt;&lt;span class=cls&gt;2&lt;span&gt;&lt;span&gt; 3 &lt;span&gt;4&lt;/span&gt;&lt;span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/div&gt; ▉ 子代选择器 —— “&gt;” 也是使用父元素作为约束条件进行匹配。 ▉ 其他 其他选择器包括逗号，表示“或”的关系。编译器当做两条规则来处理。 3、计算 css 完成 CSS 计算把 CSS 规则应用到 DOM 树上，为 DOM 树添加了相关的属性过程，最后得到了一个带有 CSS 属性的树。 六、排版 上一阶段确定了 CSS 属性得到一颗带有 CSS 属性的 DOM 树，而且构建 DOM 树和计算 CSS 属性两个节点产出的是一个一个的元素，那么这一阶段是浏览器确定每个元素的位置。 1、基本概念① 浏览器最基本的排版方案是正常流排版，浏览器的正常流是唯一文字和盒模型混排的排版方式，并遵循公认的文字排版规范。 ② 文字排版规定了行模型和文字在行模型中的排布（行模型规定了行顶、行底、行高、文字区域、基线等对齐方式）。 ③ 浏览器还支持元素和文字混排，元素是一个长方形区域，也就是所谓的盒模型。 2、正常流文字排版① 浏览器中的环境和显示中书写文字的环境差不多相同，但是浏览器支持改变排版的方向。我们把文字书写的方向叫做主方向，换行延伸的方向叫做交叉轴方向。 ② 从字体中获取相关信息，其中一个重要属性为主轴的前后距离。文字排版还会受到一些 CSS 属性的影响，line-height、letter-spacing等。 ③ 正常流中多数元素都是以盒来排版； display 为 inline 属性的元素，是拆成文本来排版的，会直接排入文档流中，主轴方向的 margin 属性和 border 属性也会计算进排版前进举例当中。 可以根据 display 属性可分为两类： 内部排版（文本排版） 是否为 inline（带有 inline- 前缀的盒子，称为行内级盒子） ④ 当没有指定文字书写方向的时候，从左到右文字中插入从右到左文字，会形成一个双向文字盒。 ⑤ 即使没有元素包裹，混合书写方向也会形成盒结构。在排版时，遇到这样双向文字盒，会先排完盒内再排盒外。 3、正常流中的盒 正常流中 display 不为 inline 的元素，以盒的形式跟文字一起进行排版。 ① 主轴方向上的占据的空间是由 margin、border、padding、with/height 等属性和决定的，交叉轴方向是由 vertical-align 决定的，也会影响实际的行高。 ② 浏览器对行的排版，先行内布局， 然后再确定行的位置，根据行的位置计算出行内盒和文字的排版位置。 ③ 块级盒子单独占据一整行，计算出交叉轴方向的高度即可。 4、绝对定位元素 position 属性为 absolute 的元素，根据包含它块来确定元素。因为这是跟正常流无关的一种独立排版模式，逐级找到父级的 position 非 static 即可。 5、浮动元素排版① 浏览器对 float 的处理事先排入正常流，在移动到排版宽度的最左/最右（主轴方向）。 ② 移动后，float 元素占据一块空间，在数行之内，主轴方向的排版距离发生了变化，直到交叉轴方向的尺寸超过了浮动元素的交叉轴尺寸范围，主轴排版尺寸才会恢复。 ③ float 元素排布完成后，float 元素所在的行需要重新确定位置。 6、其它排版 CSS 每个排版都有复杂的规定，实现形式各不同。如 Flex 排版，支持 flex 属性，将每一行后的剩余空间平均分配给主轴方向的 width/height 属性。 七、渲染 确定了每个元素的位置之后，根据样式信息和大小信息，为内存中的每个元素渲染出它的图形。在图形学中的意思是将模型变成位图的过程称为渲染。 1、位图 位图就是内存中的一个二维表格，把每张图片的像素对应的颜色保存进去。（位图信息是DOM树中占据浏览器中内存最多的信息，内存优化主要考虑这点） 2、渲染过程 浏览器渲染过程主要是将每个元素（Html元素/伪元素）的盒模型变成位图，inline 元素可能占据多行，每个盒对应一张位图。渲染过程分为两大类： 图形渲染 文字渲染 ▉ 图形渲染 盒的背景、边框、SVG元素、阴影等特性，都为绘制的图形类，需要一个底层库的支持。 ▉ 文字渲染 盒中的文字的绘制也会要一个底层库来支持，叫做字体库（目前常见的字体库为 Freetype）。字体库提供读取文字文件的基本能力，它会根据字符的码点抽取出字形。字形分为两种： 像素字形 矢量字形 通常字体会在小字体（小于6px、8px）提供像素字形，比较大的尺寸提供矢量字形（本身需要经过渲染才能继续渲染到元素的位图上去）。 ▉ 渲染过程① 渲染过程生成的位图跟排版中占据的尺寸是相同的，但是现实中确有很大的差距，因为很多属性会影响渲染位图的大小，如阴影。为了优化，将阴影作为一个单独的盒子来处理。 ② 渲染过程不会把子元素会知道渲染的位图上，当父元素和子元素发生相对位置变化时，可以保证渲染的结果最大程度被缓存，减少重新渲染。 八、合成 合成并非浏览器必要执行的一环，实际上是一个性能的考量。 合成可以这样理解：合成的元素的意思是合成之后，通过 js 动态改变其他元素，合成的这部分元素，就不会重新渲染从而提高了性能。 1、合成的过程① 渲染过程不会把子元素渲染到位图上面，合成的过程，就是要创建一个合成层，把一部分子元素渲染到合成的位图上面。 2、为哪些元素创建合成后的位图，哪些元素应该渲染到合成层上？ 合成的目标是提高性能，建立的原则就是最大限度减少绘制次数原则。好的合成策略是“猜测”可能变化的元素，把他排除到合成之外。 ① 主流的浏览器一般根据 position、transform 等属性来决定合成策略，来猜测这些元素未来的变化。 ② 以上猜测的准确性有限，所以新的 CSS 标准中，规定了 will-width 属性，可以由业务代码来提示浏览器的合成策略。 九、绘制 绘制是把位图绘制到屏幕上，变成肉眼可见的图像的过程。一般最终显示的位图位于显存中，，有的情况只需把内存中的一张位图交给显示驱动或操作系统就 ok，这个将位图合成最终的位图叫做绘制。 1、重排和重绘 所说的“重排”和“重绘”，所谓的重排是排版，重绘则是绘制过程。实际上，“绘制”过程发生的频率非常高，比如：鼠标滑过浏览器的显示区域，鼠标每次移动，都要造成重新绘制，如果不重新绘制，就会产生大量的鼠标残影。 2、怎样减少重绘？ 限制绘制面积可以提高性能，如果鼠标只在某个覆盖的区域滑动，我们只需重新绘制这个区域就可以了。 3、解决办法 “脏矩形”算法，把屏幕分成若干个矩形区域。 ① 当鼠标移动导致绘制时，只重绘它影响到的几个矩形区域就够了。最小的影响区域只会涉及 4 个矩形，大型元素则覆盖多个矩形。 ② 设置合适的矩形区域大小，可以很好的控制绘制时的消耗。设置过大会造成绘制面积增大，设置过小的矩形会造成计算复杂。 ③ 重新绘制脏矩形区域时，把所有与矩形区域有交集的合成层（位图）的交际部分绘制即可。]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 CSS 之【响应式】]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%89%8D%E7%AB%AF%20CSS%20%E4%B9%8B%E3%80%90%E5%93%8D%E5%BA%94%E5%BC%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[响应式设计！ 一、浏览器视口 通过 CSS 像素（不等于无力像素，和物理像素成比例）来合理利用视口空间。 1、理想视口：与设备自身尺寸接近的视口称为理想视口。 2、默认视口：模拟一个大的视口，然后缩小页面进行显示，称为默认视口。 3、可见视口：显示网页的矩形区域称为可见视口（减去浏览器中的按钮、滚动条等）。 4、布局视口：约束整个页面时视口为布局视口。 二、配置视口 让默认视口的设备都具有理想视口，需要进行声明 meta 标签。 12// 使用当前的设备的理想尺寸作为视口的宽度，以及与理想视口的缩放程度相匹配的缩放级别&lt;meta name="viewport" content="width=device-with,initial-scale=1"&gt; 三、媒体类型和媒体查询3.1、媒体类型 媒体类型分为 screen(屏幕显示) 和 print (打印机)。 应用方式： ① HTML 方式 1&lt;meta rel="stylesheet" href="main.css" media="screen,print"&gt; ② CSS 方式 12345@media print&#123; .smallprint&#123; font-size:11pt; &#125;&#125; 3.2、媒体查询 应用方式有两种，一种是标签的形式，另一种是 css 的形式。标签的形式由于可能有的浏览器会将外部文件下载影响性能，所以通常使用 css 的形式。 ① 可以忽略媒体类型，相当于用 all 代替。 ② only 关键字为了避免旧版本浏览器的误解。所有旧版本的浏览器遇到 only 关键字。都会跳过媒题查询应用下的样式。 123@media only screen and (min-width: 600px) &#123; /* 这里写规则 */&#125; 四、响应式设计4.1 移动端优先 我们通常设计响应式以移动端优先设计，因为移动端屏幕小、通常处理器和硬件配置比电脑要低，便于人们携带。之所以首先设计移动端，为了能够考虑到很多限制因素。如果开发桌面的程序，我们可以进行其扩展。如果我们相反，将已有的功能塞进一个有限的平台，难度会更大。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之道之【面试汇总】]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E4%B9%8B%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E3%80%91%2F</url>
    <content type="text"><![CDATA[前端 js、css、vue等面试题解答汇总。 [TOC] 一、CSS 篇1、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？ ① 标准盒子模型：宽度 = 内容的宽度（content）+ border + padding + margin② 低版本 IE 盒子模型：宽度 = 内容宽度（content+border+padding）+ margin 2、 box-sizing属性？ 用来控制元素的盒子模型的解析模式，默认为 content-box。 ① context-box： W3C 的标准盒子模型，设置元素的 height/width 属性指的是 content 部分的高/宽② border-box： IE 传统盒子模型。设置元素的 height/width 属性指的是 border + padding + content 部分的高/宽。 3、 CSS 选择器有哪些？哪些属性可以继承？① 选择器： ID 选择器、类选择器、标签选择器； 相邻选择器（+）、子元素选择器（&gt;）、兄弟选择器（~）、后代选择器（ul li）、通配符选择器（*）； 属性选择器（a[href=”…l”]）； 伪类选择器（a:hover, li:nth-child） ② 可继承属性：font-size、font-family、color。 ③ 不可继承属性：border、padding、 margin、 width、height ④ 优先级：important &gt; 内嵌样式 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪元素 &gt; 继承 &gt; 通配符 注意：important 提高 css 样式的权重，在 IE 中失效。 4、说说你对伪类和伪元素的了解，分别举出五个例子。① 伪类和伪元素 伪类：伪类用于某些选择器添加特殊效果。 伪元素：为某些元素添加特殊效果。 ② 两者区别： 伪元素相当于添加元素设置元素，而伪类是在元素添加效果。两者都不存在于 dom 树中，是文档流之外的东西。 伪类没有数量上的限制，只要两个伪类不相互排斥，可同时使用在同一元素上。 ③ 伪元素 :: before :: after :: first-line :: first-letter :: last-letter ④ 伪类 : first-child : visitive : hover : active : focus : lang ⑤ CSS3 新增伪类 p:first-of-type: 选择父元素的首个元素。 p:last-of-type: 选择属于其父元素的最后一个元素。 p:nth-child(2): 选择其父元素的第二个子元素。 p:only-of-type: 选择属于其父元素没有兄弟节点唯一元素。 p:first-child: p:last-child 选择父元素的第一个元素或最后一个元素 div:not(div2) 除 div2 的所有元素（否定伪类选择器）。 :enabled disabled 表单控件的禁用状态。 :checkd 单选框或复选框被选中。 5、 CSS 优先级怎么计算？ 特指度：表示一个 css 选择器表达式的重要程度，哪个的计算结果大，浏览器就会以哪个为优先。 ① 计算方法 通用选择器（*）、子元素选择器（&gt;）、相邻兄弟选择器（+） +0 element 元素选择器：+1； class 选择器、伪类选择器、属性选择器：+10； id 选择器：+100； 内联样式 +1000 ② 计算规则 !important 声明的样式优先级最高，如果冲突再进行计算。 如果优先级相同，则选择最后出现的样式。 继承得到的样式优先级最低。 6、 display有哪些值？说明他们的作用? inline：内联（默认值）； none：隐藏（不占空间）； block：块显示； block-inline：内联块级元素呈现； table：表格显示。 7、position的值？ static：（默认）按正常文档流排序； relative：相对定位。不脱离文档流，通过静态位置top、left、right、bottom定位； absolute：绝对定位。参考距其最近一个不为 static 的父级元素通过 top、bottom、left、right 定位。 fixed：固定定位。所固定的参照对象是可视窗口。 8、纯CSS实现三角形原理 均分原理。 12345678.triangle&#123; width: 0; height: 0; border-top: 40px solid transparent; border-left: 40px solid transparent; border-right: 40px solid transparent; border-bottom: 40px solid #ff0000;&#125; 9、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？① 如何居中一个 div？ 1margin:0 auto; ② 如何居中一个浮动元素？ flexbox 居中 ③ 如何让绝对定位的 div 居中？ flexbox 居中 10、谈一下你对 Flexbox 的了解，以及适用场景？ Flex 布局提供了更高效的对容器进行布局、对齐和分配空间。传统的布局，block 垂直从上到下布局；而 inline 布局则是水平方向排列。Flex 没有在方向上的限制，可自由操作。 11、为什么要初始化CSS样式？ 由于浏览器的兼容性问题，不同浏览器的某些标签的默认值是不相同的，如果没有对 CSS 初始化，往往会出现浏览器之间的页面显示差异。 12345678910111213141516// 淘宝初始化统一规范body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125; body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125; h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125; address, cite, dfn, em, var &#123; font-style:normal; &#125; code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125; small&#123; font-size:12px; &#125; ul, ol &#123; list-style:none; &#125; a &#123; text-decoration:none; &#125; a:hover &#123; text-decoration:underline; &#125; sup &#123; vertical-align:text-top; &#125; sub&#123; vertical-align:text-bottom; &#125; legend &#123; color:#000; &#125; fieldset, img &#123; border:0; &#125; button, input, select, textarea &#123; font-size:100%; &#125; table &#123; border-collapse:collapse; border-spacing:0; &#125; 12、CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？① 在谷歌浏览器中，使用 collapse 属性值和使用 hidden 没有区别。 ② 在火狐以及 opera 和 IE 中，使用 collapse 的值和使用 display：none 没有什么区别。 13、display:none 与 visibility：hidden 的区别？ display: none 不显示对应的元素，在文档流中不分配空间。（回流+重绘） visibility: hidden 隐藏对应元素，在文档中仍然保留原来的空间。（重绘） 14、对 BFC 的理解？ BFC 称为块级格式化上下文，是一个独立的容器，容器里边的内容不会影响到外边的内容，这个隐藏的属性需要被触发。 ① 触发 BFC 的条件： 根元素（html）; float 的值不为 none ; overflow 的值不为默认的 visible ; display 的值为 inline-block、table-cell、table-caption ; position 的值为 absolute 或 fixed。 ② BFC 的规则‘ 1）在一个块级排版上下文中，盒子是从包含块顶部开始，垂直的一个接一个的排列的。每个盒子的左外边是触碰到包含块的左边的（对于从右向左的排版，则相反）。 2）相邻两个盒子之间的垂直的间距是被 margin属性所决定的，在一个块级排版上下文中相邻的两个块级盒之间的垂直 margin 是折叠的。—— margin 上下折叠问题 3）BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。—— margin 高度塌陷 15、浮动带来的问题？以及清除浮动的方式？① 浮动问题： 父容器的高度无法撑开。 覆盖后边跟随的元素。 ② 清理浮动： overflow:hiddle(当子元素超出父元素，就会出现问题) clear: both 属性解决。 利用伪元素（::after）的方法。 16、上下 margin 重叠问题？margin 塌陷问题？以及怎么解决？① margin 折叠问题： 当两个盒子的垂直外边距 margin 是邻接的（相接触的），两个盒子就会使用一个外边距，外边距以高度最大值为准。（同一 BFC 中） 兄弟元素折叠 父子元素折叠 解决：处在不同的 BFC 中。 1、 兄弟元素折叠解决办法 将元素设置为浮动 float:left;。 在设置 margin-top/bottom 值时统一设置上或下。 元素的 position 的值为 absolute/fixed。 2、父子折叠解决办法：将两个 margin 隔离开，不直接相接触。 父元素设置 border； 父元素设置 padding； 父元素设置 overflow（父元素就为BFC，BFC 特性之一为内外不相互影响）； ② margin 塌陷问题： 高度塌陷：浮动的子元素无法撑开父元素的高度，导致父元素高度塌陷（浮动元素为一个 BFC ，所以不影响其他 BFC 外元素）。 嵌套塌陷：父盒子和子盒子存在嵌套关系的时候，子盒子和父盒子共用一个 margin。 解决： 1、高度塌陷解决办法： 清除浮动的方法。 父元素设置 overflow 属性（此时父元素也为 BFC，让浮动的元素正常溜排列，不能脱离文档流） 17、移动端的布局用过媒体查询吗？ 通过媒介查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应设备上的显示。 121、在 head 标签中&lt;link rel="stylesheet" type="text/css" href="xx.css" media="only screen and (max-device-width:480px)"&gt; 12341、在 css 中设置@media only screen and (max-device-width:480px)&#123; // css样式&#125; 18、css 预处理器 Less 是一个动态 CSS 语言框架，Less 扩展了 CSS 的动态特性。（变量、混入、嵌套、函数）。 SASS 是一种 CSS 的开发工具，提供了许多便利的写法。 19、margin 和 padding 分别适合什么场景使用？① 什么时候使用 margin? 需要在 border 外侧添加空白； 空白处不需要背景颜色； 上下相连的两个盒子之间的空白，需要相互抵消时。 ② 什么时候使用 padding？ 需要在 border 内侧添加空白 空白处需要背景颜色 上下相连的两个盒子的空白，希望为两者之和 20、display:inline-block 什么时候会显示间隙？ 有空格时候会有间隙解决：移除空格 margin 正值的时候 解决：margin使用负值 21、 CSS属性overflow属性定义溢出元素内容区的内容会如何处理? scroll：出现滚动条。 auto：子元素内容大于父元素内容出现滚动条。 visible：溢出内容出现在父元素之外。 hidden：溢出隐藏。 22、什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？① 响应式设计网站是一个网站能够兼容多个终端。 ② 基本原理：通过媒介查询检测不同设备屏幕尺寸做处理。 ③ 兼容 IE：头部必须有 meta 声明的 viewport。 22、px、em、rem 有什么区别？px： JavaScript 篇1、原始类型 定义：原始类型都是存储的值，没有函数可以调用，共有六种原始类型。 string number boolean undefined null symbol 2、关于 null 和 undefined 的区别？① null 表示”没有对象”，即该处不应该有值。 ② undefined 表示”缺少值”，就是此处应该有一个值 3、对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？① 原始类型存储的是指针，对象类型存储的是地址。 ② 对象之间的赋值，是地址的赋值，改变对象的值，导致两个变量的值都会发生改变。 4、typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？① typeof 对于原始类型来说，除了 null 都可以显示正确的类型。 12345678typeof 1 // 'number'typeof '1' // 'string'typeof undefined // 'undefined'typeof true // 'boolean'typeof Symbol() // 'symbol'typeof null // 'object'typeof &#123;&#125; // 'object'typeof console.log()// 'fuction' ② instanceof 判断一个对象的正确类型，可以使用 intanceof ，因为内部机制是通过原型链来判断的。instanceof 检测左侧的 __proto__ 原型链上，是否存在右侧的 prototype 原型。 1234const Person = function() &#123;&#125;const p1 = new Person()// p1._proto_._proto_ 原型链上是否存在 Person.prototypep1 instanceof Person // true 5、类型转换 ① 转换 Boolean 类型 undefined、null、false、NAN、‘ ’、0、-0 值为 false，其他值都为 true。 ② 对象转原始类型 对象转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，该函数的逻辑为： 如果为原始类型，就不转换； 需要转字符串，调用 x.toString() 方法。不是字符串类型就用 x.valueOf() 方法。 如果都没有返回原始类型，就会报错; 补充：x.toString 和 x.valueOf() 的区别？ x.toString：将转化的类型用字符串表示。 12345678910111213var a = 3;var b = '3';var c = true;var d = &#123;test:'123',example:123&#125;var e = function()&#123;console.log('example');&#125;var f = ['test','example'];a.toString();// "3"b.toString();// "3"c.toString();// "true"d.toString();// "[object Object]"e.toString();// "function ()&#123;console.log('example');&#125;"f.toString();// "test,example" x.valueOf：将返回自身的值。 12345678910111213var a = 3;var b = '3';var c = true;var d = &#123;test:'123',example:123&#125;var e = function()&#123;console.log('example');&#125;var f = ['test','example'];a.valueOf();// 3b.valueOf();// "3"c.valueOf();// trued.valueOf();// &#123;test:'123',example:123&#125;e.valueOf();// function()&#123;console.log('example');&#125;f.valueOf();// ['test','example'] 6、四则运算符 其中一个为字符串，另一个就会转化为字符串。 其中一方不是数字，就会转换字符串。 除了加法运算外，只要一方为数字，另一方也会转换为数字。 14 * [] // 0 + &#39;b&#39; 等于 NaN 1'a' + + 'b' // -&gt; "aNaN" 7、比较运算符 如果是对象，就通过 valueOf 转化原始类型再比较。 如果是字符串，就通过 unicode 字符索引来比较 123456789let a = &#123; valueOf() &#123; return 0 &#125;, toString() &#123; return '1' &#125;&#125;a &gt; -1 // true 8、逻辑运算符（&amp;&amp; 与 ||） 默认情况下返回布尔类型，但是也可以返回一个操作数。 运算符 语法 说明 逻辑与（&amp;&amp;） expr1 &amp;&amp; expr2 若 expr1 可转换为 true，则返回 expr2；否则，返回 expr1。 逻辑或（` `） `expr1 expr2` 若 expr1 可转换为 true，则返回 expr1；否则，返回 expr2。 逻辑非（!） !expr 若 expr 可转换为 true，则返回 false；否则，返回 true。 12345a5 = "Cat" &amp;&amp; "Dog" // t &amp;&amp; t 返回 "Dog"a6 = false &amp;&amp; "Cat" // f &amp;&amp; t 返回 falsea7 = "Cat" &amp;&amp; false // t &amp;&amp; f 返回 falsea8 = '' &amp;&amp; false // f &amp;&amp; f 返回 ""a9 = false &amp;&amp; '' // f &amp;&amp; f 返回 false 12345o5 = "Cat" || "Dog" // t || t 返回 "Cat"o6 = false || "Cat" // f || t 返回 "Cat"o7 = "Cat" || false // t || f 返回 "Cat"o8 = '' || false // f || f 返回 falseo9 = false || '' // f || f 返回 "" 8、运算符的优先级 操作符分类 操作符 算 术 操 作 符 + ++ (自增) –– (自减) * (乘法) / (除法) % (求余) &amp;&amp; （逻辑与） **\ \ ** (逻辑或) ! (逻辑非) &lt;&lt; (左移) 将第一操作数的二进制形式的每一位向左移位，所移位的数目由第二操作数指定。右面的空位补零。 &gt;&gt; (算术右移) 将第一操作数的二进制形式的每一位向右移位，所移位的数目由第二操作数指定。忽略被移出的位。 &gt;&gt;&gt; (逻辑右移) 将第一操作数的二进制形式的每一位向右移位，所移位的数目由第二操作数指定。忽略被移出的位，左面的空位补零。 = 赋值操作符 == 相等的话返回真 != 如果操作数不相等的话则返回真。 &gt; 如果左操作数大于右操作数的话则返回真。 &gt;= 如果左操作数大于等于右操作数的话则返回真。 &lt; 如果左操作数小于右操作数的话则返回真。 &lt;= 如果左操作数小于等于右操作数的话则返回真。 8、如何正确判断 this？箭头函数的 this 是什么？① 三种 this 场景： 全局调用函数，内部的 this 永远指向 windows 。 对象调用函数，谁调用 this ，this 就指向谁。 new 的方式，this 永远绑定在 new 出的对象。 ② 箭头函数中的 this： 箭头函数中是没有 this 的。 箭头函数中的 this 是指向包裹箭头函数的第一个函数的。 ③ bind 中的 this： this 取决于第一个参数，如果第一个参数为空，那么就是 window。 1fun.bind(a) // 函数.bind(参数) ④ 多种规则出现的优先级 箭头函数一旦绑定了 this，就不会被人和方式所改变。 new ——&gt; bind ——&gt; obj.foo() ——&gt; 全局调用。 8、call 、apply、bind 的区别 三者可以方便理解为：第一个参数调用了该方法，并将第二个参数作为该方法的参数传入。 共同点： ① apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的； ② apply 、 call 、bind 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文； ③ apply 、 call 、bind 三者都可以利用后续参数传参； 不同点： ① call 顺序传参，而 apply 是数组传参。 ② bind 的 this 取决于第一个参数，如果第一个参数为空，那么就是 window。 ③ bind 是返回对应函数（需要加一对花括号进行调用），便于稍后调用；apply 、call 则是立即调用 。 9、call、apply 及 bind 函数内部实现是怎么样的？▉ Call 的内部实现 首先 context 为可选参数，如果不传的话默认上下文为 window 接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数 因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来 然后调用函数并将对象上的函数删除 ※ 手写一个 call 方法： 123456789101112131415161718192021222324252627282930// this 为调用的函数// context 是参数对象Function.prototype.myCall = function(context)&#123; // 判断调用者是否为函数 if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125; // 不传参默认为 window context = context || window // 新增 fn 属性,将值设置为需要调用的函数 context.fn = this // 将 arguments 转化为数组将 call 的传参提取出来 [...arguments] const args = Array.from(arguments).slice(1) // 传参调用函数 const result = context.fn(...args) // 删除函数 delete context.fn // 返回执行结果 return result;&#125;// 普通函数function print(age)&#123; console.log(this.name+" "+age);&#125;// 自定义对象var obj = &#123; name:'小鹿'&#125;// 调用函数的 call 方法print.myCall(obj,1,2,3) ▉ apply 的内部实现 首先 context 为可选参数，如果不传的话默认上下文为 window 接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数 因为 apply 传参是数组传参，所以取得数组，将其剥离为顺序参数进行函数调用 然后调用函数并将对象上的函数删除 ※ 手写一个 apply 方法： 12345678910111213141516171819202122232425262728293031323334// 手写一个 apply 方法Function.prototype.myApply = function(context)&#123; // 判断调用者是否为函数 if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125; // 不传参默认为 window context = context || window // 新增 fn 属性,将值设置为需要调用的函数 context.fn = this // 返回执行结果 let result; // 判断是否有参数传入 if(arguments[1])&#123; result = context.fn(...arguments[1]) &#125;else&#123; result = context.fn() &#125; // 删除函数 delete context.fn // 返回执行结果 return result;&#125;// 普通函数function print(age,age2,age3)&#123; console.log(this.name+" "+ age + " "+ age2+" "+age3);&#125;// 自定义对象var obj = &#123; name:'小鹿'&#125;// 调用函数的 call 方法print.myApply(obj,[1,2,3]) ▉ bind 的内部实现 判断调用者是否为函数。 截取参数，注意：这里有两种形式传参。 返回一个函数，判断外部哪种方式调用了该函数（new | 直接调用） ※ 手写一个 bind方法： 12345678910111213141516171819202122232425262728293031323334353637// 手写一个 bind 函数Function.prototype.myBind = function (context) &#123; // 判断调用者是否为函数 if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125; // 截取传递的参数 const args = Array.from(arguments).slice(1) // _this 指向调用的函数 const _this = this; // 返回一个函数 return function F()&#123; // 因为返回了一个函数，我们可以 new F()，所以需要判断 // 对于 new 的情况来说，不会被任何方式改变 this if(this instanceof F)&#123; return new _this(...args,...arguments) &#125;else&#123; return _this.apply(context,args.concat(...arguments)) &#125; &#125;&#125;// 普通函数function print()&#123; // new 的方式调用 bind 参数输出换做 [...arguments] console.log(this.name); &#125;// 自定义对象var obj = &#123; name:'小鹿'&#125;// 调用函数的 call 方法let F = print.myBind(obj,1,2,3);// 返回对象let obj1 = new F();console.log(obj1); 10、== 和 === 有什么区别？ == 如果类型不相同，则先进行类型转换。=== 判断两者的类型和值是否相同。 ① == 比较规则 若类型相同，则直接比较大小；类型不同，先进行转换。 判断 null == undefined 返回 true。 判断 string 和 number 时，将字符换转化为 number。 判断其中一方为 boolean 值时，将 boolean 转化为 number。 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断。 11、闭包有关面试题？ 要想完全掌握闭包，一定要清楚函数作用域、内存回收机制、作用域继承 ① 什么是闭包？ 闭包是有权限访问其他函数作用域内的变量的一个函数。 ② 闭包为什么可以有权访问到？ 在 js 中，变量的作用域属于函数域，当函数执行完毕时，作用域就会被清理，内存被回收。但是闭包是建立在一个函数的内部的子函数，可以访问上级作用域，上级函数执行完后，作用域不会销毁，所以闭包可以访问上级作用域的权限，上级函数执行完后作用域内的值也不会销毁。 ③ 闭包解决了什么？ 由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的 Ajax 成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。 ④ 闭包有哪些应用场景？ 闭包随处可见，一个 Ajax 请求的成功回调，一个事件绑定的回调方法，一个 setTimeout 的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。 ⑤ 经典面试题 12345for(var i = 1;i &lt;= 5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123;console.log(j)&#125;,j*1000) &#125;)(i)&#125; 12、立即执行函数① 什么是立即执行函数 声明一个匿名函数，并立即执行。 1234// 写法一：(function()&#123;alert('我是匿名函数')&#125;)()// 写法二：(function()&#123;alert('我是匿名函数')&#125;()) ② 立即执行函数有什么作用？ js 没有块级作用域，创建一个独立的作用域，用来隔离作用域避免污染。 ③ 经典面试题 12345for(var i = 1;i &lt;= 5;i++)&#123; (function(j)&#123; console.log(j) &#125;)(i)&#125; 13、什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？ 对象赋值其实复制了地址，一方改动会导致另一方的值也改动。可以通过浅拷贝来解决这个问题。 ① 浅拷贝 ▉ Object.assign() Object.assign() 可以实现一个浅拷贝，将 source 的所有属性值拷贝到 target 新对象中。如果属性是对象的话，拷贝的是地址。 123456let a = &#123; age: 1&#125;let b = Object.assign(&#123;&#125;, a)a.age = 2console.log(b.age) // 1 ▉ ... 扩展运算符 扩展运算符也可以实现一个浅拷贝。 123456let a = &#123; age: 1&#125;let b = &#123; ...a &#125;a.age = 2console.log(b.age) // 1 ▉实现一个浅克隆 自己实现一个浅拷贝，和上边的两种实现没什么差别。 12345678 // 实现浅克隆function shallowClone(o)&#123; const obj = &#123;&#125;; for(let i in o)&#123; obj[i] = o[i] &#125; return obj;&#125; ② 深克隆 对于多层嵌套的对象，浅克隆就是失去了作用。 ▉ 序列/反序列化（parse/stringify）序列化：把变量从内存中变成可存储或传输的过程称之为序列化。stringify 方法可以将 JS 对象序列化成 JSON 字符串。 反序列化：把变量内容从序列化的对象重新读到内存里称之为反序列化。JSON对象parse 方法可以将 JSON 字符串反序列化成 JS 对象。 1const newObj = JSON.parse(JSON.stringify(oldObj)); 缺点： 1、无法实现对函数、RegExp 等特殊对象的克隆。 2、会抛弃对象的 constructor，所有的构造函数会指向 Object。 3、对象有循环引用，会报错。 ▉ 实现一个深克隆函数 序列/反序列化不可能实现了，所以实现一个对象类型判断函数。要面对不同的对象(正则、数组、Date等)要采用不同的处理方式。推荐使用 lodash 函数。 12345678910111213141516171819202122const isType = (obj, type) =&gt; &#123; if (typeof obj !== 'object') return false; const typeString = Object.prototype.toString.call(obj); let flag; switch (type) &#123; case 'Array': flag = typeString === '[object Array]'; break; case 'Date': flag = typeString === '[object Date]'; break; case 'RegExp': flag = typeString === '[object RegExp]'; break; default: flag = false; &#125; return flag;&#125;;const arr = Array.of(3, 4, 5, 2);console.log(isType(arr, 'Array')); // true 14、Object 和 Function 的关系 ① 所有的构造函数的 _proto_ 包括 Object 和 Function 本身都指向 Function.prototype。（可以理解为所有的构造函数都是 Function 的实例）。 ② 因为所有的对象实例的 _proto_ 都指向 Object.prototype ，又因为所有的原型对象都是 Object 的实例，包括 Function 的原型 Function.prototype ，所以 Function.prototype 也指向 Object.prototype。 ③ Object.prototype 的 _proto_ 最终指向 null。 er 15、你理解的原型是什么？ 每个 JS 对象都有一个 _proto_ 属性，这个属性指向了原型。原型中定义了很多属性和函数，其中的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型，这个属性和 _proto_ 属性指向是同一原型。并不是所有的函数都具有 prototype 的属性，bind函数就没有。 16、如何理解原型链？ 所谓的原型链就是多个对象通过 __proto__ 的方式连接了起来形成一条链。 17、说说 js 中的继承？ ES5 中的继承： 1、经典继承（构造函数）12345678910111213141516171819/ 详细解析//1、当用调用 call 方法时，this 带边 son 。//2、此时 Father 构造函数中的 this 指向 son。//3、也就是说 son 有了 colors 的属性。//4、每 new 一个 son ，都会产生不同的对象，每个对象的属性都是相互独立的。function Father()&#123; this.colors = ["red","blue","green"];&#125;function Son()&#123; // this 是通过 new 操作内部的新对象 &#123;&#125; ， // 此时 Father 中的 this 就是为 Son 中的新对象&#123;&#125; // 新对象就有了新的属性，并返回得到 new 的新对象实例 // 继承了Father,且向父类型传递参数 Father.call(this);&#125;let s = new Son();console.log(s.color) ① 基本思想：在子类的构造函数的内部调用父类的构造函数。 ② 优点： 保证了原型链中引用类型的独立，不被所有实例共享。 子类创建的时候可以向父类进行传参。 ③ 缺点: 继承的方法都在构造函数中定义，构造函数不能够复用了（因为构造函数中存在子类的特殊属性，所以构造函数中复用的属性不能复用了）。 父类中定义的方法对于子类型而言是不可见的（子类所有的属性都定义在父类的构造函数当中）。 2、组合继承1234567891011121314151617181920212223242526272829303132333435function Father(name)&#123; this.name = name; this.colors = ["red","blue","green"];&#125;// 方法定义在原型对象上（共享）Father.prototype.sayName = function()&#123; alert(this.name);&#125;;function Son(name,age)&#123; // 子类继承父类的属性 Father.call(this,name); //继承实例属性，第一次调用 Father() // 每个实例都有自己的属性 this.age = age;&#125;// 子类和父类共享的方法（实现了父类属性和方法的复用） Son.prototype = new Father(); //继承父类方法,第二次调用 Father()// 子类实例对象共享的方法Son.prototype.sayAge = function()&#123; alert(this.age);&#125;var instance1 = new Son("louis",5);instance1.colors.push("black");console.log(instance1.colors);//"red,blue,green,black"instance1.sayName();//louisinstance1.sayAge();//5var instance1 = new Son("zhai",10);console.log(instance1.colors);//"red,blue,green"instance1.sayName();//zhaiinstance1.sayAge();//10 ① 基本思想： 使用原型链实现对「原型对象属性和方法」的继承。 通过借用构造函数来实现对「实例属性」的继承。 ② 优点： 在原型对象上定义的方法实现了函数的复用。 每个实例都有属于自己的属性。 ③ 缺点： 组合继承调用了两次父类的构造函数，造成了不必要的消耗。 3、原型继承123456789101112131415161718192021function object(o)&#123; function F()&#123;&#125; F.prototype = o; // 每次返回的 new 是不同的 return new F();&#125;var person = &#123; friends : ["Van","Louis","Nick"]&#125;;// 实例 1var anotherPerson = object(person);anotherPerson.friends.push("Rob");// 实例 2var yetAnotherPerson = object(person);yetAnotherPerson.friends.push("Style");// 都添加至原型对象的属性(所共享)alert(person.friends); // "Van,Louis,Nick,Rob,Style" ① 基本思想：创建临时性的构造函数（无任何属性），将传入的对象作为该构造函数的原型对象，然后返回这个新构造函数的实例。 ② 浅拷贝： object 所产生的对象是不相同的，但是原型对象都是 person 对象，所改变存在原型对象的属性所有生成的实例所共享，不仅被 Person 所拥有，而且被子类生成的实例所共享。 ③ object.create()：在 ECMAScript5 中,通过新增 object.create() 方法规范化了上面的原型式继承.。 参数一：新对象的原型的对象。 参数二：先对象定义额外的属性（可选）。 4、寄生式继承1234567function createAnother(original)&#123; var clone = object(original); //通过调用object函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert("hi"); &#125;; return clone; //返回这个对象&#125; ① 基本思想：同样调用 object 函数，将返回的对象和对象的额外的方法和属性封装成一个函数进行返回。 ② 缺点：寄生式继承将对象封装起来，导致不能做到函数的复用，使得效率降低。 5、寄生组合式继承123456789// 参数分别为子类和父类的构造函数function extend(subClass,superClass)&#123; var prototype = object(superClass.prototype);//创建对象 // 下面这两部为子类的构造函数指定原型对象 // 让原型对象的 constructor 指向子类 prototype.constructor = subClass; // 为子类构造函数指定原型对象 subClass.prototype = prototype;&#125; ① 基本思想：不必为了指定子类型的原型而调用超类型的构造函数（避免第二次调用的构造函数）。 ② 优点：寄生组合式继承就是为了解决组合继承中两次调用构造函数的开销。 19、new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？以及 new 和 Object.create(null) 创建对象的区别？ new 操作符的过程其实就是一个创建空对象，为空对象添加属性，为对象链接原型链，返回对象。 ▉ new 的原理：① 新生成一个对象； ② 链接到原型； ③ 绑定 this； ④ 返回新对象。 ▉ new 创建对象和字面量创建对象的区别共同点： 对于对象，其实都是通过 new Object() 产生的。 不同点： 推荐使用字面量的方式创建对象，简单，方便。 通过 new Object() 的方式创建对象需要通过作用域链一层层的找到 Object 。 字面量的方式创建对象就没有以上问题。 12345function Foo() &#123;&#125;// function 就是个语法糖// 内部等同于 new Function()let a = &#123; b: 1 &#125;// 这个字面量内部也是使用了 new Object() ▉ Object.create(null) 创建对象1Object.create(proto, [propertiesObject]); proto：新创建对象的原型对象。 propertiesObject：（可选）可为创建的新对象设置属性和值。 ▉ Object.create() 一般用于继承12345678910111213141516171819202122232425262728293031var People = function (name)&#123; this.name = name;&#125;;People.prototype.sayName = function ()&#123; console.log(this.name);&#125;function Person(name, age)&#123; this.age = age; People.call(this, name); // 使用call，实现了People属性的继承&#125;;// 使用Object.create()方法，实现People原型方法的继承，并且修改了constructor指向Person.prototype = Object.create(People.prototype, &#123; constructor: &#123; configurable: true, enumerable: true, value: Person, writable: true &#125;&#125;);Person.prototype.sayAge = function ()&#123; console.log(this.age);&#125;var p1 = new Person('person1', 25); p1.sayName(); //'person1'p1.sayAge(); //25 ▉ new/字面量 与 Object.create() 创建对象的区别 new 和 字面量创建的对象的原型指向 Object.prototype，会继承Object的属性和方法。 而通过 Object.create(null) 创建的对象，其原型指向 null，null作为原型链的顶端，没有也不会继承任何属性和方法。 ▉ 手写实现一个 new 操作符123456789101112131415161718192021222324252627282930// new 生成对象的过程// 1、生成新对象// 2、链接到原型// 3、绑定 this// 4、返回新对象// 参数：// 1、Con: 接收一个构造函数// 2、args：传入构造函数的参数function create(Con, ...args)&#123; // 创建空对象 let obj = &#123;&#125;; // 设置空对象的原型(链接对象的原型) obj._proto_ = Con.prototype; // 绑定 this 并执行构造函数(为对象设置属性) let result = Con.apply(obj,args) // 如果 result 没有其他选择的对象，就返回 obj 对象 return result instanceof Object ? result : obj;&#125;// 构造函数function Test(name, age) &#123; this.name = name this.age = age&#125;Test.prototype.sayName = function () &#123; console.log(this.name)&#125;// 实现一个 new 操作符const a = create(Test,'小鹿','23')console.log(a.age) 20、instanceof 的原理是什么？ instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 ▉ 手写实现一个 instanceof1234567891011function myInstanceof(left, right) &#123; let prototype = right.prototype left = left.__proto__ while (true) &#123; if (left === null || left === undefined) return false if (prototype === left) return true left = left.__proto__ &#125;&#125; 21、为什么 0.1 + 0.2 != 0.3？如何解决这个问题？▉ 原因① 因为 JS 采用的是 IEEE 754 双精度版本（64）位，采用该版本的语言都存在问题。 ② 计算机是通过二进制来存储东西的，那么 0.1 会在二进制内表示的是无限循环的一些数，不只是 0.1 。还有很多的十进制小数用二进制表示的是无限循环的。 ③ 但是 js 采用的是浮点数标准却会裁减掉循环的数据而失去精度。也就造成了 0.1 不再是 0.1 了。而是变成了 0.100000000000000002。 ④ 那么同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了 0.200000000000000002。 ⑤ 所以这两者相加不等于 0.3 而是 0.300000000000000004。 ⑥ 既然 0.1 不是 0.1，那为什么 console.log(0.1) 却是正确的呢？在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值。 12// (0011) 表示循环0.1 = 2^-4 * 1.10011(0011) 10.100000000000000002 === 0.1 // true ▉ 解决问题1parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true ES6 知识点总结1、什么是提升？什么是暂时性死区？var、let 及 const 区别？※ 答✔：什么是提升？ 1）所谓的提升就是虽然变量没有声明，但是可以使用这个未声明的变量。 2）函数也有提升并且优先于变量的提升。函数提升会把整个函数挪到作用域顶部。 3）var 的变量会被提升到作用域的顶部。 ※ 答✔：什么是暂时性死区？ 1）如果使用 let、const 声明变量，在声明之前就是用了变量就会报错，报错的原因就是暂时性死区。这里的提升和 var 是有区别的，虽然变量在编译的环节中被告知在这块作用域中可以访问，但是访问是受限制的。 ※ 答✔：var、let 及 const 区别？ 1）var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会 2）let 和 const 作用基本一致，但是后者声明的变量不能再次赋值。 ※ 扩展✔：为什么或存在提升？ 1）根本原因就是为了解决函数间互相调用的情况。 2、原型如何实现继承？Class 如何实现继承？Class 本质是什么？※ 答✔：原型如何实现继承？ 1）组合继承、寄生组合继承、Class 继承 原文链接：JavaScript 中的原型链和继承 ※ 答✔：Class 如何实现继承？ 1）Class 实现继承主要使用 extends 来明确继承自哪个父类，并且再子类中调用 super，可以将这段代码看做 Parent.call(this,value)。 12345678910111213141516class Parent &#123; constructor(value) &#123; this.val = value &#125; getValue() &#123; console.log(this.val) &#125;&#125;class Child extends Parent &#123; constructor(value) &#123; super(value) &#125;&#125;let child = new Child(1)child.getValue() // 1child instanceof Parent // true ※ 答✔：Class 本质是什么？ 1）js 中并不存在类，Class 只是语法糖，Class 的本质还是函数。 3、什么使用模块化？都有哪几种方式可以实现模块化，各有什么特点？※ 答✔：为什么使用模块化？ 通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。 解决命名冲突 提供复用性 提高代码可维护性 ※ 答✔：都有哪几种方式可以实现模块化？ ① 立即执行函数（IIFE） 立即执行函数中的匿名函数中有独立的 词法作用域，避免了外界访问此作用域的变量。通过函数作用域解决了命名冲突、污染全局作用域的问题 。 ② AMD 和 CMD AMD AMD 采用异步的加载方式，加载之后不影响它后面语句的运行。require.js 实现 AMD 规范的模块化 ， require.config() 指定引用路径等，用 define() 定义模块，用 require() 加载模块。 CMD CMD 的不同点在于推崇依赖前置、提前执行，CDM 推崇依赖就近、延迟执行。 ③ CommonJS CommonJS 的规范主要用在 Node.js 中，为模块提供了四个接口：module、exports、require、global。 CommonJS 用同步的方式加载模块（服务器端），在浏览器端使用的是异步加载模块。 12345678910// lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;// 对外暴露接口module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 1234567// 加载外部模块var mod = require('./lib');console.log(mod.counter); // 3mod.incCounter();// 原始类型的值被缓存，所以就没有被改变（commonJS 不会随着执行而去模块随时调用）console.log(mod.counter); // 3 ④ ES6 模块 ES6 实现的模块非常简单，用于浏览器和服务器端。mport命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码 .主要有两个命令组成：export和import: export命令用于规定模块的对外接口。 import命令引入其他模块的功能。 123456789101112// 指定指定的值暴露对外的接口export let counter = 3;export function incCounter() &#123; counter++;&#125;// 加载模块中的某个值import &#123; counter, incCounter &#125; from './lib';console.log(counter); // 3incCounter();// ES6 模块不同的是，静态加载完毕之后，每执行到模块中的方法，就去模块内调用（外部的变量总是与模块进行绑定的），而且值不会被缓存。console.log(counter); // 4 ⑤ ES6 模块与 CommonJS 模块的区别 1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 所谓值的拷贝，原始类型的值被缓存，不随模块内部的改变而改变。 ES6 模块是动态引用，不缓存值，模块内外是绑定的，而且是只读引用，不能修改值。ES6 的 js 引擎对脚本静态分析的时候，遇到加载命令模块 import ，就会生成一个只读引用，当真正用到模块里边的值的时候，就会去模块内部去取。 2、CommonJS 模块是运行时加载，ES6 模块是编译时加载输出接口。 运行时加载：CommonJS 模块就是对象；是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载：ES6 模块不是对象，而是通过 export 命令「显式指定输出的代码」。import 时采用静态命令的形式，即在import指定「加载某个输出值」，而「不是加载整个模块」，这种加载称为“编译时加载”。 ⑥ 总结 CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。 AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。 CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重。 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 4、map、filter、reduce 各自有什么作用？※ map 有什么作用？ map 的作用是 map 中传入一个函数，该函数会遍历该数组，对每一个元素做变换之后返回新数组。 1）该函数存在三个参数： element : 对应数组的每个元素。 index : 数组元素的下标。 arr : 原数组。 2）代码实现1234let arr = [2,3,4]arr = arr.map(function(element,index,arr)&#123; return arr[index]+1;&#125;) // [3,4,5] ※ filter 有什么作用？ filter 的作用是也是生成一个数组，传入的函数返回值确实布尔类型，返回值为 true 的元素放入新数组，通常来筛选删除不需要的元素。 1）该函数存在三个参数： element : 对应数组的每个元素。 index : 数组元素的下标。 arr : 原数组。 2）代码实现1234let array = [1, 2, 4, 6]let arr = array.filter(function(element)&#123; return element != 6;&#125;)// [1,2,4] ※ reduce 有什么作用？ reduce 可以将数组中的元素通过回调函数最终转换为一个值。 1）传入 reduce 两个参数： 回调函数 accum：累计值(第一次的值代表初始化的值)。 element：当前元素。 index：当前索引。 arr：原数组。 初始值 2）代码实现1234let arr = [1,2,3]let sum = arr.reduce(function(acc,element)&#123; return acc + element;&#125;,0) // 6 3）reduce 的执行过程 初始值为 0 ，该值会传入第一次回调函数。 回到函数接收四个值，第一个值是累计值。 第一次执行回调函数将「初始值」和「当前值」做运算。 然后将结果值传入第二次执行的回调函数。 第二次回调函数会和当前值再做运算。 5、Proxy 可以实现什么功能？ Proxy 中文意思代理，可以用来自定义对象中的操作。 ① 如果设置了拦截操作，那么访问目标对象时被拦截。 ② 如果没有设置拦截操作，但是生成了 Proxy 的实例，那么可以正常访问到原始值。 ▉ 格式1var proxy = new Proxy(target, handler); target：所要拦截的目标对象。 handle：设置拦截的行为。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之递归系列]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[数据结构与算法之递归系列，题目详细解析！ 数据结构与算法之递归系列[TOC] 前言几个月之前就想写这样一篇文章分享给大家，由于自己有心而力不足，没有把真正的学到的东西沉淀下来，所以一直在不断的自学。可能是因为在一所三流大学，资源也比较少，只能自己在网搜索相关资料，在互联网上遇到了一些朋友的帮助下去深入理解，然后自己抽出大量时间做题总结、归纳，才会把已有的知识概念所被自己吸收和理解，形成了自己的技术思想体系。 然后自己又了用了一个星期的时间去整理、分类，才有了这篇 8000 字有关递归的分享，希望能够帮助正在学习递归的小伙伴们。而且有了这篇文章的支撑和动力，往后还会写出关于数据结构与算法一些难懂的概念简单化。如果文章中有错误的地方，希望大家指正，能够为他人分享出更有质量的文章！ 为什么要写这篇递归文章看了很多关于递归的文章，也总结了很多递归的文章，也看了多篇文章下方读者的评论。有的读者评论到文章清晰易懂，有的却喷作者写的存在很多错误，埋怨作者写出来很垃圾，还不如不写。我想从理性的角度说一下，创作者写文章的最初好意是能够帮助别人对此知识点有进一步的了解，并不代表一定能够满足每个人的要求。 另一方面，每篇文章的作者可能理解的不够透彻，很多地方可能存在许多错误，包括理解上的错误，笔误等，这也是写文章的第二个目的，能够让别人挑出自己文章中的不足，能够达到与别人共同进步的目的，一举两得，两全其美。 接下来分享的文章是关于递归的，这篇文章不单单分享递归的一切，我觉得更重要的是向每位读者传递一个思想。思想？对的，没错！这篇文章不能说包含递归的边边角角，但是通过自己的理论上的学习和实践，有了自己的一套递归思想。 什么问题该用递归，什么问题用递归简洁，什么问题就不能使用递归解决，以及对于特定的问题用递归解决的陷阱，能不能进一步对递归进行二次优化，这些都是今天小鹿分享的内容。 什么是递归？ 递归，顾名思义，有递有归才叫递归，有递无归，有归无递那叫 “耍流氓” 。 为什么要学习递归？我们学习一门技术也好，编程语言也好，首先学习之前我们知道它将能给我们带来什么，能帮助我们解决什么样的问题，这也是激励我们去学习它的动力所在。 从数组到链表、散列表，再到基本算法等，直到遇到递归之后，感觉非常的难理解。我相信每个人都有这种感觉，一开始觉得非常难，经历了九九八十一难之后，还是没有弄懂递归里边的猫腻，然后就自然而然的跳过了。 后来我就开始刷了一个月的 LeetCode 题，发现递归在数据结构与算法中有着一席之地，统治着江山。大部分的题都可以用递归去解决，如：二叉树的遍历、回溯算法、0-1 背包问题、深度优先遍历、回溯算法等等，我整理了至少二三十到关于递归的题，才发现递归的重要性，所以不得不重新深入递归学习，所有有了今天这篇文章。 怎么理解递归的过程？ 上方我对递归“耍流氓”式的定义并不能让你准确的理解递归是什么，那么我们就来活生生的举个生活中的例子。 1、问题 比如你和小鹿我一样，在大学里喜欢插队打饭（作为一个三好学生，我怎么能干这种事呢？哈哈），那么队伍后边的同学本数着自己前边还有 5 个同学就改轮到自己了，由于前边同学不断的插队，这时他发现，怎么觉得自己离着打饭的窗口越来越远呢？这时如果他想知道自己在队队列中的的第几个（前提是前边不再有人插队），用递归思想来解决，我们怎么做呢？ 2、“递” 于是他问前边的同学是第几位，前边的同学也不只到呀，于是前边的同学问他前边的同学是第几位，直到前边第二个同学问到第一个正在打饭的同学是队伍的第几个（有点小尴尬）。打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？这个过程其实是就是一个递归中“递”的过程。 3、“归” 然后前边打饭的第二个同学不耐烦的又告诉第三个同学，我是第二个，没看单我前边有个家伙正在打饭吗？然后第三个传给第四个，以后往后传，直到那位逐渐远离窗口的同学的前一个人告诉他是第几个之后，他知道了自己目前在队伍中的第几个位置。这个过程我们可以理解为递归中“归”的过程。 4、终止条件 “打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？”，在递归中，我们称为终止条件。 5、怎么理解递归？ 1）问题虽然是层层递归的分析，但是用程序表示的时候，不要层层的在大脑中调用递归代码去想，这样可能会使你完全陷入到 “递” 的过程中去，“归” 的时候，归不出来了，这些都是我们交给计算机干的事情。 2）那我们在写程序的时候怎么理解递归呢？我们只找问题之间存在的关系，屏蔽掉递归的细节，具体看（五）分析。 满足递归的三个条件 通过上方的例子，我们可以很容易的总结出满足递归的三个条件。 1、一个问题能不能分解成多个子问题来解决 想知道自己在队伍中的位置，将其问题分解为“每个人所处队伍中的位置”这样的多个子问题。 2、该问题是否和子问题的解决思路相同 想要知道自己当前的位置，就要问前边人所处的位置。那么前边人想要知道自己所处的位置，就要知道他前边人的位置。所以说，该问题和子问题的解决思路相同，满足第二个条件。 3、该问题是否有终止条件 第一个正在打饭的同学说自己是队伍中的第一人，这就是所谓的终止条件，找到终止条件之后就开始进行“归”的过程。 怎么编写递归代码？ 如果你对递归有了一定的了解，上边的例子对你来说小菜一碟，下边还有更大的难度来进行挑战。那么问题分析清楚了，怎么根据问题编写出递归代码来呢？ 1、写出递推公式 写递归公式最重要的一点就是找到该问题和子问题的关系，怎么找到之间存在的关系呢？这里我要强调注意的一点就是不要让大脑试图去想层层的递归过程，毕竟大脑的思考方式是顺势思考的（一开始学习递归总是把自己绕绕进去，归的时候，就完全乱套的）。那怎么找到每个子问题之间存在的某种关系呢？ 我们只想其中一层（第一层关系），以上述为例，如果我想知道当前队伍的位置，所以我要之前前一个人的位置，然后 +1 就是我的位置了。对于他在什么位置，我丝毫不用关系，而是让递归去解决他的位置。我们可以写出递推公式如下： 1234// f(n) 代表当前我在队伍中的位置// f(n-1) 代表我前边那个人的位置// 递推公式f(n) = f(n-1) + 1 ※ 注意：这个式子的含义就是 f(n) 求当前 n 这个人的位置， f(n-1) + 1 代表的就是前一个人的位置 + 1 就是 n 的位置。 2、找到终止条件 递推公式我们很轻松的写出来了，但是没有终止条件的递推公式会永远的执行下去的，所以我们要有一个终止条件终止程序的运行。那么怎么找到终止条件呢？ 所谓的终止条件就是已知的条件，比如上述的排队打饭的例子中，第一个人正在窗口打饭，他的前边是没有人的，所以他是第一个。第一个人的位置为 1，我们应该怎么表示呢？ 12// 终止条件f(1) = 1; ※ 注意：有的问题终止条件不止一个哦，比如：斐波那契数列。具体问题具体分析。 3、转换递归代码 递推公式和终止条件我们分析出来了，那么将递推公式转化为递归代码非常容易了。 123456function f(n)&#123; // 终止条件 if(n == 1) retun 1; // 递推公式 return f(n-1) + 1;&#125; 递归的分类 通过做大量的题，根据递归解决不同的问题，引申出来的几种解决和思考的方式。之所以将其分类，是为了能够更好的理解递归在不同的问题下起着什么作用，如：每层递归之间存在的关系、计算，以及递归枚举所有情况和面临选择性问题的递归。虽然分为了几类，但是递归的本质是一成不变的。 分类一：递归计算型 将哪一类用递归解决的问题作为计算型呢？我简单总结了为两点，层层计算和并列计算。 1、层层计算 层层计算，顾名思义，能够用递归解决的问题都可以分为多个子问题，我们把每个子问题可以抽象成一层，子问题之间的关系可以表示为层与层之间的关系。我们通过层与层之间的计算关系用递推公式表达出来做计算，经过层层的递归，最终得到结果值。 ▉ 例子： 我们再那上方排队打饭的例子来说明，我们的子问题已经分析出来了，就是我想知道当前在队伍中的位置，就是去问我前边人的位置加一就是我当前队伍的位置，这为一层。而前边这个人想知道当前自己的位置，需要用同样的解决思路，作为另一层。 层与层之间的关系是什么（我当前队伍中的位置与前边人的位置存在什么样的关系）？这时你会说，当前是 +1。这个大部分人都很容易找出，既然关系确定了，然后通过递推公式很容易写出递归代码。 1234// f(n) 为我所在的当前层// f(n-1) 为我前边的人所在的当前层// + 1 是层与层之间的计算关系f(n) = f(n-1) + 1 ▉ 总结： 我将以上一类递归问题命名为「递归计算型」的「层层计算类型」。 ▉ 举一反三： 求年龄的问题也是层层计算类型的问题，自己尝试分析一下（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。 问题一：有 5 个人坐在一起，问第 5 个人多少岁，他说比第 4 个人大 2 岁。问第 4 个人多少岁，他说比第 3 个人大2岁。问第 3 人多少岁，他说比第 2个 人大 2 岁。问第2个人多少岁，他说比第 1 个人大 2 岁。最后问第 1 个人，他说他是 10 岁。编写程序，当输入第几个人时求出其对应的年龄。 问题二：单链表从尾到头一次输出结点值，用递归实现。 2、并列计算 并列计算，顾名思义，问题的解决方式是通过递归的并列计算来得到结果的。层与层之间并没有一定的计算关系，而只是简单的改变输入的参数值。 ▉ 例子： 最经典的题型就是斐波那契数列。观察这样一组数据0、 1、1、2、3、5、8、13、21、34…，去除第一个和第二个数据外，其余的数据等于前两个数据之和（如：2 = 1 + 1，8 = 3 + 5，34 = 21 + 13）。你可以尝试着根据「满足递归的三个条件」以及「怎么写出递归代码」的步骤自己动手动脑亲自分析一下。 我也在这里稍微做一个分析。 1）第一步：首先判断能不能将问题分解为多个子问题，上边我也分析过了，除了第一个和第二个数据，其他数据是前两个数据之和。那么前两个数据怎么知道呢？同样的解决方式，是他们前两个数之和。 2）第二步：找到终止条件，如果不断的找到前两个数之和，直到最前边三个数据 0、1、1 。如果递归求第一个 1 时，前边的数据不够，所以这也是我们找到的终止条件。 3）第三步：既然我们终止条件和关系找到了，递推公式也就不难写出 f(n) = f(n-1) + f(n-2)（n 为要求的第几个数字的值）。 4）转化为递归代码如下： 1234567function f(n) &#123; // 终止条件 if(n == 0) return 0; if(n == 1) return 1; // 递推公式 return f(n-1) + f(n-2);&#125; ▉ 总结： 我将上方的问题总结为并列计算型。也可以归属为层层计算的一种，只不过是 + 1 改成了加一个 f 函数自身的递归（说白了，递归的结果也是一个确切的数值）。之所谓并列计算 f(n-1) 和 f(n-2) 互不打扰，各自递归计算各的值。最后我们将其计算的结果值相加是我们最想要的结果。 ▉ 举一反三： 青蛙跳台阶的问题也是一种并列计算的一种，自己尝试着根据上边的思路分析一下，实践出真知（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。 问题： 一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。 分类二：递归枚举型 递归枚举型最多的应用就是回溯算法，枚举出所有可能的情况，怎么枚举所有情况呢？通过递归编程技巧进行枚举。那什么是回溯算法？比如走迷宫，从入口走到出口，如果遇到死胡同，需要回退，退回上一个路口，然后走另一岔路口，重复上述方式，直到找到出口。 回溯算法最经典的问题又深度优先遍历、八皇后问题等，应用非常广泛，下边以八皇后问题为例子，展开分析，其他利用递归枚举型的回溯算法就很简单了。 八皇后问题 在 8 X 8 的网格中，放入八个皇后（棋子），满足的条件是，任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，问有多少种摆放方式？ 【图片】 ▉ 问题分析： 要想满足任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，需要一一枚举皇后（棋子）的所有摆放情况，然后设定条件，筛选出满足条件的情况。 ▉ 算法思路： 我们把问题分析清楚了之后，怎么通过递归实现回溯算法枚举八个皇后（棋子）出现的所有情况呢？ 1）我们在 8 X 8 的网格中，先将第一枚皇后（棋子）摆放到第一行的第一列的位置（也就是坐标: (0,0)）。 2）然后我们在第二行安置第二个皇后（棋子），先放到第一列的位置，然后判断同一行、同一列、同一斜线是否存在另一个皇后？如果存在，则该位置不合适，然后放到下一列的位置，然后在判断是否满足我们设定的条件。 3）第二个皇后（棋子）找到合适的位置之后，然后在第三行放置第三枚棋子，依次将八个皇后放到合适的位置。 4）这只是一种可能，因为我设定的第一个皇后是固定位置的，在网格坐标的（0,0） 位置，那么怎么枚举所有的情况呢？然后我们不断的改变第一个皇后位置，第二个皇后位置…… ，就可以枚举出所有的情况。如果你和我一样，看了这个题之后，如果还有点懵懵懂懂，那么直接分析代码吧。 ▉ 代码实现： 虽然是用 javascript 实现的代码，相信学过编程的小伙伴基本的代码逻辑都可以看懂。根据上方总结的递归分析满足的三个条件以及怎么写出递归代码的步骤，一步步来分析八皇后问题。 1、将问题分解为多个子问题 在上述的代码分析和算法思路分析中，我们可以大体知道怎么分解该问题了，枚举出八个皇后（棋子）所有的满足情况可以分解为，先寻找每一种满足的情况这种子问题。比如，每个子问题的算法思路就是上方列出的四个步骤。 2、找出终止条件 当遍历到第八行的时候，递归结束。 1234567// 终止条件if(row === 8)&#123; // 打印第 n 种满足的情况 console.log(result) n++; return;&#125; 3、写出递推公式 isOkCulomn() 函数判断找到的该位置是否满足条件（不能处于同一行、同一列或同一斜线上）。如果满足条件，我们返回 true，进入 if 判断，row行数加一传入进行递归下一行的皇后位置。直至递归遇到终止条件位置，column ++，将第一行的皇后放到下一位置，进行继续递归，枚举出所有可能的摆放情况。 1234567891011// 每一列的判断for(let column = 0; column &lt; 8; column++)&#123; // 判断当前的列位置是否合适 if(isOkCulomn(row,column))&#123; // 保存皇后的位置 result[row] = column; // 对下一行寻找数据 cal8queens(row + 1); &#125; // 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性&#125; 123456789101112131415161718192021222324252627// 判断当前列是否合适const isOkCulomn = (row,column) =&gt;&#123; // 左上角列的位置 let leftcolumn = column - 1; // 右上角列的位置 let rightcolumn = column + 1; for(let i = row - 1;i &gt;= 0; i--)&#123; // 判断当前格子正上方是否有重复 if(result[i] === column) return false; // 判断当前格子左上角是否有重复 if(leftcolumn &gt;= 0)&#123; if(result[i] === leftcolumn) return false; &#125; // 判断当前格式右上角是否有重复 if(leftcolumn &lt; 8)&#123; if(result[i] === rightcolumn) return false; &#125; // 继续遍历 leftcolumn --; rightcolumn ++; &#125; return true;&#125; 4、转换为递归代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 变量// result 为数组，下标为行，数组中存储的是每一行中皇后的存储的列的位置。// row 行 // column 列// n 计数满足条件的多少种var result = [];let n = 0const cal8queens = (row) =&gt;&#123; // 终止条件 if(row === 8)&#123; console.log(result) n++; return; &#125; // 每一列的判断 for(let column = 0; column &lt; 8; column++)&#123; // 判断当前的列位置是否合适 if(isOkCulomn(row,column))&#123; // 保存皇后的位置 result[row] = column; // 对下一行寻找数据 cal8queens(row + 1); &#125; // 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性 &#125;&#125;// 判断当前列是否合适const isOkCulomn = (row,column) =&gt;&#123; // 设置左上角 let leftcolumn = column - 1; let rightcolumn = column + 1; for(let i = row - 1;i &gt;= 0; i--)&#123; // 判断当前格子正上方是否有重复 if(result[i] === column) return false; // 判断当前格子左上角是否有重复 if(leftcolumn &gt;= 0)&#123; if(result[i] === leftcolumn) return false; &#125; // 判断当前格式右上角是否有重复 if(leftcolumn &lt; 8)&#123; if(result[i] === rightcolumn) return false; &#125; // 继续遍历 leftcolumn --; rightcolumn ++; &#125; return true;&#125;// 递归打印所有情况const print = (result)=&gt;&#123; for(let i = 0;i &lt; 8; i++)&#123; for(let j = 0;j &lt; 8; j++)&#123; if(result[i] === j)&#123; console.log('Q' + ' ') &#125;else&#123; console.log('*' + ' ') &#125; &#125; &#125;&#125;// 测试cal8queens(0);console.log(n) ▉ 总结 上述八皇后的问题就是用递归来枚举所有情况，然后再从中设置条件，只筛选满足条件的选项。上述代码建议多看几遍，亲自动手实践一下。一开始解决八皇后问题，我自己看了好长时间才明白的，以及递归如何发挥技巧作用的。 ▉ 举一反三： 如果你想练练手，可以自己实现以下图的深度优先遍历，这个理解起来并不难，可以自己动手尝试着写一写，我把代码传到我的 Github 上了。 分类三：递归选择型 所谓的递归选择型，每个子问题都要面临选择，求最优解的情况。有的小伙伴会说，求最优解动态规划最适合，对的，没错，但是递归通过选择型枚举所有情况，设置条件，求得问题的最优解也是可以实现的，所有我呢将其这一类问题归为递归选择型问题。 0 -1 背包问题 0 - 1 背包问题，了解过的小伙伴也是很熟悉的了。其实这个问题也属于回溯算法的一种，废话不多说，直接上问题。有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？ ▉ 问题分析： 如果你对该问题看懵了，没关系，我们一点点的分析。假如每个物品我们有两种状态，总的装法就有 2^n种，怎么才能不重复的穷举这些可能呢？ ▉ 算法思路： 我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。 ▉ 代码实现： 1234567891011121314151617181920212223242526272829// 用来存储背包中承受的最大重量var max = Number.MIN_VALUE;// i: 对第 i 个物品做出选择// currentw: 当前背包的总重量// goods：数组，存储每个物品的质量// n: 物品的数量// weight: 背包应承受的重量const f = (i, currentw, goods, n, weight) =&gt; &#123; // 终止条件 if(currentw === weight || i === n)&#123; if(currentw &gt; max)&#123; max = currentw; &#125; return ; &#125; // 选择跳过当前物品不装入背包 f(i+1, currentw, goods, n, weight) // 将当前物品装入背包 // 判断当前物品装入背包之前是否超过背包的重量,如果已经超过当前背包重量，就不要就继续装了 if(currentw + goods[i] &lt;= weight)&#123; f(i+1 ,currentw + goods[i], goods, n, weight) &#125;&#125;let a = [2,2,4,6,3]f(0,0,a,5,10)console.log(max) 递归的缺点 虽然递归的使用非常的简洁，但是也有很多缺点，也是我们在使用中需要额外注意的地方和优化的地方。 1、递归警惕堆栈溢出 你可能会问，递归和系统中的堆栈有什么关联？不要急，听我慢慢细说。 ▉ 理解堆栈溢出 1）递归的本质就是重复调用本身的过程，本身是什么？当然是一个函数，那好，函数中有参数以及一些局部的声明的变量，相信很多小伙伴只会用函数，而不知道函数中的变量是怎么存储的吧。没关系，等你听我分析完，你就会了。 2）函数中变量是存储到系统中的栈中的，栈数据结构的特点就是先进后出，后进先出。一个函数中的变量的使用情况就是随函数的声明周期变化的。当我们执行一个函数时，该函数的变量就会一直不断的压入栈中，当函数执行完毕销毁的时候，栈内的元素依次出栈。还是不懂，没关系，看下方示意图。 3）我们理解了上述过程之后，回到递归上来，我们的递归调用是在函数里调用自身，且当前函数并没有销毁，因为当前函数在执行自身层层递归进去了，所以递归的过程，函数中的变量一直不断的压栈，由于我们系统栈或虚拟机栈空间是非常小的，当栈压满之后，再压时，就会导致堆栈溢出。 123456// 函数function f(n)&#123; var a = 1; var b = 2; return a + b;&#125; 【图】 ▉ 解决办法 那么遇到这种情况，我们怎么解决呢？ 通常我们设置递归深度，简单的理解就是，如果递归超过我们设置的深度，我们就退出，不再递归下去。 2、递归警惕重复元素 有些递归问题中，存在重复计算问题，比如求斐波那契数列，我们画一下递归树如下图，我们会发现有很多重复递归计算的值，重复计算会导致程序的时间复杂度很高，而且是指数级别的，导致我们的程序效率低下。 【递归树图】 ▉ 解决办法 重复计算问题，我们应该怎么解决？有的小伙伴想到了，我们把已经计算过的值保存起来，每次递归计算之前先检查一下保存的数据有没有该数据，如果有，我们拿出来直接用。如果没有，我们计算出来保存起来。一般我们用散列表来保存。（所谓的散列表就是键值对的形式，如 map ） 【代码实现】 3、递归高空间复杂度 因为递归时函数的变量的存储需要额外的栈空间，当递归深度很深时，需要额外的内存占空间就会很多，所以递归有非常高的空间复杂度。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack成神之路之插件配置【处理CSS3属性前缀_11】]]></title>
    <url>%2F2019%2F05%2F09%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90%E5%A4%84%E7%90%86CSS3%E5%B1%9E%E6%80%A7%E5%89%8D%E7%BC%80_11%E3%80%91%2F</url>
    <content type="text"><![CDATA[处理 CSS3 属性前缀！ CSS进阶：自动处理CSS3属性前缀 CSS3 是前段必会的技能，但是通常需要添加像 -webkit,-ms,-o,-moz 这些前缀，为了能够在不同浏览器上都可已顺利的运行。为了能够自动添加这些繁琐的前缀，我们借助插件来实现。 1]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吃透 javascript 之【完整篇】]]></title>
    <url>%2F2019%2F05%2F08%2F%E5%90%83%E9%80%8F%20JavaScript%20%E4%B9%8B%E3%80%90%E5%AE%8C%E6%95%B4%E7%AF%87%E3%80%91%20%2F</url>
    <content type="text"><![CDATA[Javascript 的重点学习路线完整篇。 [TOC] 一、JavaScript 简介1、诞生 最早期网景公司开启 web 时代的第一代互联网，早起网景公司只是做静态页面，为了能够在静态页面添加一些动态的效果，所以叫Brendan Eich 这两个人两星期之内设计出 javascript ，不出所料，这两人只用了短短的10天时间。为了使其能够借助 java 的盛行，所以起名 javascript。 2、ECMAScript 网景开发了 javascript 之后，微软也模仿开发了 Jscript，为了能够让 javascript 称为全球的开发标准，所以几个公司联合发布了 ECMA 标准。ECMAScript 是一种语言标准，而网景公司开发的 javascript 是这一标准的实现。 3、版本 因为 javascript 的标准在短时间实现的，其中存在很多的缺陷，所以 javascript 的标准 ECMAScript 不断发展，到目前的 ES6 版本 2015 年发布。这里的 javascript 版本一般说的就是实现了 ECMAScript 哪个版本。 二、数据类型和变量1、== 和 ===的区别？ == 是 javascript 的设计缺陷，一般使用 === 来比较。 == : 两种之间比较需要先进行转换，然后进行比较，有时候出现很奇怪的情况。 === : 先比较类型，如果类型相等，然后在比较值。 2、NAN 是 Number 特殊的值 NAN 与任何值都不相等，包括它本身自己。 1NaN === NaN; // false 唯一能判断 NaN 的方法是通过 isNaN() 函数 3、浮点型之间的比较 问题：浮点型在运算会产生误差，导致计算机无法准确表示无限循环小数，所以导致比较不相等。 解决：要比较浮点型之间的大小，要比较两个浮点型之差的绝对值是否小于某一个阈值。 4、null 和 undefined NULL 表示“空”。undefined 表示未定义。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 5、严格模式是什么？ 缘由：初期，为了方便，不强制要求 var 声明变量，所以会导致未被 var 声明的变量自动声明为全局变量，如果同一页面不同 js 文件都用到了 js 文件的相同变量，导致变量之间相互影响，也就是我们所说的污染全局环境变量。 strict模式：不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。 三、字符串1、多行字符串 多行字符串用 反引号来表示，ES6 新增加语法。 2、字符串拼接 关于字符串拼接用 ${name} 引用，ES6 新增加语法。 四、数组1、indexof 搜索一个指定的元素的位置 。 2、slice 字符串截取。单参数为从参数起到结束，双参数为中间元素（不包括尾元素），返回新数组。 3、push 和 pop 末尾添加元素和末尾删除元素。 4、unshift 和 shift 头部添加元素和头部删除元素。 5、sort 对当前数组进行排序。 6、reverse 将数组元素反转。 7、splice 可以删除元素也可以删除同时添加元素。 12// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); 8、concat 合并两个数组，返回新数组。 9、join 指定字符连接数组中的元素。 五、Map 和 Set1、Map 一组键值对，键必须为字符串类型。 1234var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);m.get(&apos;Michael&apos;);m.set(&apos;Bob&apos;,59)m.delete(&apos;Adam&apos;); 2、Set 一组 key 的集合，不存储 value。 123var s = new Set([1, 2, 3]);s.add(4);s.delete(3); 六、iterable▉ 普通 for 循环 当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率 。 ▉ foreach 循环 功能：可以获取到 key 和 value 数组的本身。 缺点： 不能用 break，continue 语句跳出循环。 函数内不能使用 return 语句。 注意：在不同浏览器下测试的结果都是 forEach 的速度不如 for 。 12345//item 为数组元素//index 为索引下标arr.forEach(function (item,index,arr) &#123; console.log(item,index,arr)&#125;,null) ▉ for…in 循环 for-in 循环遍历的是对象的属性。而不是数组的索引 ，除了遍历数组也可以遍历对象。 缺点： for-in 遍历的顺序并不是确定的。 它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性 （Array 中的 length 不能遍历到），for-in 不适合遍历 Array 。【链接】：https://juejin.im/entry/5a1654e951882554b8373622 ▉ for…of 循环 ES6 新增语法。 优点： 以正确响应 break, continue, return。 for-of 循环不仅支持数组，还支持大多数类数组对象。 for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。 for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历 七、函数 在函数中如果没有 return 语句，函数执行完返回 undefined。 1、arguments 此关键字只在函数内部起作用，并且永远指向当前函数调用者传入的所有参数。 1、即使函数不定义参数，也是可以通过 arguments 对象拿到传入的参数的。 2、通常用来判断传入参数的个数。 1234567function foo(x) &#123; console.log('x = ' + x); // 10 for (var i=0; i&lt;arguments.length; i++) &#123; console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30 &#125;&#125;foo(10, 20, 30); 2、reset 参数（ES6） 由于 arguments 获取额外的传参非常的别扭，所以 ES6 新增了 rest 参数用来处理额外的参数。 12345678function foo(a,b,...rest)&#123; console.log(rest)&#125;//传入多余两个参数foo(1,2,3,4,5); // Array[3,4,5]//传入少于定义参数的个数foo(1,2)//Array[] 空数组 3、注意 return 语句 javascript 引擎会有一个行末添加分号的机制。 123456789101112//正确写法function foo() &#123; return &#123; // 这里不会自动加分号，因为&#123;表示语句尚未结束 name: 'foo' &#125;;&#125;//错误写法function foo() &#123; return //这一行会可能被引擎自动加分号 &#123; name: 'foo'&#125;; &#125; 4、变量作用域和解构赋值▉ 全局作用域 javascript 只有一个全局作用域，如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。 ▉ 命名空间 全局变量会绑定到 windows 上，不同的 javascript 文件使用相同的全局变量会产生命名冲突，我们很难发现，所以一般减少冲突的方法就是所有变量和函数全部绑定到一个全局变量中。 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 许多 js 库都是这么干的，jQuery，YUI等。 ▉ 局部作用域 所谓的 js 作用域是在函数内部的，for 循环等语句块中是无法定义具有局部作用域变量的。ES6 引用了 let 代替 var 声明块级作用域变量。 ▉ 对多个变量同时赋值 使用 ES6 新增加的解构赋值。 1var [x, y, z] = ['hello', 'JavaScript', 'ES6']; 适用场景： 1、交换两个变量 12var x = 1,y = 2;[x,y] = [y,x] 2、快速获取当前页面的域名和路径 1var &#123;hostname:domain, pathname:path&#125; = location; 3、函数接受对象的属性为参数 用解构直接将对象的属性绑定到变量中。 1234function buildDate(&#123;year, month, day, hour=0, minute=0, second=0&#125;) &#123; return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);&#125;buildDate(&#123; year: 2017, month: 1, day: 1 &#125;); 5、方法▉ this 指针 如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming。如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25, 正常结果getAge(); // NaN 12var fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN 以上是 js 的设计错误，ECMA决定，在 strict 模式下让函数的this指向undefined 。 123456789101112131415'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined 报错了，this 指针只在 age 方法的函数内指向 xiaoming 在函数内部定义的函数 ，this 指针指向 undefined ，他重新指向全局变量。 改进方法，用 that 进行捕获。 12345678910111213141516'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 ▉ apply() 方法 作用： 指针函数的 this 指向哪个对象。 使用： 参数一：需要绑定的 this 变量。 参数二：传入的是 Array，表示函数本身的参数。 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 ▉ call() 方法 把参数按照顺序传入。 ▉ 装饰器 利用apply()，我们还可以动态改变函数的行为。 123456789'use strict';var count = 0;var oldParseInt = parseInt; // 保存原函数window.parseInt = function () &#123; count += 1; return oldParseInt.apply(null, arguments); // 调用原函数&#125;; 6、高阶函数 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数 。 ▉ map 对元素自身进行计算 map() 方法定义在 JavaScript 的 Array 中 ,对数组中的每个数据做处理。 map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数 。 12345678'use strict';function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results); ▉ reduce 所有元素进行累加计算 Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25 ▉ filter 过滤元素 用于把 Array的某些元素过滤掉，然后返回剩下的元素。 和 map() 不同的是，filter() 把传入的函数依次作用于每个元素，然后根据返回值是 true 还是 false 决定保留还是丢弃该元素。 123456//在一个Array中，删掉偶数，只保留奇数var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] ● 回调函数 filter 有多个参数。 1、一个参数：仅使用一个表示 Array 的某个元素。 2、三个参数：回调函数可以接受另外两个参数，表示元素的位置和数组本身。 123456//去除重复元素依靠的是 indexOf 总是返回第一个元素的位置，后续的重复元素位置与 indexOf 返回的位置不相等，因此被 filter 滤掉了。var r,arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;); ▉ sort 排序 1、比较字符或者字符串，根据 ASCLL 码进行排序的。 2、比较数字，先将数组中的数字转换成字符串，然后再进行排序。 sort 是一个高阶函数，可以传入函数来进行自定义的比较： 数字比较 传入一个比较函数，-返回值为 1，-1，0； 注意：sort 直接对 Array 进行修改，结果返回 Array。 12345678910111213141516'use strict'var arr = [10, 20, 1,2];//经断点调试，更像是一种插入排序arr.sort(function (x, y) &#123; //变 if (x &lt; y) &#123; return -1; &#125; //不变 if (x &gt; y) &#123; return 1; &#125; return 0;&#125;);console.log(arr); // [1, 2, 10, 20] 6、闭包 将闭包和 Java 类中的 get 获取内部私有变量做对比。 ▉ 什么是闭包？ 只有函数内部的子函数才能读取局部变量，定义在一个函数内部的函数 。 ▉ 作用 1）在函数的外部也可以获取到函数内部的局部变量。 2）让这些局部变量值始终保存在内存中，保证不会被 js “垃圾回收机制”回收。 ▉ 使用闭包注意事项 1）闭包会被保存到内存中，内存消耗很大，会造成网页性能问题，在 IE 会导致内存泄漏。在退出函数之前，将不适用的局部变量全部删除。 7、垃圾回收机制▉ 生命周期 1）分配内存： javascript 自动完成内存的分配 2）使用内存（读或写）：使用值的过程实际上是对分配内存进行读取与写入的操作 3）释放内存：在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。所以高级语言潜入垃圾回收机制。 ▉ 垃圾回收机制 主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。 1）引用 垃圾回收算法主要依赖于引用的概念 ，一个对象访问另一个对象就叫做引用。 2）引用计数垃圾收集 初级的垃圾回收算法，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 3）限制：循环引用 当该函数调用完成离开作用域之后，可以被回收了，但是两个对象相互引用，所以不会被回收。（IE 6, 7对 DOM 结点进行计数垃圾回收） 123456function f()&#123; var o = &#123;&#125;; var o2 = &#123;&#125;; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o&#125; 4）标记—清除算法 针对于“对象是否不再需要”。 1）算法假设有一个根对象（全局对象），垃圾回收器从根开始找所有从根开始引用的对象。 2）垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。 （零引用总不可获得的） 5）限制：那些无法从根对象查询到的对象都将被清除 8、箭头函数▉ 箭头中的 this 由于之前的函数中 this 绑定的错误处理，this 在箭头函数中被修复了。this 总是与词法作用域绑定（函数的作用域在函数定义的时候就决定了 ），由上下文确定 ，外层调用者 obj. 12345678910var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window 或 undefined &#125;; return fn(); &#125;&#125;; ▉ 注意 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略。 9、generator 生成器▉ 定义 整个 Generator 函数封装了异步任务。 标注 yield 地方都是异步需要暂停的地方（yield 将任务分为几个阶段）。 1234function* gen(x)&#123; var y = yield x + 2; return y;&#125; ▉ 过程 1）调用 Generator 会返回一个指针对象（遍历器对象 ），调用指针对象的的 next 方法，会移动指针的位置（异步任务的第一阶段），也就是指向遇到第一个 yield 的位置。 2）next 方法会返回一个当前阶段的对象，表示当前阶段的信息（value:当前阶段的值，yield：布尔值 ）表示 generator 是否执行完毕。 1234var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; ▉ 数据交换 除了能够暂停、恢复之外，还可以作为函数体内外的数据交换。 1、不带有参数的 next 方法可以输出返回值。 2、带有参数的方法可以将参数作为上一阶段异步任务的返回结果，也就是输入。 12345678function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next(2) // &#123; value: 2, done: true &#125; ▉ 错误处理 Generator 内部可以部署错误处理代码，捕获函数体外抛出的错误。 1、在函数外用指针的throw抛出的错误，被函数体内的 try … catch 代码块进行捕获。 2、实现了出错代码和处理错误的代码时间和空间上的分离。 12345678910111213function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw（'出错了'）;// 出错了 ▉ 作用 异步回调代码变成“同步”代码。 八、标准对象 总结一下，有这么几条规则需要遵守： 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === &#39;undefined&#39;； 函数内部判断某个变量是否存在用typeof myVar === &#39;undefined&#39;。 任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。 1、Date JavaScript的 Date 对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 1234567891011var now = new Date();now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)now.getFullYear(); // 2015, 年份now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月now.getDate(); // 24, 表示24号now.getDay(); // 3, 表示星期三now.getHours(); // 19, 24小时制now.getMinutes(); // 49, 分钟now.getSeconds(); // 22, 秒now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1435146562875, 以number形式表示的时间戳 九、面向对象编程1、继承设计思想▉ js 的诞生 为了让静态页面进行交互，设计一种语言完成不需要借助服务器完成的操作，如：表单验证。 ▉ 模仿其他 oop 进行设计 js 不像其他语言是面向对象语言有类的概念，为了能够即不引入类又能实现继承，所以 js 设计者模仿 oop 语言进行设计。 1、其他语言通过 new 来生成实例，所以 js 也通过 new 生成实例。 2、其他语言有类可以通过 new 来实现，js 并没有类，所以借助 new 构造函数来生成实例。 3、不同对象有不同的属性，也有相同的属性，对于每个对象相同的属性都需要在内存中开辟多个空间存储。能否使相同的属性只存一个呢？然后拥有该属性的对象都去引用它。 ▉ prototype 属性 我们就给构造函数设计一个 prototype 属性，用来存储不同对象相同的属性，共享的属性都存到这里边，不共享的属性就存放到构造函数中。其实 prototype 属性存储的就是一个对象，构造函数里边存放的都是变量，具体看变量和对象在内存中的引用。 ▉ 继承 所有构造函数生成的对象都具有 prototype 对象里边的共享属性，就像是所有实例对象继承了 prototype 对象一样。 2、封装 其他语言因为有类的概念，对对象的封装是非常方便的，那么 js 是怎么封装对象的呢？ 12345//猫对象var Cat = &#123; name : '', color : ''&#125; ▉ 原始模式 下面简单的进行两个不同对象的封装，就会有两个问题： 问题： 1）生成多个实例对象写起来非常麻烦。 2）实例对象和原型对象之间没什么联系。 1234567var cat1 = &#123;&#125;; // 创建一个空对象cat1.name = "大毛"; // 按照原型对象的属性赋值cat1.color = "黄色";var cat2 = &#123;&#125;;cat2.name = "二毛";cat2.color = "黑色"; ▉ 原始模式改进 用函数来解决代码重复的问题。 问题： 1）但是不能反映他们来自于同一个原型对象。 123456789function Cat(name,color) &#123; return &#123; name:name, color:color &#125;&#125;//生成实例对象var cat1 = Cat("大毛","黄色");var cat2 = Cat("二毛","黑色"); ▉ 构造函数模式 为了解决原型对象生成实例的问题，引入构造函数模式。 1）构造函数就是一个普通函数。 2）内部使用 this 变量，对构造函数使用 new 就能生成实例对象，内部的 this 指针就会指向实例对象。 3）每个实例对象都有 constructor 属性，并指向他们的构造函数。 12345678910//1）function Cat(name,color)&#123; this.name=name; this.color=color;&#125;//2）var cat1 = new Cat("大毛","黄色");var cat2 = new Cat("二毛","黑色");//3)alert(cat1.constructor == Cat); //true 问题： 1）对于每个实例共享的属性，存在浪费内存的问题。 ▉ 原型模式（prototype 模式） 每个构造函数都有一个 prototype 属性指向原型对象，我们将共享的属性存放到原型对象上，所有实例的共享属性其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。 验证方法： 1）isPrototypeOf() ：验证实例与原型对象之间的关系。 12&gt; alert(Cat.prototype.isPrototypeOf(cat1)); //true&gt; 2）hasOwnProperty()：判断某个属性来自本地还是原型对象。 12&gt; alert(cat1.hasOwnProperty(&quot;name&quot;)); // true&gt; 3）in运算符：判断某个实例是否拥有某个属性。以及遍历某个实例的所有属性。 123&gt; alert(&quot;name&quot; in cat1); // true&gt; for(var prop in cat1) &#123; alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); &gt; 2、原型继承3、构造函数继承（五种） 两个构造函数。怎么让猫继承动物？ 123456789//动物构造函数function Animal()&#123; this.species = "动物";&#125;//猫的构造函数function Cat(name,color)&#123; this.name = name; this.color = color;&#125; ▉ 第一种：构造函数的绑定 用 call 或 apply 方法将父对象的构造函数绑定到子对象的构造函数。 123456function Cat(name,color)&#123; //改变 this 的绑定 Animal.apply(this, arguments); this.name = name; this.color = color;&#125; ▉ 第二种：原型模式 让猫构造函数的 prototype 等于 Animal 的实例，Animal 的实例拥有 Animal 的所有属性，所以相当于猫构造函数的 prototype 指向 Animal 实例了， 所有的猫的实例共享 Animal 里的属性了。 1) 每个实例都有 construct 属性，每个 prototype 也都有 construct 属性。 2）实例中的 construct 指向与 prototype 对象中 construct 指向同一个构造函数。也就是说改变 Cat 的原型对象之后，Cat 的实例对象 construct 属性指向的是 Animal 实例对象的 construct 属性，也就是 Animal 原型对象的 construct 属性，也就是构造函数 Animal 。 3）猫的实例对象是由 Cat 生成的，怎么能指向 Animal 呢，所以手动修改过来。 4）如果更换了 prototype对象 ，一定将 construct 属性修改过来。 12Cat.prototype = new Animal();Cat.prototype.constructor = Cat; ▉ 第三种：直接继承原型 第二种方式的改进，跳过 Animal 的实例，直接将 Animal 的原型对象赋值给 Cat.prototype; 优点：效率更高（不用执行和建立Animal的实例了 ） 缺点：Cat.prototype 和 Animal.prototype 现在指向了同一个对象，那么任何对 Cat.prototype 的修改，都会反映到 Animal.prototype。 12Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat; ▉ 第四种：空对象作为中介 对于第三种的缺点，第四种作为改进。F是空对象，所以几乎不占内存。 优点：修改Cat的prototype对象，就不会影响到Animal的prototype对象。 1234var F = function()&#123;&#125;;F.prototype = Animal.prototype;Cat.prototype = new F();Cat.prototype.constructor = Cat; 将其封装成方法: 这个 extend 函数，就是 YUI 库如何实现继承的方法。 1234567 function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; ▉ 第五种：拷贝继承 如果把父对象的 prototype 所有属性和方法，拷贝进子对象的 prototype 中 。 123456789// 浅拷贝继承function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; &#125; 4、非构造函数继承 让医生继承中国。 12345678//父对象var Chinese = &#123; nation:&apos;中国&apos;&#125;;//子对象var Doctor =&#123; career:&apos;医生&apos;&#125; ▉ 第一种：object()方法 让中国成为医生的原型对象。 12 ▉ 第二种：浅拷贝 把父对象的属性，全部拷贝给子对象，也能实现继承。 拷贝继承分为浅拷贝和深拷贝。 问题： 1）如果父对象的属性等于数组或另一个对象，子对象获得的只是一个内存地址 ，子对象改变，父对象的属性也将改变。 12345678function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; return c;&#125; ▉ 第二种：深拷贝 弥补浅拷贝出现的问题，真正的将对象和数组及逆行拷贝，只要递归调用”浅拷贝”就行了 。 12345678910111213 function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;//递归 deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c; &#125; jQuery库使用的就是这种继承方法。 5、class 继承 class 的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用 class 的好处就是极大地简化了原型链代码。 十、浏览器1、浏览器对象▉ window window对象不但充当全局作用域，而且表示浏览器窗口。 1console.log('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight); ▉ navigator navigator对象表示浏览器的信息，最常用的属性包括： navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 ▉ screen screen对象表示屏幕的信息，常用的属性有： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 ▉ location location对象表示当前页面的URL信息。 加载新页面：location.assign() 。 重新加载：location.reload() 。 12345678http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP//可以用location.href获取location.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP' ▉ document document 对象表示当前页面。由于 HTML 在浏览器中以 DOM 形式表示为树形结构，document 对象就是整个 DOM 树的根节点。 Cookie 1) Cookie 是由服务器发送的 key-value 标示符。因为 HTTP 协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用 Cookie 来区分 。 2) 当一个用户成功登录后，服务器发送一个 Cookie 给浏览器，例如 user=ABC123XYZ(加密的字符串)...，此后，浏览器访问该网站时，会在请求头附上这个 Cookie，服务器根据 Cookie 即可区分出用户。** 安全性： 如果引入的第三方库存在恶意代码，则被第三方直接获取到用户登录信息。为了解决这个问题，服务器在设置 Cookie 的时候使用 httpOnly，设置的 Cookie 不能被 Javascript 读取。 1document.cookie; // 'v=123; remember=true; prefer=zh' ▉ history history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 2、操作 DOM▉ 更新 DOM1）innerHtml属性 修改文本。用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。 1234567// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;var p = document.getElementById('p-id');// 设置文本为abc:p.innerHTML = 'ABC'; // &lt;p id="p-id"&gt;ABC&lt;/p&gt;// 设置HTML:p.innerHTML = 'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ';// &lt;p&gt;...&lt;/p&gt;的内部结构已修改 2) 修改 innerText 或 textContent 属性 可以自动对字符串进行HTML编码，保证无法设置任何HTML标签： 12p.innerText = '&lt;script&gt;alert("Hi")&lt;/script&gt;';// HTML被自动编码，无法设置一个&lt;script&gt;节点: 3) 两者区别 读取属性，innerText不返回隐藏元素的文本，而textContent返回所有文本。另外注意 IE &lt; 9 支持textContent。 4）设置 CSS 样式 DOM节点的style属性对应所有的 CSS 。CSS允许font-size这样的名称使用驼峰命名法（fontSize）。 1p.style.fontSize = &apos;20px&apos;; ▉ 插入 DOM1）使用 appendChild 把一个子节点添加到父节点的最后一个子节点。 123456var list = document.getElementById('list'), haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.appendChild(haskell); 2) insertBefore 插入指定位置 12// 将子节点插入到 referenceElement 之前parentElement.insertBefore(newElement, referenceElement); ▉ 删除 DOM parentElement () 得到删除节点的父节点，然后 removeChild() 删除节点。 1234567// 拿到待删除节点:var self = document.getElementById('to-be-removed');// 拿到父节点:var parent = self.parentElement;// 删除:var removed = parent.removeChild(self);removed === self; // true 注意： 1、删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 2、parent.children[0] 删除节点的时候注意下标。 3、操作表单HTML表单的输入控件主要有以下几种： 文本框，对应的&lt;input type=&quot;text&quot;&gt;，用于输入文本； 口令框，对应的&lt;input type=&quot;password&quot;&gt;，用于输入口令； 单选框，对应的&lt;input type=&quot;radio&quot;&gt;，用于选择一项； 复选框，对应的&lt;input type=&quot;checkbox&quot;&gt;，用于选择多项； 下拉框，对应的&lt;select&gt;，用于选择一项； 隐藏文本，对应的&lt;input type=&quot;hidden&quot;&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 ▉ 获取值1234567// &lt;input type="text" id="email"&gt;var input = document.getElementById('email');input.value; // '用户输入的值'// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;mon.value; // '1'mon.checked; // true或者false ▉ 提交表单方法一： 响应一个 button 方法。 1234567891011121314&lt;!-- HTML --&gt;&lt;form id="test-form"&gt; &lt;input type="text" name="test"&gt; &lt;button type="button" onclick="doSubmitForm()"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function doSubmitForm() &#123; var form = document.getElementById('test-form'); // 可以在此修改form的input... // 提交form: form.submit();&#125;&lt;/script&gt; 方法二： onsubmit 事件。 12345678910111213141516&lt;form id="login-form" method="post" onsubmit="return checkForm()"&gt; &lt;input type="text" id="username" name="username"&gt; &lt;input type="password" id="input-password"&gt; &lt;input type="hidden" id="md5-password" name="password"&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() &#123; var input_pwd = document.getElementById('input-password'); var md5_pwd = document.getElementById('md5-password'); // 把用户输入的明文变为MD5: md5_pwd.value = toMD5(input_pwd.value); // 继续下一步: return true;&#125; 4、操作文件 在表单提交文件时，from 表单的 enctype 属性应该使用 multipart/form-data 不对文件数据进行编码才能上传，其他数据默认 application/x-www-form-urlencoded 编码再提交。 1234567//input 的 IDvar f = document.getElementById(&apos;test-file-upload&apos;);var filename = f.value; // &apos;C:\fakepath\test.png&apos;if (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) &#123; alert(&apos;Can only upload image file.&apos;); return false;&#125; ▉ File API 操作文件 HTML5的File API提供了 File 和 FileReader 两个主要对象，可以获得文件信息并读取文件。 12345678910111213141516171819202122232425262728293031323334var fileInput = document.getElementById('test-image-file'), info = document.getElementById('test-file-info'), preview = document.getElementById('test-image-preview'); // 监听change事件: fileInput.addEventListener('change', function () &#123; // 清除背景图片: preview.style.backgroundImage = ''; // 检查文件是否选择: if (!fileInput.value) &#123; info.innerHTML = '没有选择文件'; return; &#125; // 获取File引用: var file = fileInput.files[0]; // 获取File信息: info.innerHTML = '文件: ' + file.name + '&lt;br&gt;' + '大小: ' + file.size + '&lt;br&gt;' + '修改: ' + file.lastModifiedDate; if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') &#123; alert('不是有效的图片文件!'); return; &#125; // 读取文件: var reader = new FileReader(); //异步操作的回调函数 reader.onload = function(e) &#123; var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')'; &#125;; // 以DataURL的形式读取文件:(异步操作) reader.readAsDataURL(file); &#125;); 5、AJAX 需要注意的几点： 1、通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest 2、先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成 3、XMLHttpRequest对象的open()方法有3个参数，分别为请求方式、URL地址、是否使用异步。 4、send 发送，Get 不需要参数，Post 需要把 body 部分以字符串或者 FormData 对象传进去。 关于 FromData 请查看：FormData 123456789101112131415161718192021222324252627282930313233343536373839function success(text) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = text;&#125;function fail(code) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code;&#125;var request;if (window.XMLHttpRequest) &#123; //现代浏览器 request = new XMLHttpRequest();&#125; else &#123; //低版本 IE 浏览器 request = new ActiveXObject('Microsoft.XMLHTTP');&#125;request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果 if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 6、Cookie▉ 定义 1）概念：Cookie 小段文本信息，存储于计算机硬盘中，大小只有 4 k。 2）特点：每个 Cookie 文件都对应一个域名，同一域名下的所以页面可以共享 Cookie，不能跨域名访问。 3）使用：通常从 document 中提取 cookie 属性提供给 javascript，然后进行创建或发送 cookie 到服务器。 ▉ 作用 cookie 是存在用户硬盘中，用户每次访问站点时，Web应用程序都可以读取 Cookie 包含的信息。当用户再次访问这个站点时，浏览器就会在本地硬盘上查找与该 URL 相关联的 Cookie。如果该 Cookie 存在，浏览器就将它添加到 request header 的 Cookie 字段中，与 http请求 一起发送到该站点。 ▉ 缺点 安全性：由于cookie在HTTP中是明文传递的，其中包含的数据都可以被他人访问，可能会被篡改、盗用。 大小限制：cookie的大小限制在4KB左右，若要做大量存储显然不是理想的选择。 增加流量：cookie每次请求都会被自动添加到Request Header中，无形中增加了流量。cookie信息越大，对服务器请求的时间也越长。 ▉ 用途 Cookie 一般用于保存网页访问者的信息。 1）保存用户登录信息。在一些登录网站选择下次自动登录，登录成功后，后台对用户名和密码进行加密返回数据，客户端就会将数据存储到 Cookie 中。当用户下一次进行登录时，判断 Cookie 中否存在值，存在则将Cookie 信息加到 HTTP 头部发送到服务器，实现自动登录。 2）创建购物车。通常将选择的物品放入 Cookie 中，同一域名下页面实现 Cookie 共享，提交订单将 Cookie 传到后台。 3）跟踪用户。用 Cookie 记录用户的偏好信息，然后推广小广告，在侧边栏经常是我们之前搜索过的内容。 ▉ 其他存储机制 1）web存储机制 sessionStorage：用于一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除 localStorage ：用于跨会话持久化地存储数据。 2）indexedDB 是 indexed Database API 的简称，是在浏览器中保存结构化数据的一种「数据库」，它类似SQL数据库的结构化数据存储机制 ， 它能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。 7、 同源跨域问题请查看另一篇：]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack成神之路之插件配置【CSS 图片处理_08】]]></title>
    <url>%2F2019%2F05%2F08%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90CSS%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86_08%E3%80%91%2F</url>
    <content type="text"><![CDATA[webpack 处理 CSS 中的图片！ 01|CSS 中的图片处理1、图片准备 通常我们保存的图片早 src 中的 images 文件夹下。 2、安装解析图片的 loader 1）当我们直接用 webpack 命令时，就会报错，报错的原因就是无法解析 CSS 中的图片。之前解析 CSS 文件使用的 loader ，所以我们要添加专门解析图片用的 loader。 2）webpack 打包将各个模块打包成一个文件，所以我们的样式文件 url 是相对于 CSS 文件的，当我们打包成一个文件，url 的路径是相对于 html 而言的，导致原来的 css 文件引入的路径就会导致找不到原来的图片位置。 3）图片过多，导致有很多的 http 请求，降低页面的性能。 1npm install --save-dev file-loader url-loader file-loader：这个模块主要解决上述 （2）的问题。file-loader 可以解析项目中的 ur l引入（不仅限于 css ），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。 url-loader：这个模块主要解决上述 （3）的问题。url-loader 会将引入的图片编码，生成 dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此 url-loader 提供了一个 limit 参数，小于 limit 字节的文件会被转为 DataURl，大于 limit 的还会使用 file-loader 进行 copy.。 3、配置 loader test:/.(png|jpg|gif)/：是匹配图片文件后缀名称。 use：是指定使用的 loader 和 loader 的配置参数。 imit：是把小于 500000B 的文件打成 Base64 的格式，写入JS。 12345678910111213141516module:&#123; rules:[ &#123; test: /\.(png|jpg|gif)/, use: [&#123; loader: 'url-loader', options:&#123; options:&#123; limit: 500000, outputPath:'images/', // 将图片放到规定的目录下 &#125; &#125; &#125;] &#125; ]&#125;, 4、url-loader 和 file-loader 的关系 url-loader封装了 file-loader，配置中的 limit ，url-loader 会调用 file-loader进行处理。 02|CSS分离与图片路径处理 1）把 CSS 从J avasScript 代码中分离出来 。 2）如何处理分离出来后 CSS 中的图片路径不对问题 。 1、CSS 分离 2、安装插件（extract-text-webpack-plugin） 注意版本号，我 webpack3.0 使用的是 2.0.1 版本的插件。 1npm install --save-dev extract-text-webpack-plugin@2.0.1 3、配置文件 1）引入插件。 2）new 出插件对象。 3）修改 style-loader 和 css-loader。 1234// 引入插件const extractTextPlugin = require('extract-text-webpack-plugin'); // 此路径是分离的 CSS 文件路径new extractTextPlugin("/css/index.css") 1234567&#123; test:/\.css$/, use:extractTextPlugin.extract(&#123; fallback: "style-loader", use: "css-loader" &#125;)&#125;, 4、路径失效问题03|处理 HTML 中的图片 通常我们会在 HTML 中引入图片，需要对 HTML 中的图片进行打包。 1、安装 Loader1npm install html-withimg-loader --save 2、配置 Loader1234&#123; test: /\.(htm|html)$/i, use:[ 'html-withimg-loader'] &#125;]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之【CSS 常用布局】]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90CSS%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E3%80%91%2F</url>
    <content type="text"><![CDATA[CSS 中常用的几种布局方式！ 三种最基本的布局方式1、流式布局 流动布局模型就是默认的网页布局模式。 块级元素都会在所处的最近父级容器元素内自上而下按顺序垂直顺延分布，块元素的宽度一般为 100%，也就是父元素的宽度。 内联元素一般从左到右依次分布显示。 2、浮动布局 流式布局的元素基本都是在整个文档流中的，如果使用浮动布局，需要给某一元素设置浮动属性，脱离当前文档流。 3、层级布局 层级布局指的是通过相对定位以及绝对定位以及固定定位的方式来进行布局。 1）通过设置 top、left、right、bottom 来记性定位元素。 2）缺点：对于相应式的布局，该布局方式还有很多不便之处。 fixed 定位：固定定位，相对于浏览器窗口进行定位，不随窗口滚动，可以和其他元素重叠，不占据空间。 relative 定位：相对定位，相对于正常位置进行定位，原本的空间不会改变。 absolute 定位：绝对定位，是相对于已经定位的父元素进行定位，如果没有父元素，就相当于 &lt;html&gt; ，不占据任何空间，定位元素可以和其他元素进行重叠。 弹性布局（Flex）栅格布局响应式布局两种自适应布局1、双飞翼布局2、圣杯布局]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之【盒模型】]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E7%9B%92%E6%A8%A1%E5%9E%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[盒模型相关知识点！ css 盒模型一、盒模型的分类 IE 盒模型和 W3C 标准盒模型。 盒模型 一个盒子模型是由 外边距（margin）、边框（border）、内边距（padding）、内容（content）四部分组成的。 IE 盒模型 盒子的属性 width 和 height 指的是 content + padding + border。 W3C 标准盒模型 盒子的属性 width 和 height 指的是 content。 兼容性 1）只有在 IE8 + 版本中可以通过 box-sizing（centent-box 标准盒模型/border-sizing IE 盒模型） 切换 IE 盒模型和 W3C 标准盒模型。其他浏览器需要加上前缀。 2）在 IE6、IE7、IE8 中添加 &lt;!DOCTYPE&gt; 就会使用 W3C 标准盒模型。否则出现不同浏览器兼容性问题（IE浏览器会将盒子模型解释为 IE 盒子模型，FireFox等会将其解释为 W3C 盒子模型）。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之道【网络攻击】]]></title>
    <url>%2F2019%2F05%2F02%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E3%80%91%2F</url>
    <content type="text"><![CDATA[常见的网络攻击！ 一、XSS 攻击1、XSS 是什么 XSS 攻击称为跨站脚本攻击，是一种代码注入的攻击。攻击者通过向目标网站注入恶意脚本，使之在浏览器中运行。利用脚本获取到用户的信息。 XSS 常见几种注入方法： 以 javascript 标签的形式注入。 在内联 javascript 中，拼接的数据突破了原本的限制（字符串、变量等） 在属性标签中，恶意内容包含引号，突破属性值的限制，注入其他属性。 在标签的 href、src 等属性中，包含 js 可执行代码。 在 onload、onerror、onclick 等事件中，注入不受控制的代码。 2、XSS 攻击的分类 存储型 XSS 反射型 XSS DOM型 XSS ▉ 存储型 XSS 最危险的一种跨站脚本攻击，危害比反射性和DOM型都要大，因为不需要用户手动触发。恶意代码存储在数据库中。 1）攻击者将恶意代码提交至目标网站的数据库中。 2）用户打开网站，网站将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 3）浏览器将服务器返回的 HTML 进行解析，恶意代码被执行。 4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。 ▉ 反射型 XSS 需要用户主动打开 URL 。恶意代码存储在 URL 中。常见的用于 URL 传递参数的功能，如：网站搜索、跳转等。 1）攻击者伪造包含恶意代码的URL。 2）用户打开恶意的URL，服务端将恶意的 URL 代码取出拼接在HTML 后返回给浏览器。 3）用户浏览器解析请求，恶意代码得到执行。 4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。 ▉DOM 型 XSS DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 1）攻击者伪造包含恶意代码的 URL。 2）用户打开恶意的 URL。 3）前端 Javascript 取出 URL 中的恶意代码由浏览器完成，属于前端 javascript 自身的安全漏洞，触发XSS 靠的是浏览器端的DOM解析 。 4）恶意代码就会盗取用户信息向攻击者网站发送隐私数据。 3、防御 XSS▉ 常用的防御方法 一般页面输入的地方会存在 XSS 攻击的危险。 httpOnly: 在 cookie 中设置 HttpOnly 属性后，js 脚本无法读取到 Cookie 信息。 输入过滤：用于对输入格式的检查（邮箱、电话号码等）。前后台多要进行过滤检查，因为攻击者完全可以绕过前端直接利用接口对后端发送设置。 白名单：名单控制允许的 HTML标签及各标签的属性 。 转义 HTML：如果拼接 HTML 是必要的，对于引号，尖括号，斜杠进行转义（可以借助转义库）。 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/"/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\//g, '&amp;#x2F;') return str&#125; ▉ 预防存储型和反射性 XSS 攻击 这两种攻击一般在服务器端取出恶意代码，拼接到 HTML 中，然后被浏览器所执行。 1、改成纯前端渲染，使代码和数据分离。 作用：明确告诉浏览器，要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了 。 缺点：需要避免 DOM 型的 XSS 攻击。 1）浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 2）然后浏览器执行 HTML 中的 JavaScript。 3）JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上 2、对 HTML 做充分的转义。 在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题,这时就需要对HTML进行充分的转义。 ▉ 预防 DOM 型 XSS 攻击 由于前端的 javascript 代码本身不够严谨，把不可信的数据当做代码执行了。 1、HTML 插入数据 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等 2、DOM 内联监听 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。 1234567891011121314151617&lt;!-- 内联事件监听器中包含恶意代码 --&gt;&lt;img onclick="UNTRUSTED" onerror="UNTRUSTED" src="data:image/png,"&gt;&lt;!-- 链接内包含恶意代码 --&gt;&lt;a href="UNTRUSTED"&gt;1&lt;/a&gt;&lt;script&gt;// setTimeout()/setInterval() 中调用恶意代码setTimeout("UNTRUSTED")setInterval("UNTRUSTED")// location 调用恶意代码location.href = 'UNTRUSTED'// eval() 中调用恶意代码eval("UNTRUSTED")&lt;/script&gt; 二、CSRF 跨站请求伪造2.1 跨站请求伪造（CSRF） 跨站伪造请求（Cross-site request forgery ），缩写为 CSRF。冒充用户发起请求（在用户不知情的情况下）， 完成一些违背用户意愿的事情（如修改用户信息，删初评论等）。 1、攻击原理 攻击者通过技术手段欺骗用户的浏览器去访问一个曾经认证过的网站，所以用户不用进行重新认证，这是一个用户身份验证的一个漏洞：简单身份认证只保证请求来自某个用户的浏览器，确不能保证请求的本身是用户自愿发出的。攻击者诱导用户在刚访问不久的网站中点击设定的链接（本页的论坛、博客等自动生成的链接内容）。 2、防御措施▉ 检查 Referer 字段 HTTP 头有一个 Referer 字段，用来标记请求来源于哪个地址。Referer 字段应和请求的地址位于同一域名下。 服务器在处理请求的时候，可以判断该字段是否位于正确的源地址下发送的请求。如果是 CSRF 攻击，该字段会包含恶意的网址。 局限性：设置 Referer 有本身的局限性，攻击者可以篡改 Referer 字段来达到攻击的目的。 ▉ Token 验证 CSRF 的本质是在于攻击者欺骗自己去访问设置的地址，如果在请求数据的时候，用户不把信息保存到浏览器的 Cookie 中，那么攻击者无法获取数据校验，从而不能进行 CSRF 攻击。 第一步：后端随机产生一个 token，把这个 token 保存到 session 状态中；同时后端把这个 token 交给前端页面； 第二步：前端页面提交请求时，把 token 加入到请求数据或者头信息中，一起传给后端； 第三步：端验证前端传来的 token 与 session 是否一致，一致则合法，否则是非法请求。 四、DNS 攻击1、什么是 DNS 攻击？ 利用 DNS（域名系统）中的漏洞，发起 DNS 攻击。 ▉ DNS 的工作原理 将用户输入的域名转换成相对应的 IP 地址。 DNS 首先搜索缓存中是否存在该域名的 IP 地址。 如果找不到该域名的地址，就到 DNS 服务器查找该域名准确的 IP 地址。 DNS 一直循环工作，DNS 服务器之间可以相互查询到域名的 IP 地址的DNS 服务器。 DNS 一旦找到 IP 地址，就将当前的 IP 地址返回给请求的程序，将其存储缓存中。 ▉ 如何利用 DNS 攻击 1）DNS 不太注重安全问题，所以容易被攻击者发起 DNS 攻击。攻击者利用一种方式来用恶意的 IP 地址替换 DNS 解析的域名的 IP 地址，那么用户发送的数据发送到这个攻击者替换的 IP 假地址中去。 2）DNS 服务器配置不记得它的默认配置，所以利用这一漏洞进行攻击。 ▉ DNS 的攻击类型 零日攻击：利用 DNS 服务器软件和协议堆栈中未知的漏洞。 Fast Flux DNS ： 以高频率交换 DNS 记录以重定向 DNS 请求，也有利于攻击者避免检测。 DNS 欺骗：攻击者通过用服务器缓存中的伪造 IP 地址替换授权的 IP 地址来破坏整个DNS服务器。通过这种方式，他们将整个流量重定向到恶意网站并收集重要信息。 五、DDOS 攻击 DDoS 攻击称为分布式拒绝服务攻击。 通过多台计算机对 DNS 服务器发送大量的请求，达到目标的 DNS 服务器无法进行正常队请求进行解析回应的目的。DDoS 攻击可能导致整个 DNS 服务器崩溃并使用户无法访问 Web。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之题型篇【查找和排序】]]></title>
    <url>%2F2019%2F05%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A2%98%E5%9E%8B%E7%AF%87%E3%80%90%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[数据结构与算法中所必会的查找和排序算法。 写在前边一、查找和排序的基础练习（阶段一）二、查找和排序的进阶练习（阶段二）1、旋转数组的最小数字 题目：把一个数组最开始的若干个元素搬移到数组的尾部，称为旋转数组。输入一个递增排序的数组的一个旋转，输出旋转数组中最小的值。 1.1 问题分析与解决▉ 问题分析 1）最先想到的方法是暴力破解法，能否遍历整个数组，得出最小值呢？ 2）暴力破解法时间复杂度太高，是否还有其他方法减少时间复杂度呢？查找一个数据，我们想到的方法是二分查找，但是二分查找是查找一个给定值的数据。能够自己改进一下，借助二分查找的思想呢？ 我们发现旋转数组是由两个升序的数组组成的，最小值的位置是在第一个升序数组的后边，第二个数组的最大值小于第一个升序数组中最小值的，我们发现是有规律可循的。 ▉ 算法思路 暴力破解法： 1）遍历整个数组，找出数组中的最小值。 二分查找法： 1）首先声明两个指针分别指向数组的起始位置和终止位置，取中间元素 mid。 2）判断当前数据 mid 和起始指针的大小，如果大于起始指针（或等于），说明这个中间数据一定是第一个数组中的值。那数组中的最小值一定在该数字的后边。 3）判断当前数据 mid 和起始指针的大小，如果小于终止指针（或等于），说明这个中间数据一定是第二个数组中的值。那数组中的最小值一定在该数字的前边。 4）我们把指针指向中间元素，将搜索范围缩小到原来的一半了，循环以上过程。 5）那么终止条件是什么呢？我们不断的缩小范围，我们会发现，起始指针和终止指针最终相邻，起始指针会指向数组的最后一个元素，终止指针会指向第二个数组的起始元素。那么终止指针指向的就是我们要查找的最小值。（之所以两个指针最后相邻，是因为我们不断你的在第一个或第二个数组中移动起始或终止指针，该指针永远不会越界指向超出本身数组的值） ▉ 边界条件 虽然我们上述的算法思路可以实现，但是有几个特殊情况需要处理一下： 1）如果数组中有重复的值，上述的方法不再适用。假如三个数组{11101} 是 {01111}的旋转数组，那么起始指针与终止指针以及中间元素相等，无法再用之前的判断，此时遇到这种情况需要遍历当前数组。 2）向后移动 0 个元素也算是一个旋转数组呀，相当于数组本身。此时需要判断数组的最后一个元素是否大于第一个元素，如果是这种情况，那就说明旋转数组就是本身。 ▉ 测试用例 1）空数组 2）原数组 3）重复元素的数组 4）正常旋转数组（升序数组，为一个值的数组） ▉ 代码实现12 ▉ 性能分析 暴力破解法 时间复杂度：O(n)。遍历整个数组。 空间复杂度：O(1)。不需要额外的内存空间。 二分查找法 时间复杂度：log(n)。二分查找，每次都缩小范围的 1/2 。 空间复杂度：不需要额外的内存空间 O(1)。 1.2 小结▉ 考查内容 1）对二分查找的充分理解。 2）能在短时间内了解旋转数组这种新的概念。 3）问题的全面性。（重复元素以及向后移动 0 个元素） ▉ 扩展思考 1）对二分查找条件的变换，使得问题可以举一反三。 2、二叉查找树的后续序列 题目：给你一个整型数组，判断该数组是否为二叉查找树的后序遍历。如果是返回 true，如果不是返回 false。 2.1 问题分析与解决▉ 问题分析 1）根据二叉查找树后续遍历的特点，先遍历左子树，然后遍历右子树，最后遍历根节点。存储在数组中的二叉查找树是有规律的，所以观察数组中的数据，与后序遍历是否存在一些规律和关系呢？ 2）二叉查找树的后序遍可以用递归实现遍历的，如果判断一组数据是否为后序遍历是否也可以通过递归来进行判断呢？ ▉ 算法思路 1）数组中的数据最后一个数据一定是树的根节点。 2）如果为一棵二叉查找树，除最后一个根节结点外，数组分为两份数据，我们发现前一份数据小于根节点，后一份数据大于根节点。也就是说，前一半数据为树的左子节点，后一半数据为树的右子节点。 3）然后对左右两部分的数据分别递归按照上述的方法进行判断。 ▉ 测试用例 1）空树 2）非二叉查找树 3）只有一个结点的二叉查找树。 4）只有右/左子树的二叉查找树。 ▉ 代码实现 ▉ 性能分析 2.2 小结▉ 考查内容 1）对问题的分析能力，能否找到解题问题的规律。 2）对二叉查找树遍历的理解。 3）递归的灵活运用。 ▉ 扩展思考 1）判断一个数组是否为树的前序遍历或中序遍历？ 2）”重建二叉树“ 也是同样的解题思路。 三、查找和排序的高级练习（阶段三）四、查找和排序的总结]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之道【事件流与委托】]]></title>
    <url>%2F2019%2F05%2F02%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%8E%E5%A7%94%E6%89%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[事件流与委托是前端重点内容之一！ 事件流 浏览器开发团队遇到的问题是，当点击页面的某一元素的时候，不仅点击了当前源苏苏，而且也点击了包含当前元素的容器，也相当于点击了整个页面。然而为了规范页面中的事件的接收顺序，两个浏览器团队提出了完全相反的想法。 一、事件流 所谓的事件流描述的是从页面中接收事件的顺序。 1）IE 提出的是事件冒泡流。 2）NC 提出的是事件捕获流。 1、事件冒泡 IE 的事件流叫做事件冒泡。事件是从具体的元素接收，向上传播到不具体的结点。 1）所有的浏览器都支持事件冒泡。 2）IE 5 之前事件冒泡会跳过&lt;html&gt; 元素，从 body 到 document。 3）IE 9、Firefox、Safari、Chrome 等浏览器事件一直冒泡到 window 对象。 12// 例子div &gt; body &gt; html &gt; document &gt; window // 当点击页面的 div 元素时，事件的传播顺序 2、事件捕获 NC 提出的另一个事件流叫做事件捕获。事件从不具体的结点到具体的元素。用意是事件到达预定的目标结点之前捕获它。 1）老版本的浏览器只支持事件冒泡，不支持事件捕获。 2）一般没有特殊要求，都是用事件冒泡。 12// 例子window &gt; document &gt; html &gt; body &gt; div // 当点击页面的 div 元素时，事件的传播顺序 3、DOM 事件流 “DOM2” 的事件流包括三个阶段，事件捕获、处于目标阶段、事件冒泡阶段。 1）一般「处于目标阶段」属于事件「冒泡阶段」的一部分。 1）IE 9、Firefox、Safari、Chrome 等浏览器会在事件捕获阶段触发事件对象上的目标。相当于有两个机会在目标对象上操作事件。 2）IE 8 更早的版本不支持 DOM 事件流。 123456// 事件捕获window &gt; document &gt; html &gt; body// 处于目标阶段body &gt; div // 事件冒泡阶段div &gt; body &gt; html &gt; document &gt; window 二、事件处理程序链接：事件绑定和事件对象 委托 事件处理程序的数量直接关系到页面的性能问题，主要分为两个方面： 1）每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。 2）事先指定所有事件处理程序而导致的 DOM 访问次数过多，会延迟整个页面的交互就绪时间。 一、事件委托 为了解决“事件绑定”过多的问题，解决方案是事件委托。利用事件冒泡，只需绑定一个事件处理程序，就可以管理页面所有的事件。 1、定义 1）事件委托，只需将事件处理程序绑定到 DOM 树最高的层次上。 2）一般考虑绑定到页面的 document 对象上。 123456789101112131415161718192021// 绑定到 document 对象上EventUtil.addHandler(document, "click", handler);const handler = (event)=&gt;&#123; event = EventUtil.getEvent(); let target = EventUtil.getTarget(event); if (target.name &amp;&amp; target.id) &#123; switch (target.name) &#123; case 'delete': case 'edit': case 'selectImg': case 'updataImg': case 'modifyStaffInfo': case 'modelYes': &#125; &#125;&#125; 1、优点 1）document 很快就可以访问，页面呈现的元素立即具备了绑定的功能。 2）页面设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的 DOM 引用更少，时间就越少。 3）整个页面占用的内存空间少，提升了整体的性能。 二、移除事件绑定 页面元素在绑定事件处理程序的时候，浏览器中的代码就会和 javascript 代码之间建立一个链接。这种链接越多，页面就会越慢。 1）事件委托减少事件绑定，限制连接的数量。 2）在不需要时移除时间绑定程序（内存中留有不用的处理程序）。 1、两种情况 造成以上问题的两种情况： 1）文档中移除绑定事件的元素。虽然元素被移除，但是事件处理程序还在内存中，无法当做垃圾被回收,因为虽然元素被移除了，但是在内存中与元素保持的引用的关系。 例如：removeChild() 和 replaceChild() 方法，更多的是使用 innerHtml 替换页面的一部分。 2）卸载页面的时候。如果在页面卸载之前没有清理干净事件处理程序，还会存储在内存中。不断的刷新、卸载页面使得内存中事件处理程序的数量越来越多，因为事件处理程序占用的内存空间有没释放掉。 2、解决方案 通过 onunload 事件处理在页面卸载的时候，将页面中绑定的事件处理程序全部移除掉。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端功能之【Datatables插件】]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E4%B9%8B%E3%80%90Datatables%E6%8F%92%E4%BB%B6%E3%80%91%2F</url>
    <content type="text"><![CDATA[Datatables 功能插件的使用详细讲解！ 一、1、引用插件 首先引入 Datatables 插件、Bootstrap、jQuery 插件。 123&lt;!--DataTables js--&gt;&lt;script src="assets/plugins/Datatable/js/jquery.dataTables.js"&gt;&lt;/script&gt;&lt;script src="assets/plugins/Datatable/js/dataTables.bootstrap4.js"&gt;&lt;/script&gt; 2、HTML 表格 在界面添加 HTML 表格代码。 123456789101112131415161718192021&lt;table id="example"&gt; &lt;!-- 行标题 --&gt; &lt;thead&gt; &lt;tr&gt; &lt;!-- 每列的标题 --&gt; &lt;th class="wd-15p"&gt;权限&lt;/th&gt; &lt;th class="wd-15p"&gt;登陆号&lt;/th&gt; &lt;th class="wd-20p"&gt;密码&lt;/th&gt; &lt;th class="wd-15p"&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!-- 表格内容 --&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Bella&lt;/td&gt; &lt;td&gt;Chloe&lt;/td&gt; &lt;td&gt;System Developer&lt;/td&gt; &lt;td&gt;2018/03/12&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 3、Datatables 语言设置 Datatables 默认的语言设置是英文，我们要将其设置为中文。在 $(document).render(function(){}) HTML 结构渲染完进行设置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758$(document).ready(()=&gt;&#123; let table = $('#example').DataTable(&#123; // Datatable 语言设置 'language': &#123; // 左上角的显示数量设置 "lengthMenu": '每页显示&lt;select class="form-control"&gt;' + '&lt;option value="10"&gt;10&lt;/option&gt;' + '&lt;option value="20"&gt;20&lt;/option&gt;' + '&lt;option value="30"&gt;30&lt;/option&gt;' + '&lt;option value="40"&gt;40&lt;/option&gt;' + '&lt;option value="50"&gt;50&lt;/option&gt;' + '&lt;/select&gt;条', // 右下角的翻页设置 "paginate": &#123; "first": "首页", "last": "尾页", "previous": "上一页", "next": "下一页" &#125;, "processing": "加载中...", // DataTables载入数据时，是否显示进度条 "emptyTable": "暂无数据", // 表格无数据时显示情况 "info": "共 _PAGES_ 页 _TOTAL_ 条数据 ", "infoEmpty": "暂无数据", "emptyTable": "暂无要处理的数据...", //表格中无数据 "search": "搜索:", "infoFiltered": " —— 从 _MAX_ 条数据中筛选", "zeroRecords": "没有找到记录" &#125;, // datatables 自带的 ajax 请求数据 "ajax": &#123; url: '', // 请求的 url method: 'post', // 请求方式 timeout: 5000, // 请求延迟 dataType: 'JSON', // 数据类型 &#125;, let alldata = ['role', 'name', 'password']; // 设置后台返回的字段名，Datatable 会自动填充 'columns': [ &#123; 'data': 'role' &#125;, &#123; 'data': 'name' &#125;, &#123; 'data': 'password' &#125;, // name 为每一行传入的 data 字段 &#123; 'data': 'name', 'render':function(data,type,row,meta)&#123; // 自定义代码（一般添加增、删、改按钮），data 为传入的 name 值 var html = `&lt;button name="add" id="add_$&#123;data&#125;"&gt;添加&lt;/button&gt; &lt;button name="delete" id="delete_$&#123;data&#125;"&gt;删除&lt;/button&gt;` return html; &#125; &#125; ], // cells 存储着所有行对象（通过 . 可获取属性） createdRow: function (row, data, dataIndex, cells) &#123; for (let i = 0; i &lt; alldata.length; i++) &#123; // 为每一行元素添加唯一标识 ID cells[i].id = alldata[i] &#125; &#125;&#125; 4、为 Table 添加点击事件 通过事件委托的方式添加事件监听。 1）虽然监听事件添加到 table 上，但是可以通过 event 事件对象判断点击了哪一个 id 或 name 的控件。 123456789101112131415$('#example').click(function (event) &#123; // 每一行数据中每个字段的 name 值和 id 值 if (event.target.name &amp;&amp; event.target.id) &#123; // 通过判断 name 值来确定删除/添加 switch (event.target.name) &#123; case 'add': // 对表格做添加数据 // ...... break; case 'delete': // 对该行做删除处理 // ...... &#125; &#125;&#125;); 5、获取同行的所有数据 通过点击某按钮的 id 获取父节点，从而达到获取同行的数据。 1）得到同一行数据之后，我们可以进行传值编辑或者删除一行数据。 1234567891011121314// 同行某点击事件的 idfunction getSameValue(id) &#123; // 获取该 id 父节点的所有兄弟节点（存储所有数据的结点） let values = $('#' + id).parent().parent().siblings(); // 以键值对的方式存储到 map 中 let result = new Map(); // 将同一行的数据 name:value 遍历出来 for (let obj of values) &#123; // 通过结点得到想要的属性存储起来 result.set(obj.id, obj.outerText); &#125; // 返回 map return result;&#125; 6、删除一行数据 得到同一行数据之后，进行删除操作。 1）删除一行需要的到该行的 DOM 对象，可以通过目标值的父节点获取 123let row = event.target.parentNode.（...）.parentNode;// 进行删除更新table.row(row).remove().draw(false); 7、添加一行数据 123let table = $('#example').DataTable(&#123;&#125;)// 更新数据table.ajax.reload(null, true);]]></content>
      <categories>
        <category>前端功能实现</category>
      </categories>
      <tags>
        <tag>前端功能实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之【事件绑定】]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E3%80%91%2F</url>
    <content type="text"><![CDATA[js 事件的处理程序！ [TOC] 事件绑定（事件处理程序）一、HTML 事件绑定 最直接的事件绑定就是在 HTML 上做处理，显式的为按钮绑定 click 事件，用户点击按钮就会触发事件。 1、事件绑定定义1）onClick 特性的值是 javascript ，所以不能在内使用未转义的 HTML 语法字符。 2）onClick 也可以调用页面定义的脚本（函数名）。也可以是外部文件，事件处理程序有权访问全局变量。 3）onClick 内定义的函数自带的一个 event变量存储事件对象，通过 event 变量可以访问事件对象的属性值（也可以使用 this ，this 指向事件对象本身）。 12//1、onClick 内不能使用未转义的 HTML 语法字符（单引号）&lt;input type='button' value="点击我" onclick="alert(&amp;quot;Clicked&amp;quot;)" /&gt; 1234567//2、调用页面其他地方的脚本&lt;input type='button' value="点击我" onclick="showMessage()" /&gt;&lt;script&gt; showMessage = ()=&#123; alert("Hello Word") &#125;&lt;/script&gt; 1234//3、event 事件对象&lt;!--两个都输出‘点击我’--&gt;&lt;input type='button' value="点击我" onclick="alert('event.value')" /&gt; &lt;input type='button' value="点击我" onclick="alert(this.value)" /&gt; 2、存在的缺点▉ 缺点 1）用户在 HTML 元素一出现就点击元素触发相应的事件，但可能改事件还没有初始化（尚未具备执行的条件），导致报错。 2）HTML 和 Javascript 紧密耦合。修改事件时，会修改两处，所以一般不使用 HTML 事件绑定。 ▉ 解决 1）加入 try catch 语句，在脚本函数没有被解析之前就点击了元素，就会引出错误。该错误不会让用户看见，而是被捕获。 2）不使用 HTML 事件绑定，而是转向使用 javascript 执行事件处理程序。 1&lt;input type='button' value="点击我" onclick="try&#123;showMessage();&#125;catch(ex)&#123;&#125;" /&gt; 二、DOM0 级事件绑定 通过将一个函数的值赋值给事件处理程序的属性来绑定事件。 1）简单 2）跨浏览器 1、事件绑定定义 1）先获取某个拥有事件处理程序属性的对象（属性一般都是小写，如 onclick），然后将该属性指向一个事件处理函数。 2）该方法被认为定义了元素的方法，处理事件是在该元素的作用域执行的，所以 this 指向该元素（可以通过 this 访问该元素的任何属性和方法）。 3）DOM0 级事件处理是在事件的冒泡阶段进行绑定的。 4）删除元素的绑定事件。 1234var btn = documentElementById("myBtn");btn.onclick = function()&#123; alert('HelloWord')&#125; 1234var btn = document.ElementById("myBtn");btn.onclick = function()&#123; alert(this.id) // 输出 myBtn&#125; 1btn.onclick = null; 三、DOM2级事件绑定 DOM2 级事件处理程序定义了两个方法，分别是处理事件和删除事件的两个操作：addEventListener() 和 removeEventListener() 。 1、事件绑定定义 1）可以添加多个事件处理函数。 2）移除函数必须和移除函数相同的参数。并且 addEventListener() 函数必须使用 removeEventListener() 才能移除。 该函数接受三个参数： 要处理的事件名； 绑定的函数； 布尔值（true：表示捕获阶段调用事件程序，false：表示冒泡阶段调用事件程序）； 1234567// 为 btn 绑定了两个事件处理函数，按顺序执行btn.addEventListener('click',function()&#123; alert('HelloWord') // 先执行 HelloWord&#125;,false)btn.addEventListener('click',function()&#123; alert(this.id) // 再执行 ID&#125;,false) 12345// 注意：这里的 function 和上方不是同一个函数，所以移除失败// 通过将同一个函数赋值给统一的变量，就可以视作为统一参数btn.removeEventListener('click',function()&#123; alert(this.id)&#125;,false) 2、兼容性 1）DOM2 级事件处理程序兼容的浏览器有 IE9、Firefox、Safari、Chrome 和 Opera。 2）大多情况下，都将事件处理程序添加到冒泡阶段，为了最大限度的兼容各种浏览器。 四、IE 事件绑定 1）IE 实现了与 DOM 类中的两个方法：attachEvent() 和 detachEvent() 。 2）IE8 版本之前所有的事件绑定都是在冒泡阶段。 3）IE 与 DOM0 级绑定事件的区别在于事件的作用域是「全局变量」（ this 指向 window 作用域）。 4）可以通过 attach 添加多个事件，且「执行顺序和 DOM2 级相反」。 5）detachEvent 删除事件也必须提供相同的参数，匿名函数无效。 123btn.attach('onclick',function()&#123; alert('HelloWord')&#125;,false) 123456btn.attach('onclick',function()&#123; alert('HelloWord') // 再执行 HelloWord&#125;,false)btn.attach('onclick',function()&#123; alert(this.id) // 先执行 ID&#125;,false) 1234// 移除无效btn.detachEvent('onclick',function()&#123; alert(this.id)&#125;,false) 五、跨浏览器的事件绑定 为了能够保证事件绑定能在大多数的浏览器下运行，一般有两种方式： 1）使用能够隔离浏览器差异的 javascript 库。 2）自己开发合适的功能，使用能力检测，保证能够在大多数的浏览器下运行。 3）该程序没有考虑到浏览器的所有问题。如：在 IE 中的作用域问题。 12345678910111213141516171819202122var EventUtil = &#123; // 绑定事件 addHandler: function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125;else if(element.attachEvent)&#123; element.attachEvent('on'+ type,handler) &#125;else&#123; element['on' + type] = handler; &#125; &#125;, // 解除绑定 removeHandler: function(element,type,handler)&#123; if(element.addEventListener)&#123; element.removeEventListener(type, handler, false); &#125;else if(element.attachEvent)&#123; element.detachEvent('on'+ type,handler) &#125;else&#123; element['on' + type] = null; &#125; &#125;&#125; 小结1、IE 与 DOM0/DOM2 之间的区别 1）IE 与 DOM0 比较：IE 事件绑定时，this 指向全局变量 window，而 DOM0 的 this 却指向事件本身。 2）IE 与 DOM2 比较：IE 与 DOM2 相比，DOM2 中的添加多个事件执行的顺序（正序）与 IE 绑定多个事件执行的顺序相反（逆序）。 2、兼容性 1）IE8 之前的只有冒泡阶段，所以 IE8 之前的事件绑定都是在冒泡阶段完成的（DOM0 级以及 IE 事件绑定）。 2）DOM2 事件第三个参数可以选择绑定阶段（冒泡还是捕获），因为 IE8 之前只有冒泡阶段，所以 DOM2级别的事件绑定只适用于 IE9+ 。 事件对象 当触发 DOM 的某个事件时，就会产生一个 event 对象，对象中包含着与事件相关信息。 一、DOM 中的事件对象1、this、currentTarget、target 1）当事件直接绑定到目标事件时，三者的值相同。 2）当事件绑定到目标事件的父节点上，this 与currentTarget 的值与 target 的值不相同。 当点击该按钮时，事件的绑定是按钮的父节点，所以目标对象 target 是指向按钮元素的（click 的真正目标），由于按钮没有绑定事件处理程序，所以 click 事件冒泡到 document.body 事件才得到处理 。 1234// 将事件绑定 btn 按钮的父节点上document.body.onclick = (event)=&gt;&#123; alert(event.target === document.getElementById('btn')) // true&#125; 2、处理多个事件 为了能够减少代码量，通过 event.type 来确定一个函数处理多个事件。 12345678910111213141516handler = (event)=&gt;&#123; switch(event.type)&#123; case 'click': //要处理的点击事件 break; case 'mouseover': // 要处理的鼠标进入事件 break; case 'mouseout': // 要处理的鼠标滑出事件 &#125;&#125;btn.onclick = handler;btn.mouseover = handler;btn.mouseout = handler; 3、阻止默认的事件行为 可以通过使用 preventDefault() 方法来取消默认的行为（必须设置属性 cancelable 为 true），如 a标签的链接事件，阻止了跳转 href 的链接。 1234link.onclick = (event)=&gt;&#123; event.cancelable = true; event.preventDefault();&#125; 4、立即停止事件的传播 通过设置 stopPropagation() 方法立即停止在 DOM 层次中的传播（停止事件的捕获或冒泡）。 1）通过这种方式可以避免发生在父节点绑定的事件处理程序。 二、IE 中的事件对象 IE 中事件对象 event 有一种不同的方式。 1）DOM0 级：event 作为 window 的一个属性。 2）attatach 添加的：传入一个 event 对象。 1234btn.onclick = ()=&gt;&#123; let event = window.event; alert(event.type)&#125; 1、srcElement srcElement 属性相当于 DOM 中的 target 属性，用来确定事件目标对象的。 1）因为事件处理程序的作用域是根据指定它的方式来确定，所以 this 不一定指向目标对象。因此我们通常用 srcElement 来替换。 1234567btn.onclick = ()=&gt;&#123; alert(window.event.srcElement === this) // true&#125;btn.attachEvent('onclick',(event)=&gt;&#123; alert(event.srcElement === this) // false&#125;) 2、阻止默认的事件行为 只要将 returnValue 设置为 false 就可以阻止默认的行为。 123link.onclick = (event)=&gt;&#123; window.event.returnValue = false;&#125; 3、立即停止事件的传播 设置 cancelBubble 属性即可停止事件的传播。由于 IE 中只有冒泡阶段，所以也只能阻止冒泡阶段在 DOM 层次中的传播。 123btn.onclick = (event)=&gt;&#123; window.event.cancelBubble = true;&#125; 三、跨浏览器的事件对象 不同浏览器中的 Event 对象是不同的，所以要写一个跨浏览器的事件对象。 1、定义 Event 事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546let EventUtil = &#123; // 绑定事件 addHandler: function(element,type,handler)&#123; if(element.addEventListener)&#123; element.addEventListener(type, handler, false); &#125;else if(element.attachEvent)&#123; element.attachEvent('on'+ type,handler) &#125;else&#123; element['on' + type] = handler; &#125; &#125;, // 解除绑定 removeHandler: function(element,type,handler)&#123; if(element.addEventListener)&#123; element.removeEventListener(type, handler, false); &#125;else if(element.attachEvent)&#123; element.detachEvent('on'+ type,handler) &#125;else&#123; element['on' + type] = null; &#125; &#125;, // 获取事件对象 getEvent: function(event)&#123; return event ? event : window.event; &#125;, // 获取事件目标对象 getTarget: function(event)&#123; return event.target || event.srcElement; &#125;, // 阻止事件 preventDefault: function(event)&#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue; &#125; &#125;, // 立即停止事件传播 stopPropagation: function(event)&#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125; &#125;&#125; 2、调用 Event 对象事件 1）getEvent() 2）getTarget() 3）preventDefault（） 4）stopPropagation（） 1234// IE 不存在 event (undefined)就返回 window.eventbtn.onclick = (event)=&gt;&#123; event = EventUtil.getEvent(event);&#125; 12345// 获取目标对象btn.onclick = (event)=&gt;&#123; event = EventUtil.getEvent(event); let target = EventUtil.getTarget(event);&#125; 12345// 阻止事件btn.onclick = (event)=&gt;&#123; event = EventUtil.getEvent(event); let target = EventUtil.preventDefault(event);&#125; 12345// 立即停止事件传播btn.onclick = (event)=&gt;&#123; event = EventUtil.getEvent(event); let target = EventUtil.stopPropagation(event);&#125; 小结 1）DOM0 级别的 Event 存在 window 对象中，而 DOM2 和 IE 处理事件程序中的 Event 对象是当做参数传入的。]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试之【异步编程】]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%90%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[js 异步常考面试题！ JS 为什么用单线程？※ 答✔：js为什么会用单线程？ 1）js 单线程的特点就是同一时刻只能执行一个任务，js 的任务基本都是与用户互动，以及操作 DOM，所以使用单线程，否则会带来复杂的同步问题。 2）如果为多线程，多个线程同时操作 DOM 就会造成浏览器不知道以哪个为标准的问题。 3）如果执行同步问题的话，多线程需要加锁，执行任务造成非常的繁琐。 4）H5 新的规定。允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。 单线程带来的问题是什么？JS 为什么会有异步？※ 答✔：单线程带来的问题是什么？JS 为什么会有异步？ 单线程就一味着要排队执行任务，如果前一个任务执行非常耗时，下一个任务就必须等待，如果是网络请求的话，必须等待着结果返回才会执行，那么页面就会出现卡死状态，导致页面无响应，影响用户的体验。为了解决单线程带来的问题，所以就设计 js 有两种任务，分别为同步任务和异步任务。 同步代码和异步代码的执行顺序？※ 答✔：同步代码和异步代码的执行顺序？JS 的运行机制（Event Loop）？ 1）所有同步任务都在主线程上执行，形成一个执行栈。 2）主线程之外，还存在一个”任务队列”。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 4）只要主线程空了，就会去读取”任务队列”。 js 怎么样实现异步？※ 答✔：js 怎么样实现异步？ 事件和回调函数。 一、事件 任务队列”是一个事件的队列，当执行完异步任务时，就在任务队列中添加一个事件，表示该异步任务已经执行完成，可以进入执行栈了。主线程就会读取任务队列中完成的异步事件。 二、回调函数※ 答✔：什么是回调函数 回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应 ※ 答✔：回调函数有什么缺点？ 如果说个请求存在依赖性，容易写成回调地狱问题。 ※ 答✔：如何理解回调地狱问题？ 1）嵌套函数存在耦合性，一旦有所改动，牵一发而动全身。 2）嵌套函数一多，就很难处理错误。 3）回调函数不能使用 try catch 捕获异常(异常的捕获只能在函数执行的时候才能捕获到)。 4）回调函数不能直接 return 。 1234561、为什么不能捕获异常？ 这跟 js 的运行机制相关，异步任务执行完成会加入任务队列，当执行栈中没有可执行任务了，主线程取出任务队列中的异步任务并入栈执行，当异步任务执行的时候，捕获异常的函数已经在执行栈内退出了，所以异常无法被捕获。2、为什么不能return？ return 只能终止回调的函数的执行，而不能终止外部代码的执行。 return false：阻止默认事件的发生（a标签跳转链接）。 ※ 答✔：如何解决回调地狱问题？ 玩转ES6之Generator) 玩转ES6之Promise) 二、Generator 生成器玩转ES6之Generator) 三、Promise玩转ES6之Promise)]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端功能之【选取图片并显示】]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E4%B9%8B%E3%80%90%E9%80%89%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[本地选取图片并显示！ 一、选取本地图片1、HTML▉ accept 属性 控制选取照片的类型。 1234// 建议只选择照片使用这种写法accept=&quot;image/png, image/jpeg, image/gif, image/jpg&quot;// 其次这种写法accept=&quot;image/*&quot; ▉ multiple 属性 用来选择多个文件上传。 ▉ 改变样式 通过使用 lable for 的联动改变上传按钮的样式。 1）input 需要设置 display:none 属性进行隐藏。 2）然后通过 lable 的 for 的值为input 的ID 属性值。 ▉ 实例123456// input 选取&lt;input id="user_icon" type="file" accept="image/*" onchange="preImg(this.id,'image_icon',this)" style="display: none" /&gt;// 按钮&lt;button id="choose_icon"&gt;选择照片&lt;/button&gt;// 显示图片&lt;img id="image_icon" width="138" height="150"&gt; 2、javascript▉ 限制照片大小1234567891011121314151617// 添加内容：图片大小限制function limitFileSize(sourceId)&#123; //图片大小限制 var fileSize = 0; var fileMaxSize = 1024;//1024k // 通过 input ID 获取到图片的大小 fileSize = document.getElementById(sourceId).files.item(0).size; var size = fileSize / 1024; //转换成 KB if(size &gt;= fileMaxSize)&#123; alert("文件大小不能大于 1 M！"); return false; &#125;else if(size &lt;= 0)&#123; alert("文件大小不能小于 0 M！"); return false; &#125; return true;&#125; ▉ 显示图片12345678//显示图片// sourceId: ipnput id,sourceId: image id file: input objectfunction preImg(sourceId, targetId,file) &#123; var url = getFileUrl(sourceId); var imgPre = document.getElementById(targetId); // 获取到的图片本地 url 设置 img 的 src 属性就 ok 了 imgPre.src = url;&#125; ▉ 判断浏览器类型 不同的浏览器，选取图片 URL 的路径方式不相同。 1） 照片的路径就是 input 的 value 的值 2）选择 url 之前，要判断图片的大小。 123456789101112131415161718192021222324252627282930313233// 选择图片按钮监听$("#choose_icon").click(function () &#123; $("#user_icon").click();&#125;);// 选取本地文件function getFileUrl(sourceId) &#123; var url; if (navigator.userAgent.indexOf("MSIE")&gt;=1) &#123; // IE //限制文件大小 if(limitFileSize(sourceId))&#123; // 照片的路径就是 input 的 value 的值 url = document.getElementById(sourceId).value; &#125;else&#123; return; &#125; &#125; else if(navigator.userAgent.indexOf("Firefox")&gt;0) &#123; // Firefox //限制文件大小 if(limitFileSize(sourceId))&#123; url = window.URL.createObjectURL(document.getElementById(sourceId).files.item(0)); &#125;else&#123; return; &#125; &#125; else if(navigator.userAgent.indexOf("Chrome")&gt;0) &#123; // Chrome //限制文件大小 if(limitFileSize(sourceId))&#123; url = window.URL.createObjectURL(document.getElementById(sourceId).files.item(0)); &#125;else&#123; return; &#125; &#125; return url;&#125; 二、上传本地图片 enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码，默认的编码是：” application/x-www-form-urlencoded “。对于普通数据是挺适用的，对于文件，就不能乱编码了，该什么就是什么，只能使用 multipart/form-data 作为 enctype 属性值。]]></content>
      <categories>
        <category>前端功能实现</category>
      </categories>
      <tags>
        <tag>前端功能实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小学生都能学会的 Git 之【Github 提交篇】]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%B0%8F%E5%AD%A6%E7%94%9F%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%20Git%20%E4%B9%8B%E3%80%90Github%E6%8F%90%E4%BA%A4%E7%AF%87%E3%80%91%2F</url>
    <content type="text"><![CDATA[Git 版本控制完整使用流程！ [TOC] 一、创建版本库1、初始化仓库1git init 2、添加文件到版本库的缓存区1git add xiaolu.txt 3、将缓存区文件提交到本地正式仓库1git commit -m &quot;wrote a file&quot; 4、当前版本库的状态 比如修改了内容。 1git status 5、查看修改的内容1git diff 文件名 6、查看提交记录 --pretty=oneline 用于格式化。 1git log --pretty=oneline 二、时光穿梭1、版本回退 回到上一个版本 HEAD^，上上版本就是 HEAD^^ ，100 个之前的版本 HEAD~100 1git reset --hard HEAD^ 2、向后回滚 1）如果窗口不关闭的情况下可以找到 commit id 。 2) 如果窗口关闭了，需要使用 git reflog 命令找到 commit id 1git reset --hard 1094a // 提供的提交 ID 123456// 查看命令历史记录git reflog//878eae2 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 878ea//ad3b64b HEAD@&#123;1&#125;: reset: moving to HEAD^//878eae2 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: 第二次提交//ad3b64b HEAD@&#123;3&#125;: commit (initial): xiaolu.txt 3、管理修改 查看工作区和版本区最新版本的区别。 1234567891011121314git diff HEAD -- xiaolu.txtdiff --git a/xiaolu.txt b/xiaolu.txtindex fda2ac1..4832c20 100644--- a/xiaolu.txt+++ b/xiaolu.txt@@ -1,3 +1,4 @@ 1111 2222-333 // 版本区\ No newline at end of file+333^M+444 // 工作区\ No newline at end of file 4、撤销修改 丢弃工作区的修改。 丢弃缓存区的添加 让这个文件回到最近一次 git commit 或 git add 时的状态。 1）文件修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 2）文件经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态 ； 1git checkout -- xiaolu.txt 丢弃缓存区的添加，就是撤销 git add 命令操作。 1git reset HEAD xiaolu.txt // HEAD 代表最新版本 5、删除文件 工作区删除了文件，导致工作区和版本库中的版本不一致所以杰西莱有两种选择。 1）将版本库中的该文件进行删除，然后提交。 2）不小心误删了工作区的文件，要回复工作区误删除的文件。 12345// 将版本库中的该文件进行删除git rm test.mdgit commit -m &apos;删除test&apos;// 恢复误删除的文件git checkout -- test.txt 三、远程仓库 本地仓库和远程的仓库通信需要 SSH 加密的，需要设计一样的秘钥才可以进行通信。 ▉ 创建秘钥本地仓库设置密钥需要和远程仓库及逆行加密通信。 在 window 下创建 SSH Key，一路回车。在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; ▉ Github设置 key在远程仓库设置一个或多个公钥知道有哪里的本地仓库要通信。 登陆GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，点“Add Key”，你就应该看到已经添加的Key 。 1、添加远程仓库 1）将本地仓库和远程仓库进行关联之后才可以推送信息。 2）将本地所有内容推送到远程仓库。 12345// 关联远程仓库git remote add origin 远程仓库地址//-u 参数不但会把 master 分支推上去，还会将关联两个分支git push -u origin master 2、克隆仓库 从远程克隆下仓库。 1git clone 仓库地址 四、创建与合并分支 HEAD 指针是指向 master 的，master 是指向提交的，通过切换 HEAD 指针来切换指针。 1、创建分支123456// 创建分支git branch dev//切换分支git checkout dev// 创建并切换分支git checkout -b dev 2、查看当前分支123git branch* dev master 3、合并分支 Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 123456// 合并分支git merge devUpdating 9220589..b12c1f2Fast-forward xiaolu.txt | 4 +++- 1 file changed, 3 insertions(+), 1 deletion(-) 4、删除分支1git branch -d dev 五、解决冲突 创建的新分支与主分支 master 都进行修改了，分支进行了分叉，出现合并冲突，不能正常合并。必须手动解决冲突。 12345// 尝试合并,产生冲突$ git merge feature1Auto-merging xiaolu.txtCONFLICT (content): Merge conflict in xiaolu.txtAutomatic merge failed; fix conflicts and then commit the result. 123456789101112// 冲突信息$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: xiaolu.txt 查看文件内容 vi xiaolu.txt 可以查看不同分值冲突的内容。 1234567891011121314// 查看文件内容vi xiaolu.txt11112222333444dev·ÖÖ§¸üÐÂ&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADfeatrue ·ÖÖ§master ·ÖÖ§ÐÞ¸Ä=======featrue ·ÖÖ§&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 用 git log 带参数的情况看到分治合并情况。 1234567891011121314// 带参查看合并分支情况git log --graph --pretty=oneline --abbrev-commit* 34b90d1 (HEAD -&gt; master) 解决冲突后提交|\| * e890412 (feature1) featrue提交* | 775427c master提交|/* b12c1f2 在dev分支提交* 9220589 删除test文件* 89bd80c 添加新文件* 5564077 第三次提交* 878eae2 第二次提交* ad3b64b xiaolu.txt 六、分支管理策略 合并分支时，如果可能，Git会用 Fast forward 模式，但这种模式下，删除分支后，会丢掉分支信息 。要强制关闭该模式，git 就会在 merge 时生成一个新的 commit。 1、合并分支强制禁用 ff 模式123456$ git merge --no-ff -m &apos;merge with no-ff&apos; devMerge made by the &apos;recursive&apos; strategy. xiaolu.txt | 1 + 1 file changed, 1 insertion(+) 2、查看合并记录 不使用 Fast forward 模式。 1234567891011121314151617$ git log --graph --pretty=oneline --abbrev-commit* 9885e46 (HEAD -&gt; master) merge with no-ff|\| * d303c02 (dev) dev分支提交修改|/* 34b90d1 解决冲突后提交|\| * e890412 featrue提交* | 775427c master提交|/* b12c1f2 在dev分支提交* 9220589 删除test文件* 89bd80c 添加新文件* 5564077 第三次提交* 878eae2 第二次提交* ad3b64b xiaolu.txt 3、分支策略 实际开发，按照这几个基本原则进行分支管理。 1）master 主分治，只用于发布新的版本，平时开发不能在此分支。 2）开发都在 dev 分支开发。每到一个阶段就要合并 master 分支进行版本发布。 3）多人合作，创建自己的分支，时不时的向 dev 分支合并。 七、Bug 分支 每当开发中有 Bug 时，需要通过新的临时分支来修复，修复后合并分支，然后临时分支删除。 如果接到修改 Bug ，当前在 dev 分支工作还没提交，又不想提交，一天后才能开发完毕。只能将现场保护起来。 123456789101112$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: test.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: xiaolu.txt 1、存储当前开发进度 当前的进度存储起来之后，回到主分支，然后创建 bug 分支，修改 bug 后提交，然后合并到 master分支，然后恢复现场进度。 123// 存储当前开发进度$ git stashSaved working directory and index state WIP on master: 9885e46 merge with no-ff 2、查看进度存储列表12$ git stash liststash@&#123;0&#125;: WIP on master: 9885e46 merge with no-ff 3、恢复开发进度 两种方法： 1）git stash apply 恢复后的 stash 并不删除；通过 git stash drop 删除。 2）git stash pop 进行删除，stash 存储的开发进度被删除了。 4、恢复指定存储1git stash apply stash@&#123;0&#125; 八、Feature 分支 软件开发出现新功能，需要单独创建 feature 分支进行开发。 如果开发增加一个功能，需要在新分支进行开发，但是中途取消了开发，就地需要删除已经开发的。回到主分支，删除该分支。 123$ git branch -d feature-vulcanerror: The branch &apos;feature-vulcan&apos; is not fully merged.If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;. 分支还没有进行合并，不能删除分支，所以我们要进行强制删除分支。 1、强制删除分支1git branch -D feature-vulcan 九、多人合作 从远程仓库进行克隆，Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin 1、远程仓库信息1git remove -v 2、推送分支 把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支。Git就会把该分支推送到远程库对应的远程分支上 。 1git push origin dev master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 3、抓取分支 1）多人合作，克隆远程仓库，只能看到本地 master 分支。 2）要在 dev 开发，就必须创建远程 origin 的 dev 分支到本地，于是他用这个命令创建本地dev分支： 12//将本地 git 的头指针指向 origin 库的 dev 分支$ git checkout -b dev origin/dev 4、创建远程仓库分支1234git checkout -b my-test //在当前分支下创建my-test的本地分支分支git push origin my-test //将my-test分支推送到远程git branch --set-upstream-to=origin/my-test //将本地分支my-test关联到远程分支my-test上 git branch -a //查看远程分支 5、推送失败 1）如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并。 2）如果合并有冲突，则解决冲突，并在本地提交； 3）如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;]]></content>
      <categories>
        <category>Git版本控制</category>
      </categories>
      <tags>
        <tag>Git版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶深入系列之【原型链和继承】]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF%E3%80%91%2F</url>
    <content type="text"><![CDATA[一篇让你完全明白 js 中原型链和继承！ 一、原型链 回顾上一节的内容《原型》，我们知道了构造函数与实例以及原型对象之间的关系，下面我们来看原型链。 1、概念 所谓的原型链就是，一个构造函数的原型对象是另一个构造函数的实例。· 2、实现 要在引用的对象（实例 instance）中引用某个属性，首先在对象内部查找，然后再到原型对象中查找（instance.__proto__ (constructor1.prototype)）,如果这个原型对象是另一构造函数的实例的话，就会继续沿着这个实例的原型对象继续查找。 3、原型链 这种实例与原型的链条叫做原型链。 1搜索轨迹: instance1--&gt; instance2 --&gt; （instance2.__proto__ ）constructor2.prototype…--&gt;Object.prototype 补充：所有的对象都继承与 Object 对象。 4、原型和实例的关系▉ instanceof （实例 —&gt; 原型） 用于测试实例（instance）在原型链中出现的构造函数。 12alert(instance instanceof Object);//truealert(instance instanceof Father);//true ▉ isPrototypeOf()（原型 —&gt; 实例） 只要该实例出现在原型链中，就会返回 true。 1alert(Object.prototype.isPrototypeOf(instance));//true 5、原型链的问题 问题一：当原型链中包含引用类型值的原型（实例）时,该引用类型值会被所有实例共享; 问题二：在创建子类型(例如创建 Son 的实例) ,不能向超类型(例如 Father )的构造函数中传递参数. 二、继承 为了能够解决上面的问题，所以使用一下几种继承的方式。 1、经典继承（构造函数）▉ 基本思想 在子类型构造函数的内部调用超类型构造函数. ▉ 代码实现 1）保证了原型链中引用类型值（实例）的独立，不被所有实例共享。 2）子类创建的时候可以向父类进行传参。 1234567891011121314151617// 详细解析//1、当用调用 call 方法时，this 带边 son 。//2、此时 Father 构造函数中的 this 指向 son。//3、也就是说 son 有了 colors 的属性。//4、每 new 一个 son ，都会产生不同的对象，每个对象的属性都是相互独立的。function Father()&#123; this.colors = ["red","blue","green"];&#125;function Son()&#123; Father.call(this);//继承了Father,且向父类型传递参数&#125;var instance1 = new Son();instance1.colors.push("black");console.log(instance1.colors);//"red,blue,green,black"var instance2 = new Son();console.log(instance2.colors);//"red,blue,green" 可见引用类型值是独立的 ▉ 缺陷 1）继承的方法都在构造函数中定义，构造函数不能够复用了（Father 的 this 已经绑定到 son，this 只能用于 son ，所以说 Father 构造函数不能复用了 ） 2）父类中定义的方法对于子类型而言是不可见的。 2、组合继承（最常见的继承模式） 上述的构造函数模式因为存在的两个缺点，所以不经常被使用。组合继承是将原型链技术和构造函数来实现堆实例属性的继承。 ▉ 基本思想 使用原型链实现对「原型属性和方法」的继承,通过借用构造函数来实现对「实例属性」的继承. ▉ 代码实现 1）在原型对象上定义的方法实现了函数的复用。 2）每个实例都有属于自己的属性。 123456789101112131415161718192021222324252627282930function Father(name)&#123; this.name = name; this.colors = ["red","blue","green"];&#125;// 方法定义在原型对象上（共享）Father.prototype.sayName = function()&#123; alert(this.name);&#125;;function Son(name,age)&#123; // 子类继承父类的属性 Father.call(this,name); //继承实例属性，第一次调用 Father() // 每个实例都有自己的属性 this.age = age;&#125;// 将父类的实例变为子类的原型对象 Son.prototype = new Father(); //继承父类方法,第二次调用 Father()Son.prototype.sayAge = function()&#123; alert(this.age);&#125;var instance1 = new Son("louis",5);instance1.colors.push("black");console.log(instance1.colors); //"red,blue,green,black"instance1.sayName(); //louisinstance1.sayAge(); //5var instance1 = new Son("zhai",10);console.log(instance1.colors); //"red,blue,green"instance1.sayName(); //zhaiinstance1.sayAge(); //10 ▉ 缺陷 1）组合继承调用了两次父类的构造函数，造成了不必要的消耗。 ▉ 改进 也就是寄生组合式继承。 12345678910111213141516171819202122232425function Father(name)&#123; this.name = name; this.colors = ["red","blue","green"];&#125;Father.prototype.sayName = function()&#123; alert(this.name);&#125;;function Son(name,age)&#123; Father.call(this,name);//继承实例属性，第一次调用Father() this.age = age;&#125;extend(Son,Father)//继承父类方法,此处并不会第二次调用Father()Son.prototype.sayAge = function()&#123; alert(this.age);&#125;var instance1 = new Son("louis",5);instance1.colors.push("black");console.log(instance1.colors);//"red,blue,green,black"instance1.sayName();//louisinstance1.sayAge();//5var instance1 = new Son("zhai",10);console.log(instance1.colors);//"red,blue,green"instance1.sayName();//zhaiinstance1.sayAge();//10 3、原型继承▉ 基本思想 创建临时性的构造函数（无任何属性），将传入的对象作为该构造函数的原型对象，然后返回这个新构造函数的实例。 ▉ 代码实现 对传入的 o 对象进行了一次浅拷贝。 12345function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 浅拷贝。 1）object 所产生的对象是不相同的，但是原型对象都是 person 对象，所改变存在原型对象的属性所有生成的实例所共享，不仅被 Person 所拥有，而且被子类生成的实例所共享。 1234567891011var person = &#123; friends : ["Van","Louis","Nick"]&#125;;// 实例 1var anotherPerson = object(person);anotherPerson.friends.push("Rob");// 实例 2var yetAnotherPerson = object(person);yetAnotherPerson.friends.push("Style");// 都添加至原型对象的属性(所共享)alert(person.friends); // "Van,Louis,Nick,Rob,Style" ▉ object.create() 在 ECMAScript5 中,通过新增 object.create() 方法规范化了上面的原型式继承.。 两个参数： 1）参数一：新对象的原型的对象。 2）参数二：先对象定义额外的属性（可选）。 12345678var person = &#123; friends : ["Van","Louis","Nick"]&#125;;var anotherPerson = Object.create(person);anotherPerson.friends.push("Rob");var yetAnotherPerson = Object.create(person);yetAnotherPerson.friends.push("Style");alert(person.friends);//"Van,Louis,Nick,Rob,Style" 123456789var person = &#123; name : "Van"&#125;;var anotherPerson = Object.create(person, &#123; name : &#123; value : "Louis" &#125;&#125;);alert(anotherPerson.name);//"Louis" 4、寄生式继承 寄生继承对原型继承的改进，原型继承生成的子类实例是通过 create 的第二个参数设定的；而寄生式继承是靠函数的封装，将封装好的对象实例进行返回。 ▉ 基本思想 同样调用 object 函数，将返回的对象和对象的额外的方法和属性封装成一个函数进行返回。 ▉ 代码实现1234567function createAnother(original)&#123; var clone = object(original); //通过调用object函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert("hi"); &#125;; return clone; //返回这个对象&#125; ▉ 缺陷 寄生式继承将对象封装起来，导致不能做到函数的复用，使得效率降低。 5、寄生组合式继承 寄生组合式继承就是为了解决组合继承中两次调用构造函数的开销。 ▉ 基本思想 不必为了指定子类型的原型而调用超类型的构造函数（避免第二次调用的构造函数）。 ▉ 代码实现 F 的构造函数指向父类的原型对象，让 F 的实例的 constructor 指向子类构造函数，子类的构造函数的原型指向 F 的实例对象。 1）这样做避免了在 F 的实例上创建不必要的属性，也没有调用 superClass 构造函数。 1234567// subClass:子类构造函数// superClass:父类构造函数function extend(subClass,superClass)&#123; var prototype = object(superClass.prototype);//创建对象 prototype.constructor = subClass;//增强对象 subClass.prototype = prototype;//指定对象&#125; 1subClass.prototype = superClass.prototype;//直接指向超类型prototype 注意：之所以没有进行如上操作，就是因为如上操作只不过是子类和父类共享原型对象，并没有实现继承。 ▉ extend 有效扩展 将 object() 里边的内容扩展开，将整体封装成函数。 1234567891011function extend(subClass, superClass) &#123; var F = function() &#123;&#125;; F.prototype = superClass.prototype; subClass.prototype = new F(); subClass.prototype.constructor = subClass; subClass.superclass = superClass.prototype; if(superClass.prototype.constructor == Object.prototype.constructor) &#123; superClass.prototype.constructor = superClass; &#125;&#125; 三、new 运算符 new 运算符创建对象的过程中，新创建一个对象，然后对对象进行一系列的关联。 创建一个空对象。 将空对象的原型指向构造函数的原型对象。 对构造函数的属性和方法进行浅拷贝到新对象中。 123var obj = &#123;&#125;;obj.__proto__ = F.prototype;F.call(obj);]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>前端深入系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>前端深入系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析之爬虫【基本流程】]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E7%88%AC%E8%99%AB%E3%80%90%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[本篇文章教你数据分析爬虫的基本流程！ 一、爬虫的基本流程 三个基本流程： 打开网页: Request 访问网页，得到服务器返回的数据，包括 HTML 和 JSON 数据。 提取数据: 针对 HTML 使用 XPath 元素定位；针对 JSON 使用 JSON 进行解析。 保存数据：使用 Pandas 保存数据，最后导出 XSL 或 CSV 文件。 1、Request 访问页面 Request 是 Python 的 HTTP 的客户端库，两种访问方式 GET 和 POST 。请求回来的数据可以通过 text 或 content 来获取 HTML 的正文。 1234// get 方式r = requests.get('http://www.douban.com')// post 方式r = requests.post('http://xxx.com', data = &#123;'key':'value'&#125;) 2、XPath 定位 XPath 是 XML 的路径语言，通过元素和属性进行导航，定位位置。 1）XPath 有 100 多个内置函数进行快速的定位。 2）XPath 需要借助一个解析库 lxml 。例如: 1234// 得到 HTML 的所有列表项目from lxml import etreehtml = etree.HTML(html)result = html.xpath('//li') 3、JSON 对象 Python 中有 JSON 库，可以将 Python 对象和 JSON 对象相互转换。 4、使用 JSON 数据爬取实战 抓取的页面时动态页面，需要关注 XHR 数据，动态页面是通过原生的 XHR 数据对象发送 HTTP 请求，得到服务器返回的值，在进行处理。（使用谷歌开发工具可以查看） ▉ 导包123# coding:utf-8import requestsimport json ▉ 查看 XHR 请求的页数1234# range(开始，结束，步长) for i in range(0,23287,20): # XHR 请求的路径 url = 'https://www.douban.com/j/search_photo?q=' + query + '&amp;limit=20&amp;start=' + str(i) ▉ 进行 XHR 请求12# 获取服务器返回的文本html = requests.get(url).text ▉ 将 JSON 对象转化为 Python 对象进行解析12# 将 JSON 转化为 Python 对象response = json.loads(html,encoding='utf-8') ▉ 循环遍历出内容1234567# images: [&#123;src: "https://img3.doubanio.com/view/photo/thumb/public/p637714342.jpg", author: "華生",…&#125;,…]# 获取内容数组response['images']# 获取数组中的每个对象for image in response['images']# 获取每个对象中的值image['src'] ▉ 下载图片12345678910111213def download(src,id): # 设置路径和图片命名 dir = './' + str(id) + '.jpg' try: # timeout 设置爬虫超时操作 pic = requests.get(src,timeout = 10) # 内置函数 open 用于打开文件(wb 二进制文件只写入) fp = open(dir,'wb') # 以二进制方式写入本地文件 fp.write(pic.content) fp.close() except requests.exceptions.ConnectionError: print('图片无法下载') 5、使用 XPath 爬取数据 网页除了用 XHR 做请求，也会用 JS 做请求，如果用到 JS 做请求，那么我们就用 XPath 做解析。用 XPath 做解析必须 JS 请求后接受到整个页面之后，才能进行解析。 1）快速定位 XPath 的方法就是使用谷歌插件 XPath Helper 使用快捷键 Ctrl + Shift + X ,直接定位你想要的元素。 2）使用 lxml 库来进行对获取的网页进行解析。 1、Selenium 模拟测试工具 因为 XPath 的使用必须在页面加载完成才可以，所以使用 Request 获取页面的 HTML 时候，发现 XPath 并不存在，所以必须借助 Selenium 模拟工具（模拟用户操作页面的工具）。 1）必须下载 Driver 执行程序才能正常打开浏览器。 2、代码实现▉ 加载浏览器程序1browser = webdriver.Chrome('C:/Program Files (x86)/Google/Chrome/Application/chromedriver.exe') ▉ 打开指定网址12// 尽情请求browser.get(url) ▉ 获取网页源代码1234// 获取打开网页的源代码browser.page_source// 转化为可以被 lxml 解析的对象html = etree.HTML(browser.page_source) ▉ 获取到 XPath 匹配的元素12src_xpath = "//div[@class='result']/div[@class='pic']/a[@class='nbg']/img/@src"srcs = html.xpath(src_xpath) ▉ 遍历获取数据1234# zip 将对象中对应的元素打包成元组for src,title in zip(srcs,titles): print(src) download(src,title.text)]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吃透 JQuery 之【完整篇】]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%90%83%E9%80%8F%20JQuery%20%E4%B9%8B%E3%80%90%E5%AE%8C%E6%95%B4%E7%AF%87%E3%80%91%2F</url>
    <content type="text"><![CDATA[一篇 JQuery 核心内容文章！ [TOC] 一、选择器1、基本选择器1.1 按 ID 查找 返回 jQuery 对象，jQuery 对象类似数组，每个元素都是引用了 DOM 节点的对象。[&lt;div id=&quot;abc&quot;&gt;...&lt;/div&gt;]，如果找不到该对象，返回 [] 空对象。 123// 按照 ID 查找&lt;div id="abc"&gt;&lt;/div&gt;var div = $('#abc'); jQuery 对象与 DOM 对象之间的转化： 123var div = $('#abc'); // 获取 jQuery 对象 ‘#abc’ 执行了 document.getElementById('#abc');var divDOM = div.get(0);// 获取第一个 DOM 对象var anthor = $(divDOM); // 重新把 DOM 封装为 jQuery 对象 1.2 按 tag 查找12var ps = $('p');//获取所有的 &lt;p&gt; 节点ps.length; //统计 &lt;p&gt; 节点的个数 1.3 按 class 查找 查找之前要加一个 ‘.’； 1var ps = $('.red');// 所有节点包含`class="red"`都将返回 1.4 按属性查找 DOM 节点很多属性，可以根据属性来快速定位节点。 1234567// 找出属性为 [name=email] 的节点var email = $('[name^=email]');// 按属性查找使用前缀或后缀查找var icons = $('name^= icon') // 找出所有 name 属性值以 icon 开头的 DOMvar names = $('[name$=with]'); // 找出所有 name 属性值以 with 结尾的 DOMvar icons = $('[class^="icon-"]'); // class 经常使用到 1.5 组合查找 通常选择会选择所有的属性，但是有时我们只选择某标签里的属性进行使用。 1234// 标签和属性组合var emilInput = $('input[name = email]');// 标签和 Class 组合var tr = $('tr.red'); 1.6 多项选择器 多个选择器用 ， 组合起来一块选。选出来的元素是按照它们在 HTML 中出现的顺序排列的，而且不会有重复元素。 1234// 把 &lt;p&gt; 和 &lt;div&gt; 都选出来$('p,div')// 把 &lt;p class="red"&gt; 和 &lt;p class="green"&gt; 都选出来$('p.red,p.green') 2、层级选择器 由于 DOM 的结构是层级结构，经常需要根据层级来进行选择，所以 jQuery 层级选择器更加灵活。 优点： 层级选择器的好处就是在于缩小了选择的范围，定位父元素后再定位子元素，避免了不相干页面的干扰。 2.1 层级选择器 如果两个 DOM 元素有层级结构，可以使用 $(&#39;ancestor descendant&#39;) 来选择，层级之间需要用空格隔开。 1$('form[name=upload] input'); 2.2 子选择器（Child Selector） 类似层级选择器，但是限定了只能选择父元素的子元素。 1$('ul &gt; li') //选择 &lt;ul&gt; 父节点下的子节点 &lt;li&gt; 2.3 过滤器（Filter） 过滤器通常不单独使用，附加到选择器中使用，更精确的定位元素。 12345678910$('ul.lang li'); // 选出 JavaScript、Python 和 Lua 3个节点// 选择节点的第一个节点$('ul.lang li:first-child'); // 仅选出 JavaScript// 选择最后一个元素$('ul.lang li:last-child'); // 仅选出 Lua// 选出第 n 的元素，n 从 1 开始$('ul.lang li:nth-child(2)'); $('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素$('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素 2.4 表单相关 针对表单，jQuery 有一组特殊的选择器。 :input：可以选择 &lt;input&gt;，&lt;textarea&gt;，&lt;select&gt; 和 &lt;button&gt;； :file：可以选择 &lt;input type=&quot;file&quot;&gt; 和 input[type=file] 一样； :checkbox：可以选择复选框，和 input[type=checkbox] 一样； :radio：可以选择单选框和 input[type=radio] 一样； :focus：可以选择当前输入焦点的元素，例如把光标放到一个 &lt;input&gt; 上，用 $(&#39;input:focus&#39;) 就可以选出； :checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$(&#39;input[type=radio]:checked&#39;)； :enabled：可以选择可以正常输入的 &lt;input&gt;、&lt;select&gt; 等，也就是没有灰掉的输入； :disabled：和 :enabled 正好相反，选择那些不能输入的。 12$('div:visible'); // 所有可见的div$('div:hidden'); // 所有隐藏的div 3、查找和过滤 最常用的是在某个节点的所有子节点中查找，使用 find 方法，接受一个选择器进行选择。 1234567&lt;ul class="lang"&gt; &lt;li class="js dy"&gt;JavaScript&lt;/li&gt; &lt;li class="dy"&gt;Python&lt;/li&gt; &lt;li id="swift"&gt;Swift&lt;/li&gt; &lt;li class="dy"&gt;Scheme&lt;/li&gt; &lt;li name="haskell"&gt;Haskell&lt;/li&gt;&lt;/ul&gt; 1234var ul = $('ul.lang'); // 获得 &lt;ul&gt;var dy = ul.find('.dy'); // 获得 JavaScript, Python, Schemevar swf = ul.find('#swift'); // 获得 Swiftvar hsk = ul.find('[name=haskell]'); // 获得 Haskell 向上查找使用 parent() 方法： 123var swf = $('#swift'); // 获得Swiftvar parent = swf.parent(); // 获得 Swift 的上层节点 &lt;ul&gt;var a = swf.parent('.red'); // 获得 Swift 的上层节点 &lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空 jQuery 对象 同级元素使用 next（） 和 prev（） 方法： 1234567var swift = $('#swift');swift.next(); // Schemeswift.next('[name=haskell]'); // 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]swift.prev(); // Pythonswift.prev('.dy'); // Python，因为 Python 同时符合过滤器条件.dy 3.1 过滤 函数式编程中的 map、filter类似，jQuery 也有自己类似的方法。 filter() 方法： 12var langs = $('ul.lang li');// 拿到 JavaScript, Python, Swift, Scheme 和 Haskellvar a = langs.filter('.dy') // 拿到 JavaScript, Python, Scheme 12345678//传入一个函数var langs = $('ul.lang li'); // 拿到 JavaScript, Python, Swift, Scheme 和 Haskelllangs.filter( function () &#123; // 函数内部的 this 被绑定为 DOM 对象，不是 jQuery 对象 return this.innerHTML.indexOf('S') === 0; // 检查每个子节点，返回 S 开头的节点 &#125;); // 拿到Swift, Scheme map() 方法：把一个 jQuery 对象包含的若干 DOM 节点转化为其他对象 。 12345var langs = $('ul.lang li'); // 拿到 JavaScript, Python, Swift, Scheme 和 Haskellvar arr = langs.map(function () &#123; return this.innerHTML;&#125;).get(); // 用 get() 拿到包含 string 的 Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell'] 一个jQuery对象如果包含了不止一个DOM节点，first()、last()和slice()方法可以返回一个新的 jQuery对象，把不需要的 DOM 节点去掉： 1234var langs = $('ul.lang li'); // 拿到 JavaScript, Python, Swift, Scheme 和 Haskellvar js = langs.first(); // JavaScript，相当于 $('ul.lang li:first-child')var haskell = langs.last(); // Haskell, 相当于 $('ul.lang li:last-child')var sub = langs.slice(2, 4); // Swift, Scheme 参数和数组的 slice() 方法一致 1234567var inputs = $(&apos;#test-form :input&apos;).not(&apos;button&apos;);var obj = &#123;&#125;;inputs.filter(function()&#123; if(this.type !== &quot;radio&quot; || this.checked); obj[this.name] = this.value;&#125;)json = JSON.stringify(obj); 二、操作 DOM1. 操作 DOM1.1 修改 Text 和 HTML jQuery 对象的 text() 和 html() 方法分别获取节点文本和原始的 HTML 文本。 1）jQuery 可以获取一组数据进行统一设置文本。 2）jQuery 如果不存在结点对象，将不会报错。 1234&lt;ul id="test-ul"&gt; &lt;li class="js"&gt;JavaScript&lt;/li&gt; &lt;li name="book"&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt; 1234567// 获取文本$('#test-ul li[name=book]').text(); // 'Java &amp; JavaScript'$('#test-ul li[name=book]').html(); // 'Java &amp;amp; JavaScript'// 设置文本$('#test-ul li[name=book]').text('JavaScript &amp; ECMAScript'); $('#test-ul li[name=book]').html('&lt;span style="color: red"&gt;JavaScript&lt;/span&gt;'); 1.2 修改 CSS 调用 jQuery 对象的 css(&quot;name&quot;,&quot;value&quot;) 方法。 1）CSS 属性可以使用 &#39;background-color&#39; 和 &#39;backgroundColor&#39;两种格式。 2）css() 方法将作用于 DOM 节点的 style 属性，具有最高的优先级。 12// 注意：jQuery 的所有方法返回的是对象，可以链式调用。$('#test-css li.dy&gt;span').css('background-color', '#ffd351').css('color', 'red'); 修改 class 属性，jQuery 提供一下方法： 1234var div = $('#test');div.hasClass('container');// 判断该结点 class 是否包含 container 属性div.addClass('container');// 添加 container 这个 Classdiv.removeClass('container'); // 删除 container 这个 Class 1.3 显示和隐藏 DOM 显示或隐藏 DOM 需要设置 CSS 属性的 display 属性。 1）隐藏 DOM 需要设置 CSS 的 display 属性为 none。 2）显示 DOM 需要知道 display 之前的属性（block,inline）。 3）jQuery 对象提供的 show() 和 hide() 方法。 123var a = $('div');a.hide(); // 隐藏a.show(); // 显示(并没有删除 DOM 结点，影响了 DOM 结点的显示) 1.4 获取 DOM 信息 无序针对特定的浏览器编写特定的代码，jQuery 对象的方法直接获取。 1）操作 DOM 节点的属性：attr() 和 removeAttr() 方法。 2）操作 H5 中无值属性：prop() 但会 boolean 值，也可以用 is 判断。 1234567891011121314// 浏览器可视窗口大小:$(window).width(); // 800$(window).height(); // 600// HTML文档大小:$(document).width(); // 800$(document).height(); // 3500// 某个div的大小:var div = $('#test-div');div.width(); // 600div.height(); // 300div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效 123456var div = $('#test-div');div.attr('data');// undefined 属性值不存在div.attr('name');// test 获取属性值div.attr('name','Hello'); // 设置属性值div.removeAttr('name'); //删除 name 属性div.attr('name'); // undefined 123456&lt;input id="test-radio" type="radio" name="test" checked value="1"&gt;var radio = $('#test-radio');radio.prop('checked'); // trueradio.is(':checked'); // trueis(':selected');// 下拉属性判断 1.5 操作表单 对于 jQuery 操作表单，统一使用 val() 方法获取和设置对应的 value 属性： 12345678910111213141516171819202122/* &lt;input id="test-input" name="email" value=""&gt; &lt;select id="test-select" name="city"&gt; &lt;option value="BJ" selected&gt;Beijing&lt;/option&gt; &lt;option value="SH"&gt;Shanghai&lt;/option&gt; &lt;option value="SZ"&gt;Shenzhen&lt;/option&gt; &lt;/select&gt; &lt;textarea id="test-textarea"&gt;Hello&lt;/textarea&gt;*/var input = $('#test-input'), select = $('#test-select'), textarea = $('#test-textarea');input.val(); // 'test'input.val('abc@example.com'); // 文本框的内容已变为abc@example.comselect.val(); // 'BJ'select.val('SH'); // 选择框已变为Shanghaitextarea.val(); // 'Hello'textarea.val('Hi'); // 文本区域已更新为'Hi' 2、修改 DOM 原生的浏览器 API 修改 DOM 需要根据不同的浏览器进行写不同的代码。 2.1 添加 DOM 添加 DOM 结点除了使用 html() 方法外还可以使用 append() 方法。 1) append() 方法可以接收一下几个参数： DOM 对象 jQuery 对象 函数对象(该函数要返回一个字符串、DOM 对象、jQuery对象) 2）append() 把DOM添加到最后，prepend() 则把 DOM 添加到最前。 3）after() 方法和 before() 方法将 DOM 插入指定位置。 123456789/*&lt;div id="test-div"&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;*/var ul = $('#test-div&gt;ul');ul.append('&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'); 12345678910111213// 创建DOM对象:var ps = document.createElement('li');ps.innerHTML = '&lt;span&gt;Pascal&lt;/span&gt;';// 添加DOM对象:ul.append(ps);// 添加jQuery对象:ul.append($('#scheme'));// 添加函数对象:ul.append(function (index, html) &#123; return '&lt;li&gt;&lt;span&gt;Language - ' + index + '&lt;/span&gt;&lt;/li&gt;';&#125;); 注意：jQuery的 append() 可能作用于一组 DOM 节点，只有传入函数才能针对每个 DOM 生成不同的子节点。 12var js = $('#test-div&gt;ul&gt;li:first-child');js.after('&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'); 2.2 删除节点 拿到 jQuery 对象之后，直接执行 remove() 方法可以删除一组或单个节点。 3、事件 1) 浏览器获取到鼠标事件，自动在对应的 DOM 结点上触发响应的时间，如果该结点绑定了函数，函数就触发响应的事件，然后调用绑定了对应的 javascript 处理函数，该函数就会自动调用。 2) 不同浏览器的代码是不一样的，jQuery 屏蔽了不同浏览器的差异。 123a.on('click', function () &#123; alert('Hello!');&#125;); 3.1 鼠标事件 click : 单击事件 dbclick: 双击事件 mouseenter: 鼠标进入时触发 mouseleace: 鼠标离开时触发 mousemove: 鼠标在 DOM 内部移动时触发 hover: 鼠标进入和退出时触发两个函数，相当于 mouseenter 加上 mouseleave。 3.2 键盘事件 键盘事件仅作用在当前焦点 DOM 上，通常是 &lt;imput&gt; 和 &lt;textarea&gt;。 keydown：键盘按下时触发 keyup：键盘松开时触发 keypress：按一次键后触发 3.3 其他事件 focus：当 DOM 获取焦点时触发； blur：当 DOM 失去焦点时触发； change：当 &lt;input&gt;、&lt;select&gt; 或 &lt;textarea&gt; 的内容改变时触发； submit：当 &lt;form&gt; 提交时触发； ready：当页面被载入并且 DOM 树完成初始化后触发（仅作用于 document 对象）。 12 3.4 事件参数 有些事件需要传入参数，获取到按键的值和鼠标的位置。所有事件都传入 Event 对象作为参数。 12345$(function () &#123; $('#testMouseMoveDiv').mousemove(function (e) &#123; $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY); &#125;);&#125;); 3.5 取消绑定 一个绑定的事件可以被解除，通过 off（‘click’, function） 实现： 1) off 无参会一次性移除已绑定的所有类型的事件处理函数。 12345678910function hello() &#123; alert('hello!');&#125;a.click(hello); // 绑定事件// 10秒钟后解除绑定:setTimeout(function () &#123; a.off('click', hello);&#125;, 10000); 3.6 事件触发条件 事件的触发是由用户操作引发的。 1）change 事件的触发是由用户改变文本框内容触发的，在 js 修改文本框内容则不会触发。 2）用代码触发 change 事件，可以直接调用无参数的 change() 方法来触发事件。 1234var input = $('#test-input');input.change(function () &#123; console.log('changed...');&#125;); 123var input = $('#test-input');input.val('change it!');input.change(); // 触发change事件,相当于 input.trigger('change') 3.7 浏览器安全限制 有些 javascript 代码只有用户触发才能执行，如 window.open() 函数。 1234// 无法弹出新窗口，将被浏览器屏蔽:$(function () &#123; window.open('/');&#125;); 4、AJAX jQuery 的 AJAX 不用针对不同浏览器写不同代码，代码也得到很大的简化。 4.1 ajax jQuery 在全局对象中（$）绑定了 ajax() 函数。 1）ajax(url,settings) 函数需要接收一个 URL 和一个可选的 settings 对象 async ：默认 true method： 发送的 Method ，默认为 GET。 contentType： 发送的 POST 格式，默认值为 &#39;application/x-www-form-urlencoded; charset=UTF-8&#39; 其余格式为 text/plain、application/json； data： 发送的数据，可以是字符串、数组或 object。如果是 GET 请求，data 转换为 query 附加到 URL 上。如果是 POST 根据 contentType 将数据序列化成合适的格式； headers： 发送额外的 HTTP 头，必须是一个 object; dataType：接受的数据格，html 、xml、json 、text 等，没有设置的情况下根据 contentType 来定义。 123var jqxhr = $.ajax('/api/categories',&#123; dataType: 'json'&#125;) 响应方式： 123456789var jqxhr = $.ajax('/api/categories', &#123; dataType: 'json'&#125;).done(function (data) &#123; ajaxLog('成功, 收到的数据: ' + JSON.stringify(data));&#125;).fail(function (xhr, status) &#123; ajaxLog('失败: ' + xhr.status + ', 原因: ' + status);&#125;).always(function () &#123; ajaxLog('请求完成: 无论成功或失败都会调用');&#125;); 4.2 get 方法 最常见的写法；第二个参数会被拼接到 url 后边 1234var jqxhr = $.get(url, &#123; name: 'Bob Lee', check: 1&#125;); 1url?name=Bob%20Lee&amp;check=1 4.3 post 方法 虽然写法和 GET 类似，但是第二个参数被序列化了为 application/x-www-form-urlencoded。 1234var jqxhr = $.post('/path/to/resource', &#123; name: 'Bob Lee', check: 1&#125;); 4.4 getJSON 对象 通过 getJSON() 方法来快速通过 GET 获取一个 JSON 对象： 123456var jqxhr = $.getJSON('/path/to/resource', &#123; name: 'Bob Lee', check: 1&#125;).done(function (data) &#123; // data已经被解析为JSON对象了&#125;); 4.5 安全限制 关于跨域，jQuery 也是有限制的，和 JavaScript 一样。如果跨域加载数据，设置 jsonp：‘callback’ ，这样就可以实现 jQuery 加载跨域数据了。 5、动画 jQuery 封装的动画非常简单，只需要一行代码就可以搞定。 5.1 show/hide 无参的show() hide() 方法用于隐藏、显示元素，传入一个时间参数就会变成动画。 1）参数可以是&#39;slow&#39;，&#39;fast&#39; 。 2）toggle() 根据当前的状态来决定显示还是隐藏。 12var div = $('#id');div.hide(3000); // 在 3 秒钟内逐渐消失 5.2 slideUp / slideDown 这两个方法是垂直方向消失和隐藏的。 1) slideToggle() 根据状态来决定。 12var div = $('#id');div.slideUp(3000); // 在3秒钟内逐渐向上消失 5.3 fadeIn/fadeOut 这两个方法的动画就是淡入淡出，通过设置 opacity 来实现的。 1）fadeToggle() 决定是否状态是否改变。 12var div = $('#id');div.fadeOut('slow'); // 在 0.6 秒内淡出 5.4 自定义动画 animate() 可以实现自定义动画，传入的参数就是 DOM 元素最终的 CSS 状态和时间。 123456var div = $('#id');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000); // 在 3 秒钟内 CSS 过渡到设定值 第三个参数就是传入一个函数。 12345678910var div = $('#test-animate');div.animate(&#123; opacity: 0.25, width: '256px', height: '256px'&#125;, 3000, function () &#123; console.log('动画已结束'); // 恢复至初始状态: $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px');&#125;); 5.5 串行动画 动画可以串行执行，通过 delay（） 方法可以实现暂停，可以实现更复杂的动画效果。 1234567891011121314var div = $('#id');// 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小div.slideDown(2000) .delay(1000) .animate(&#123; width: '256px', height: '256px' &#125;, 2000) .delay(1000) .animate(&#123; width: '128px', height: '128px' &#125;, 2000);&#125; 5.6 动画设置失败 1）有的动画没有效果，jQuery 动画的原理是逐渐改变 CSS 的值。很多元素不是 block 性质的 DOM 元素，对它们设置有的属性不起作用，所以没有动画效果。 2）jQuery也没有实现对background-color的动画效果，用animate()设置background-color也没有效果 。只能借助 CSS3 动画。]]></content>
      <categories>
        <category>前端</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之题型篇【链表】]]></title>
    <url>%2F2019%2F04%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A2%98%E5%9E%8B%E7%AF%87%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[有关链表的所有操作和题型的详细解析和扩展。 [TOC] 写在前边 如果你和小鹿一样，刚开始对链表的操作代码实现很懵的话，不妨按照小鹿经过一个月的时间对链表相关操作以及题型的整理总结，由浅入深进行适当的练习，我相信，当你真正的练习完这些题目，不但会让你放下对链表心理上的困惑，而且对你学习其他数据结构有很大的信心和帮助！ 1、学习建议 小鹿不建议你一口气去看完这篇所有的题目和练习，给自己制定一个小计划，我当初整理该题目的时候，每天都计划认真整理一到题目，把每道题分析透，这样才能达到最好的吸收效果。 2、学习路径 本篇分为三个阶段，基础练习阶段、进阶练习阶段、加强练习阶段。 1）基础练习阶段 首先进行第一个阶段之前，你已经对链表的基础知识能够熟练掌握，但是对于没有动手写过链表代码，那么你从第一阶段最基础的开始进行。确保每一个基础点要亲自动手用自己熟悉的语言写出来，虽然本篇中基本都是 javascript 代码实现的，但是算法思路是一成不变的，如果遇到困难可以自行百度或谷歌，也可以下方给我进行留言。 2）进阶练习阶段 如果你对上述的链表基本代码已经完全熟练掌握了，那么恭喜你可以进行下一个阶段，进阶阶段，这一阶段增加的难度就是链表的操作是对于实际问题来解决的，所以非常锻炼你对问题的分析能力和解决能力，也考验你对代码的全面性、鲁棒性。这一阶段非常的重要，下面的每道题我都做出了详细的分析。 3）加强练习阶段 如果上述的进阶练习阶段的题型你都了如指掌了，那么不妨我们实战一下，LeetCode 汇聚了很多面试的题型，所以我在上边整理了几个经典的题目，你可以尝试着解答它们，相关题目的代码以及解题思路我都整理好了。这一阶段的题目小鹿会在后期不断的更新，这些题目你能够完全掌握，链表对你来说小菜一碟了。 一、链表基础练习（阶段一） 自己首相尝试着一个个攻破下方的链表中最基础的操作，相关代码我也整理好了（先自己尝试着去解决哦）。 单链表的插入、删除、查找操作（点击查看代码实现）。 循环链表的插入、删除、查找操作 (点击查看代码实现)。 双向链表的插入、删除、查找操作 (点击查看代码实现)。 二、链表进阶练习（阶段二）1、单链表从尾到头打印 题目：输入一个链表的头结点，从尾到头反过来打印出每个节点的值。 1.1 问题分析与解决▉ 问题分析 1）看到题目第一想到的就是反转链表在打印输出，一种反转链表的方法，但是这种方法改变了原有的链表结构。 缺点：使得链表的结构发生改变了。如果不改变链表结构应该怎么解决？ 2）从问题中可以得出，我们想要从尾到头打印链表，正常情况下是从头到尾打印的，我们就会想到最后的数据先打印，开始的数据最后打印，有种“先进后出”的特点，我们就能想到用“栈”这种结构，用栈来实现。 缺点：代码不够简洁。 优点：鲁棒性好（在不确定的情况下，程序仍然可以正确的执行）。 3）提到栈这种数据结构，我们就会想到“递归”的实现就是用栈这种数据结构实现的。既然栈能实现，那么递归也能实现。 缺点：如果链表很长，递归深度很深，导致堆栈溢出。 优点：代码简洁、明了。 ▉ 算法思路 得出以下几种实现方式： 反转链表法 栈实现 递归实现 1）反转链表实现： 从尾到头输出链表的内容，一般的思路就是将链表反转过来，然后从头到尾输出数据。 2）栈实现 从头到尾遍历单链表，将数据存储按照顺序存储到栈中。然后遍历整个栈，打印输出数据。 2）递归实现： 可以通过递归的方式来实现单链表从尾到头依次输出，递归过程涉及到“递”和“归”，反转链表输出数据，正式利用了循环“递”的过程，所以数据先从头部输出，那么递归采用的是“归”的过程来输出内容，输出当前结点先要输出当前节点的下一节点。 ▉ 测试用例 在写代码之前，要想好测试用例才能写出健全、鲁棒性的代码，也是为了考虑到边界情况，往往也是整个程序最致命的地方，如果考虑不全面，就会出现 bug，导致程序崩溃。 测试用例： 1）输入空链表； 2）输入的链表只有一个结点； 3）输入的链表有多个结点。 ▉ 代码实现：反转链表法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 //定义结点class Node&#123; constructor(data)&#123; this.data = data; this.next = null; &#125;&#125;//定义链表class LinkedList&#123; constructor()&#123; this.head = new Node('head'); &#125; // 功能：单链表反转 // 步骤: // 1、定义三个指针(pre=null/next/current) // 2、判断链表是否可反转(头节点是否为空、是否有第二个结点) // 3、尾指针指向第一个结点的 next // 4、尾指针向前移动 // 5、当前指针(current)向后移动 // 6、将 head 指向单转好的结点 reverseList = () =&gt;&#123; //声明三个指针 let current = this.head; //当前指针指向头节点 let pre = null;//尾指针 let next;//指向当前指针的下一个指针 //判断单链表是否符合反转的条件(一个结点以上)？ if(this.head == null || this.head.next == null) return -1; //开始反转 while(current !== null)&#123; next = current.next; current.next = pre; pre = current; current = next; &#125; this.head = pre; &#125; //输出结点 print = () =&gt;&#123; let currentNode = this.head //如果结点不为空 while(currentNode !== null)&#123; console.log(currentNode.data) currentNode = currentNode.next; &#125; &#125;&#125; ▉ 代码实现：循环栈12345678910111213//方法三：栈实现const tailToHeadOutput = (currentNode)=&gt;&#123; let stack = []; //遍历链表，将数据入栈 while(currentNode !== null)&#123; stack.push(currentNode.data); currentNode = currentNode.next; &#125; //遍历栈，数据出栈 while(stack.length !== 0)&#123; console.log(stack.pop()); &#125;&#125; ▉ 代码实现：递归1234567891011121314151617// 步骤:// 1、判断是否为空链表// 2、终止条件（下一结点为空）// 3、递归打印下一结点信息const tailToHeadOutput = (head)=&gt;&#123; // 判断是否空链表 if(head !== null)&#123; // 判断下一结点是否为空 if(head.next !== null)&#123; // 下一结点不为空，先输出下一结点 tailToHeadOutput(head.next) &#125; console.log(head.data); &#125;else&#123; console.log("空链表"); &#125;&#125; ▉ 性能分析 反转链表实现： 时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。 空间复杂度：O(1)。不需要额外的栈存储空间，空间复杂度为 O(1)。 循环栈实现： 时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。 空间复杂度：O(n)。需要额外的栈存储空间，空间复杂度为 O(n)。 递归实现： 时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。 空间复杂度：O(n)。需要额外的栈存储空间，空间复杂度为 O(n)。 2.2 小结▉ 考察内容 1）对单链表的基本操作。 2）代码的鲁棒性。 3）循环、递归、栈的灵活运用。 ▉ 扩展思考：循环和递归 适用条件：如果需要进行多次计算相同的问题，将采用循环或递归的方式。 递归的优点：代码简洁。 递归的缺点： 1）堆栈溢出：函数调用自身，函数的临时变量是压栈的操作，当函数执行完，栈才清空，如果递归的规模过大，在函数内部一直执行函数的自身调用，临时变量一直压栈，系统栈或虚拟机栈内存小，导致堆栈溢出。 2）重复计算：递归会出现很多的重复计算问题，重复计算对程序的性能有很大影响，导致消耗时间成指数增长，但是可以通过散列表的方式解决。 3）高空间复杂度：递归的每次函数调用都要涉及到在内存开辟空间，压栈、出栈等操作，即耗时又耗费空间，导致递归的效率并不如循环的效率。 扩展： 1）递归—栈：递归的本质是栈，通常用栈循环解决的问题适合于递归。 2）递归-动态规划：动态规划解决问题经常用递归的思路分析问题。关于递归重复计算问题，我们通常使用自下而上的解决思路（动态规划）来解决递归重复计算的问题。 ▉ 注意事项： 1）涉及到循环解决的问题，可以想一想能不能使用递归来解决。 2）用递归解决一定要铭记递归的缺点带来的性能问题。 3）递归解决的问题，能不能用动态规划来解决，使得性能更高。 4）用到栈这种数据结构，想一想递归是否可以实现呢。 2、删除链表结点 题目：在 O（1）的时间复杂度内删除链表节点。 给定单向链表的头指针和一个节点指针，定义一个函数在 O（1）时间内删除该节点。 2.1 问题分析与解决▉ 问题分析 1）想必看到单链表删除节点的题，第一想到的就是删除链表结点需要以 O（n）时间复杂度遍历链表找到该结点的前结点，然后以 O（1）时间复杂度进行删除，时间复杂度为O（n）。而题目中的确实整体要求时间复杂度为 O（1）。 2）怎么才能达到 O（1）的时间复杂度删除链表？如果不遍历不就可以了？如果直接删除的时间复杂度为 O（1），前提是我们需要知道前结点才能做到。我们就会想怎么做到不用遍历数据才能获取到前结点呢？而且必须保证时间复杂度为 O（1）。 3）但是必须让自己多想一步就是如果删除的结点是尾结点怎么操作，如果删除的链表结点只有一个结点，即是尾结点又是头结点怎么办？ ▉ 算法思路 得出以下几种实现方式： 交换结点法 1）这一有种技巧很难想到，就是我把当前结点的数据与下一结点的数据进行交换，删除下一结点不就可以达到时间复杂度为O（1）了吗。而且我们知道当前结点就是下一结点的前节点，perfect。 2）针对以上两种特殊情况，如果是尾结点，没有下一结点，我们就从头遍历链表删除节点；如果即是尾结点又是头结点，那么删除头结点，并置于 null。 ▉ 测试用例 1) 输入空链表； 2）在多个结点链表中删除中间结点； 3）在多个链表中删除头结点； 4）在多个链表总删除尾结点； 5）在只有一个结点链表中删除唯一结点； ▉ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 定义结点class Node&#123; constructor(data)&#123; this.data = data; this.next = null; &#125;&#125;// 定义链表class LinkedList&#123; constructor()&#123; this.head = new Node('head'); &#125; //根据 value 查找结点 findByValue = (value) =&gt;&#123; let currentNode = this.head; while(currentNode !== null &amp;&amp; currentNode.data !== value)&#123; currentNode = currentNode.next; &#125; //判断该结点是否找到 console.log(currentNode) return currentNode === null ? -1 : currentNode; &#125; //插入元素(指定元素向后插入) insert = (value,element) =&gt;&#123; //先查找该元素 let currentNode = this.findByValue(element); //如果没有找到 if(currentNode == -1)&#123; console.log("未找到插入位置!") return; &#125; let newNode = new Node(value); newNode.next = currentNode.next; currentNode.next = newNode; &#125; //遍历所有结点 print = () =&gt;&#123; let currentNode = this.head //如果结点不为空 while(currentNode !== null)&#123; console.log(currentNode.data) currentNode = currentNode.next; &#125; &#125; // 删除节点(核心代码) deleteNode = node =&gt;&#123; // 判断当前查找的结点是否为 null if(node == null) return -1; // 1、查找删除的结点 let d_node = this.findByValue(parseInt(node.data)) // 2、判断该结点是否为尾结点 if(d_node.next == null)&#123; // 重新遍历链表 let p = null; let current = this.head; while(current.next !== null)&#123; p = current; current = current.next; &#125; // 尾结点置为 null p.next = null; &#125;else&#123; // 3、将删除结点的值与下一结点交换 d_node.data = d_node.next.data; // 4、删除下一结点 d_node.next = d_node.next.next; &#125; &#125;&#125;// 测试 sortedList1 = new LinkedList()sortedList1.insert(1, 'head')sortedList1.insert(2, 1)sortedList1.insert(3, 2)sortedList1.insert(4, 3)sortedList1.print();console.log('------------------------------删除指定结点----------------------------')let dnode = new Node('1')sortedList1.deleteNode(dnode)sortedList1.print(); ▉ 性能分析 时间复杂度：O（1）。经过上述的方法，删除一个链表的结点，除了删除一个链表的尾结点之外，其他删除节点的时间复杂度为 O（1），获取删除的结点的前一结点，时间复杂度为 O（1），删除节点的时间复杂度为 O（1）。只有删除尾结点才需要遍历整个链表，但大部分删除节点是 O（1）的。使用分析时间复杂度的一个方法摊还分析，将删除节点的时间复杂度平均分到其他大部分情况下，所以平均时间复杂度为 O（1）。 空间复杂度：O（1）。不需要额外的内存空间。 2.2 小结▉ 内容考察 1）对单链表的删除基本操作。 2）对问题的有创新思维的解决能力：能不能将复杂问题的根源用另一种思维去优化。 3）问题考虑的全面性：考虑到问题出现的各种特殊情况，以及边界问题。 3、链表中的倒数第 K 个结点 题目：输入一个链表，输出该链表中倒数第 K 个节点。为符合大多数人的习惯，从 1 开始计数，即链表的尾结点是倒数第一个节点。 3.1 问题分析与解决▉ 问题分析 1）看到这个题的第一想法就是从链表头遍历到链表尾部，然后尾部倒数 k 个数，因为是单链表，所以倒数并不能实现，想法行不通。 2）那我们只能将思路转移到头结点开始，怎么才能从头结点开始遍历到倒数第 k 个结点呢？大体我们可以得出至少需要遍历两次链表。 3）上述能不能再优化呢？遍历一次链表就可以完成查找？ ▉ 算法思路 得出以下几种实现方式： 两次遍历法 一次遍历法 前提条件： 1）不要忘记判断单链表是否为环型结构 两次遍历法： 1）有一个规律就是链表的长度 n 减去 k 加 1 就是倒数第 k 个数据。所以需要遍历链表得到链表的长度，然后再遍历两次找到链表的倒数第 k 个数据。整个过程需要遍历两遍链表。 一次遍历法： 1）那我们就用到双指针，第一个指针指向第一个结点，第二个指针指向 k - 1 个结点，同时向前移动，直到第二个节点指向尾结点位置，第一个节点就指向了倒数第 k 结点。遍历一遍链表就完成查找。 ▉ 测试用例 1）k 的取值范围（0 &lt; k &lt; n）;输入不在范围内的数据。 2）输入空链表。 3）查找倒数第 k 结点为头结点/尾结点。 ▉ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// 定义结点class Node&#123; constructor(data)&#123; this.data = data; this.next = null; &#125;&#125;// 定义链表class LinkedList&#123; constructor()&#123; this.head = new Node('head'); &#125; //根据 value 查找结点 findByValue = (value) =&gt;&#123; let currentNode = this.head; while(currentNode !== null &amp;&amp; currentNode.data !== value)&#123; currentNode = currentNode.next; &#125; //判断该结点是否找到 console.log(currentNode) return currentNode === null ? -1 : currentNode; &#125; //插入元素(指定元素向后插入) insert = (value,element) =&gt;&#123; //先查找该元素 let currentNode = this.findByValue(element); //如果没有找到 if(currentNode == -1)&#123; console.log("未找到插入位置!") return; &#125; let newNode = new Node(value); newNode.next = currentNode.next; currentNode.next = newNode; &#125; //遍历所有结点 print = () =&gt;&#123; let currentNode = this.head //如果结点不为空 while(currentNode !== null)&#123; console.log(currentNode.data) currentNode = currentNode.next; &#125; &#125; // 检测单链表是否为环 checkCircle = ()=&gt;&#123; // 判断是否为空链表 if(this.head == null) return fast; // 定义快慢指针 let fast = this.head.next; let low = this.head; //进行循环判断(当前 fast 结点/fast 移动两步后的结点是否为 null) while(fast !== null &amp;&amp; fast.next !== null)&#123; // fast 指针向前移动两步 fast = fast.next.next; // low 指针向前移动一步 low = low.next; // 如果为环，总有一天会相遇 if(fast === low) return true; &#125; return false; &#125; // 查找倒数第 k 结点 findByIndexFromEnd = k =&gt;&#123; //判断 k 是否大于0 if(k &lt; 1) return 'k 的大小不在搜索范围内'; // 检测是否为环 if(this.checkCircle()) return false; // 定义两个指针进行遍历 let current = this.head; let fast = current; let low = current; let pos = 0; for(let i = 1;i &lt;= k - 1;i++)&#123; if(fast.next !== null)&#123; fast = fast.next; &#125;else&#123; // k 的大小超出链表大小的范围 return 'k 的大小超出链表的范围'; &#125; &#125; // low 和 fast 指针同时移动 while(fast.next !== null)&#123; fast = fast.next; low = low.next; &#125; // 返回倒数第 k 结点 return low; &#125;&#125;// 测试const list = new LinkedList();list.insert('1','head');// list.insert('2','1');// list.insert('3','2');// list.insert('4','3');// list.insert('5','4');// list.insert('6','5');list.print();console.log('-------------------查找倒数第 k 结点----------------')console.log(list.findByIndexFromEnd(8)); ▉ 性能分析 两次遍历法： 时间复杂度：O（k*n）。当 k 趋近于 n 时，最坏时间复杂度为 O（n^2）。 空间复杂度：O（1）。不需要额外的内存空间。 一次遍历法： 时间复杂度：O（n）。只需要遍历一次单链表，所以时间复杂度为O（n）。 空间复杂度：O（1）。不需要额外的内存空间。 3.2 小结▉ 内容考察 1）对单链表的基本操作。 2）代码的全面性、鲁棒性。 ▉ 注意事项 1）当我们用一个指针不能解决时，想一想两个指针能否解决？ ▉ 相关题目 1）求中间结点 2）求倒数第 k 个结点 3）检测环的存在 4、反转链表 题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转链表的头结点。 4.1 问题分析与解决▉ 问题分析 1）反转链表的我们第一能够想到的方法就是最常用的方法，声明三个指针，把头结点变为尾结点，然后下一结点拼接到尾结点的头部，一次类推。说白了就是就是直接将链表指针反转就可以实现反转链表。 ▉ 算法思路 1）定义三个指针，分别为 Pnext、pre、current，current 存储当前结点， pre 指向反转好的结点的头结点，Pnext 存储下一结点信息。 2）判断当前结点是否可以反转（是否为空链表或链表大于 1 个结点）? 步骤： 1）Pnext 指针存储下一结点 。 2）当前结点的 next 结点是否为 null (为 null 的话当前结点就是最后的一个结点)，如果为 null，将当前节点赋值为 head 头指针（断裂处）。 3）将 pre 指针指向的结点赋值当前节点 current 的下一结点 next。 4）然后让 pre 指针指向当前节点 current。 5）current 继续遍历, 当前节点指向 current 指向 Pnext。 递归法（重点分析）： 1）先确定终止条件：当下一结点为 null 时，返回当前节点； 2）判断当前的链表是否为 null； 3）递归找到尾结点，将其存储为头结点。 4）此时递归的层次是第二层递归，所以要设置为头结点的下一结点就是当前第二层结点，并且将第二节点的下一结点设置为 bull。 ▉ 测试用例 1）链表是空链表。 2）当前链表的长度小于等于 1。 3）输入长度大于 1 的链表。 ▉ 代码实现12345678910111213141516171819var reverseList = function(head) &#123; // 判断当前链表是否为空链表 if(head == null) return null; // 定义三个指针 let [current,prev,next] = [head,null,null]; while(current !== null)&#123; //1、存储下一结点 next = current.next; if(next == null)&#123; head = current; &#125; current.next = prev; prev = current; current = next; &#125; return head;&#125;; ▉ 递归法12345678910111213const reverseList = (head)=&gt;&#123; //如果链表为空或者链表中只有一个元素 if(head == null || head.next == null)&#123; return head; &#125;else&#123; //先反转后面的链表，走到链表的末端结点 let newhead = reverseList(head.next); //再将当前节点设置为后面节点的后续节点 head.next.next = head; head.next = null; return newhead; &#125;&#125; ▉ 性能分析 时间复杂度：O(n)。只需遍历整个链表就可以完成反转，时间复杂度为 O(n)。 空间复杂度：O(1)。只需要常量级的空间，空间复杂度为 O(1)。 4.2 小结▉ 内容考察 1）对单链表的基本操作。 2）对指针操作顺序的逻辑性考察。 3）考察思维的全面性以及代码的鲁棒性。 ▉ 注意事项 1）边界条件。 2）写代码之前想好测试用例，写完代码一一验证测试用例的正确性。 5、合并两个有序链表 题目：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 5.1 问题分析与解决▉ 问题分析 1）合并两个链表，经常犯的错误就是没有弄清除指针的指向，导致链表合并的时候断裂以及代码全面性考虑的不全，也就是代码的鲁棒性存在问题。 2）递归。每次都要比较两个结点大小，是否可以使用递归来解决呢？ ▉ 算法思路 一般解决法： 1）合并两个链表，首先需要两个指针，分别指向两个链表。 2）比较两个指针指向结点元素的大小，小的结点添加到新链表，然后指针向后移动继续比较。 3）直到其中一个链表没有结点了，另一个链表存在结点，将剩余的结点加入到新链表的尾部，完成合并。 递归法：（满足递归的三个条件） 比较当前结点大小先比较下一结点的大小。 1）结点之间的比较可以分的子问题为每个节点的比较。 2）终止条件：其中一个链表结点为 null。 3）子问题和总问题具有相同的解决思路。 ▉ 测试用例 1）输入两个空链表。 2）其中一个链表为空链表。 3）输入两个完整的链表。 ▉ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445// 功能:两个有序链表的合并// 步骤:// 1、判断两个链表是否为 null,并将链表赋予临时变量// 2、声明合并链表,通过 currentNode 指向当前结点// 3、两个链表比较大小,数值小的添加到合并链表中,合并链表进行指针移动// 4、将链表剩余数据添加到合并链表后边const mergeSortList = (listA,listB) =&gt;&#123; //判断链表是否为空 if(listA === null) return false; if(listB === null) return false; let a = listA; let b = listB; //声明合并链表,通过 currentNode 指向当前结点 let resultList = undefined //两个链表比较大小,数值小的添加到合并链表中,合并链表进行指针移动 if (a.data &lt; b.data) &#123; resultList = a a = a.next &#125; else &#123; resultList = b b = b.next &#125; let currentNode = resultList; while (a !== null &amp;&amp; b !== null) &#123; if (a.data &lt; b.data) &#123; currentNode.next = a a = a.next &#125; else &#123; currentNode.next = b b = b.next &#125; currentNode = currentNode.next &#125; // 将链表剩余数据添加到合并链表后边 if(a !== null)&#123; currentNode.next = a; &#125;else&#123; currentNode.next = b; &#125; //返回合并链表 return resultList;&#125; ▉ 递归实现123456789101112131415161718var mergeTwoLists = function(l1, l2) &#123; let result = null; //终止条件 if(l1 == null) return l2; if(l2 == null) return l1; //判断数值大小递归 if(l1.val &lt; l2.val)&#123; result = l1; result.next = mergeTwoLists(l1.next,l2); &#125;else&#123; result = l2; result.next = mergeTwoLists(l2.next,l1); &#125; //返回结果 return result;&#125;; ▉ 代码测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 //定义结点class Node&#123; constructor(data)&#123; this.data = data; this.next = null; &#125;&#125;//定义链表class LinkedList&#123; constructor()&#123; this.head = new Node('head'); &#125; //根据 value 查找结点 findByValue = (value) =&gt;&#123; let currentNode = this.head; while(currentNode !== null &amp;&amp; currentNode.data !== value)&#123; currentNode = currentNode.next; &#125; //判断该结点是否找到 console.log(currentNode) return currentNode === null ? -1 : currentNode; &#125; //插入元素(指定元素向后插入) insert = (value,element) =&gt;&#123; //先查找该元素 let currentNode = this.findByValue(element); //如果没有找到 if(currentNode == -1)&#123; console.log("未找到插入位置!") return; &#125; let newNode = new Node(value); newNode.next = currentNode.next; currentNode.next = newNode; &#125; //遍历所有结点 print = () =&gt;&#123; let currentNode = this.head //如果结点不为空 while(currentNode !== null)&#123; console.log(currentNode.data) currentNode = currentNode.next; &#125; &#125;&#125;// 合并两个链表var mergeSortList = function(l1, l2) &#123; let result = null; //终止条件 if(l1 == null) return l2; if(l2 == null) return l1; //判断数值大小递归 if(l1.val &lt; l2.val)&#123; result = l1; result.next = mergeSortList(l1.next,l2); &#125;else&#123; result = l2; result.next = mergeSortList(l2.next,l1); &#125; //返回结果 return result;&#125;;// 测试sortedList1 = new LinkedList()sortedList1.insert(9, 'head')sortedList1.insert(8, 'head')sortedList1.insert(7, 'head')sortedList1.insert(6, 'head')sortedList1.print();sortedList2 = new LinkedList()sortedList2.insert(21, 'head')sortedList2.insert(20, 'head')sortedList2.insert(19, 'head')sortedList2.insert(18, 'head')sortedList2.print();console.log('----------------合并两个有序的链表----------------')let resultList = mergeSortList(sortedList1.head.next,sortedList2.head.next)while (resultList !== null) &#123; console.log(resultList.date); resultList = resultList.next;&#125; ▉ 性能分析 时间复杂度：O（n）。n 为较短的链表的长度。 空间复杂度：O（n+m）。需要额外的 n+m(两个链表长度之和) 大小的空间来存储合并的结点。 5.2 小结▉ 内容考察 1）对链表的基本操作。 2）写代码考虑问题的全面性和鲁棒性。 ▉ 注意事项 1）递归实现，注意递归解决问题的三个缺点。 堆栈溢出 重复数据 高空间复杂度 三、LeetCode 加强练习阶段（阶段三） 如果你对基本的链表操作已经掌握，想进一步提高对链表熟练度的操作，可以练习一下 LeetCode 题目。每道题我都做了详细的解析，如：问题分析、算法思路、代码实现、考查内容等，有关链表的相关题目会不断更新…… 环形链表 I (题目解析 ) 环形链表 II (题目解析 ) 合并K个排序链表 (题目解析 ) 四、链表总结 做了大量有关链表的题型之后，对链表的操作做一个总结和复盘，对链表有一个整体的把握和重新的认识。 1、结构上 1）存储链表的内存空间是不连续的，所有需要使用指针将这些零碎内存空间连接起来，导致需要通过指针来进行操作，这也是为什么链表中大多数都是关于指针的操作的原因。 2）链表在结构上有两个特殊的地方就是链表头和链表尾，很多操作都要对链表头和链表尾进行特殊处理，所以我们可以借助哨兵思想（在链表头添加一个哨兵），这样带头的链表可以简化问题的解决。 2、操作上 1）递归：链表中的很多操作都是可以用递归来进行解决的，因为链表的每个结点都有着相同的结构，再加上解决的问题可以分解为子问题进行解决。所以在链表中递归编程技巧还是非常常用的。如：从尾到头打印链表、合并两个有序链表、反转链表等。 2）双指针：链表中大部分都是进行指针操作，链表属于线性表结构（形如一条线的结构），很多问题可以使用双指针来解决，也是非常常用到的。如：查找倒数第K 结点、求链表的中间结点等。 3、性能上 1）链表正是因为存储空间不连续，对 CPU 缓存不友好，随时访问只能从头遍历链表，时间复杂度为 O（n），但是链表的这种结构也有个好处就是。可以动态的申请内存空间，不需要提前申请。 2）指针的存储是需要额外的内存空间的，如果存储的数据远大于存储指针的内存空间，可以进行忽略。]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶深入系列之【跨域问题】]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[AJAX 以及跨域问题完整详细解析，面试、日常项目常用点。 [TOC] 跨域问题一、同源策略1.1 同源策略的由来 为了防止网站遭到恶意攻击，这里所谓恶意攻击就是从自己服务器的页面代码 js 中通过别人的 URL 去请求别人的服务器资源，这样通俗一点。这会导致信息被窃取，所以浏览器设计了同源策略。 例如：A 网站的服务器存有 A 网站用户的登录、账户等信息，该信息通常是由 A 网站的用户可获取的，但是如果没有同源策略，那么 B 网站的用户可以通过 AJAX 请求 A 网站服务器的资源，从而获取到用户的信息，导致用户信息被窃取。 2.2 什么是同源策略 1995年，同源政策由 Netscape 公司引入浏览器。 所谓的「同源」，浏览器规定 AJAX 做请求时，请求的服务器的 URL 的域名必须和当前页面的 URL 「域名相同」浏览器才会让你做请求（同源才会进行通信）。相同包括三个部分： 域名相同 协议相同 端口号相同 举例：假设网址为 http://www.xiaolu.com/example/index.html ，请求的服务器 URL 必须在一下三个方面做到相同才可以请求： 1234567891011//协议如果服务器使用 https 的协议： https://www.xiaolu.com/example/index.html （不同源，不能请求）//端口号如果服务器使用 8016 端口号：http://www.xiaolu.com：8016/example/index.html （不同源，不能请求）//域名如果服务器使用其他域名：http://www.lu.xiaolu.com：8016/example/index.html （不同源，不能请求）//三者必须都相同http://www.xiaolu.com/example/index.html （同源，可以请求） 2.3 同源策略的问题 虽然浏览器引入了同源策略，防止了恶意网站获取资源导致信息泄露。但是，会导致一下几个问题。 Cookie、LocalStorage 和 IndexDB 无法读取。 DOM 无法获得。 AJAX 请求不能发送。 1、不同源获取 Cookie 同源策略导致不同源的页面是不可以获取 Cookie 值的，如果有存在不同源的两个页面（一级域名相同，二级域名不同），想要共享 Cookie ，怎么做呢？ 12345678910//假设两个共享 Cookie 的网址A 网址：http://v1.xiaolu.com/index.htmlB 网址：http://v2.xiaolu.com/index.html// 同源策略导致不同源的页面是不可以获取 Cookie 值的// 注意：只是适用于二级域名不同 Cookie 和 iframe,对于 LocalStorage 和 IndexDB 不适用。 document.domain = '.xiaolu.com'//方法二：服务器设置 Cookie 的时候，指定 Cookie 所属一级域名，上述如果一级域名不同也不会存在限制Set-Cookie: key=value; domain=.xiaolu.com; path=/ 二、AJAX 跨域共享2.1 架设代理服务器 同源域名下架设代理服务器，JavaScript负责把请求发送到代理服务器，代理服务器将结果返回，准守了浏览器的同源策略。 缺点：需要额外的服务器做开发 1&apos;/proxy?url=http://www.baidu.com.cn&apos; 2.2 domain 同一主域的不同子域可以设置 document.domain 为主域来让他们同域,并且子域的协议和端口都要一致。 document.domain 只能设置往上设置域名,需要载入 iframe 来相互操作。 2.3 JSONP 一些带 src 的 html 标签都可以实现跨域，link、font-face、img、video、audio、script等。 1、本质 利用浏览器允许跨域引用 JavaScript 资源的功能。 2、缺点 只能用 Get 请求，并且返回 javascript。 3、优点 简单适用，老式浏览器全部支持，服务器改造非常小 4、基本流程 JSONP 通常以函数的形式返回，需要在页面写好返回的函数，页面动态的添加一个&lt;script&gt;节点，动态读取外域的 javascript 资源，然接受回调。（在外域的 javascript 文件中返回一个函数，函数中有我们需要的数据，我们在本地触发该函数就可以完成跨域）。 123456789101112131415&lt;script&gt; function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script); &#125; window.onload = function () &#123; addScriptTag('http://ip.jsontest.com/?callback=ip'); &#125; // 触发外域函数 ip();&lt;/script&gt; 5、安全性 当这个接口没有验证Referer头的时候,就存在JSONP劫持漏洞,即在任何域下都能窃取到传输的数据。 当接口返回的是一些敏感数据时(如 CSRF TOKEN,用户个人信息等),危害是很大的。 2.4 WebSocket1、概念 WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 2、基本流程 浏览器发出的WebSocket请求的头信息。 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 因为请求头部信息中的 origin 字段，所以 websocket 没有同源策略。服务器根据这个字段进行相应。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 2.5 CORS CORS 是 “跨域资源共享” （Cross-origin resource sharing ）的缩写，解决 AJAX 只能同源通信的限制问题。 1、简介 1）基本流程 ：整个 CORS 是浏览器自动完成的，浏览器一旦发现 AJAX 是跨域请求，自动添加一些信息在头部，只要服务器端能够识别在头部的信息，就可以完成跨域通信。 2）设计思想：CORS 的设计思想就是使用自定义 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还应该是失败。 2、兼容性 CORS 需要浏览器和服务器同时支持，IE 不能低于 IE10。 3、CORS 两种请求方式 CORS 分为两种请求方式： 普通请求: 简单的进行 AJAX 跨域请求，不需要服务器设置对请求的一些限制条件。 高级请求 : 服务器对 AJAX 跨域请求设置限制条件，如：请求方法必须使用 Get 或者 Post、SSL 认证等。 4、请求流程 当浏览器发现是 AJAX 跨域请求时，就会识别此次跨域请求是普通请求还是高级请求，怎么识别普通请求和高级请求呢？根据浏览器发现 ajax 进行跨域请求时自动添加上的头部信息进行识别，如果头部信息符合一下两个条件就为「普通请求」，如果不符合一下两个条件，就判断为「高级请求」。 1234567891011// 1）普通请求使用一下请求方法之一● HEAD ● GET● POST// 2）自动添加的头部信息小于等于一下几个字段● Accept● Accept-Language● Content-Language● Last-Event-ID● Content-Type：application/x-www-form-urlencoded、multipart/form-data、text/plain 三个类型之一 4.1 普通请求▉ 判断请求方式 AJAX 发送跨域请求，通过以上几个条件判断该请求是否为普通请求，如果满足条件，此次跨域请求为普通求请求。 ▉ 普通请求的基本流程 浏览器发现 AJAX 是跨域请求，然后再请求的头部添加一个 Origin 字段信息（发出请求的源地址）。然后浏览器检查请求信息确定此次的跨域的请求方式，如果为普通请求，请求信息相关字段如下： 123456GET /cors HTTP/1.1 //请求方法Origin: http://xiaolu.com //跨域字段（该字段的值为请求的源地址信息，包括域名、端口号、协议）Host: api.alice.com //主机地址Accept-Language: en-US //语言类型Connection: keep-alive //连接方式User-Agent: Mozilla/5.0... //浏览器版本 ▉ 服务器端 请求到达服务器，服务器提取 Origin信息，看是谁给我发来的请求信息，判断 Origin 是否为之前在服务器设置好的 Origin 字段信息，如果没有此信息，就返回一个正常的 HTTP 响应。如果有此信息，就在 HTTP 回应的头部添加几个字段，让浏览器根据服务器添加的几个字段再判断此次跨域请求是否同意了。 如果此次请求被允许，HTTP 响应的头部添加一下几个字段： 12345678910111213141516// 1) 用来让浏览器判断该信息服务器是否允许了此次请求。// 2) 如果值为 * ，表示服务器可以接收任意域名的请求。// 3）否则，代表服务器之允许设置好的域名进行跨域请求。Access-Control-Allow-Origin: http://xiaolu.com // 1）该字段表示浏览器是否可以向服务器发送 Cookie，默认情况 Cookie 不存在 CORS 请求中的。// 2) 设置为 true，允许 Cookie 信息包含在请求中的。// 3) 如果服务器不要浏览器发送Cookie，删除该字段即可Access-Control-Allow-Credentials: true// 1）如果不设置此字段，浏览器接受到请求之后，只能通过 XMLHttpRequest 对象的 getResponseHeader()拿到最基本的 6 个字段。// 2）如果想要拿到其他字段，需要在下面字段中指定。(下面设置了允许获取取 name 字段信息,通过 getResponseHeader('FooBar') 获取字段的值)Access-Control-Expose-Headers: name//1）响应类型和字符编码Content-Type: text/html; charset=utf-8 ▉ 客户端（AJAX 请求端） 当浏览器接收到服务器的响应信息后，判断响应头中是否包含 Access-Control-Allow-Origin 字段，如果没有包含，浏览器就不会将响应信息让开发人员做处理，直接抛出一个错误，回调 XMLHttpRequest的onerror 方法（虽然服务器返回的状态码可能是 200，但是被浏览器拦截了，就会被 onerror 所捕获）。 ▉ withCredentials 属性 CORS 请求默认不发送 Cookie 等认证信息。如果要发送 Cookie 信息，需要分别在服务器和 AJAX 请求中设置。 1234567//服务器端响应头部添加一下字段//注意：发送 Cookie ,服务器的 Access-Control-Allow-Origin 的字段不能设置为 * 。必须指定明确的、与请求网页一致的域名。只有这样，服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传。Access-Control-Allow-Credentials: true//客户端在 AJAX 请求中设置（即使服务器统一发送 Cookie ，但是浏览器不统一发送 Cookie 必须设置下字段）var xhr = new XMLHttpRequest();xhr.withCredentials = true; 4.2 高级请求▉ 判断请求方式 发送 AJAX 跨域请求，浏览器检测请求信息中存在 PUT 或 DELETE 方法，或者 Content-Type字段的类型是application/json ，就将此次跨域请求定义为「高级请求」。 ▉ 高级请求的基本流程 高级请求会在真正的请求之前，先和服务器“打电话”，问一下服务器当前网页的域名，以及请求方法能够进行此次通信。服务器说，这次通信可以使用 PUT 或 DELETE 方法，那么浏览器才会发出 AJAX 的正式请求，否则就会报错。 123456//Ajax 跨域请求的正式内容：var url = 'http://xiaolu.com ';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); ▉ preflight 预请求 上述中，在真正的请求之前，「浏览器」先和服务器“打电话”，打电话的过程称为 “preflight 请求“。preflight 预请求的内容如下： 12345678OPTIONS /cors HTTP/1.1Origin: 'http://xiaolu.com ' // 源地址 Access-Control-Request-Method: PUT //请求方法Access-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 步骤一：浏览器发出请求 该预请求信息通过浏览器的 OPTIONS 方法来询问服务器，发送该预请求的内容，就是用来让服务器接受判断这些信息是否符合服务器端的要求。 步骤二：服务器响应请求 服务器接受到信息之后，取出字段进行以预先设置好的字段值进行判断，然后做出回应。如果与服务器设置的不符合条件，此次拒绝了 preflight 预先请求，就会返回一个正常的 HTTP 响应给浏览器。否则响应以下信息给浏览器。 12345678910111213HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: 'http://xiaolu.com 'Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000 //服务器运行此源地址请求的时间，一旦超过这个时间，就重新进行预请求Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 步骤三：浏览器接收请求 1）浏览器接收到服务器的响应之后，发现只有简单的 HTPP 响应头部，没有任何的 CORS 请求信息，浏览器就知道了服务器拒绝这次 preflight 预请求，然后返回给开发人员一个错误信息，被 XMLHttpRequest对象的onerror 回调函数捕获 。 2）如果浏览器发现服务器返回的请求带有 CORS 请求头部，就获取字段判断，此次服务器允许了此次请求。 步骤四：AJAX 正常请求和回应 preflight 预请求一旦通过，浏览器就会向服务器发送正式的 AJAX 请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样。 5、安全性 安全漏洞：因为 Access-Control-Allow-Origin 设置成通配符”*”时,表示允许任何域名跨源，如果再把 Access-Control-Allow-Credentials 设置为 true,允许客户端带上 cookie 的话,无疑此时是非常危险的.因为攻击者很容易就能窃取到用户个人的数据。 保护机制：客户端不带 cookie 请求的话还是会正常呈现的,因为 cookie 是一种身份标识,一旦浏览器标识了用户身份,那么返回的数据必然属于用户个人,所以浏览器设计了这种措施来保护用户数据不被泄露。 ▉ 配置错误 尽管 CORS 在设计上考虑到安全问题，但是在用户配置时经常出现很多错误，如设置 ”Access-Control-Allow-Origin”的白名单时,正则写的不正确,导致预期外的域名可以跨域。 2.5 CORS 与 JSONP 比较 1、JSONP 只支持 GET 请求。CORS 支持所有的 HTTP 请求。 2、JSONP 支持老式浏览器以及向不支持 CORS 的服务器请求数据。CORS 只支持 IE10 版本以上浏览器。 2.6 IE 对 CORS 的实现 通过 XHR 实现 AJAX 通信是一个主要限制，默认情况下，XHR 对象只能访问与包含它页面在同一域下的资源 1、简介 微软在 IE8 中引入了 XDR 类型，部分实现了 CORS 的规范，使得 IE 可以完成跨域处理。 2、XDR 与 XHR 的不同 Cookie 不能随请求发送，也不会随响应返回。 只能设置请求头部的 Content-Type 字段。 不能访问响应头部的信息。 只支持 GET 和 POST 请求。 3、XDR 的使用 1、XDR 与 XHR 的 open 方法稍有不同，XDR 的 open 函数只有两个参数（只有异步操作），请求返回后，会触发 onload 事件，可以获取到返回的文本内容。 2、响应只能访问文本文件，没有状态码可用，如果缺少 Access-Control-Allow-Origin 头部就会触发 onerror 事件。（所有的请求错误只能用 onerror 来捕获） 123456789var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.onerror = function()&#123; alert('响应错误');&#125;xdr.open('get','http://xiaolu.com/index.html');xdr.send(null); 4、POST 请求 XDR 为了支持 post 请求，XDR 提供了 contentType 属性，用来表示发送数据的格式， 12xdr.Content-Type = "application/x-www-form-urlencoded"xdr.send("name1=value1&amp;name2=value2") 2.7 其他浏览器对 CORS 的实现 Firefox 3.5+、Safari 4+、Chrome、iso 和 Android 平台中的 webKit 都通过了 XMLHttpRequest 对象实现了对 CORS 的原生支持。 1、XHR 在尝试打开不同来源的资源时，无序额外的编码触发这个行为，只需在 open 中传入绝对的 URL 就可以触发浏览器的跨域。 12// 跨域的绝对 URL 路径xhr.open("get","http://www.xiaolu2.com/page/index.html") 2、XHR 的限制 不能使用 setRequestHeader() 设置自定义的头部。 不能发送和接受 Cookie。 调用 getAllResponseHeaders() 方法总返回空字符串。 2.7 跨浏览器的 CORS 浏览器对 CORS 的支持程度不一样，但是都能实现简单（不带 preflight）的请求，所以要实现一个跨浏览器的方案。 1、检测 XHR 是否支持 CORS ：检测是否存在 withCredentials 属性(该属性只存在 IE 10 以上版本)。 2、检测 XDomain 对象是否存在：该属性只存在 IE 8 以上浏览器中。 1234567891011121314151617181920function createCORSRequest(method,url)&#123; var xhr = new XMLHttpRequest(); if("withCredentials" in xhr)&#123; // IE 10+ xhr.open(method,url,true) &#125;else if(typeof XDomainRequest != "undefined")&#123; // IE 8+ var xhr = new XDomainRequest(); xhr.open('get','http://xiaolu.com/index.html'); &#125;else&#123; xhr = null; &#125; return xhr;&#125;var request = createCORSRequest("get","http://www.xiaolu.com");if(request)&#123; request.onload = function()&#123; // 对 request.responseText 进行处理 &#125; request.send&#125; 无论是 Firefox 3.5+、Safari 4+、Chrome 中的 XMLHttpRequest 对象还是 IE 中的XDomainRequest 对象，都可以使用以上的方法。 onerror：用于替代 onreadystatechange 检测错误。 onload：用于替代 onreadystatechange 检测成功。 三、跨域存在的两种攻击（XSS/CSRF）3.1 跨站请求伪造（CSRF） 跨站伪造请求（Cross-site request forgery ），缩写为 CSRF。CSRF 利用的是网站对用户网页浏览器的信任来进行恶意攻击的。 1、攻击原理 攻击者通过技术手段欺骗用户的浏览器去访问一个曾经认证过的网站，所以用户不用进行重新认证，这是一个用户身份验证的一个漏洞：简单身份认证只保证请求来自某个用户的浏览器，确不能保证请求的本身是用户自愿发出的。攻击者诱导用户在刚访问不久的网站中点击设定的链接（本页的论坛、博客等自动生成的链接内容）。 2、防御措施▉ 检查 Referer 字段 HTTP 头有一个 Referer 字段，用来标记请求来源于哪个地址。Referer字段应和请求的地址位于同一域名下。 服务器在处理请求的时候，可以判断该字段是否位于正确的源地址下发送的请求。如果是 CSRF 攻击，该字段会包含恶意的网址。 局限性：设置 Referer 有本身的局限性，攻击者可以篡改 Referer 字段来达到攻击的目的。 ▉ 添加校验 token 本质：CSRF 的本质是在于攻击者欺骗自己去访问设置的地址，如果在请求数据的时候，用户不把信息保存到浏览器的 Cookie 中，那么攻击者无法获取数据校验，从而不能进行 CSRF 攻击。 随机校验：服务器为客户端的窗体设置一个伪随机数，客户端在提交请求的时候，将随机数与请求内容一并提交服务器，正常访问时，客户端将会收到正确得到并传回这个伪随机数。CSRF 攻击无从事先知道这个伪随机数，所以导致 token 值为空，拒绝请求。 ▉ JSONP 劫持漏洞 如果 JSONP 没有验证 Referer 头的时候,就存在JSONP劫持漏洞,即在任何域下都能窃取到传输的数据。 参考资料： Javascript 高级程序设计 https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000 http://www.ruanyifeng.com/blog/2016/04/cors.html]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>前端深入系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>前端深入系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吃透 javascript 之【完整篇】]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%90%83%E9%80%8F%20JavaScript%20%E4%B9%8B%E3%80%90%E5%AE%8C%E6%95%B4%E7%AF%87%E3%80%91%2F</url>
    <content type="text"><![CDATA[Javascript 的重点学习路线完整篇。 [TOC] 一、JavaScript 简介1、诞生 最早期网景公司开启 web 时代的第一代互联网，早起网景公司只是做静态页面，为了能够在静态页面添加一些动态的效果，所以叫Brendan Eich 这两个人两星期之内设计出 javascript ，不出所料，这两人只用了短短的10天时间。为了使其能够借助 java 的盛行，所以起名 javascript。 2、ECMAScript 网景开发了 javascript 之后，微软也模仿开发了 Jscript，为了能够让 javascript 称为全球的开发标准，所以几个公司联合发布了 ECMA 标准。ECMAScript 是一种语言标准，而网景公司开发的 javascript 是这一标准的实现。 3、版本 因为 javascript 的标准在短时间实现的，其中存在很多的缺陷，所以 javascript 的标准 ECMAScript 不断发展，到目前的 ES6 版本 2015 年发布。这里的 javascript 版本一般说的就是实现了 ECMAScript 哪个版本。 二、数据类型和变量1、== 和 ===的区别？ == 是 javascript 的设计缺陷，一般使用 === 来比较。 == : 两种之间比较需要先进行转换，然后进行比较，有时候出现很奇怪的情况。 === : 先比较类型，如果类型相等，然后在比较值。 2、NAN 是 Number 特殊的值 NAN 与任何值都不相等，包括它本身自己。 1NaN === NaN; // false 唯一能判断 NaN 的方法是通过 isNaN() 函数 3、浮点型之间的比较 问题：浮点型在运算会产生误差，导致计算机无法准确表示无限循环小数，所以导致比较不相等。 解决：要比较浮点型之间的大小，要比较两个浮点型之差的绝对值是否小于某一个阈值。 4、null 和 undefined NULL 表示“空”。undefined 表示未定义。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 5、严格模式是什么？ 缘由：初期，为了方便，不强制要求 var 声明变量，所以会导致未被 var 声明的变量自动声明为全局变量，如果同一页面不同 js 文件都用到了 js 文件的相同变量，导致变量之间相互影响，也就是我们所说的污染全局环境变量。 strict模式：不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。 三、字符串1、多行字符串 多行字符串用 反引号来表示，ES6 新增加语法。 2、字符串拼接 关于字符串拼接用 ${name} 引用，ES6 新增加语法。 四、数组1、indexof 搜索一个指定的元素的位置 。 2、slice 字符串截取。单参数为从参数起到结束，双参数为中间元素（不包括尾元素），返回新数组。 3、push 和 pop 末尾添加元素和末尾删除元素。 4、unshift 和 shift 头部添加元素和头部删除元素。 5、sort 对当前数组进行排序。 6、reverse 将数组元素反转。 7、splice 可以删除元素也可以删除同时添加元素。 12// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); 8、concat 合并两个数组，返回新数组。 9、join 指定字符连接数组中的元素。 五、Map 和 Set1、Map 一组键值对，键必须为字符串类型。 1234var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);m.get(&apos;Michael&apos;);m.set(&apos;Bob&apos;,59)m.delete(&apos;Adam&apos;); 2、Set 一组 key 的集合，不存储 value。 123var s = new Set([1, 2, 3]);s.add(4);s.delete(3); 六、iterable▉ 普通 for 循环 当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率 。 ▉ foreach 循环 功能：可以获取到 key 和 value 数组的本身。 缺点： 不能用 break，continue 语句跳出循环。 函数内不能使用 return 语句。 注意：在不同浏览器下测试的结果都是 forEach 的速度不如 for 。 12345//item 为数组元素//index 为索引下标arr.forEach(function (item,index,arr) &#123; console.log(item,index,arr)&#125;,null) ▉ for…in 循环 for-in 循环遍历的是对象的属性。而不是数组的索引 ，除了遍历数组也可以遍历对象。 缺点： for-in 遍历的顺序并不是确定的。 它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性 （Array 中的 length 不能遍历到），for-in 不适合遍历 Array 。【链接】：https://juejin.im/entry/5a1654e951882554b8373622 ▉ for…of 循环 ES6 新增语法。 优点： 以正确响应 break, continue, return。 for-of 循环不仅支持数组，还支持大多数类数组对象。 for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。 for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历 七、函数 在函数中如果没有 return 语句，函数执行完返回 undefined。 1、arguments 此关键字只在函数内部起作用，并且永远指向当前函数调用者传入的所有参数。 1、即使函数不定义参数，也是可以通过 arguments 对象拿到传入的参数的。 2、通常用来判断传入参数的个数。 1234567function foo(x) &#123; console.log('x = ' + x); // 10 for (var i=0; i&lt;arguments.length; i++) &#123; console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30 &#125;&#125;foo(10, 20, 30); 2、reset 参数（ES6） 由于 arguments 获取额外的传参非常的别扭，所以 ES6 新增了 rest 参数用来处理额外的参数。 12345678function foo(a,b,...rest)&#123; console.log(rest)&#125;//传入多余两个参数foo(1,2,3,4,5); // Array[3,4,5]//传入少于定义参数的个数foo(1,2)//Array[] 空数组 3、注意 return 语句 javascript 引擎会有一个行末添加分号的机制。 123456789101112//正确写法function foo() &#123; return &#123; // 这里不会自动加分号，因为&#123;表示语句尚未结束 name: 'foo' &#125;;&#125;//错误写法function foo() &#123; return //这一行会可能被引擎自动加分号 &#123; name: 'foo'&#125;; &#125; 4、变量作用域和解构赋值▉ 全局作用域 javascript 只有一个全局作用域，如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。 ▉ 命名空间 全局变量会绑定到 windows 上，不同的 javascript 文件使用相同的全局变量会产生命名冲突，我们很难发现，所以一般减少冲突的方法就是所有变量和函数全部绑定到一个全局变量中。 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 许多 js 库都是这么干的，jQuery，YUI等。 ▉ 局部作用域 所谓的 js 作用域是在函数内部的，for 循环等语句块中是无法定义具有局部作用域变量的。ES6 引用了 let 代替 var 声明块级作用域变量。 ▉ 对多个变量同时赋值 使用 ES6 新增加的解构赋值。 1var [x, y, z] = ['hello', 'JavaScript', 'ES6']; 适用场景： 1、交换两个变量 12var x = 1,y = 2;[x,y] = [y,x] 2、快速获取当前页面的域名和路径 1var &#123;hostname:domain, pathname:path&#125; = location; 3、函数接受对象的属性为参数 用解构直接将对象的属性绑定到变量中。 1234function buildDate(&#123;year, month, day, hour=0, minute=0, second=0&#125;) &#123; return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);&#125;buildDate(&#123; year: 2017, month: 1, day: 1 &#125;); 5、方法▉ this 指针 如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming。如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25, 正常结果getAge(); // NaN 12var fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN 以上是 js 的设计错误，ECMA决定，在 strict 模式下让函数的this指向undefined 。 123456789101112131415'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined 报错了，this 指针只在 age 方法的函数内指向 xiaoming 在函数内部定义的函数 ，this 指针指向 undefined ，他重新指向全局变量。 改进方法，用 that 进行捕获。 12345678910111213141516'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 ▉ apply() 方法 作用： 指针函数的 this 指向哪个对象。 使用： 参数一：需要绑定的 this 变量。 参数二：传入的是 Array，表示函数本身的参数。 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 ▉ call() 方法 把参数按照顺序传入。 ▉ 装饰器 利用apply()，我们还可以动态改变函数的行为。 123456789'use strict';var count = 0;var oldParseInt = parseInt; // 保存原函数window.parseInt = function () &#123; count += 1; return oldParseInt.apply(null, arguments); // 调用原函数&#125;; 6、高阶函数 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数 。 ▉ map 对元素自身进行计算 map() 方法定义在 JavaScript 的 Array 中 ,对数组中的每个数据做处理。 map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数 。 12345678'use strict';function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results); ▉ reduce 所有元素进行累加计算 Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25 ▉ filter 过滤元素 用于把 Array的某些元素过滤掉，然后返回剩下的元素。 和 map() 不同的是，filter() 把传入的函数依次作用于每个元素，然后根据返回值是 true 还是 false 决定保留还是丢弃该元素。 123456//在一个Array中，删掉偶数，只保留奇数var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] ● 回调函数 filter 有多个参数。 1、一个参数：仅使用一个表示 Array 的某个元素。 2、三个参数：回调函数可以接受另外两个参数，表示元素的位置和数组本身。 123456//去除重复元素依靠的是 indexOf 总是返回第一个元素的位置，后续的重复元素位置与 indexOf 返回的位置不相等，因此被 filter 滤掉了。var r,arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;); ▉ sort 排序 1、比较字符或者字符串，根据 ASCLL 码进行排序的。 2、比较数字，先将数组中的数字转换成字符串，然后再进行排序。 sort 是一个高阶函数，可以传入函数来进行自定义的比较： 数字比较 传入一个比较函数，-返回值为 1，-1，0； 注意：sort 直接对 Array 进行修改，结果返回 Array。 12345678910111213141516'use strict'var arr = [10, 20, 1,2];//经断点调试，更像是一种插入排序arr.sort(function (x, y) &#123; //变 if (x &lt; y) &#123; return -1; &#125; //不变 if (x &gt; y) &#123; return 1; &#125; return 0;&#125;);console.log(arr); // [1, 2, 10, 20] 6、闭包 将闭包和 Java 类中的 get 获取内部私有变量做对比。 ▉ 什么是闭包？ 只有函数内部的子函数才能读取局部变量，定义在一个函数内部的函数 。 ▉ 作用 1）在函数的外部也可以获取到函数内部的局部变量。 2）让这些局部变量值始终保存在内存中，保证不会被 js “垃圾回收机制”回收。 ▉ 使用闭包注意事项 1）闭包会被保存到内存中，内存消耗很大，会造成网页性能问题，在 IE 会导致内存泄漏。在退出函数之前，将不适用的局部变量全部删除。 7、垃圾回收机制▉ 生命周期 1）分配内存： javascript 自动完成内存的分配 2）使用内存（读或写）：使用值的过程实际上是对分配内存进行读取与写入的操作 3）释放内存：在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。所以高级语言潜入垃圾回收机制。 ▉ 垃圾回收机制 主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。 1）引用 垃圾回收算法主要依赖于引用的概念 ，一个对象访问另一个对象就叫做引用。 2）引用计数垃圾收集 初级的垃圾回收算法，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 3）限制：循环引用 当该函数调用完成离开作用域之后，可以被回收了，但是两个对象相互引用，所以不会被回收。（IE 6, 7对 DOM 结点进行计数垃圾回收） 123456function f()&#123; var o = &#123;&#125;; var o2 = &#123;&#125;; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o&#125; 4）标记—清除算法 针对于“对象是否不再需要”。 1）算法假设有一个根对象（全局对象），垃圾回收器从根开始找所有从根开始引用的对象。 2）垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。 （零引用总不可获得的） 5）限制：那些无法从根对象查询到的对象都将被清除 8、箭头函数▉ 箭头中的 this 由于之前的函数中 this 绑定的错误处理，this 在箭头函数中被修复了。this 总是与词法作用域绑定（函数的作用域在函数定义的时候就决定了 ），由上下文确定 ，外层调用者 obj. 12345678910var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window 或 undefined &#125;; return fn(); &#125;&#125;; ▉ 注意 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略。 9、generator 生成器▉ 定义 整个 Generator 函数封装了异步任务。 标注 yield 地方都是异步需要暂停的地方（yield 将任务分为几个阶段）。 1234function* gen(x)&#123; var y = yield x + 2; return y;&#125; ▉ 过程 1）调用 Generator 会返回一个指针对象（遍历器对象 ），调用指针对象的的 next 方法，会移动指针的位置（异步任务的第一阶段），也就是指向遇到第一个 yield 的位置。 2）next 方法会返回一个当前阶段的对象，表示当前阶段的信息（value:当前阶段的值，yield：布尔值 ）表示 generator 是否执行完毕。 1234var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; ▉ 数据交换 除了能够暂停、恢复之外，还可以作为函数体内外的数据交换。 1、不带有参数的 next 方法可以输出返回值。 2、带有参数的方法可以将参数作为上一阶段异步任务的返回结果，也就是输入。 12345678function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next(2) // &#123; value: 2, done: true &#125; ▉ 错误处理 Generator 内部可以部署错误处理代码，捕获函数体外抛出的错误。 1、在函数外用指针的throw抛出的错误，被函数体内的 try … catch 代码块进行捕获。 2、实现了出错代码和处理错误的代码时间和空间上的分离。 12345678910111213function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw（'出错了'）;// 出错了 ▉ 作用 异步回调代码变成“同步”代码。 八、标准对象 总结一下，有这么几条规则需要遵守： 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === &#39;undefined&#39;； 函数内部判断某个变量是否存在用typeof myVar === &#39;undefined&#39;。 任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。 1、Date JavaScript的 Date 对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 1234567891011var now = new Date();now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)now.getFullYear(); // 2015, 年份now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月now.getDate(); // 24, 表示24号now.getDay(); // 3, 表示星期三now.getHours(); // 19, 24小时制now.getMinutes(); // 49, 分钟now.getSeconds(); // 22, 秒now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1435146562875, 以number形式表示的时间戳 九、面向对象编程1、继承设计思想▉ js 的诞生 为了让静态页面进行交互，设计一种语言完成不需要借助服务器完成的操作，如：表单验证。 ▉ 模仿其他 oop 进行设计 js 不像其他语言是面向对象语言有类的概念，为了能够即不引入类又能实现继承，所以 js 设计者模仿 oop 语言进行设计。 1、其他语言通过 new 来生成实例，所以 js 也通过 new 生成实例。 2、其他语言有类可以通过 new 来实现，js 并没有类，所以借助 new 构造函数来生成实例。 3、不同对象有不同的属性，也有相同的属性，对于每个对象相同的属性都需要在内存中开辟多个空间存储。能否使相同的属性只存一个呢？然后拥有该属性的对象都去引用它。 ▉ prototype 属性 我们就给构造函数设计一个 prototype 属性，用来存储不同对象相同的属性，共享的属性都存到这里边，不共享的属性就存放到构造函数中。其实 prototype 属性存储的就是一个对象，构造函数里边存放的都是变量，具体看变量和对象在内存中的引用。 ▉ 继承 所有构造函数生成的对象都具有 prototype 对象里边的共享属性，就像是所有实例对象继承了 prototype 对象一样。 2、封装 其他语言因为有类的概念，对对象的封装是非常方便的，那么 js 是怎么封装对象的呢？ 12345//猫对象var Cat = &#123; name : '', color : ''&#125; ▉ 原始模式 下面简单的进行两个不同对象的封装，就会有两个问题： 问题： 1）生成多个实例对象写起来非常麻烦。 2）实例对象和原型对象之间没什么联系。 1234567var cat1 = &#123;&#125;; // 创建一个空对象cat1.name = "大毛"; // 按照原型对象的属性赋值cat1.color = "黄色";var cat2 = &#123;&#125;;cat2.name = "二毛";cat2.color = "黑色"; ▉ 原始模式改进 用函数来解决代码重复的问题。 问题： 1）但是不能反映他们来自于同一个原型对象。 123456789function Cat(name,color) &#123; return &#123; name:name, color:color &#125;&#125;//生成实例对象var cat1 = Cat("大毛","黄色");var cat2 = Cat("二毛","黑色"); ▉ 构造函数模式 为了解决原型对象生成实例的问题，引入构造函数模式。 1）构造函数就是一个普通函数。 2）内部使用 this 变量，对构造函数使用 new 就能生成实例对象，内部的 this 指针就会指向实例对象。 3）每个实例对象都有 constructor 属性，并指向他们的构造函数。 12345678910//1）function Cat(name,color)&#123; this.name=name; this.color=color;&#125;//2）var cat1 = new Cat("大毛","黄色");var cat2 = new Cat("二毛","黑色");//3)alert(cat1.constructor == Cat); //true 问题： 1）对于每个实例共享的属性，存在浪费内存的问题。 ▉ 原型模式（prototype 模式） 每个构造函数都有一个 prototype 属性指向原型对象，我们将共享的属性存放到原型对象上，所有实例的共享属性其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。 验证方法： 1）isPrototypeOf() ：验证实例与原型对象之间的关系。 12&gt; alert(Cat.prototype.isPrototypeOf(cat1)); //true&gt; 2）hasOwnProperty()：判断某个属性来自本地还是原型对象。 12&gt; alert(cat1.hasOwnProperty(&quot;name&quot;)); // true&gt; 3）in运算符：判断某个实例是否拥有某个属性。以及遍历某个实例的所有属性。 123&gt; alert(&quot;name&quot; in cat1); // true&gt; for(var prop in cat1) &#123; alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); &gt; 2、原型继承3、构造函数继承（五种） 两个构造函数。怎么让猫继承动物？ 123456789//动物构造函数function Animal()&#123; this.species = "动物";&#125;//猫的构造函数function Cat(name,color)&#123; this.name = name; this.color = color;&#125; ▉ 第一种：构造函数的绑定 用 call 或 apply 方法将父对象的构造函数绑定到子对象的构造函数。 123456function Cat(name,color)&#123; //改变 this 的绑定 Animal.apply(this, arguments); this.name = name; this.color = color;&#125; ▉ 第二种：原型模式 让猫构造函数的 prototype 等于 Animal 的实例，Animal 的实例拥有 Animal 的所有属性，所以相当于猫构造函数的 prototype 指向 Animal 实例了， 所有的猫的实例共享 Animal 里的属性了。 1) 每个实例都有 construct 属性，每个 prototype 也都有 construct 属性。 2）实例中的 construct 指向与 prototype 对象中 construct 指向同一个构造函数。也就是说改变 Cat 的原型对象之后，Cat 的实例对象 construct 属性指向的是 Animal 实例对象的 construct 属性，也就是 Animal 原型对象的 construct 属性，也就是构造函数 Animal 。 3）猫的实例对象是由 Cat 生成的，怎么能指向 Animal 呢，所以手动修改过来。 4）如果更换了 prototype对象 ，一定将 construct 属性修改过来。 12Cat.prototype = new Animal();Cat.prototype.constructor = Cat; ▉ 第三种：直接继承原型 第二种方式的改进，跳过 Animal 的实例，直接将 Animal 的原型对象赋值给 Cat.prototype; 优点：效率更高（不用执行和建立Animal的实例了 ） 缺点：Cat.prototype 和 Animal.prototype 现在指向了同一个对象，那么任何对 Cat.prototype 的修改，都会反映到 Animal.prototype。 12Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat; ▉ 第四种：空对象作为中介 对于第三种的缺点，第四种作为改进。F是空对象，所以几乎不占内存。 优点：修改Cat的prototype对象，就不会影响到Animal的prototype对象。 1234var F = function()&#123;&#125;;F.prototype = Animal.prototype;Cat.prototype = new F();Cat.prototype.constructor = Cat; 将其封装成方法: 这个 extend 函数，就是 YUI 库如何实现继承的方法。 1234567 function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; ▉ 第五种：拷贝继承 如果把父对象的 prototype 所有属性和方法，拷贝进子对象的 prototype 中 。 123456789// 浅拷贝继承function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; &#125; 4、非构造函数继承 让医生继承中国。 12345678//父对象var Chinese = &#123; nation:&apos;中国&apos;&#125;;//子对象var Doctor =&#123; career:&apos;医生&apos;&#125; ▉ 第一种：object()方法 让中国成为医生的原型对象。 12 ▉ 第二种：浅拷贝 把父对象的属性，全部拷贝给子对象，也能实现继承。 拷贝继承分为浅拷贝和深拷贝。 问题： 1）如果父对象的属性等于数组或另一个对象，子对象获得的只是一个内存地址 ，子对象改变，父对象的属性也将改变。 12345678function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; return c;&#125; ▉ 第二种：深拷贝 弥补浅拷贝出现的问题，真正的将对象和数组及逆行拷贝，只要递归调用”浅拷贝”就行了 。 12345678910111213 function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;//递归 deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c; &#125; jQuery库使用的就是这种继承方法。 5、class 继承 class 的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用 class 的好处就是极大地简化了原型链代码。 十、浏览器1、浏览器对象▉ window window对象不但充当全局作用域，而且表示浏览器窗口。 1console.log('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight); ▉ navigator navigator对象表示浏览器的信息，最常用的属性包括： navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 ▉ screen screen对象表示屏幕的信息，常用的属性有： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 ▉ location location对象表示当前页面的URL信息。 加载新页面：location.assign() 。 重新加载：location.reload() 。 12345678http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP//可以用location.href获取location.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP' ▉ document document 对象表示当前页面。由于 HTML 在浏览器中以 DOM 形式表示为树形结构，document 对象就是整个 DOM 树的根节点。 Cookie 1) Cookie 是由服务器发送的 key-value 标示符。因为 HTTP 协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用 Cookie 来区分 。 2) 当一个用户成功登录后，服务器发送一个 Cookie 给浏览器，例如 user=ABC123XYZ(加密的字符串)...，此后，浏览器访问该网站时，会在请求头附上这个 Cookie，服务器根据 Cookie 即可区分出用户。** 安全性： 如果引入的第三方库存在恶意代码，则被第三方直接获取到用户登录信息。为了解决这个问题，服务器在设置 Cookie 的时候使用 httpOnly，设置的 Cookie 不能被 Javascript 读取。 1document.cookie; // 'v=123; remember=true; prefer=zh' ▉ history history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 2、操作 DOM▉ 更新 DOM1）innerHtml属性 修改文本。用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。 1234567// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;var p = document.getElementById('p-id');// 设置文本为abc:p.innerHTML = 'ABC'; // &lt;p id="p-id"&gt;ABC&lt;/p&gt;// 设置HTML:p.innerHTML = 'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ';// &lt;p&gt;...&lt;/p&gt;的内部结构已修改 2) 修改 innerText 或 textContent 属性 可以自动对字符串进行HTML编码，保证无法设置任何HTML标签： 12p.innerText = '&lt;script&gt;alert("Hi")&lt;/script&gt;';// HTML被自动编码，无法设置一个&lt;script&gt;节点: 3) 两者区别 读取属性，innerText不返回隐藏元素的文本，而textContent返回所有文本。另外注意 IE &lt; 9 支持textContent。 4）设置 CSS 样式 DOM节点的style属性对应所有的 CSS 。CSS允许font-size这样的名称使用驼峰命名法（fontSize）。 1p.style.fontSize = &apos;20px&apos;; ▉ 插入 DOM1）使用 appendChild 把一个子节点添加到父节点的最后一个子节点。 123456var list = document.getElementById('list'), haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.appendChild(haskell); 2) insertBefore 插入指定位置 12// 将子节点插入到 referenceElement 之前parentElement.insertBefore(newElement, referenceElement); ▉ 删除 DOM parentElement () 得到删除节点的父节点，然后 removeChild() 删除节点。 1234567// 拿到待删除节点:var self = document.getElementById('to-be-removed');// 拿到父节点:var parent = self.parentElement;// 删除:var removed = parent.removeChild(self);removed === self; // true 注意： 1、删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 2、parent.children[0] 删除节点的时候注意下标。 3、操作表单HTML表单的输入控件主要有以下几种： 文本框，对应的&lt;input type=&quot;text&quot;&gt;，用于输入文本； 口令框，对应的&lt;input type=&quot;password&quot;&gt;，用于输入口令； 单选框，对应的&lt;input type=&quot;radio&quot;&gt;，用于选择一项； 复选框，对应的&lt;input type=&quot;checkbox&quot;&gt;，用于选择多项； 下拉框，对应的&lt;select&gt;，用于选择一项； 隐藏文本，对应的&lt;input type=&quot;hidden&quot;&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 ▉ 获取值1234567// &lt;input type="text" id="email"&gt;var input = document.getElementById('email');input.value; // '用户输入的值'// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;mon.value; // '1'mon.checked; // true或者false ▉ 提交表单方法一： 响应一个 button 方法。 1234567891011121314&lt;!-- HTML --&gt;&lt;form id="test-form"&gt; &lt;input type="text" name="test"&gt; &lt;button type="button" onclick="doSubmitForm()"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function doSubmitForm() &#123; var form = document.getElementById('test-form'); // 可以在此修改form的input... // 提交form: form.submit();&#125;&lt;/script&gt; 方法二： onsubmit 事件。 12345678910111213141516&lt;form id="login-form" method="post" onsubmit="return checkForm()"&gt; &lt;input type="text" id="username" name="username"&gt; &lt;input type="password" id="input-password"&gt; &lt;input type="hidden" id="md5-password" name="password"&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() &#123; var input_pwd = document.getElementById('input-password'); var md5_pwd = document.getElementById('md5-password'); // 把用户输入的明文变为MD5: md5_pwd.value = toMD5(input_pwd.value); // 继续下一步: return true;&#125; 4、操作文件 在表单提交文件时，from 表单的 enctype 属性应该使用 multipart/form-data 不对文件数据进行编码才能上传，其他数据默认 application/x-www-form-urlencoded 编码再提交。 1234567//input 的 IDvar f = document.getElementById(&apos;test-file-upload&apos;);var filename = f.value; // &apos;C:\fakepath\test.png&apos;if (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) &#123; alert(&apos;Can only upload image file.&apos;); return false;&#125; ▉ File API 操作文件 HTML5的File API提供了 File 和 FileReader 两个主要对象，可以获得文件信息并读取文件。 12345678910111213141516171819202122232425262728293031323334var fileInput = document.getElementById('test-image-file'), info = document.getElementById('test-file-info'), preview = document.getElementById('test-image-preview'); // 监听change事件: fileInput.addEventListener('change', function () &#123; // 清除背景图片: preview.style.backgroundImage = ''; // 检查文件是否选择: if (!fileInput.value) &#123; info.innerHTML = '没有选择文件'; return; &#125; // 获取File引用: var file = fileInput.files[0]; // 获取File信息: info.innerHTML = '文件: ' + file.name + '&lt;br&gt;' + '大小: ' + file.size + '&lt;br&gt;' + '修改: ' + file.lastModifiedDate; if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') &#123; alert('不是有效的图片文件!'); return; &#125; // 读取文件: var reader = new FileReader(); //异步操作的回调函数 reader.onload = function(e) &#123; var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')'; &#125;; // 以DataURL的形式读取文件:(异步操作) reader.readAsDataURL(file); &#125;); 5、AJAX 需要注意的几点： 1、通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest 2、先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成 3、XMLHttpRequest对象的open()方法有3个参数，分别为请求方式、URL地址、是否使用异步。 4、send 发送，Get 不需要参数，Post 需要把 body 部分以字符串或者 FormData 对象传进去。 关于 FromData 请查看：FormData 123456789101112131415161718192021222324252627282930313233343536373839function success(text) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = text;&#125;function fail(code) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code;&#125;var request;if (window.XMLHttpRequest) &#123; //现代浏览器 request = new XMLHttpRequest();&#125; else &#123; //低版本 IE 浏览器 request = new ActiveXObject('Microsoft.XMLHTTP');&#125;request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果 if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 6、Cookie▉ 定义 1）概念：Cookie 小段文本信息，存储于计算机硬盘中，大小只有 4 k。 2）特点：每个 Cookie 文件都对应一个域名，同一域名下的所以页面可以共享 Cookie，不能跨域名访问。 3）使用：通常从 document 中提取 cookie 属性提供给 javascript，然后进行创建或发送 cookie 到服务器。 ▉ 作用 cookie 是存在用户硬盘中，用户每次访问站点时，Web应用程序都可以读取 Cookie 包含的信息。当用户再次访问这个站点时，浏览器就会在本地硬盘上查找与该 URL 相关联的 Cookie。如果该 Cookie 存在，浏览器就将它添加到 request header 的 Cookie 字段中，与 http请求 一起发送到该站点。 ▉ 缺点 安全性：由于cookie在HTTP中是明文传递的，其中包含的数据都可以被他人访问，可能会被篡改、盗用。 大小限制：cookie的大小限制在4KB左右，若要做大量存储显然不是理想的选择。 增加流量：cookie每次请求都会被自动添加到Request Header中，无形中增加了流量。cookie信息越大，对服务器请求的时间也越长。 ▉ 用途 Cookie 一般用于保存网页访问者的信息。 1）保存用户登录信息。在一些登录网站选择下次自动登录，登录成功后，后台对用户名和密码进行加密返回数据，客户端就会将数据存储到 Cookie 中。当用户下一次进行登录时，判断 Cookie 中否存在值，存在则将Cookie 信息加到 HTTP 头部发送到服务器，实现自动登录。 2）创建购物车。通常将选择的物品放入 Cookie 中，同一域名下页面实现 Cookie 共享，提交订单将 Cookie 传到后台。 3）跟踪用户。用 Cookie 记录用户的偏好信息，然后推广小广告，在侧边栏经常是我们之前搜索过的内容。 ▉ 其他存储机制 1）web存储机制 sessionStorage：用于一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除 localStorage ：用于跨会话持久化地存储数据。 2）indexedDB 是 indexed Database API 的简称，是在浏览器中保存结构化数据的一种「数据库」，它类似SQL数据库的结构化数据存储机制 ， 它能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。 7、 同源跨域问题请查看另一篇：]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 CSS3 之基础篇【转换】]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E8%BD%AC%E6%8D%A2%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进 CSS3 转换，好玩又是重点。 一、Treansform CSS3 变形属性。 让元素在一个坐标系中变形。这个属性包含一系列的变形函数，可以移动、旋转和缩放元素。 ▉ 语法1transform:none | &lt;tranform-function&gt; ▉ 兼容性1IE12+、ForeFox16+、Chrome36+、Safari16+、Opera23+ 二、2D 转换 rotate() 旋转 translate() 平移 scale() 缩放 skew() 扭曲和斜切 matrix() 矩阵或混合 1、旋转 rotate 通过指定的角度参数对原元素指定一个 2D rotation （2D 旋转）。 ▉ 语法1transform: rotate(&lt;angle&gt;); ▉ 参数说明angle 指旋转角度，正数表示顺时针旋转，负数表示逆时针旋转。 2、移动 translate 根据左（X轴）和顶部（Y轴）位置给定的参数，从当前元素位置移动。 ▉ 语法1transform: translate (); ▉ 三种情况 translateX(x) 仅仅水平方向移动（X 轴移动）； translateY(Y) 仅垂直方向移动（Y 轴移动）; translate(x,y) 水平方向和垂直方向同时移动（也就是 X 轴和 Y 轴同时移动）。 3、scale 缩放 2D 缩放。 ▉ 三种缩放 scaleX() 水平方向缩放 scaleY() 垂直方向缩放 scale() x y 同时缩放 4、扭曲 skew 斜切扭曲。 ▉ 三种扭曲 skewX（）水平扭曲（正值，逆时针） skewY（）垂直扭曲（正值，顺时针） skew（）水平垂直同时扭曲 5、矩阵 matrix（难点） 矩阵分为 matrix 和 matrix3d 矩阵，分别为 3 3 和 4 4 的矩阵。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 CSS3 之基础篇【图片切换】]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2%E3%80%91%2F</url>
    <content type="text"><![CDATA[CSS3 实现图片多样式切换！ 一、不同格式的字体对浏览器的兼容性不同 Browser @font-face TrueType WOFF EOT SVG SVGZ IE 4+ 9+ 9+ 4+ 火狐 3.5+ 3.5+ 3.6+ 谷歌 4+ 4+ 6+ 4+ 6+ 苹果 3.1+ 3.1+ 6+ 3.1+ 3.1+ opera 10+ 10+ 11.1+ 10+ 10+ 二、内联元素的自动转换 当给一个内联元素加以下属性就会转换为块元素。 1、float; 2、position; 3、absolute;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析之 Python 【Pandas】]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%20Python%20%E4%B9%8B%E3%80%90Pandas%E3%80%91%2F</url>
    <content type="text"><![CDATA[如果日常数据清理工作不是非常复杂，几句 Pandas 代码就给你搞定！ 一、Series 和 DataFrame 分别代表着一维的序列和二维的表结构。基于这两种数据结构，Pandas 可以对数据进行导入、清洗、处理、统计和输出。 1、Series Series 是个定长的字典序列。 1、Series 有两个属性：values 和 index（默认的index为1,2…），指定 index 比如 index=[‘a’,’b’,’c’,’d’]。 12345678910111213141516171819import pandas as pdfrom pandas import Series,DataFramex1 = Series([1,2,3,4])x2 = Series(data=[1,2,3,4], index=['a','b','c','d'])print(x1)print(x2)# 输出结果0 11 22 33 4dtype: int64a 1b 2c 3d 4dtype: int64 ▉ 数据字典创建 用数据字典的方式创建 Series。 12345678910# 数据字典创建 Seriesd = &#123;'a':1,'b':2,'c':3,'d':4&#125;x3 = Series(d)print(x3)# 结果a 1b 2c 3d 4dtype: int64 2、DataFrame 类似数据库的表。包括行索引和列索引。 12345678910111213141516171819202122232425262728import pandas as pdfrom pandas import Series,DataFrame# 数据data = &#123; 'Chinese':[66, 95, 93, 90, 80], 'English':[65, 85, 92, 88, 90], 'Math':[30, 98, 96, 77, 90] &#125;# 索引默认 1,2,3...df1 = DataFrame(data)# 设置索引df2 = DataFrame( data, # 行索引 index=['ZhangFei', 'GuanYu', 'ZhaoYun', 'HuangZhong', 'DianWei'], # 列索引 columns=['English', 'Math', 'Chinese'] )print(df1)print(df2)# 结果4 80 90 90 Chinese English MathZhangFei 66 65 30GuanYu 95 85 98ZhaoYun 93 92 96HuangZhong 90 88 77DianWei 80 90 90 二、数据的导入和输出 Pandas 允许直接从 xlsx,csv 等文件导入数据，也可以输出到这些文件。 1# python3.0 安装 openpyxl 包 三、数据清洗1、删除 DataFrame 中不必要的行或列123456789101112131415161718192021import pandas as pdfrom pandas import Series,DataFramedata = &#123; 'Chinese': [66, 95, 93, 90,80], 'English': [65, 85, 92, 88, 90], 'Math': [30, 98, 96, 77, 90]&#125;df2 = DataFrame(data, index=['ZhangFei', 'GuanYu', 'ZhaoYun', 'HuangZhong', 'DianWei'], columns=['English', 'Math', 'Chinese'] )print(df2)# drop 删除 DataFrame 中不必要的列或行# columns 删除行df2 = df2.drop(columns=['Chinese'])print(df2)# index 删除列df2 = df2.drop(index=['ZhangFei'])print(df2) 2、重命命列名 columns，让列表名更容易识别 对列名重新命名，直接使用 rename(columns = new_name,inplace=True)函数。 123# 重命名列名df2.rename(columns=&#123;'Chinese':'YuWen','English':'YingYu'&#125;,inplace = True)print(df2) 3、去重复的值 数据采集有重复的行，使用 drop_duplicates() 就会自动把重复的行去掉。 12# 去除重复行df = df.drop_duplicates() 4、格式问题▉ 更改数据格式 使用 astype 函数来规范数据格式，比如 Chinese 字段的值改为 str 类型，或者 int64 可以这么写。 123# 更改数据格式df2['YuWen'].astype('str')df2['YuWen'].astype(np.int64) ▉ 数据间的空格 用 strip 函数删除数据之间的空格。 123456# 删除左右两边空格df2['Chinese']=df2['Chinese'].map(str.strip)# 删除左边空格df2['Chinese']=df2['Chinese'].map(str.lstrip)# 删除右边空格df2['Chinese']=df2['Chinese'].map(str.rstrip) 删除某一个字段里的特殊符号。 12# 删除某一字段中的特殊符号df2['YuWen']=df2['YuWen'].str.strip('$') ▉ 大小写转换 对人名、城市名为了统一都可能用到大小写转换，直接用 upper()、lower()、title() 函数，方法如下。 123456# 全部大写df2.columns = df2.columns.str.upper()# 全部小写df2.columns = df2.columns.str.lower()# 首字母大写df2.columns = df2.columns.str.title() ▉ 查找空值 数据量大的情况下，有很多字段存在 NaN 的可能，使用 isnull 函数进行查找。 12345678910111213141516# 查找空值print(df2.isnull());# 只显示空值df2.isnull().any()# 结果1 Yingyu Math YuwenGuanYu False False FalseZhaoYun False False TrueHuangZhong False False TrueDianWei False False True# 结果2Yingyu FalseMath FalseYuwen Truedtype: bool]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 CSS3 之基础篇【过渡】]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E8%BF%87%E6%B8%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[CSS 过渡会用到什么地方呢？ 一、CSS3 过渡 1、允许 css 的属性值在一定的时间区间内平滑地过渡。 2、在鼠标点击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变 css 的属性值。 ▉ 兼容性 IE 10+、FireFox16+、Chrome26+、Safari6.1+ Opera 12.1 + 二、CSS3 transition 属性(4个)1、transition-property 属性 检索或设置对象中的参与过渡的属性。 ▉ 语法1transition-property:none|all|property 参数说明： none : 没有属性改变 all : 所有属性改变，默认值 property: 元素的属性名称 2、transition-property 属性 检索或设置对象过渡的持续时间。 ▉ 语法1transition - duration: time; 参数说明： 规定完成过渡效果需要花费的时间（以秒或毫秒计） 默认为 0 3、transition-timing-function 属性 检索或设置独享中的过渡的当动画类型。 ▉ 语法1transition-timing-function：ease|linear|ease-in|ease-out|ease-in-out|step-start|step-end 参数说明： linear：匀速过渡 ease：平滑过渡（慢—快—慢） ease - in：由慢到快 ease - out: 由快到慢 ease - in - out：由慢到快再到慢（最人性化） step-start：等同于 steps(1,start) step-start：等同于 steps(1,end) 3、transition-delay 属性 检索或设置对象延迟过渡的时间。 ▉ 语法1transition-delay：time; 4、transition 复合属性 复合属性 ▉ 语法12//属性 过渡时间 类型 延迟transition:property duration timing-fnction delay;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 CSS3 之基础篇【选择器】]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E8%BE%B9%E6%A1%86%E4%B8%8E%E9%98%B4%E5%BD%B1%E3%80%91%2F</url>
    <content type="text"><![CDATA[带你走进 CSS3 的边框与阴影！ 一、CSS3 圆角1、border - radius 属性 最多可以指定四个 border -*- radius 属性的符合属性，这个属性允许为你元素添加圆角边框！ ▉ 语法1border-radius:1-4 length|% ▉ 兼容性 IE9+、FireFox4+、Chrome、Safari5+、Opera 123456//不同浏览器使用不同内核来渲染-webkit-border-radius：50%;//谷歌浏览器 -moz-border-radius:50%;//火狐浏览器 -ms-border-radius:50%;//IE 浏览器 -o-border-radius:50%;//Opera浏览器 border-radius:50%; 12345678910&lt;style&gt; div&#123; width: 800px; height: 300px; border: 5px solid red; margin: 0 auto; /* 左上角、右上角、右下角、左下角 */ border-radius: 10px 20px 30px 40px; &#125;&lt;/style&gt; ▉ 指定每个圆角 border-top-left-radius 定义左上角的弧度 border-top-right-radius 定义右上角的弧度 border-bottom-left-radius 定义左下角的弧度 border-bottom-right-radius 定义右下角的弧度 二、CSS 盒阴影属性 可以设置一个或多个下拉阴影的框。 1、box-shadow 属性▉ 语法12//水平偏移量，垂直偏移量，模糊，扩展(向周边长度进行扩展)，颜色，内阴影box-shadow:h-shadow v-shadow blur spread color insert; ▉ 兼容性 IE9+、FireFox4+、Chrome、Safari5+、Opera 三、CSS 边界图片1、border-image 属性 使用 border-image- * 属性来构建魅力的可扩展按钮。 ▉ 语法12// border-image:source slice width outset repeat; ▉ 兼容性 IE 不兼容、FireFox、Chrome、Safair6+、Opera 不兼容。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络原理之【五层协议】]]></title>
    <url>%2F2019%2F03%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E3%80%90%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[网络协议是每个工程师必须要掌握的知识。 从底层到高层看网络协议（从下到上）一、物理层1、物理层通过物理手段将电脑连接起来，主要负传送 0 ，1 信号来通信。但是单纯的 0 1 没有任何意义，也没有规定怎么结合，那么有了链路层。 二、链路层2、链路层诞生意味着通过规定的“以太网”协议规定的电信号的分组形式，不同分组代表不同的信息，双方通信都可以识别这些信息。发送方和接受方怎么确定对方是谁的？（要有个标识才行） 3、每台计算机都要有“网卡”，数据包都是通过网卡传输的，每个网卡都有一个地址，叫做 MAC 地址（每台计算机一出生在厂商就确定的），也就明确了数据包的发送地址和接收地址。有了标识了，发送方怎么才能知道接收方的 MAC 地址呢？（ARK协议） 4、如果两台设备不在同一网络中，那么没办法知道对方的 MAC 地址，只能通过连接两个子网络的网关去处理；具体过程是： 首先判断两个设备是否在同一子网中，如果不在，发送方就将数据包发送到子网的网关，首先要通过 ARK 协议知道网关的 MAC 地址，然后该网关通过路由发送到接收方的网关，然后送达接收方。 如果在同一网络中，我们就通过 ARK 协议得到对方的 MAC 地址。因为每台设备都有一个 IP 地址，所以我们想着通过 IP 地址去确定对方的 MAC 地址。该发送方通过 ARP 协议广播的形式发送一个带有对方 IP 的数据包，子网中的每个计算机都收到了该数据包，就取出头部的IP地址信息对比，如果和自己的一样，接收方就给发送方报告自己的 MAC 地址，否则就丢弃这个包。通过 ARP 协议我们就知道了同一子网中的 MAC 地址，可随意发送信息。 既然知道了对方的 MAC 地址，怎么准确的将数据发送过去呢？ 5、并不是我们所想的直接送达，而是通过广播的方式，向网络的所有计算机发送，让每台计算机通过读取数据包的标头看看和自己的 MAC 地址是否一样，如果一样就接受数据呗。 三、网络层6、链路层的兄弟，没人都要送一个包，你这发送消息效率太低了，而且只能在一个子网络中发送，如果别人不在这个网络中是发送不出去的，太 Low，给我改进。 7、那行，我改，那找我路由朋友来帮忙，如果路由朋友来帮忙，如果两个计算机不在子网络中，那么让我朋友路由去发送，如果在同一子网络中，那么我自己来负责，省的整天给我瞎BB。 8、链路兄弟，两台计算机不在同一子网络中的通信你怎么甩给我了？真不够哥们，我只能通过 “网络地址” 来识别不同子网中的通信了。 9、网络地址需要有规矩，不能瞎规定，规定网络地址的协议叫做 IP 协议，定义的地址叫做 IP 地址。通常是由四段的十进制表示（32个二进制），从 0.0.0.0 到 255.255.255.255（每段由 8 位二进制组成 2^8）。 10、每台计算机都会分配一个 IP 地址，每个 IP 地址分为两部分，一部分是代表网络地址，另一部分代表主机地址。若网络部分地址相同，这两台计算机必处于同一子网中。那怎么区分这个IP的前多少位代表的是网络地址，后多少位代表的是主机地址呢？这个在 IP 地址上看不出来。 11、那么我们用另一个 32 位的二进制值来专门来代表。形式和 IP 地址的形式完全一样的，1 代表网络地址部分，0 代表主机部分。（11111111.11111111.11111111.00000000 十进制为 255.255.255.0，前24位代表网络部分，后8位代表主机部分） 12、判断两个 IP 是否在同一网络中方法就是两个 IP 地址与子网掩码进行 AND 运算（两数为1，结果为1，其他为0）。最后的比较结果相同就处在同一子网络中。 13、当两台计算机不在同一子网时，就通过 IP 协议发送数据包了。IP 数据包要有 IP 地址的信息呀，那么就将 IP 数据包放到以太网数据包的数据部分，这样一来，就体现出了互联网分层的好处。上层变动，和上层变动没有什么太大关系。 网络层的通信是主机到主机的通信。 四、传输层14、虽然通过上述的 IP 地址和 MAC 地址可以进行通信了，但是计算机打开多个软件，怎么才能知道网络传来的信息那是哪个软件的？ 15、那么我们就规定不同的程序数据要走不同的端口。传输层的功能就是建立“端口到端口”的通信。主机和端口确认了，就可以正常的进行通信了。 16、在数据包中加入端口信息，就需要新的协议，就用 UDP 协议来实现。将端口信息打包之后，将放入到 IP 数据包中。但是 UDP 简单，但是可靠性差，一旦发出数据包，无法知道对方是否收到？ 17、那么具有验证功能的 UDP 协议 TCP 协议诞生了，TCP也是内嵌在 IP 数据包中的。每个发送的数据包都要确认一下对方是否收到，如果收到没收到的确认，就重新发送该数据包，但是 TCP 的实现非常复杂。 五、应用层18、应用层主要对数据进行读取，因为数据包的数据来自有不同的程序，格式各不相同，所以要规定好格式再进行解读，否则无法解读。应用层的作用就是规定应用程序的数据格式。应用层规定格式的数据包在 TCP 数据包中。 从高层到底层看网络协议（从上到下）一、配置上网参数 本机 IP 地址 子网掩码 网关的 IP 地址 DNS 的 IP 地址 1、计算机上网必须设置 IP 地址、子网掩码、网关地址以及 DNS，这样计算机每次开机都会设置这样的地址，这种地址叫做“静态IP地址“。不过有一个缺点，如果这台计算机不上网总是占用这个IP地址，所以必须设置动态获取IP。 2、每次开启计算机都要动态分配一个 IP 地址，所使用的协议为 DHCP 协议，在每一个子网络中都会有一台计算机专门负责分配 IP 地址，这个机器叫做“DHCP服务器”。 3、每次计算机开机，都会向 DHCP 服务器发送一个请求申请IP地址等信息。发送请求必须知道对方的IP地址和MAC地址，起初的两台计算机都没有设置，应该怎么办？ 4、这时用到 DHCP 的巧妙设计，DHCP 是基于 UDP 协议的。因为发送方不知道对方的 MAC 地址，所以在数据包中设置 FF-FF-FF-FF-FF-FF，将其封装到以太网的数据包中。由于计算机也不知道自己的IP地址，所以发送方的 IP 地址为 0.0.0.0。DHCP 服务器的 IP 地址为255.255.255.255，将信息封装到 IP 头部。然后将端口号信息进行封装到 UDP 的头部，发送方的端口号为 68 端口，接收方的端口号为 67 端口。 5、发送方开始进行广播发送，子网络中的计算机接收到数据包，首先查看以太网数据包中的 MAC 地址为 FF-FF-FF-FF-FF-FF，不能确认是谁发送的数据，然后查看 IP 头部发现地址为 0.0.0.0，于是 DHCP 知道了这个包是给自己发的，其他计算机将会丢弃这个包。 6、然后 DHCP 服务器读取这个包的数据内容，分配好 IP 地址，然后发送回去一个 DHCP 响应，新加入的计算机接收到响应包之后，就会进行配置。 二、网页请求过程1、首先在浏览器输入一个域名，是没有 IP 地址的，先要将域名传到 DNS 服务器进行解析，DNS 服务器会返回一个锁清秋服务器的 IP 地址。 2、然后判断两个计算机是否在同一个子网络中，就会用到子网掩码，两台计算机的 IP 地址分别对子网掩码进行 AND 运算，发现不在同一子网络中，所以必须通过网关发送数据包，此时接受方的 MAC 地址是网关的 MAC 地址。 3、浏览网页所用的是 HTTP 协议，将其嵌入在 TCP 数据包中，TCP 数据包需要设置端口，将信息嵌入在 IP 数据包中，IP数据包需要设置双方的 IP 地址，然后将 IP 数据包嵌入在以太网的数据包中，以太网数据包需要设置双方的 MAC 地址，然后将数据包在网络中传输。 （注意：如果 IP 数据包过长，需要分割发送） 4、经过多个网关的转发，服务器收到数据包，将其多个数据包进行拼接，取出完整的 TCP 数据包，然后读出 HTTP 的请求，做出 HTTP 响应，然后再用 TCP 协议发回来。 一、网络层中协议1、五层模型 越最下层越靠近硬件，越最上方的层，越靠近用户。 应用层 传输层 网络层 数据链路层 物理层 2、层与协议 互联网分为若干层，每一层都有特定的功能和规则。大家都要遵守的规则叫做 “协议”。每次层都有很多协议，总起来叫做“互联网协议”。 3、物理层 物理层主要是通过光缆、电缆、双绞线、无线电波等方式把电脑连起来，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。 4、链路层▉ 定义 问题：单纯的 0 和 1 没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？ 解决：这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。 ▉以太网协议（数据包的定义） 一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。 标头：包含数据包的一些说明项，比如发送者、接受者、数据类型等等 。 数据： 数据包的具体内容 。 ▉MAC地址 问题：发送者和接受者是如何标识呢？ 解决：以太网规定，连入网络的所有设备，都必须具有”网卡“接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。 ▉广播 1、问题：一块网卡怎么会知道另一块网卡的MAC地址？以太网数据包必须知道接收方的MAC地址，然后才能发送。 解决：通过 ARP 协议知道对方的 MAC 地址。 2、问题：知道MAC地址了，系统怎样才能把数据包准确送到接收方 ？ 解决： 发送方并不是准确的发送到接受方，而是向本网络内所有计算机发送，每台计算机判断是否接收？它们读取这个包的”标头”，找到接收方的 MAC 地址，然后与自身的 MAC 地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。 5、网络层▉ 由来 上述虽然可以实现通信，存在一下弊端： 1）局限在发送者所在的子网络 。 2）以广播发送效率低下。 3）两台机器不在子网络。广播是传不过去的。 ▉ 网络层的定义 问题：怎么做到如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送？ 解决: 这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。 ▉ 网络地址和MAC地址的区别？ 1、两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。 2、网络在确定所在子网络的时候，先处理网络地址，然后在处理MAC地址。 ▉ IP 协议 作用： 一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 定义：规定网络地址的协议，叫做IP协议。它所定义的地址，就被称 为IP地址。 组成： 地址分成两个部分，前一部分代表网络，后一部分代表主机 。可以判断两台计算机是否处于同一网络中。 ▉ 子网掩码 问题： 对于 IP 地址无法判断网络部分，到底是前16位还是前24位代表网络地址？ 解决：子网掩码 组成: 它的网络部分全部为1，主机部分全部为0。 比如，比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 ▉ 判断是否处于同一网络 将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。 ▉ IP 数据包 之前的以太网数据包只包含 MAC 地址，没有 IP 地址的栏位。并不需要添加 IP 栏位，我们直接将 IP 数据包添加到以太网数据包的数据部分。这就是互联网分层的好处，上层的变动完全不涉及下层的结构。 IP 数据包： 标头：包括版本、长度、IP地址等信息。 数据：IP 数据包的具体内容。 ▉ ARP 协议 问题：IP 数据包是放在以太网数据包里发送的，所以同时知道 IP 地址和 MAC 地址，IP 地址是已知的，但是不知道 MAC 地址。我们需要从 IP 地址中的到 MAC 地址。 解决： 两种情况：是否在同一子网络。 第一种情况，不在同一子网络，将数据包扔给两个子网络连接处网关处理。 第二种情况，同一子网络中，通过 ARP协议。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包 。 6、传输层 问题：计算机很多程序同时运行，那一个数据包传过来怎么区分知道是哪个程序的内容呢？ 解决：提供一个参数，用来表示数据包对应的程序，这个参数叫做“端口（port）”。每个数据包发送到特定的端口，不同的程序就能取到自己所需要的数据。 ▉ 端口 “端口”是0到65535之间的一个整数，正好16个二进制位。应用程序会随机选用一个端口，然后与服务器的相应端口联系。 ▉ 功能 “传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。 ▉ UDP 协议 在数据包中加入端口号，就实现了新的协议叫 UDP 协议。将数据包存放到 IP 数据包中。 优点：比较简单，容易实现。 缺点：可靠性较差，一旦数据包发出，无法知道对方是否收到。 ▉ TCP 协议 为了提高网络的可靠性，就诞生了新的协议叫做 TCP 协议（有确认机制的 UDP 协议）。将数据包存放到 IP 数据包中。 每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。 优点：可靠性好，稳定性好。 缺点：过程复杂、实现困难、消耗较多的资源。 7、应用层 应用层接收到“传输层”的数据，然后进行读取数据。读取前必须规定好格式，否则无法读取。TCP 通过各种各样的程序传输数据，不同的协议规定了不同数据的格式，这些程序协议就构成了“应用层”。 ▉ 作用 规定应用程序的数据格式。]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
      <tags>
        <tag>网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析之 Python 【NumPy库】]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%20Python%20%E3%80%90NumPy%E5%BA%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[NumPy 是一个重要的 Python 库，有哪些操作呢？ 一、Numpy是什么？ Python 中使用最多的第三方库，NumPy 所提供的数据结构是 Python 数据分析的基础。 ▍两个对象 1、ndarray解决了多维数组问题。 2、ufunc 则是解决对数组进行处理的函数。 二、Numpy 和 list 的区别？ 1、 Python中的 list 保存的是对象的指针，因此数据量大时很占内存，所以会慢。 2、NumPy 数组存储在一个均匀连续的内存块中，这样数组计算遍历所有的元素，不像列表 list 还需要对内存地址进行查找，从而节省了计算资源，比较快。 三、Numpy 的使用1、安装 Numpy 使用 pip 命令进行安装，如果 pip 不是内外部命令，则在 path 环境变量中进行配置。 1pip install numpy 2、创建数组 在 NumPy 数组中，维数称为秩（rank），一维数组的秩为 1，二维数组的秩为 2，以此类推。在 NumPy 中，每一个线性的数组称为一个轴（axes），其实秩就是描述轴的数量。 123456789101112import numpy as npa = np.array([1,2,3])b = np.array([[1,2,3],[4,5,6],[7,8,9]])//添加数据b[1,1] = 10// 获取数组大小print(a.shape)print(b.shape)//获取元素类型print(a.dtype)print(b) 3、结构数组 总体数量中的某一类数据，求平均数等操作。 123456789101112131415161718import numpy as nppersontype = np.dtype(&#123; 'names':['name','age','chinese','math','english'], 'formats':['S32','i', 'i', 'i', 'f']&#125;)# 添加数据,参数二：设置数组的类型persons = np.array([("ZhangFei",32,75,100, 90), ("GuanYu",24,85,96,88.5), ("ZhaoYun",28,85,92,96.5), ("HuangZhong",29,65,85,100)],dtype = persontype)# 统计每个人的年龄ages = persons[:]['age']print(ages)# 计算年龄的平均数print(np.mean(ages)) S32 : 32个字节的字符串类型，由于结构中的每个元素的大小必须固定，因此需要指定字符串的长度 i : 32bit的整数类型，相当于np.int32 f : 32bit的单精度浮点数类型，相当于np.float32 4、ufunc 运算 对数组中的每个元素进行操作。ufunc 计算速度快，底层是 c 语言实现的。 5、连续数组的创建 使用 arange 或 linspace 创建连续函数。 ▉ arange 通过指定（初始值、终值、步长）来创建等差数列的一维数组，默认不包括终值。 1x1 = np.arange(1,11,2)//[1 3 5 7 9] ▉ linspace 通过指定（初始值、终值、元素个数）来创建等差数列的一维数组，默认包括终值。 6、算数运算 通过 NumPy 可以自由地创建等差数组，同时也可以进行加、减、乘、除、求 n 次方和取余数。 12345678910111213141516171819202122import numpy as npx1 = np.arange(1,11,2)x2 = np.linspace(1,9,5)# 相加print(np.add(x1,x2))# 相减print(np.subtract(x1,x2))# 相乘print(np.multiply(x1,x2))# 相除print(np.divide(x1,x2))# 求 n 次方print(np.power(x1,x2))# 取余print(np.remainder(x1,x2))print(np.mod(x1,x2)) 7、统计函数 对大量数据进行描述性的统计分析。最大值、最小值、平均值，是否符合正态分布、方差、标准差多少等等。 ▉ 计算数组/矩阵的最大值函数(amax()),最小值函数 (amin())123456789101112import numpy as npa = np.array([[1,2,3],[4,5,6],[7,8,9]])# 数组中的最大值print(np.amax(a))# 延 axis=0 轴(纵轴)的最小值print(np.amin(a,0))# 延 axis=1 轴(横轴)的最小值print(np.amin(a,1)) ▉ 统计最大值与最小值之差12345678# 数组中最大值和最小值之差print(np.ptp(a))# 延 axis=0 轴(纵轴)最大值和最小值之差print(np.ptp(a,0))# 延 axis=1 轴(横轴)最大值和最小值之差print(np.ptp(a,1)) ▉ 统计数组的百分位数 percentile() percentile() 代表着第 p 个百分位数，这里 p的取值范围是 0-100，如果 p=0，那么就是求最小值，如果 p=50 就是求平均值，如果 p=100 就是求最大值。同样你也可以求得在 axis=0 和 axis=1 两个轴上的 p% 的百分位数。 1234567a = np.array([[1,2,3],[4,5,6],[7,8,9]])# 统计数组的百分位数print(np.percentile(a,100))//9.0print np.percentile(a, 50, axis=0)print np.percentile(a, 50, axis=1) ▉ 统计数组中的中位数 median、平均数 mean()12345# 求中位数print(np.median(a))# 求中位数print(np.mean(a)) ▉ 统计数组中的加权平均值 average() average() 函数可以求加权平均，加权平均的意思就是每个元素可以设置个权重，默认情况下每个元素的权重是相同的，所以np.average(a)=(1+2+3+4)/4=2.5，你也可以指定权重数组 wts=[1,2,3,4]，这样加权平平均 np.average(a,weights=wts)=(11+22+33+44)/(1+2+3+4)=3.0。 12345# 统计数组的加权平均值a = np.array([1,2,3,4])wts = np.array([1,2,3,4])print(np.average(a))print(np.average(a,weights=wts)) ▉ 统计数组中的标准差 std()、方差 var() 方差的计算是指每个数值与平均值之差的平方求和的平均值,标准差是方差的算术平方根(代表的是一组数据离平均值的分散程度)。 1234# 求标准差和方差a = np.array([1,2,3,4])print(np.std(a))print(np.var(a)) 8、NumPy 排序1sort(a, axis=-1, kind=‘quicksort’, order=None) 1、使用 sort 函数，kind 的值可以指定为 quicksort 、mergesort、heapsort分别表示快速排序、归并排序、堆排序，一般使用快速排序。 2、同样 axis 默认是 -1，即沿着数组的最后一个轴进行排序，也可以取不同的 axis 轴，或者 axis=None 代表采用扁平化的方式作为一个向量进行排序。 3、order 字段，对于结构化的数组可以指定按照某个字段进行排序。 12345678910111213141516171819# NumPy 排序# 4 3 2# 2 4 1a = np.array([[4,3,2],[2,4,1]])# 横轴排序print(np.sort(a,axis=-1))# 纵轴排序print(np.sort(a,axis=0))print(np.sort(a,axis=1))# 结果[[2 3 4] [1 2 4]]---------[[2 3 1] [4 4 2]]---------[[2 3 4] [1 2 4]]]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 CSS3 之基础篇【选择器】]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[CSS3 所有基本选择器（必会）！ 基本选择器一、回顾选择器（5个） 1、通配符选择器 *{} 2、元素选择器 h1{} 3、类选择器 .container{} 4、ID选择器 #id{} 5、后代选择器 ul em{ } 二、新增基本选择器（4个） 子元素选择器，相邻兄弟元素选择器，通用兄弟选择器，群组选择器。 1、直接后代选择器（子元素选择器） 只能选择某元素的子元素。 ▉ 语法格式 父元素 &gt; 子元素 （Father &gt; Children） ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 123456789101112&lt;style&gt; section&gt;div&#123; color: #0f0f; &#125;&lt;/style&gt;&lt;section&gt; //这个div变色 &lt;div&gt;外边的DIV&lt;/div&gt; &lt;article&gt; &lt;div&gt;里边的DIV&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 2、相邻兄弟选择器 相邻兄弟选择器可以选择紧接在另一元素后的元素，而且他们具有一个相同的父元素。 ▉ 语法格式 元素 + 兄弟相邻元素。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 123456789101112131415&lt;style&gt; section&gt;div + article&#123; color: #0f0f; &#125;&lt;/style&gt;&lt;section&gt; &lt;div&gt;外边的DIV&lt;/div&gt; &lt;!-- 控制这一个 --&gt; &lt;article&gt; &lt;div&gt;里边的DIV&lt;/div&gt; &lt;/article&gt; &lt;article&gt; &lt;div&gt;里边的DIV&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 3、通用兄弟选择器 选择某元素后边的多有兄弟元素，而且他们具有一个相同的父元素。 ▉ 语法格式 元素 ~ 后面所有兄弟相邻元素 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 1234567891011121314151617 &lt;style&gt; section&gt;div ~ article&#123; color: #0f0f; &#125; &lt;/style&gt; &lt;section&gt; &lt;!-- div 前边的 article 不会被选择 --&gt; &lt;div&gt;外边的DIV&lt;/div&gt; &lt;!-- 控制这一个 --&gt; &lt;article&gt; &lt;div&gt;里边的DIV&lt;/div&gt; &lt;/article&gt; &lt;!-- 也控制这一个 --&gt; &lt;article&gt; &lt;div&gt;里边的DIV&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 4、群组选择器 相同元素的样式分组在一起，每个选择器之前使用逗号 “，” 隔开。 ▉ 语法格式 元素，元素，…，元素n ▉ 兼容性 IE6+、FireFox、Chrome、Safari、Opera。 12345section &gt; div,section &gt; article,section &gt; aside&#123; color:#000;&#125; 三、伪类选择器（5个）1、动态伪类选择器 并不存在 HTML 中，只有当用户和网站交互的时候才能体现出来。 ▉ 锚点伪类 : link，: visited。 ▉ 用户行为伪类 : hover（必须写在 link 和 visited 才会生效）, : active（必须写在 hover 后才会生效）,: focus(用于input输入) 2、UI元素状态伪类 把“：enabled”，“：disabled”，“：checked” 伪类称为UI元素状态伪类。 ▉ 兼容性 IE9+、FireFox、Chrome、Safari、Opera。 123456789101112&lt;style&gt; input:enable&#123; width:100px; height:100px; background: #0000ff; &#125; //没有宽和高 input:disabled&#123; background: #0000ff; &#125;&lt;/style&gt;&lt;input type="text" disabled="disabled"&gt; 3、否定选择器 :not （Element/selector）选择器匹配非指定元素/选择器的每个元素。 ▉ 语法格式 父元素：not(子元素/子选择器) ▉ 兼容性 IE9+、FireFox、Chrome、Safari、Opera。 123nav &gt; a:not(:last-of-type)&#123; border-right:1px solid red;&#125; 四、伪元素选择器 伪元素用于向某些选择区设置特殊效果。 :first-line: 应用于多行文本的首行元素。应用于块元素。 :first-letter: 选取首字母。应用于块元素。 :first-child:选择父元素的第一个子元素。注意：在 IE 中声明&lt;!DOCTYPE&gt; 才生效！ :before:元素之前添加内容 :after : 元素之后添加内容 五、属性选择器 Element[attribute]、Element[attribute= “value” ]、Element[attribute~= “value” ]、Element[attribute^= “value” ]、Element[attribute$= “value” ]、Element[attribute*= “value” ]、Element[attribute|= “value” ]。 1、Element[attribute] 为带有 attribute 属性的 Element 元素设置样式。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 123456&lt;style&gt; a[href]&#123; text-decoration: none; &#125;&lt;/style&gt;&lt;a href="attribute.html"&gt;atribute&lt;/a&gt; 2、Element[attribute= “value” ] 为 attribute= “value” 属性的 Element 元素设置样式。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 1234a[href = "attribute.html"]&#123; text-decoration: none; color: #f0f; &#125; 3、Element[attribute~= “value” ] 选择 attribute 属性包含单词 “value” 的元素，并设置其样式。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 123456789&lt;style&gt; a[class ~= "two"]&#123; text-decoration: none; color: #f0f; &#125;&lt;/style&gt;&lt;a class="one two" href="attribute.html1"&gt;atribute&lt;/a&gt;&lt;a class="two three" href="attribute.html2"&gt;atribute&lt;/a&gt; 4、Element[attribute^= “value” ] 选择以 value 开头的元素。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 123456789101112&lt;style&gt; a[href ^= "attribute.html"]&#123; text-decoration: none; color: #f0f; &#125;&lt;/style&gt; &lt;a href="attribute.html"&gt;atribute&lt;/a&gt;//变 &lt;a class="one two" href="attribute.html1"&gt;atribute&lt;/a&gt; &lt;a class="two three" href="attribute.html2"&gt;atribute&lt;/a&gt; &lt;a href="attribute.html3"&gt;atribute&lt;/a&gt;//变 &lt;a href="attribute.html4"&gt;atribute&lt;/a&gt;//变 &lt;a href="attribute.html5"&gt;atribute&lt;/a&gt;//变 5、Element[attribute$= “value” ] 选择以 value 结尾的元素。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 6、Element[attribute*= “value” ] 选择包含 value 的元素。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 7、Element[attribute|= “value” ] 选择为 “value” 或者以 “value-” 开头的元素，并设置其样式。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 六、CSS 权重1、什么是权重？ 很多规则被应用于某一个元素上，权重就是那中规则生效。或者说是优先级。 2、权重等级与权值 行内样式（1000）&gt; ID 选择器（100）&gt;类、属性选择器和伪类选择器（10）&gt;元素和伪类（1）&gt; * (0)。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析之 Python 【基础篇】]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%20Python%20%E3%80%90%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%91%2F</url>
    <content type="text"><![CDATA[快速入门 Python 基础! 1、输入输出 input 用于 py3.0 的输入，print 用于输出。 1234name = input("请输入输出的数据")sum = 100 + 100print('hello,%s'%name)print('sum = %d'%sum) 2、判断语句（if…else）12345678910# 判断语句number = input('请输入成绩:')score = int(number)if score &gt;= 90: print('优秀')else: if score &lt; 60: print('不及格') else: print('及格') 3、循环语句 range(11) 代表从 0 到 10，不包括 11，也相当于 range(0,11)，range 里面还可以增加步长，比如 range(1,11,2) 代表的是 [1,3,5,7,9]。 12345# 循环语句sum = 0for item in range(11): sum = sum + itemprint(sum) 4、while 循环 while 循环适合循环次数不确定的循环，而 for 循环循环的条件相对确定，适合固定次数的循环。 123456sum = 0number = 1while number &lt; 11: sum = sum + number number = number + 1print(sum) 5、数据类型：列表、元组、字典、集合▉ 列表: [] —— 数组 列表是 Python 中常用的数据结构，相当于数组，具有增删删改查的功能，我们可以使用 len() 函数获得 lists中元素的个数；使用 append() 在尾部添加元素，使用 insert() 在列表中插入元素，使用 pop() 删除尾部的元素。 12345678# 列表lists = ['1','2','3']lists.append('4')print (lists)print (len(lists))lists.insert(0,'xiaolu')lists.pop()print (lists) ▉ 元组 () —— 只能访问，不能赋值 元组 tuple 和 list 非常类似，但是 tuple 一旦初始化就不能修改。因为不能修改所以没有append(), insert() 这样的方法，可以像访问数组一样进行访问，比如 tuples[0]，但不能赋值。 123# 元组tuples = ('xiaolu','小鹿')print(tuples[0]) ▉ 字典 {} —— map 字典其实就是{key, value},多次对同一个 key 放入 value，后面的值会把前面的值替换，同样有增删改查 123456789101112131415# 字典# 字典定义score = &#123;'age':22,'name':'xiaolu'&#125;# 添加数据score['school'] = '三本'print(score)# 删除元素score.pop('name')print(score)# 查看 key 是否存在print('age' in score)# 查看 key 对应的值print(score.get('age'))# 给一个默认值print(score.get('school','三本')) ▉ 集合: set —— 存储字典的 key 值 集合 set 和字典 dictory 类似，不过它只是 key 的集合，不存储 value。同样可以增删查，增加使用 add，删除使用 remove，查询看某个元素是否在这个集合里，使用 in。 12345678# 集合s = set(['a','b','c'])# 添加s.add('d')# 移除s.remove('b')print(s)print('c' in s) 6、引用模块 / 包：import 1、import 的本质是路径搜索。import 引用可以是模块 module，或者包 package。 2、针对 module，实际上是引用一个.py 文件。 3、而针对 package，可以采用 from … import… 的 方式。 4、这里实际上是从一个目录中引用模块，这时目录结构中必须带有一个init.py 文件。 12345678# 导入一个模块import model_name# 导入多个模块import module_name1,module_name2# 导入包中指定模块 from package_name import moudule_name# 导入包中所有模块 from package_name import * 7、函数：def 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号，在圆括号里是传进来的参数，然后通过 return 进行函数结果得反馈。 1234# 函数def addone(score): return score + 1print(addone(1))]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶深入系列之【模块化】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%91%2F</url>
    <content type="text"><![CDATA[代码实现模块化有哪些方式？ 一、什么是模块化？模块化具备哪些特性？ 定义模块接口，通过接口可以调用模块的功能。 隐藏模块内部实现，使用模块无知关注模块内部的实现细节。也避免了有可能产生的副作用和 bug。 二、使用对象、闭包和立即执行函数实现模块1、隐藏模块内部实现 函数会创建的新的作用域，在此作用域内创建的变量只对当前函数可见，对外部不可见，所以可以选择立即执行函数来作为模块。 2、定义模块接口 有了模块，要想在外部使用模块内部的变量，必须通过接口来实现。一种实现方式是利用对象和闭包，模块内部返回一个对象，该对象内包含模块提供的方法。而这些方法通过闭包保持函数模块内部变量，甚至当模块执行完毕仍然保持模块内部变量。 3、模块扩展 扩展模块是为了更好的扩展模块的功能，调用立即执行函数，并将需要扩展的模块作为参数，然后在函数内部，为模块扩展方法，增加所需要的变量和函数，最后通过公共的两个方法，可以使用模块。 ▉ 模块扩展的缺点 创建的两个模块的功能都有自己独立的作用域，导致扩展的模块无法共享原有模块的内部属性。 三、使用 AMD 和 CommonJs 模块化 两者的主要区别是：AMD 的设计理念是明确基于浏览器，而 CommonJs 的设计是面向通用的 JavaScript 环境的，而不限于浏览器。 1、AMD AMD 很容易指定模块及依赖关系，最流行的实现是 RequireJs 。 define 函数接受一下参数： 新创建模块的 ID。 当前模块依赖的ID列表。 初始化模块的函数。 12345// 具体过程// AMD 首先请求依赖的模块，这个过程是异步的，以免阻塞。下载解析完毕之后，调用函数工厂，并传入依赖的模块。define(&apos;MouseCounterModule&apos;,[&apos;jQuery&apos;],$ =&gt; &#123; ...&#125;) ▉ AMD 的优点 自动处理依赖，无序考虑模块引入的顺序。 异步加载模块，避免阻塞。 在同一个文件中可以定义多个模块。 2、CommonJS CommonJS 是基于 JavaScript 环境的（Node.js），它的使用是基于文件的模块，所以每个文件中只能定义一个模块。通过 module 对象的 exports 方法暴露模块的接口，require 引用接口。 服务器之所以流行的原因： 服务端：服务器加载模块是同步加载，可以访问模块的公共接口； 客户端： 客户端需要远程服务器下载文件，同步加载导致阻塞。 ▉ CommonJS 的优点 语法简单。 CommonJS 是 Node.js 的默认格式。 ▉ CommonJS 的缺点 不显式的支持浏览器，需要对不支持的格式进行打包。 四、ES6 模块 ES6 模块结合了 CommonJS 和 AMD 的优点： ES6 语法简单，是基于文件的； ES6 支持异步模块加载。 ▉ 导入和导出 ES6 引入了两个关键字： export —— 从模块外部指定标识符。 import —— 导入模块标识符。 1234// 导出部分表示符export &#123; message, sayHi&#125;// 默认导出export default class xiaolu&#123;&#125; 123456// 导入部分标识符(花括号是导入指定内容)import &#123;message, sayHi&#125; from 'app.js' // 导入全部标识符 import * as xiaolu from 'app.js' // 导入默认导出的内容import xiaolu from 'app.js' ▉ export 和 import 重命名 当出现重命名是，可以使用关键字 as 设置别名 12export &#123; say as sayHello &#125;import &#123;greet as sayHello&#125; from &apos;Salute.js&apos;]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
        <category>前端深入系列</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>前端深入系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【promise对象】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90class%E7%B1%BB%E3%80%91%2F</url>
    <content type="text"><![CDATA[ES6为我们提供了类的使用。需要注意的是在写类的时候和 ES5 中的对象和构造函数要区分开来，不要学混了。 1、类的声明 最简单的类只有一个方法。 12345class coder&#123; name(val)&#123; console.log(val); &#125;&#125; 2、类的使用123456789//类的使用class Coder&#123; name(val)&#123; console.log(val) &#125;&#125;let xiaolu = new Coder;xiaolu.name('小鹿') 3、类的多方法声明 这里需要注意的是两个方法中间不要写逗号了，还有这里的this指类本身，还有要注意return 的用法。 1234567891011121314//类的使用class Coder&#123; name(val)&#123; console.log(val) return val &#125; skill(val)&#123; console.log(this.name('xiaolu')+':'+'Skill:'+val) &#125;&#125;let xiaolu = new Coder;xiaolu.name('小鹿')xiaolu.skill('三本') 4、类的传参 在类的参数传递中用 constructor() 进行传参。传递参数后可以直接使用 this.xxx 进行调用。 123456789101112131415161718192021//类的使用class Coder&#123; name(val)&#123; console.log(val) return val &#125; skill(val)&#123; console.log(this.name('xiaolu')+':'+'Skill:'+val) &#125; constructor(a,b)&#123; this.a = a; this.b = b; &#125; add()&#123; return this.a+this.b; &#125;&#125;let xiaolu = new Coder(1,2);console.log(xiaolu.add()) 5、class的继承123456class Html extends Coder&#123;&#125;let l = new Htmll.name('哈哈哈')]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【promise对象】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90promise%E5%AF%B9%E8%B1%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[深入了解 ES6 中的 Promise 的原理 。 一、使用 Promise 的原因1、原因一 由于 JS 的运行时单线程的，所以当执行耗时的任务时，就会造成 UI 渲染的阻塞。当前的解决方法是使用回调函数来解决这个问题，当任务执行完毕会，会调用回调方法。 2、原因二 回调函数能解决上述的问题，但是有几个缺点： 不能捕捉异常（错误处理困难）——回调函数的代码和开始任务代码不在同一事件循环中； 回调地域问题（嵌套回调）； 处理并行任务棘手（请求之间互不依赖）； 二、简单的 Promise123456789let promise = new Promise(function(resolve, reject) &#123; resolve();&#125;);promise.then((res)=&gt;&#123; console.log("回调成功！")&#125;,(err) =&gt;&#123; console.log("回调失败！")&#125;); 1、通过内置的 Promise 构造函数可以创建一个 Promise 对象，构造函数中传入两个函数参数：resolve，reject。两个参数的作用是，在函数内手动调用 resolve 的时候，就说明回调成功了；调用 reject 说明调用失败。通常在 promise 中进行耗时的异步操作，响应是否成功，我们根据判断就可以调用对应的函数。 2、调用 Promise 对象内置的方法 then，传入两个函数，一个是成功回调的函数，一个失败回调的函数。当再 promise 内部调用 resolve 函数时，之后就会回调 then 方法里的第一个函数。当调用了 reject 方法时，就会调用 then 方法的第二个函数。 3、promise 相当于是一个承诺，当承诺兑现的时候（调用了 resolve 函数），就会调用 then 中的第一个回调函数，在回调函数中做处理。当承诺出现未知的错误或异常的时候（调用了 reject 函数），就会调用 then 方法的第二个回调函数，提示开发者出现错误。 三、promise 的原理 其实 Promise 对象用作异步任务的一个占位符，代表暂时还没有获得但在未来获得的值。 1、promise 的状态 promise 共有三种状态，完成状态和拒绝状态状态都是由等待状态转变的。一旦 promise 进入了拒绝或完成状态，它的状态就不能切换了。 等待状态（pending） 完成状态（resolve） 拒绝状态（reject） 2、promise 的拒绝状态 promise 共有两种拒绝状态：显示拒绝（直接调用 reject）和隐式拒绝（抛出异常）。 四、一个 promise 实例 客户端请求服务器是最常用的异步任务，下面实现一下。 123456789101112131415161718192021222324252627282930313233343536373839404142function getJson(url)&#123; // 返回一个 promise 对象 return new Promise((resolve,reject)=&gt;&#123; const request = new XMLHttpRequest(); request.open("GET",url); // 服务器响应成功 request.onload = function()&#123; //try-catch 考虑到 JSON 可能解析会出现错误 try&#123; // 响应码正确且 JSON 解析正确 if(this.status == 200)&#123; // 调用成功承诺 resolve(JSON.parse(this.response)) &#125;else&#123; // 调用失败承诺 reject(this.status + " " +this.statusText); &#125; &#125;catch(e)&#123; // 调用失败承诺 reject(e.message) &#125; &#125; // 服务器响应失败 request.onerror = function()&#123; // 调用失败承诺 reject(this.status + " " +this.statusText); &#125; // 发送请求 request.send(); &#125;)&#125;// 调用上述异步请求getJson("url").then((res)=&gt;&#123; console.log("解析的JSON数据为:"+res)&#125;,(res)=&gt;&#123; console.log("错误信息："+res)&#125;) 五、嵌套处理异步任务 如果连续进行一连串异步请求，并且各个请求之间相互依赖，使用回调函数解决出现 “回到地狱” 现象，所以我们可以使用 promise 的链式回调。 123456// 链式回调getJson("url") .then(n =&gt; &#123;getJson(n[0].url)&#125;) .then(m =&gt; &#123;getJson(m[0].url)&#125;) .then(w =&gt; &#123;getJson(w[0].url)&#125;) .catch((error =&gt; &#123;console.log("异常错误！")&#125;)) 1、因为 then 方法会返回一个 promise 对象，所以连续调用 then 方法可以进行链式调用 promise 。 2、多个异步任务中可能出现错误，只需要调用一个 catch 方法并向其传入错误处理的回调函数。 六、并行处理异步任务 上述的链式调用主要处理的是多个异步任务之间存在依赖性的，如果同时执行多个异步任务，就是用 promise 中的 all 方法。 123456789 // 并行处理多个异步任务Promise.all([getJson(url), getJson(url), getJson(url)]).then(resule =&gt; &#123; // 如果三个请求都响应成功 if(result[0] == 1 &amp;&amp; result[1] == 1 &amp;&amp; result[2] == 1)&#123; console.log("请求成功！") &#125; &#125;).catch(error =&gt; &#123;console.log("异常错误！")&#125;) 1、使用 Promise.all() 方法进行异步请求，将多个请求任务封装数组进行同步请求。 2、返回的结果值会打包成一个数组，可以通过数组的下标获取值对返回的结果进行判断。 3、只有全部请求成功才会进入成功的方法，否则就会调用 catch 抛出异常。 4、与 Promise.race() 方法不同的是，race 方法只要其中一个返回成功，就会调用成功的方法。 七、生成器和 Promise 相结合 生成器和 promise 的结合可以实现更加优雅的异步代码，为了能够解决同步请求导致 UI 阻塞的问题。 1、结合的过程 将一个异步的任务放入到一个生成器中，然后执行生成器函数。每执行到一个异步任务，就创建一个 promise 用于代表异步的执行结果。因为不知道 promise 的承诺什么时候兑现，所以此时的执行权交给生成器，生成器挂起，从而不会导致 UI 阻塞。一旦承诺被兑现，就会立即执行生成器的 next 方法，一直重复执行这个过程。 2、async 函数 生成器和 promise 的结合代码非常的糟糕，所以需要一个函数管理所有 promise 的调用，还要管理向生成器的发出的所有请求。所以 js 在关键字中新增加了两个关键字分别是 async 和 await 。 ① async 表明当前的函数依赖一个异步返回的值。 ② 每个异步请求的位置前都要返回一个 await 关键字，告诉浏览器引擎，请在不阻塞应用执行的情况下在这个位置上等待执行结果。 Promise 面试题※ 答✔：promise 是什么？promise 的特点是什么？ promise 是承诺的意思，在未来会有一个确切的回复，并且该有三种状态：承诺一旦从等待状态变为其他状态就会不更改状态。 等待状态 （pending） 完成状态 （resolved） 拒绝状态 （rejected） ※ 答✔：解决了什么问题？ promise 解决了函数回调地狱的问题。 ※ 答✔：如何使用 promise ? 通过构造函数创建一个 promise 对象并立即执行，在未来会有一个确切的回复，一旦承诺从等待状态转换为 resolve 或 reject 就不会再更改，通过 then 执行回调函数处理对应的任务。 Promise 的两种使用方法： Promise.all() ：将多个请求任务封装数组进行同步请求。 Promise.race()：race 方法只要其中一个返回成功，就会调用成功的方法。 ※ 答✔：什么是 Promise 链？ promise 可以实现链式调用，每次 then 之后返回的都是一个 promise 对象，可以紧接着使用 then 继续处理接下来的任务，这样就实现了链式调用。如果在 then 中使用了 return，那么 return 的值也会被 Promise.resove() 包装。 12345678Promise.resolve(1) .then(res =&gt; &#123; console.log(res) // =&gt; 1 return 2 // 包装成 Promise.resolve(2) &#125;) .then(res =&gt; &#123; console.log(res) // =&gt; 2 &#125;) ※ 答✔：Promise 构造函数执行和 then 函数执行有什么区别？ 构造函数内部的代码是立即执行的，而 then 是回调之后执行的。 ※ 答✔：promise 的优缺点是什么？ 优点： 1、链式调用。 2、解决回调地狱的问题。 3、代码实现简洁优雅。 缺点： 1、无法取消promise。 2、promise 错误需要通过回调函数捕获。 ※ 答✔：Promise 在事件循环中的执行过程是怎样的？※ 答✔：能不能手写一个 Promise ? promise 的执行顺序： 1、先执行 MyPromise 构造函数； 2、注册 then 函数； 3、此时的 promise 挂起，UI 非堵塞，执行其他的同步代码； 4、执行回调函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 三种状态const PENDING = "pending";const RESOLVE = "resolve";const REJECT = "reject";// promise 函数function MyPromise(fn)&#123; const that = this; // 回调时用于保存正确的 this 对象 that.state = PENDING; // 初始化状态 that.value = null; // value 用于保存回调函数(resolve/reject 传递的参数值) that.resolvedCallbacks = []; // 用于保存 then 中的回调 that.rejectedCallbacks = []; // resolve 和 reject 函数 function resolve(value) &#123; if(that.state === PENDING)&#123; that.state = 'resolve'; that.value = value; that.resolvedCallbacks.map(cb =&gt; cb(that.value)); &#125; &#125; function reject(value) &#123; if (that.state === PENDING) &#123; that.state = 'reject' that.value = value that.rejectedCallbacks.map(cb =&gt; cb(that.value)) &#125; &#125; // 实现如何执行 Promise 中传入的函数 try &#123; fn(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125;// 实现 then 函数MyPromise.prototype.then = function(onResolved, onRejected) &#123; const that = this; // 判断两个参数是否为函数类型(如果不是函数，就创建一个函数赋值给对应的参数) onResolved = typeof onResolved === 'function' ? onResolved : v =&gt; v; onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123;throw r&#125; // 判断当前的状态 if (that.state === 'pending') &#123; that.resolvedCallbacks.push(onResolved) that.rejectedCallbacks.push(onRejected) &#125; if (that.state === 'resolve') &#123; onResolved(that.value) &#125; if (that.state === 'reject') &#123; onRejected(that.value) &#125;&#125;new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 0)&#125;).then(value =&gt; &#123; console.log(value)&#125;) async 及 await 面试题：async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？ ※ 答✔：async 的特点？ 一个函数前加上 async 关键字，就将该函数返回一个 Promise，async 直接将返回值使用 Promise.resolve() 进行包裹（与 then 处理效果相同）。 ※ 答✔：await 的特点？ await 只能配套 async 使用，await 内部实现了 generator，await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。 ※ 答✔：async 和 await 的优缺点？优点： 1、内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。 2、更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 3、更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 缺点： 因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。 ※ 答✔：await 原理是什么？ async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。 123456789101112131415161718192021function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; var gen = genF(); function step(nextF) &#123; try &#123; var next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v); &#125;); &#125;, function(e) &#123; step(function() &#123; return gen.throw(e); &#125;); &#125;); &#125; step(function() &#123; return gen.next(undefined); &#125;); &#125;);&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【对象代理】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90Proxy%E9%A2%84%E5%A4%84%E7%90%86%E3%80%91%2F</url>
    <content type="text"><![CDATA[了解对象的访问以及监控对象的技术！ 通过 getter 与 setter 访问属性值有什么好处？- 代理与 getter 和 setter 的主要区别是什么？ 代理对象常见的问题是什么？ 一、为什么需要 getter 和 setter 访问？1、避免意外的错误发生； 2、需要记录属性的变化； 3、数据绑定。 二、定义 getter 和 setter 三种定义方法： 字面量定义 ES6 中的 Class 定义 使用 Object.definedProperty 方法 1、字面量定义 getter 和 setter 对象访问属性通常隐士调用 getter 和 setter 方法，属性自动关联 getter 和 setter 方法。这些都是标准方法，在访问属性的时候都是立即执行的。 1234567891011121314const collection = &#123; name='xiaolu', // 读取属性 get name()&#123; return this.name; &#125; // 设置属性 set name(value)&#123; this.name = value; &#125;&#125;collection.name // 隐士调用 getter 方法collection.name = "xiaolu1" // 隐士调用 setter 方法 2、ES6 Class 定义 getter 和 setter123456789101112131415161718// calss 定义 setter 和 getterclass Xiaolu &#123; constructor()&#123; this.name = 'xiaolu' &#125; get firstXiaolu()&#123; console.log('属性已访问') return this.name; &#125; set firstXiaolu(value)&#123; this.name = value; &#125;&#125;const x = new Xiaolu();x.firstXiaolu 3、Object.definedProperty() 原因：对象的字面量与类、getter 和 setter 方法不是在一同一作用域定义的，因此那些希望作为私有变量属性的标量是无法实现的。 123456789101112131415// Object.definedPropertyfunction xiaolu()&#123; let count = 0; Object.defineProperty(this,'skillLevel',&#123; get:() =&gt; &#123; return count; &#125;, set:value =&gt; &#123; count = value; &#125; &#125;)&#125;// 隐士的调用 get 方法console.log(xiaolu.count) 通过 Object.definedProperty() 创建的 get 和 set 方法，与私有的变量处于相同的作用域中，get 和 set 方法分别创建了含有私有变量的闭包。 三、getter 和 setter 的应用1、日志记录 当访问属性时，可以在 getter 和 setter 中记录访问日志。 2、校验值 有效的避免指定属性类型错误的发生。 123456789101112131415function xiaolu()&#123; let count = 0; Object.defineProperty(this,'skillLevel',&#123; get:() =&gt; &#123; return count; &#125;, set:value =&gt; &#123; if(!Number.isInteger(value))&#123; throw new TypeError("抛出错误") &#125; count = value; &#125; &#125;)&#125; 3、定义如何计算属性值 每次访问属性值，都会进行计算属性值。 1234567891011121314const collection = &#123; name:'xiaolu', age:'2', // 读取属性 get getName()&#123; return this.name + " "+this.age; &#125;, // 设置属性 set setName(value)&#123; this.name = value; &#125;&#125;console.log(collection.getName) 四、Proxy]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【map】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E3%80%90map%E3%80%91%2F</url>
    <content type="text"><![CDATA[map是一种灵活，简单的适合一对一查找的数据结构。 1、Json和map格式的对比 map的效率和灵活性更好 ,可以把它看成一种特殊的键值对，但你的key可以设置成数组，值也可以设置成字符串。 123456789let json = &#123; name:'xiaolu', skill:'小鹿'&#125;console.log(json.name);let map = new Map();map.set(json,'123')console.log(map) 2、Map 的增删改▉ get 取值1console.log(map.get(json)) ▉ delete 删除12map.delete(json)console.log(map) ▉ has 查找1console.log(map.has(json)) ▉ 清楚所有元素clear1console.log(map.clear) ▉ size 属性1console.log(map.size)]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【set和WeakSet数据结构】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90set%E5%92%8CWeakSet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%2F</url>
    <content type="text"><![CDATA[ES6中的数据结构，很有用处的新知识！ 1、set的声明 Set和Array 的区别是 Set 不允许内部有重复的值，如果有只显示一个，相当于去重。 123//Setlet setArr = new Set(['小鹿','xiaolu','三本'])console.log(setArr) 2、Set值的增删查▉ add 增加1234let setArr = new Set(['小鹿','xiaolu','三本'])console.log(setArr)setArr.add('哈哈')console.log(setArr) ▉ delete 删除12345678let setArr = new Set(['小鹿','xiaolu','三本'])console.log(setArr)setArr.add('哈哈')console.log(setArr)setArr.delete('小鹿')console.log(setArr) ▉ has 查找12let setArr = new Set(['小鹿','xiaolu','三本'])console.log(setArr.has('xiaolu')) ▉ clear 清空12setArr.clear();console.log(setArr) ▉ set的循环 for…of…循环：1234let setArr = new Set(['小鹿','xiaolu','三本'])for(let item of setArr)&#123; console.log(item)&#125; ▉ size属性 返回 set 中的数量。 1console.log(setArr.size) ▉ forEach循环12345setArr.forEach( (value)=&gt;&#123; console.log(value) &#125;) 3、WeakSet的声明 注意：这里需要注意的是，如果你直接在new 的时候就放入值，将报错， 而且不能传入重复的值。 12345let weakObj = new WeakSet();let obj = &#123;a:'xiaolu',b:'小鹿'&#125;weakObj.add(obj);console.log(weakObj)]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【Symbol在对象中的作用】]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90Symbol%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[Symbol，它的意思是全局标记。 1、声明Symbol1234567var a = new String;var b = new Number;var c = new Boolean;var d = new Array;var e = new Object; var f= Symbol();console.log(typeof(d)); 2、Symbol的打印123var g = Symbol('xiaolu');console.log(g);console.log(g.toString()); 3、Symbol在对象中的应用1234567var xiaolu = Symbol();var obj=&#123; [jspang]:'小鹿'&#125;console.log(obj[jspang]);obj[jspang]='三本';console.log(obj[jspang]); 4、Symbol对象元素的保护作用 循环的是时候不输出。 1234567let obj=&#123;name:'xiaolu',skill:'三本'&#125;;let age=Symbol();obj[age]=18;for (let item in obj)&#123; console.log(obj[item]);&#125; console.log(obj);]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【ES6对象】]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90ES6%E5%AF%B9%E8%B1%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[对象对于Javascript是非常重要的。在ES6中对象有了很多新特性。 1、对象赋值 ES6允许把声明的变量直接赋值给对象。 12345//ES6对象let name="xiaolu";let skill= '小鹿';var obj= &#123;name,skill&#125;;console.log(obj); 2、对象 Key 值的构建 获取对象键值对 key 值，我们自己定义键值对 key 值。 123456//对象构建key值let key='skill';var obj=&#123; [key]:'小鹿'&#125;console.log(obj.skill); 3、自定义对象方法123456var obj=&#123; add:function(a,b)&#123; return a+b; &#125;&#125;console.log(obj.add(1,2)); //3 4、Object.is( ) 对象比较 ES6为我们提供了is方法进行对比。 1234var obj1 = &#123;name:'xiaolu'&#125;;var obj2 = &#123;name:'xiaolu'&#125;;console.log(obj1 === obj2);//falseconsole.log(Object.is(obj1.name,obj2.name)); //true 区分 === 和 is方法的区别是什么 12345//===为同值相等，is()为严格相等。console.log(+0 === -0); //trueconsole.log(NaN === NaN ); //falseconsole.log(Object.is(+0,-0)); //falseconsole.log(Object.is(NaN,NaN)); //true 5、Object.assign( )合并对象12345var a=&#123;a:'xiaolu'&#125;;var b=&#123;b:'小鹿'&#125;;var c=&#123;c:'三本'&#125;;let d=Object.assign(a,b,c)console.log(d);]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【函数和数组补漏】]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E5%87%BD%E6%95%B0%E6%95%B0%E7%BB%84%E8%A1%A5%E6%BC%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[数组和函数的其他使用！ 1、对象的函数解构 后台传来的JSON格式数据当作参数，传递到函数内部进行处理。ES6就为供了这样的解构赋值，不用一个个传递参数了。 12345678910// 数组 JSON 解构let json = &#123; a:'xiaolu', b:'小鹿'&#125;//b设置默认值function fun(&#123;a,b='xiaolu'&#125;)&#123; console.log(a,b);&#125;fun(json); 2、数组的函数解构123456//解构数组let arr = [&apos;xiaolu&apos;,&apos;小鹿&apos;,&apos;三本&apos;];function fun(a,b,c)&#123; console.log(a,b,c);&#125;fun(...arr); 3、in的用法■ 对象判断 判断某一个属性值是否在对象中。 12 ■ 数组判断1234567891011//ES5存在的弊端let arr=[,,,,,];console.log(arr.length); //5// ES6中的 in 来解决let arr=[,,,,,];//这里的0指的是数组下标位置是否为空。console.log(0 in arr); //falselet arr1=['xiaolu','小鹿'];console.log(0 in arr1); // true 4、数组的遍历方法■ forEach forEach循环的特点是会自动省略为空的数组元素，相当于直接给筛空了。 12345//遍历数组let arr = ['xiaolu','小鹿','三本'];arr.forEach((element,index) =&gt; &#123; console.log(element+index)&#125;); ■ filter12345//filter遍历let arr = ['xiaolu','小鹿','三本'];arr.filter( element =&gt;console.log(element)) ■ some123//some 遍历let arr = ['xiaolu','小鹿','三本'];arr.some(element =&gt;console.log(element)) ■ map 遍历123//map循环起到代替作用let arr = [&apos;xiaolu&apos;,&apos;小鹿&apos;,&apos;三本&apos;];console.log(arr.map(element=&gt;&apos;xiaolu&apos;)) 5、数组转换为字符串■ join() 方法123//‘|’隔开let arr = ['xiaolu','小鹿','三本'];console.log(arr.join('|')) ■ toString() 方法123//逗号隔开let arr = [&apos;xiaolu&apos;,&apos;小鹿&apos;,&apos;三本&apos;];console.log(arr.toString())]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【箭头函数和扩展】]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[箭头函数的使用！ 一、箭头函数 注意箭头函数不能当做 构造函数来使用。 1、箭头函数1234567//普通函数function add(a,b=1)&#123; return a+b;&#125;//箭头函数var add = (a,b=1)=&gt;a+b;console.log(add(1)) 2、{ } 使用 如果函数体内多余两条语句，就使用 {}。 12345var add =(a,b=1) =&gt; &#123; console.log('jspang') return a+b;&#125;;console.log(add(1));]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【新增数组】]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E6%96%B0%E5%A2%9E%E6%95%B0%E7%BB%84%E3%80%91%2F</url>
    <content type="text"><![CDATA[ES6 中新增的数组知识！ 一、ES6中新增的数组知识 在ES6中绝大部分的Array操作都存在于Array对象里。 1、JSON数组格式转换123456789// JSON 转换数组let json = &#123; '0':'xiaolu', '1':'小鹿', '2':'小鹿哈哈', length:3&#125;let arr = Array.from(json)console.log(arr) 2、Array.of()方法 负责把一堆文本或者变量转换成数组。 1234let arr = Array.of(1,2,3,4);let arrText = Array.of('小鹿','小明','小强')console.log(arr)console.log(arrText) 3、find()实例方法 所谓的实例方法就是并不是以Array对象开始的，而是必须有一个已经存在的数组，然后使用的方法，这就是实例方法。 value：表示当前查找的值。 index：表示当前查找的数组索引。 arr：表示当前数组。 123456//find() 实例方法let arr=[1,2,3,4,5,6,7,8,9];console.log(arr.find(function(value,index,arr)&#123; return value &gt; 10;&#125;))//控制台输出了6，说明找到了符合条件的值，并进行返回了，如果找不到会显示undefined。 4、fill() 实例方法 用于把数组进行填充 。 参数一：填充的变量 参数二：开始填充的位置 参数三：填充到的位置 12345//fill()填充方法let arr=[0,1,2,3,4,5,6,7,8,9];arr.fill('小鹿',2,5);//把数组从第二位到第五位用xiaolu进行填充console.log(arr);//[0, 1, "小鹿", "小鹿", "小鹿", 5, 6, 7, 8, 9] 5、数组的遍历 for…of循环。 12345//for-of循环let arr = ['小鹿','xiaolu','啦啦']for(let item of arr)&#123; console.log(item)&#125; 输出数组索引。 123for(let index of arr.keys())&#123; console.log(index)&#125; 同时输出索引和元素。 123for(let [index,val] of arr.entries())&#123; console.log(index+':'+val);&#125; 6、entries( )实例方法 entries()实例方式生成的是Iterator形式的数组，需要时用next()手动跳转到下一个值。 12345678let arr = ['小鹿','xiaolu','啦啦']let list = arr.entries();console.log(list.next().value);console.log(list.next().value);console.log(list.next().value);//[0, "小鹿"]//[1, "xiaolu"]//[2, "啦啦"]]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 HTML5 基础篇之【属性变化】]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%89%8D%E7%AB%AF%20HTML5%20%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E3%80%90%E5%B1%9E%E6%80%A7%E5%8F%98%E5%8C%96%E3%80%91%2F</url>
    <content type="text"><![CDATA[第二节：HTML5 的属性添加了哪些？ HTML5 属性变化目录 Input 标签 表单属性 链接属性 其它属性 一、Input 属性 针对于 iphone 手机端(5个)：email /url /tel /数字/Date Pickers 针对于客户端（3个）：Range / Search /Color 1、email 类型 针对于手机端，出现特殊的键盘，电子邮件 Input 类型。 12//用于手机输入邮件&lt;input type="email" name="email" &gt; 2、url 类型 之应用于苹果手机端，特殊键盘。 1&lt;input type="url" name="url"&gt; 3、tel 类型 出现特殊的电话号码键盘。 1&lt;input type="tel" name="tel"&gt; 4、数字类型 出现数字运算键盘。 1&lt;input type="number" name="number"&gt; 5、Date Pickers类型 日期类型。手机端只应用于 iphone。 Date —— 选取日、月、年 Month —— 选取月年 Week —— 选取周和年 Time —— 选取时间（小时和分钟） Datetime —— 选取时间、日、月、年（UTC时间） Datetime-local —— 选取时间、日、月、年（本地时间） 1234567// 手机出现滚动日期date:&lt;input type="date" name="date"&gt;&lt;br&gt;//年、月、日month:&lt;input type="month" name="month"&gt;&lt;br&gt;//年、月week:&lt;input type="week" name="week"&gt;&lt;br&gt;//年、周time:&lt;input type="time" name="time"&gt;&lt;br&gt;//时、分datetime:&lt;input type="datetime" name="datetime"&gt;&lt;br&gt;//年、月、日、时区datetime-local:&lt;input type="datetime-local" name="datetime-local"&gt;&lt;br&gt;//年、月、日 Datetime 和 Datetime-local 的区别？ 1)兼容性。Datetime 类型只有 Safire 和 Opera 浏览器兼容；而 Datetime-local 兼容 Chrome 、 Safire 和 Opera。 2) 返回类型不同。local 返回本地时间，而 Date 返回时区。 6、Range 类型 范围，默认范围0—100。 1&lt;input type="range" name="range" min="1" max="10"&gt; 7、search 类型 搜索框。 1&lt;input type="search" name="search"&gt; 8、Color 类型 出现颜色色板。 1&lt;input type="color" name="color"&gt; 二、表单属性（5个）1、autocomplete 属性 当重新加载页面时，输入框重置，是否提示。autocomplete=”on/off” 12345&lt;form action="" autocomplete="on"&gt; &lt;input type="text" name="text"&gt; &lt;input type="email" name="email" autocomplete="off"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 2、aotufocus 属性 页面加载时，自动获取属性。 1&lt;input type="text" name="text" autofocus="autofocus"&gt; 3、multiple 属性 规定输入域可选择多个值。一般应用于上传文件（file）和邮件 （email ）输入框。 4、placeholder 属性 提供一种提示（hint）。 1&lt;input type="text" name="text" placeholder="请输入您的用户名"&gt; PS：适用于以下几个 input 标签：（6个） text，search，url，tel，email，password。 5、require 属性 主要用来进行输入域验证（不能为空），必填字段。 12//填写完整才能进行提交&lt;input type="email" name="email" required="required"&gt; PS：适用于以下几个 input 标签： text，search，url，telephone，email，password，date，pickers，number，checkbox，radio，file。 三、链接属性（3个）1、sizes 根据屏幕不同的分辨率来调整不同的sizes。 1&lt;link rel=&quot;icon&quot; href=&quot;icon.gif&quot; type=&quot;image/gif&quot; size=&quot;16X16&quot;&gt; 2、target base标签写在之间。 12//控制所有的页面的超链接默认选择新窗口。&lt;base href="http://localhost/" target="_blank"&gt; 3、超链接123a：media=&quot;&quot;//表示对设备进行优化，handhelp对手持设备进行支持，tv 对“电视”设备进行支持。a:hreflang=&quot;zh&quot;//设置语言，这里设置的中文a:rel=&quot;external&quot; //这里的超链接为外部链接 三、其他属性（4个）1、script 标签 defer 属性：（只兼容 IE 浏览器）加载完浏览器之后，再加载 js 外部文件夹。 async 属性：（兼容一切浏览器）加载页面的同时也加载外部文件。 2、ol Start —— 起始值：有序列表的起始值。 Reversed —— 有序列表倒序输出。 3、html 定义页面的离线文件。 1&lt;html mainifest=&quot;index.mainifest&quot; 4、*style scoped：内嵌CSS。 12&lt;style scoped&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 HTML5 基础篇之【新增标签】]]></title>
    <url>%2F2019%2F03%2F20%2F%E9%87%8D%E5%AD%A6%20HTML5%20%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E3%80%90%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E3%80%91%2F</url>
    <content type="text"><![CDATA[第一节：HTML 5 有哪些新增标签，各有什么作用呢？ HTML5新增标签1、结构标签 块状元素——有意义的div。（10个可根据网页记忆） ■ ：标记一篇文章。 ■ ：标记一个页面的头部或一个区域的头部。 ■ ：标记定义导航链接。 ■ ：标记定义一个区域。 ■ ：标记定义页面内容部分的侧边栏。 ■ ：标记定义文件中的一个区块的相关信息。 ■ ：标记定义一组媒体内容以及它们的标题。 ■ ：标记定义 figure元素的标题。 ■ ：标记定义一个页面或一个区域的底部。 ■ ：标记定义一个对话框类似微信。 2、多媒体标签■ ：标记定义一个视频。 12345//对于不是 mp4 格式的视频，使用 source 来解决&lt;video src=&quot; &quot; autoplay=&quot;autoplay&quot; width=&quot; &quot; height=&quot; &quot;&gt; //需要进行转码 &lt;source src=&quot; &quot; type=&quot;video/mp4&quot; /&gt;&lt;/video &gt; ■ ：标记定义音频内容。 ■ ：标记定义媒体资源。 1&lt;video src=&quot; &quot; autoplay=&quot; &quot; loop=&quot; &quot; controls=&quot; &quot;&gt;您的浏览器不支持！&lt;/video&gt; 12345//对于不是 mp3 格式的音频，使用 source 来解决&lt;audio autoplay=&quot; &quot;&gt; //需要进行转码 &lt;source src=&quot; &quot; type=&quot;audio/mpeg&quot; /&gt;&lt;/audio&gt; ■ ： 画布 ■ ：标记定义外部的可交互的内容或插件，比如 flash。 3、Web 应用标签▉ 状态标签■ ：状态标签（实时状态显示：气压、气温） 浏览器兼容：Chrome、Opera 12&lt;meter value="380" min="20" max="380" low="200" high="240" optimum="220"&gt;&lt;/meter&gt;&lt;meter value="0.75"&gt;75%&lt;/meter&gt; ■ ：状态标签（任务过程：安装、加载） 浏览器兼容：Chrome、Firefox、Opera 12&lt;progress value="30" max="100"&gt; &lt;/progress&gt;&lt;progress max="100"&gt; ▉ 列表标签■ ：为 input 添加下拉列表。 浏览器的兼容性：Firefox、Opera 12345678&lt;input placeholder="请选择您喜欢的手机品牌" list="phoneList"/&gt;&lt;datalist id="phoneList"&gt; &lt;option value="iphone"&gt;&lt;/option&gt; &lt;option value="sumsung"&gt;&lt;/option&gt; &lt;option value="HUawei"&gt;&lt;/option&gt; &lt;option value="HTC"&gt;&lt;/option&gt; &lt;option value="Meizu"&gt;&lt;/option&gt;&lt;/datalist&gt; ■ ：隐藏、显示详细内容。 浏览器兼容 ：Chrome。 1234567891011&lt;details&gt; &lt;summary&gt;问候&lt;/summary&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;&lt;/details&gt; ▉ Menu 标签■ ：工具栏菜单 大部分浏览器不支持。 4、其他标签■ ：标记定义有标记的文本（黄色选中状态） ■ ：标记定义一些输出类型，计算表单结果配合 oninput 事件。 ■ ：标记定义表单里一个生成的键值（加密信息传送） ■ ：标记定义一个日期/时间，目前所有的主流浏览器都不支持 删除的标签一、纯表现的元素 html：结构层；CSS：表现层； Basefont、Big、Center、font、s、strike、tt、u 二、对可用性产生负面影响的元素 框架级元素。 1、frameset 会去掉 body ，破坏 html 的结构。 frame、frameset、noframes 三、产生混淆的元素 acronym、applet、isindex、dir 重定义标签■ :代表内联文本，通常是粗体，没有传递表示重要的意思 ■ ：代表内联文本，通常是斜体，没有传递表示重要的意思 ■ ：描述，可以同 details 与 figure 一同使用，定义包含文本，dialog 也可用 ■ ：标题，可以同 details 与 figure 一同使用，汇总细节，dialog 也可用 ■ ：表示主题结束，而不是水平线，虽然显示相同 ■ ：表示小字体，例如打印注释或者法律条款 ■ ：表示重要性而不是强调符号]]></content>
      <categories>
        <category>前端</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 HTML5 基础篇之【新增标签】]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%89%8D%E7%AB%AF%20HTML5%20%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E3%80%90%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E3%80%91%2F</url>
    <content type="text"><![CDATA[第一节：HTML 5 有哪些新增标签，各有什么作用呢？ HTML5一、新增标签1、结构标签(10个) 块状元素——有意义的div。（10个可根据网页记忆） ■ article：标记一篇文章。 ■ header ：标记一个页面的头部或一个区域的头部。 ■ nav：标记定义导航链接。 ■ section：标记定义一个区域。 ■ aside：标记定义页面内容部分的侧边栏。 ■ hgroup：标记定义文件中的一个区块的相关信息。 ■ figure：标记定义一组媒体内容以及它们的标题。 ■ figcaption：标记定义 figure元素的标题。 ■ footer：标记定义一个页面或一个区域的底部。 ■ dialog：标记定义一个对话框类似微信。 2、多媒体标签（5个）■ &lt;video src=&quot; &quot; autoplay=&quot; &quot; loop=&quot; &quot; controls=&quot; &quot;&gt; ：标记定义一个视频。 12345//对于不是 mp4 格式的视频，使用 source 来解决&lt;video src=" " autoplay="autoplay" width=" " height=" "&gt; //需要进行转码 &lt;source src=" " type="video/mp4" /&gt;&lt;/video &gt; ■ &lt;audio&gt;：标记定义音频内容。 ■ &lt;source&gt;：标记定义媒体资源。 1&lt;video src=&quot; &quot; autoplay=&quot; &quot; loop=&quot; &quot; controls=&quot; &quot;&gt;您的浏览器不支持！&lt;/video&gt; 12345//对于不是 mp3 格式的音频，使用 source 来解决&lt;audio autoplay=&quot; &quot;&gt; //需要进行转码 &lt;source src=&quot; &quot; type=&quot;audio/mpeg&quot; /&gt;&lt;/audio&gt; ■ &lt;canvas&gt;： 画布。 ■ &lt;embed&gt;：标记定义外部的可交互的内容或插件，比如 flash。 3、Web 应用标签（5个)▉ 状态标签■ &lt;meter&gt;：状态标签（实时状态显示：气压、气温） 浏览器兼容：Chrome、Opera。 12&lt;meter value="380" min="20" max="380" low="200" high="240" optimum="220"&gt;&lt;/meter&gt;&lt;meter value="0.75"&gt;75%&lt;/meter&gt; ■ &lt;progress&gt;：状态标签（任务过程：安装、加载) 浏览器兼容：Chrome、Firefox、Opera 12&lt;progress value="30" max="100"&gt; &lt;/progress&gt;&lt;progress max="100"&gt; ▉ 列表标签■ &lt;datalist&gt;：为 input 添加下拉列表。 浏览器的兼容性：Firefox、Opera。 12345678&lt;input placeholder="请选择您喜欢的手机品牌" list="phoneList"/&gt;&lt;datalist id="phoneList"&gt; &lt;option value="iphone"&gt;&lt;/option&gt; &lt;option value="sumsung"&gt;&lt;/option&gt; &lt;option value="HUawei"&gt;&lt;/option&gt; &lt;option value="HTC"&gt;&lt;/option&gt; &lt;option value="Meizu"&gt;&lt;/option&gt;&lt;/datalist&gt; ■ &lt;details&gt;：隐藏、显示详细内容。 浏览器兼容 ：Chrome。 1234567891011&lt;details&gt; &lt;summary&gt;问候&lt;/summary&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;&lt;/details&gt; ▉ Menu 标签■ &lt;menu&gt;：工具栏菜单 大部分浏览器不支持。 4、其他标签■ &lt;mark&gt;：标记定义有标记的文本（黄色选中状态）。 ■ &lt;output&gt;：标记定义一些输出类型，计算表单结果配合 oninput 事件。 ■ &lt;keygen&gt;：标记定义表单里一个生成的键值（加密信息传送）。 ■ &lt;time&gt;：标记定义一个日期/时间，目前所有的主流浏览器都不支持。 二、删除的标签1、纯表现的元素 html：结构层；CSS：表现层； Basefont、Big、Center、font、s、strike、tt、u。 2、对可用性产生负面影响的元素 框架级元素。 1、frameset 会去掉 body ，破坏 html 的结构。 frame、frameset、noframes 3、产生混淆的元素 acronym、applet、isindex、dir。 三、重定义标签■ &lt;b&gt; :代表内联文本，通常是粗体，没有传递表示重要的意思。 ■ &lt;i&gt;：代表内联文本，通常是斜体，没有传递表示重要的意思。 ■ &lt;dd&gt;：描述，可以同 details 与 figure 一同使用，定义包含文本，dialog 也可用。 ■ &lt;dt&gt;：标题，可以同 details 与 figure 一同使用，汇总细节，dialog 也可用。 ■ &lt;hr&gt;：表示主题结束，而不是水平线，虽然显示相同。 ■ &lt;small&gt;：表示小字体，例如打印注释或者法律条款。 ■ &lt;strong&gt;：表示重要性而不是强调符号。]]></content>
      <categories>
        <category>前端</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【数字操作】]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%20%E3%80%90%E6%95%B0%E5%AD%97%E6%93%8D%E4%BD%9C%E3%80%91%2F</url>
    <content type="text"><![CDATA[如果你对数字操作的不好，就很难写出令人惊奇的程序 。 一、进制声明1、二进制声明 二进制的英文单词是Binary，二进制的开始是0（零），然后第二个位置是b ，然后跟上二进制的值就可以了 1let binary = 0b010101;//21 2、八进制声明 八进制的英文单词是Octal，也是以0（零）开始的，然后第二个位置是O（欧），然后跟上八进制的值就可以了。 1let b=0o666;//438 二、数字判断和转换1、数字验证 Number.isFinite( xx ) 只要是数字，不论是浮点型还是整形都会返回true，其他时候会返回false。 123let a= 11/4;console.log(Number.isFinite(a));//trueconsole.log(Number.isFinite('xiaolu'));//false 2、NaN验证 NaN是特殊的非数字，可以使用Number.isNaN()来进行验证。下边的代码控制台返回了true。 1console.log(Number.isNaN(NaN)); 3、判断是否为整数Number.isInteger(xx)12let a=123.1;console.log(Number.isInteger(a)); //false 4、整数转换Number.parseInt(xxx)和浮点型转换Number.parseFloat(xxx)123let s = 12.34console.log(Number.parseInt(s))console.log(Number.parseFloat(s)) 5、整数取值范围操作 整数的操作是有一个取值范围的，它的取值范围就是2的53次方。 12let a = Math.pow(2,53)-1;console.log(a); //9007199254740991 6、最大安全整数 计算时会经常超出这个值，所以我们要进行判断，ES6提供了一个常数，叫做最大安全整数 1consolec .log(Number.MAX_SAFE_INTEGER); 7、最小安全整数1console.log(Number.MIN_SAFE_INTEGER); 8、安全整数判断isSafeInteger( )12let a= Math.pow(2,53)-1;console.log(Number.isSafeInteger(a));//false 9、]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【字符串模板】]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF%E3%80%91%2F</url>
    <content type="text"><![CDATA[前后端分离经常用到拼接。 字符串拼接1、简单拼接 使用 ${} 进行拼接。 1234// 注意使用的 ` 符号let lu = 'xiaolu';let blog = `$&#123;lu&#125; 你好&lt;br&gt;呀`; //在里边可以加标签document.write(blog) 2、对运算符的支持1234let a = 1;let b = 2;let c = `$&#123;a+b&#125;`document.write(c) 3、字符串查找▉ 查找是否存在123let xiaolu='小鹿';let blog = '大家好，我是小鹿。';document.write(blog.includes(xiaolu))//返回true ▉ 判断开头是否存在1blog.startsWith(xiaolu); ▉ 判断开头是否存在1blog.endsWith(xiaolu); ▉ 复制字符串1document.write(&apos;xiaolu|&apos;.repeat(3));]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【扩展运算符和rest运算符】]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8Crest%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[两者都是（…）三个点，更好的为我们解决参数和对象数组未知情况下的编程，代码更健壮 。 一、扩展运算符1、含义 1、扩展运算符可以将数组转化为用逗号分隔的参数序列。 2、该运算符主要用于函数的调用。 3、注意：只有函数调用扩展运算符时才能够放入到圆括号中，否则报错。 4、扩展运算符代替 apply 方法。 5、将一个数组拼接到另一个数组后边。 123// 1console.log([1,2,3]) // 【1,2,3】console.log(...[1,2,3]) // 1 2 3 1234567// 2function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 将数组变为参数序列 123456// 4// 求数组中的最大值Math.max.apply(null, [14, 3, 77]) // ES5 写法Math.max(...[14, 3, 77]) // ES6 写法// 等同于Math.max(14, 3, 77); 123456// 5// 将一个数组拼接到另一个数组后边var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);// ES6 的写法arr1.push(...arr2);// ES6 的写法 2、扩展运算符的应用2.1 复制数组 数组是一个 object 类型，复制数组的时候，只复制了数组的地址，会导致牵一发而动千军。 1234567// ES5 变通的复制数组const a1 = [1,2]const a2 = a1.concat(); // 返回原数组的克隆(浅克隆)// ES6 的修改const a1 = [1,2]const a2 = [...a1] // 浅克隆 2.2 合并数组 这两种方法都是对原数组的引用，如果修改了原数组，同步反映到新数组。 1234// ES5 合并数组arr1.concat(arr2,arr3)// ES6 合并数组(外边为[]，内层的数组序列化开)[...arr1, ...arr2, ...arr3] 2.3 字符串 将字符串转为真正的数组。 12[...'hello']// [ "h", "e", "l", "l", "o" ] 二、rest 运算符 最基本用法。 123456//rest 运算符const xiaolu = (fist,...arg) =&gt;&#123; console.log(arg.length)&#125;//first 代表 1 参数xiaolu(1,2,3,4,5,6,7)//打印 7 ，说明 age 里边有 7 个参数 ▉ for…of 打印 arg 的值123456const xiaolu = (fist,...arg) =&gt;&#123; for(let a of arg)&#123; console.log(a) &#125;&#125;xiaolu(1,2,3,4,5,6,7)//打印 2,3,4,5,6,7]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【解构赋值】]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E3%80%91%2F</url>
    <content type="text"><![CDATA[解构赋值在实际开发中可以大量减少我们的代码量，并且让我们的程序结构更清晰，主要应用于解析 JSON 。 变量的解构赋值 应用：一般应用于解构 JSON 数据，非常方面快捷。 1、数组的结构▉ 简单数组结构1234567//一般形式let a=0;let b=1;let c=2;//解构形式letl [a,b,c]=[1,2,3]; ▉ 数组和赋值模式统一 等号左右要统一，否则可能获得 undefined。 1let [a,[b,c],d] = [1,[2,3],4]; ▉ 解构的默认值 需要注意 undefined 和 null 的区别。undefined 代表什么都没有，null代表有值。 12let [foo = true] = [];console.log(foo); //控制台打印出true 2、对象的解构 与数组解构的不同点：数组的元素是按次序排列的 ，而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 1let &#123;foo,bar&#125; = &#123;foo:'xiaolu',bar:'小鹿'&#125;; ▉ 圆括号的使用1234567//如果之前已经解构，现在就会报错let foo;&#123;foo&#125; =&#123;foo:'xiaolu'&#125;;//需要加圆括号let foo;(&#123;foo&#125;=&#123;foo:'xiaolu'&#125;); 3、字符串解构 字符串被转换成了一个类似数组的对象 。 1const [a,b,c,d,e,f]="JSPang";]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零学习 React 之【环境搭建】]]></title>
    <url>%2F2019%2F03%2F18%2F%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0%20React%20%E4%B9%8B%E3%80%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[第一小节：从零学习 react 环境搭建！ React 环境搭建1、初始化项目 初始化项目，生成 package.json 文件 1npm init -y 2、安装 webpack 和 webpack-cli 安装 webpack。 12npm install --save-dev webpacknpm install --save-dev webpack-cli 3、配置 webpack.config.js 根目录新建 webpack.config.js 配置文件，配置出入口文件： 12345678910var path =require(&apos;path&apos;);module.exports = &#123; //入口文件 entry:&apos;./app/index.js&apos;, //出口文件 output:&#123; filename:&apos;index.js&apos;, path:path.resolve(__dirname,&apos;dist&apos;) &#125;&#125; 在package.json的script中加入&quot;build&quot;: &quot;webpack&quot;命令配置。 1234567891011121314151617&#123; &quot;name&quot;: &quot;react-demo-webpack&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.29.6&quot;, &quot;webpack-dev-server&quot;: &quot;^3.2.1&quot; &#125;&#125; 4、测试 webpack 配置 在终端输入命令进行打包测试 dist 文件夹中出现打包文件。 1npm run build 5、开发服务器配置 实现开发环境下的代码与浏览器热更新。 1npm install --save-dev webpack-dev-server 配置在 webpack.config.js文件中配置服务器 123456devServer:&#123; contentBase:&apos;./&apos;, host:&apos;localhost&apos;, compress:true, port:1717&#125; 在 package.json 中加入启动服务器命令。 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;server&quot;: &quot;webpack-dev-server --open&quot; &#125;, 6、自动刷新浏览器 上方配置并不能自动刷新浏览器，我们稍微进行配置。 在 package.json 文件中加入 publicPath:&#39;temp/&#39; 12345output:&#123; filename:&apos;index.js&apos;, path:path.resolve(__dirname,&apos;dist&apos;), publicPath:&apos;temp/&apos;&#125;, index.html文件引入JS 1&lt;script src=&quot;./temp/index.js&quot;&gt;&lt;/script&gt; 7、Babel安装配置 在webpack中配置Babel需要先加入babel-loader ,需要支持es2015和React ,共安装四个包。 1npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react 在 package.js 文件中查看包的版本信息。 12345678&quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.26.0&quot;, &quot;babel-loader&quot;: &quot;^7.1.2&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;, &quot;webpack&quot;: &quot;^3.8.1&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.3&quot;&#125; 8、配置module 在 webpack.config.js 配置 loader 。 12345678910loaders:[ &#123; test:/\.js$/, exclude:/node_modules/, loaders:&quot;babel-loader&quot;, query:&#123; presets:[&apos;es2015&apos;,&apos;react&apos;] &#125; &#125; ] 9、安装 React 和 React-dom1npm install --save react react-dom]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小学生都能学会的 Git 之【本地仓库】]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%B0%8F%E5%AD%A6%E7%94%9F%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%20Git%20%E4%B9%8B%E3%80%90%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[git 怎么搭建本地仓库？ 一、Git 简介二、安装 Git三、配置用户信息1. 命令来配置用户名和邮箱 有 –global 「所有项目」默认使用此信息。 无 –global 「特定项目」下的配置信息。 1234//配置用户名git config --global user.name &quot;xiaolu&quot; //配置邮件git config --global user.email xiaolu@example.com 图示： 2、检查是否配置成功123456//单独检查用户名git config user.name//单独检查邮件地址git config user.email//查看 git 的全部配置信息git config --list 图示： 四、创建 git 项目 在本地创建一个文件夹（xiaolu），进入该文件夹，然后初始化该文件夹（仓库）,创建之后就会出现一个隐藏文件 .git ，该文件会记录所有有关 git 操作提交记录和你所进行的 git 全部操作。 图示： 注意： 如果没有发现 .git 隐藏文件，因为我们文件夹设置不显示隐藏文件了，通过在查看的隐藏文件夹中勾选选择显示隐藏文件。 图示： 五、工作区、版本库和暂存区 工作区：工作区就是一个文件夹，比如刚刚创建的有 .git 文件夹的命名为 xiaolu 文件夹。 版本库：工作区有一个 .git 隐藏文件，我们叫做 Git 的版本库，工作区有一个称为 stage 的暂存区。 暂存区：暂存区就是临时的仓库，存放即将提交的临时文件。 六、提交代码 我们在文件夹中创建一个命名为 xiaolu.txt 的文件（手动创建或命令创建），我们将本地文件夹（仓库）的 xiaolu.txt文件提交到 Github 远程仓库中去，将经历以下过程。 1、创建文件夹1234//命令创建 xiaolu.txt 文件touch xiaolu.txt//命令查看在 xiaolu 文件中是否存 xiaolu.txt 文件ls 命令图示： 可视图示： 2、提交过程 将本地代码先提交至版本库，等待提交至远程仓库。 12345678//1、先将工作区的文件添加到暂存区等待被提交git add xiaolu.txt//2、查看缓存区是否存在 xiaolu.txt 文件git status//3、将暂存区文件提交至版本库 master 分支（-m 后是提交备注信息）git commit -m &apos;第一次提交，提交内容为 xiaolu.txt 文件&apos;//4、显示最近一次提交记录git show 提交图示： 提交过程图示： 3、删除文件 删除已经提交至版本库中的文件。新建命名为 file.txt 的文件，提交至版本库，然后进行在版本库中的删除。 创建 file.txt 提交至版本库： 删除工作区file文件同时删除版本库file文件： 123456//1、删除工作区文件git rm file.txt//2、查看要删除文件状态git status//3、提交删除版本库中的 file 文件git commit -m &apos;删除file文件&apos; 查看本地所有提交记录： 12//4、查看本地所有 git 提交记录git log 3、拉取版本库代码]]></content>
      <categories>
        <category>Git版本控制</category>
      </categories>
      <tags>
        <tag>Git版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack成神之路之插件配置【HTML发布_07】]]></title>
    <url>%2F2019%2F03%2F11%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90HTML%E5%8F%91%E5%B8%83_07%E3%80%91%2F</url>
    <content type="text"><![CDATA[打包发布 HTML 文件！ 一、开发环境和生产环境 在实际开发中，webpack 配置文件是分开的，开发环境一个文件，生产环境一个文件。 注意：两者设置冲突会报错！ 开发环境：开发环境中是基本不会对 js 进行压缩的，在开发预览时需要明确的报错行数和错误信息，所以完全没有必要压缩 avasScript 代码。热更新的插件 devServer 用于开发环境 。 生产环境：生产环境中才会压缩 JS 代码，用于加快程序的工作效率。 二、打包 HTML 文件1、安装打包插件 webpack 安装时 html-webpack-plugin 注意版本号。 注意：我这里用的是 webpack3 插件的版本号为 2.30.1。 1npm install --save-dev html-webpack-plugin@2.30.1 2、webpack.config.js文件引入html-webpack-plugin插件。1const htmlPlugin= require('html-webpack-plugin'); 3、webpack.config.js 里的 plugins 里进行插件配置1234567new htmlPlugin(&#123; minify:&#123; removeAttributeQuotes:true &#125;, hash:true, template:'./src/index.html'&#125;) minify：是对 html 文件进行压缩，removeAttrubuteQuotes 是却掉属性的双引号。 hash：为了开发中 js 有缓存效果，所以加入 hash，这样可以有效避免缓存 JS。 template： 是要打包的 html 模版路径和文件名称。 4、webpack 进行打包 HTML 文件里引用的 js 路径可以去掉，打包之后它会自动加上。]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack成神之路之插件配置【js压缩_06】]]></title>
    <url>%2F2019%2F03%2F11%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90js%E5%8E%8B%E7%BC%A9_06%E3%80%91%2F</url>
    <content type="text"><![CDATA[使用插件对 JS 进行压缩！ webpack 插件压缩 js 在 webpack 已经集成，但是有的还是需要手动安装。 1、安装 uglifyjs-webpack-glugin webpack3 需要安装低版本的 uglifyjs-webpack-glugin 1234// 查看版本号npm view uglifyjs-webpack-plugin versions// 安装一定版本的 uglifyjs-webpack-gluginnpm install uglifyjs-webpack-plugin@1.3.0 --save-dev 2、导入插件 在 webpack.config.js 中引入 uglifyjs-webpack-glugi 插件。 注意： webpack.json 文件中的 plugins 配置的插件一定要引用。 1const uglify = require(&apos;uglifyjs-webpack-plugin&apos;); 3、配置插件 plugins 配置里 new 一个 uglify 对象 。 注意：不同版本不同的写法。 123plugins:[ new uglify()], 4、进行压缩 webpack 进行压缩，你会发现文件的大小前后的变化，文件变小了。]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack成神之路之模块【css文件打包_05】]]></title>
    <url>%2F2019%2F03%2F11%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%90css%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85_05%E3%80%91%2F</url>
    <content type="text"><![CDATA[将 CSS 文件进行打包！ 模块：CSS 文件打包 Webpack 在生产环境中有一个重要的作用就是减少 http 的请求数，就是把多个文件打包到一个 js 里，这样请求数就可以减少好多。 在对 CSS 打包之前，需要进行配置。 一、Loaders Loaders 是 Webpack 最重要的功能之一， Loader 对不同的文件进行处理。 可以把 SASS 文件的写法转换成 CSS，而不在使用其他转换工具。 可以把 ES6 或者 ES7 的代码，转换成大多浏览器兼容的 JS 代码。 可以把 React 中的 JSX 转换成 JavaScript 代码。 1、安装 Loader Loader 有两个解析的 Loader 分别为 style-loader 和 css-loader。 1）style-loader：用来处理 CSS 文件中的 url() 等（https://www.npmjs.com/package/style-loader ）。 2）css-loader：用来将 CSS 插入到页面中的 style 标签中(https://www.npmjs.com/package/css-loader )。 12345//安装style-loadernpm install style-loader --save-dev//安装css-loadernpm install --save-dev css-loader 2、配置 Loader 在 webpack.config.js 进行配置。 test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的； use： loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错； include/exclude: 手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选）。 1234567891011//直接用usemodule:&#123; rules: [ &#123; //用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的； test: /\.css$/, //loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错； use: [ 'style-loader', 'css-loader' ] &#125; ]&#125;, 123456789//把 use 换成 loader。module:&#123; rules:[ &#123; test:/\.css$/, loader:['style-loader','css-loader'] &#125; ] &#125;, 123456789101112131415//用 use + loader 的写法：module:&#123; rules:[ &#123; test:/\.css$/, use: [ &#123; loader: "style-loader" &#125;, &#123; loader: "css-loader" &#125; ] &#125; ]&#125;, 3、打包 CSS 在 js 文件中引入 css 文件。 1import css from &apos;./src/index.css&apos;; 12//命令进行打包webpack]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack 成神之路【服务和热更新_04】]]></title>
    <url>%2F2019%2F03%2F10%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%90%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%83%AD%E6%9B%B4%E6%96%B0_04%E3%80%91%2F</url>
    <content type="text"><![CDATA[服务和热更新配置！ 配置文件：服务和热更新一、设置 webpack-dev-server1、下载 webpack-dev-server1npm install webpack-dev-server –-save-dev 2、配置 devServer 在 webpack.config.js 文件中进行配置。 12345678910devServer:&#123; //设置基本目录结构 contentBase:path.resolve(__dirname,'dist'), //服务器的IP地址，可以使用IP也可以使用localhost host:'localhost', //服务端压缩是否开启 compress:true, //配置服务端口号 port:1717&#125; contentBase:配置服务器基本运行路径，用于找到程序打包地址。 host：服务运行地址，建议使用本机IP，这里为了讲解方便，所以用localhost。 compress：服务器端压缩选型，一般设置为开启，如果你对服务器压缩感兴趣，可以自行学习。 port：服务运行端口，建议不使用80，很容易被占用，这里使用了1717.]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack 成神之路【多入口多出口_03】]]></title>
    <url>%2F2019%2F03%2F10%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%90%E5%A4%9A%E5%85%A5%E5%8F%A3%E5%A4%9A%E5%87%BA%E5%8F%A3_03%E3%80%91%2F</url>
    <content type="text"><![CDATA[webpack 配置文件实现多入口多出口！ 一、新建 webpack.config.js 文件 webpack.config.js 这是 webpack 自有的配置文件。在根目录新建 webpack.config.js 配置文件,属性如下： 123456789101112module.exports=&#123; //入口文件的配置项 entry:&#123;&#125;, //出口文件的配置项 output:&#123;&#125;, //模块：例如解读 CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置 webpack 开发服务功能 devServer:&#123;&#125;&#125; 1234567891011121314151617const path = require('path')module.exports=&#123; entry:&#123; // 打包文件的路径 entry: '' &#125;, output:&#123; // 打包路径(获取项目的绝对路径) path: path.resolve(__dirname,'dist'), //打包的文件名称 filename: '' &#125;, module:&#123;&#125;, plugins:[], devServer:&#123;&#125;&#125; 二、配置属性信息 添加入口文件和出口文件进行打包。 1234567//双入口配置文件entry:&#123; // 第一个入口文件 entry:'./src/entry.js', //另一个入口文件 entry2:'./src/entry2.js'&#125;, 出口文件修改 [name]。 123456789//全局const path = require('path');//局部 output:&#123; //打包的路径文职，绝对路径 path:path.resolve(__dirname,'dist'), //打包文件名（[name] 根据入口文件的名称作为出口文件名称） filename:'[name].js' &#125;, 三、命令打包 控制台输入 Webpack命令进行打包。 四、全部代码123456789101112131415161718192021222324//node 知识const path = require('path');// 配置文件module.exports=&#123; //入口文件的配置项 entry:&#123; entry:'./src/entry.js', //另一个入口文件 entry2:'./src/entry2.js' &#125;, //出口文件的配置项 output:&#123; //打包的路径文职，绝对路径 path:path.resolve(__dirname,'dist'), //打包文件名(name)表示对应的入口文件名 filename:'[name].js' &#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125;]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 2016 入门【函数的扩展】]]></title>
    <url>%2F2019%2F03%2F10%2FECMAScript%202016%20%E5%85%A5%E9%97%A8%E3%80%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[ES 6中对函数的扩展。 一、箭头函数1、基本用法▉格式一：最基本的格式123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; ▉格式二：多个参数，圆括号表示123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; ▉格式三：代码块多余一条，大括号括起来，用 return 返回1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; ▉格式四：返回对象加圆括号1let getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;); ▉格式五：只有一行语句 ，不需要返回值1let fn = () =&gt; void doesNotReturn(); ▉格式六：与变量结构结合使用123456const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之JavaScript执行(三)]]></title>
    <url>%2F2019%2F03%2F09%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BJavaScript%E6%89%A7%E8%A1%8C(%E4%B8%89)10%2F</url>
    <content type="text"><![CDATA[你知道现在有多少种函数吗？ 一、函数1、普通函数 用 function 关键字定义的函数。 123function foo()&#123; // code&#125; 2、箭头函数 用 =&gt;运算符定义的函数。 12345class C &#123; foo()&#123; //code &#125;&#125; 3、方法 在 Class 中定义的函数。 12345class C &#123; foo()&#123; //code &#125;&#125; 4、生成器函数 用 function * 定义的函数。 123function foo*()&#123; // code&#125; 5、类 用 Class 定义的类，实际上也是函数。 12345class Foo &#123; constructor()&#123; //code &#125;&#125; 6、异步函数 普通函数、箭头函数和生成器函数加上 async 关键字。 123456789async function foo()&#123; // code&#125;const foo = async () =&gt; &#123; // code&#125;async function foo*()&#123; // code&#125; 二、this 关键字的行为 this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同。]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack 成神之路【搭建 Demo_02】]]></title>
    <url>%2F2019%2F03%2F08%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E3%80%90%E6%90%AD%E5%BB%BADemo_02%E3%80%91%2F</url>
    <content type="text"><![CDATA[Webpack 实现项目打包！ 一、项目基本目录 在根目录下建立两个文件夹，分别是 src 文件夹和 dist 文件夹。 src：用来存放我们编写的 javascript 代码，可以简单的理解为用 JavaScript 编写的模块。 dist ：用来存放供浏览器读取的文件，这个是webpack打包成的文件。 二、添加文件 1）在 dist 中我们建立 index.html 的文件并引入 bubdle.js 文件（bubdle.js是打包后的文件，在这先进行引入）。 2）在 src 下建立源文件 js，也就是我们所说的入口文件 entery.js ，用来编写 js 代码。 三、打包 webpack 4.0+ 在终端使用命令进行打包，命令格式如下： 1234// webpack 3.0+wepack &#123;入口文件路径&#125; &#123;出口文件路径&#125;//webpack 4.0+webpack [入口文件路径] --output [出口文件路径] --mode development 四、打包完成 运行完上方命令之后，在 dist 打包后的文件夹中出现 bundle.js打包文件，我们就可以在浏览器中进行预览了。]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack成神之路【环境搭建_01】]]></title>
    <url>%2F2019%2F03%2F08%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E3%80%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA_01%E3%80%91%2F</url>
    <content type="text"><![CDATA[一文教你搭建 Webpack 在 VS code 中的环境搭建！ 一、为什么需要webpack? JS 的复杂性和需要很多依赖包，CSS,Less…新增样式的扩展写法的编译工作，所以我们不得不借助Webpack工具来做辅助。 二、什么是Webpack? WebPack 可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。3.0 版本出现了优化的作用。 打包： 可以把多个 Javascript 文件打包成一个文件，减少服务器压力和下载带宽。(模块 —&gt; 静态优化) 转换： 把拓展语言转换成为普通的 JavaScript，让浏览器顺利运行。 优化：前端变的越来越复杂后，性能也会遇到问题，而 WebPack 也开始肩负起了优化和提升性能的责任。 三、安装 Webpack1、前提 安装 Node.js ，用 npm 来进行安装，进入项目的根目录。 2、初始化项目12//初始化项目npm init 3、安装 webpack,并一路回车 主要目的就是生成 package.json 文件(当前项目的依赖模块，自定义的脚本任务等 ) ,自行扩展到 Node相关知识。 1）初始化目录12//初始化目录$ npm init npm终端会问你关于项目的名称，描述等，如果你不考虑发布到npm上，这些内容都不重要， 直接回车初始化，根目录会生成 package.json 文件。 script 字段： scripts指定了运行脚本命令的 npm 命令行缩写，比如start指定了运行 npm run start时，所要执行的命令。 dependencies 字段：dependencies字段指定了项目发布后运行所依赖的模块。 devDependencies 字段：devDependencies指定项目开发所需要的模块。 2）安装webpack ① --save 将其 webpack 保存到 package.json 中。 ② -dev 是只在开发环境下使用。 1$ npm install webpack（@版本号） -g 3）检测版本 如果报错，请检查版本是否错误，或者全局已经安装，本地安装就会报错（需要删除全局安装，然后进行本地安装）。 12// 查看版本号webpack -v 12// 全局卸载 webpacknpm uninstall webpack -g 四、问题 局部安装的 webpack 失效问题。 1npm install webpack（@版本号） --save-dev]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之JavaScript执行(二)]]></title>
    <url>%2F2019%2F03%2F06%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BJavaScript%E6%89%A7%E8%A1%8C(%E4%BA%8C)9%2F</url>
    <content type="text"><![CDATA[闭包和执行上下文到底怎么回事？ 本节目录 闭包； 作用域链； 执行上下文； this 值； 一、闭包1、什么是闭包？ 闭包是一个绑定了执行环境的函数，与普通函数的区别就是它携带了执行的环境。 2、闭包的组成？ 环境部分 环境：函数的词法环境（执行上下文的一部分） 标识符列表：函数中用到的未声明的变量 表达式部分：函数体 二、执行上下文：执行的基础设施 执行上下文：JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。 1、var 声明与赋值 var 声明作用域是函数执行的作用域，也就是说 var 会穿透 for、if等语句。 ■ 将函数变为函数表达式12345678910//注意：加上分号，否则自动执行;(function()&#123; var a; //code&#125;());(function()&#123; var a; //code&#125;)(); 推荐写法： 12345//加 void 关键字void function()&#123; var a; //code&#125;(); 2、let ES6 引入的新特性，为了实现 let ，js 引入了会计作用域。 以下语句会产生 let 使用作用域： for if switch try/catch/finally 3、Realm 在标准（9.0）中引入新概念 Realm “范围”。]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【环境搭建】]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[VSCode ES6 Babel 环境搭建。 一、ES6 环境搭建 目前 Chrome 浏览器已经支持 ES6 了，但是很多低版本的浏览器不支持 ES6 语法，所以需要将 ES6 转换成 ES5 来进行打包执行，除了 Webpack 支持自动编译转换的能力，Babel 也可以完成，下边用 Babel 来搭建 ES6 环境。 1、初始化项目 安装 Babel 之前，需要初始化项目，打开终端或者 cmd 进入项目目录下，输入以下命令，项目根目录会出现 package.json 配置文件，可进行修改。 12// -y 默认全部同意npm init -y 2、全局安装 Babel-cli 在终端输入安装命令，npm 或者 cnpm 进行安装。 12// -g 全局npm install -g babel-cli 注意：这时输入命令babel [用ES6写的js目录/index.js] -o [转换成ES5的目录/index.js]虽然可以在新转换成ES5的目录中出现新转换的文件夹，但是里边的内容还是ES6语法。 3、安装 babel-preset-es2015 和 babel-cli 转换包1npm install --save-dev babel-preset-es2015 babel-cli 安装完成之后，package.json 文件多了 devDependencies 选项。 1234&quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot; &#125; ▉ 新建 .babelrc在根目录下新建 .babelrc 文件，MAC 可能此后缀文件不支持，可上网自行搜索方法，让其支持此后缀。打开文件输入一下内容： 123456&#123; &quot;presets&quot;:[ &quot;es2015&quot; ], &quot;plugins&quot;:[]&#125; ▉ 转化命令 完成上边的安装之后，我们开始进行转换。下边这种命令转换非常繁琐，我们可以进一步进行简化。 1babel src/index.js -o dist/index.js 简化： 1234567891011121314151617&#123; &quot;name&quot;: &quot;ReactDome&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; //修改这一行，冒号前边是命令，后边是转化路径 &quot;bulid&quot;: &quot;babel [用ES6写的js目录/index.js] -o [转换成ES5的目录/index.js]&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot; &#125;&#125; 输入一下命令将ES6 转化 ES5： 1npm run build]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【哈希算法】]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[如何防止数据库中的用户信息被脱库？ 一、哈希基本常识1、什么是哈希算法？ 将任意长度的二进制串映射为固定长度的二进制串，这个映射规则就是哈希算法。从原始数据映射之后的二进制串就是哈希值。 2、哈希算法满足的条件？ 1）从哈希值不能反向推导出原始数据（单向哈希算法）； 2）对原始数据敏感，哪怕只改了一个bit，得到的哈希值大不形同； 3）散列冲突的概率要小，对于不同原始的数据，哈希值相同的概率非常小； 4）哈希算法执行效率要高效，对于较长的文本，也能快速的计算出哈希值。 3、实际用途（MD5 算法） MD5 的哈希值是 128 位的 Bit 长度，为了方便表示转化成了 16 进制编码。 12MD5(&quot; 我今天讲哈希算法！&quot;) = 425f0d5a917188d2c3c3dc85b5e4f2cbMD5(&quot; 我今天讲哈希算法 &quot;) = a1fb91ac128e6aa37fe42c663971ac3d 二、哈希算法最常见的七大应用 安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。 应用一：安全加密 最常用的两种加密算法 MD5（Message-Digest Algorithm，消息摘要算法） 加密算法和 SHA（Secure Hash Algorithm，安全散列算法）。 1、加密的哈希特性有哪些？■ 对于加密，不能通过哈希值反向推导。 加密为了防止原始数据泄漏，所以很难通过哈希值反向推倒原始数据。 ■ 散列冲突要小 无论什么哈希算法，我们只能尽量减少冲突的概率，理论上没有办法做到完全不冲突 —— 鸽巢原理（也叫抽屉原理）。 2、为什么哈希无法做到零冲突？ 哈希算法产生的哈希值长度是固定值有限的。 比如： MD5 算法，哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据。而我们的原始数据是无限的，就必然会存在哈希值冲突现象。 应用二：唯一标识1、问题 在海量的图库中，搜索到一张图片是否存在，最常用的解决办法就是对比图像的名称，有可能出现名称相同，图像内容不符的情况，所以应该怎么来解决？ 2、解决方法 图片在计算机中的存储是以二进制码串的形式，就是用查找图片的码串和图库中的所有码串进行对比。但是由于每张图片几十 kb 转化成二进制码串非常长，怎么进行优化？ 3、方法优化 给每个字符串取唯一标识，取二进制码头100字节，中间100字节，尾100字节，将这 100 字节放到一块，通过哈希算法得到一个哈希字符串当做图片的唯一标识。 4、进一步优化 通过图片的唯一标识和图片相应的路径信息都对应的存在散列表中。直接通过对比哈希字符串定位到图片的唯一标识，然后通过散列表得到该图片再进行比较，如果完全相同，说明存在该图片，如果不相同，就说明存在图片名称相同，内容不同的两张图片。 应用三：数据校验1、问题 基于 p2p 协议的 BT 下载软件，在多个机器并行下载，电影被分割成多块进行同步下载，然后下载完成进行整合。由于不能确定每块文件的完整性，可能被恶意篡改、下载错误等，导致最后整合无法观看，那么如何校验文件块的正确性呢？ 2、校验的哈希特性 哈希算法对数据很敏感，一旦文件快内容一丁点的改变，最后的哈希值就完全不同。 3、解决方法 用哈希算法检验下载文件块是否完整，可以对下好的文件块的哈希值与完整的文件块进行一一对比，如果不相同，就说明该文件快损坏，需要重新下载。 应用四：散列函数 散列函数也是哈希算法的一种应用。 1、散列函数的哈希要求 1）散列函数对散列冲突要求比较低，只要不过于严重，通过开发寻址法或者链表法解决。 2）散列函数计算出的值能否反向解密不关心，反而更加关注是否能平均分布，也就是一组数据能否均匀的在各个槽中。 3）散列函数的快慢影响散列表的性能，所以说散列函数要求比较简单，比较追求性能。 哈希算法在分布式系统中有哪些应用？ 应用五：负载均衡 负载均衡算法有很多，比如轮询、随机、加权轮询等。 1、问题 那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢。也就是说，需要在同一个客户端上，在一次会话中的所有请求都路由到一个同一个服务器上。 2、常规解决 维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。 3、存在弊端 1、如果客户端很多，映射表可能会很大，比较浪费内存空间； 2、客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大； 4、哈希解决 对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算。最终得到的值就是应该被路由到的服务器编号。就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。 应用六：数据分片▉ 示例一：如何统计“搜索关键词”出现的次数？1、问题 假如有 1T 的日志文件，这里面记录了用户的搜索关键词，想要快速统计出每个关键词被搜索的次数，该怎么做呢？ 2、思路分析 1） 搜索日志很大，没办法放到一台机器的内存中。 2）如果只用一台机器来处理这么巨大的数据，处理时间会很长。 3、解决办法 MapReduce 的基本设计思想，先进行数据分片，然后采用多台机器的方法处理，来提高处理效率。 1）从搜索记录的日志文件中，依次读出每个搜索关键词。 2）并且通过哈希函数计算哈希值，然后再跟 n 取模。 3） 最终得到的值，就是应该被分配到的机器编号。 4、条件限制 有另一种方法可以解决，用到散列表，详细章节情跳转：《堆》的求前 k 大搜索关键词求所有关键字的次数。 ▉ 示例二：如何快速判断图片是否在图库中？1、问题 假设现在我们的图库中有 1 亿张图片，如何快速判断图片是否在图库中？ 2、思路分析 1）在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。 2）用多台机器进行计算。 3、解决 当判断一个图片是否在图库中的时候，用同样的哈希算法，计算唯一标识，然后与机器个数n求余取模。假设得到的值是k，那就去标号k的机器构建的散列表中查。 应用七：分布式存储1、问题 当拥有海量的用户和数据的时候，为了提高数据的读写、写入能力，一般采用分布式来存储数据。 2、思想 利用数据分片思想，通过计算哈希算法，对数据去哈希值，然后对机器的个数进行取余，最终的就是存储缓存机器的标号。 3、数据太大如何扩容？ 变化最大就是机器的数量增加了，导致取模使得哈希值变化很大。 4、导致问题 1）进行大规模数据迁移，所有的数据都要进行重新计算哈希值，重新搬移到正确的机器上。 2）当量的数据在缓存中就失效了，所有的数据请求都会穿透缓存，直接去请求数据库。会发生雪崩效应，压垮数据库。 5、解决方法 假设有k个机器，数据的哈希值范围是【0，MAX】。我们将整个范围划分为m个小区间（m远大于k）， 每个机器负责m/k个小区间。当有新机器加入的时候，我们在几个小区间里搬移数据到新机器中，即不用重 搬移数据，又保持了各个机器上数据的均衡。 三、本节思考：如何防止数据库的用户信息被脱库？ 安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，只是增加了攻击的成本而已。 ■ 问题 用户的密码通过哈希算法都能转化成哈希值，所有的用户信息形成一个数据字典，一旦数据字典被攻击，黑客就会拿到加密后的密文之后和数据字典中的数据进行比对，一般对比相同的就是数据字典中的明文。 ■ 优化 引入一个盐（salt）概念，跟用户的密码进行组合到一起，增加密码的复杂度，拿到组合后的字符串进行哈希加密，将它存储到数据库，进一步增加破解的难度。 四、扩展思考▉ 问题： 区块链是怎么用哈希算法进行解决问题的？ ▉ 区块链的组成 区块链分为区块头和区块体。区块头保存着自己区块体和上一区块头的哈希值。 ▉ 区块链的哈希特性 唯一性：链式关系用到了哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。 ▉ 区块链的算法 区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 2016 入门【基本语法】]]></title>
    <url>%2F2019%2F03%2F03%2FECMAScript%202016%20%E5%85%A5%E9%97%A8%E3%80%90%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[ECMAScript 6 基本入门。 Promise 对象1、定义 Promise 是一种异步编程的解决方案。 2、基本用法123456789101112131415const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); Promise 接受一个函数，该函数两个参数分别为 resolve和reject。 resolve函数的作用: pending 变为 resolved； reject函数的作用：pending 变为 rejected； then方法：指定 resolved 状态和rejected的回调函数。 then两个方法：第一个当状态变为resolve时调用；第二个当状态变为rejected时调用；第二个通常不提供； 3、应用场景■ 异步加载图片123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; ■ Promise 实现 AJAX1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); async 函数1、含义 ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 2、基本用法 async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 ■ 代码示例 指定 50 毫秒以后，输出hello world。 123456789101112function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50);]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之JavaScript执行(一)]]></title>
    <url>%2F2019%2F03%2F03%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BJavaScript%E6%89%A7%E8%A1%8C(%E4%B8%80)8%2F</url>
    <content type="text"><![CDATA[Promise 里的代码为什么比 setTimeout 先执行？ 一、JavaScript 引擎 一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。 1、ES3 更早的版本 js 没有处理异步的能力。ES5 之后 js 引入 Promise 异步编程，js 引擎本身也可以发起任务。 1、宏观任务 由宿主环境发起的任务叫做宏观任务。 ■ 事件循环 JavaScript 引擎等待宿主环境分配宏观任务，等待就是一个事件循环。 ■ 宏观任务 每次执行的过程就是一个宏观任务。宏观任务的队列就相当于事件循环。 2、微观任务 由 js 引擎发起的任务称为微观任务，x许多微观任务组成了宏观任务。 3、Promise Promise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。 ■ 代码实例一12345678 //输出的顺序是 a、b、cvar r = new Promise(function(resolve, reject)&#123; console.log("a"); resolve() &#125;);//异步回调 r.then(() =&gt; console.log("c")); console.log("b") ■ 代码实例二1234567891011// js 引擎发起的微观任务var r = new Promise(function(resolve, reject)&#123; console.log("a"); resolve()&#125;);//浏览器(宿主)发起的宏观任务setTimeout(()=&gt;console.log("d"), 0)//微观任务先于宏观任务r.then(() =&gt; console.log("c"));console.log("b")//打印顺序 a、b、c、d 4、如何分析异步执行的顺序 首先我们分析有多少个宏任务； 在每个宏任务中，分析有多少个微任务； 根据调用次序，确定宏任务中的微任务执行次序； 根据宏任务的触发规则和调用次序，确定宏任务的执行次序； 确定整个顺序。 5、ES6新特性：async/await参考 ES6 语法：http://es6.ruanyifeng.com/#docs/async]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 高级程序设计第七章【函数表达式】]]></title>
    <url>%2F2019%2F02%2F27%2FJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%90%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[递归与闭包以及私有变量 第七章 函数表达式 定义函数有两种形式：1、函数声明 2、函数表达式 1、函数声明 函数提升：在执行代码之前，先读取函数声明，所以函数声明代码可以放在函数调用的后边。 2、函数表达式 匿名函数：function 后边没有函数名， 3、函数提升 理解函数声明与函数表达式之间的区别。 注意：同一个函数声明不要出现在同一 if - else 判断中语句中使用，但是函数表达式可以使用。 7.1 递归1、示例 下方示例会出现错误，因为在 otherfun 里调用 fun ，fun 已经变为 null 了。 1234567891011var otherfun = fun;fun = null;alert(otherfun(4));fun(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return fun(num-1); &#125;&#125; 2、改进 arguments.callee 是一个指向正在执行的函数的指针，用它来实现递归的调用。 12345678fun(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; // arguments.callee 永远指向正在执行的函数 return arguments.callee(num-1); &#125;&#125; 3、严格模式下 严格模式下，不能通过脚本来调用 arguments.callee ，否则报错。 123456789// 通过匿名函数可以来访问var fun2 = ( if(num &lt;= 1)&#123; return 1; &#125;else&#123; return f(num-1); &#125;); 7.2 闭包 区分闭包和匿名函数。 闭包：有权访问另一个函数作用域中的变量的函数。 1、理解闭包的 即使函数内部的函数返回了，在另一地方照样可以访问外部函数的参数，因为匿名函数的作用域链包含 createFunction函数的作用域。 1234567function createFunction（name）&#123; //返回匿名函数 return function(object1)&#123; //匿名函数内部访问外部函数变量 var value = object1[name]; &#125;&#125; 过程分析： 1、匿名函数返回时会将外部函数的活动对象和全局的活动对象添加到自己的作用域链中，当匿名函数在外部访问时，外部的变量就会访问到。 2、包含闭包函数的外部函数销毁时，只会销毁执行环境中的作用域链，而不会销毁活动对象，活动对象仍然留在内存中；直到闭包函数被销毁后，活动对象才会被销毁。 闭包使用注意： 闭包会携带其他函数的作用域链，在内存中会占用很大的空间，过度使用闭包可能导致内存占用过多，有必要时在考虑闭包问题。 7.2.1 闭包与变量]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【队列】]]></title>
    <url>%2F2019%2F02%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E9%98%9F%E5%88%97%E3%80%91%2F</url>
    <content type="text"><![CDATA[队列在线程池等有限资源池中的应用！ 一、队列的基本常识1、什么是队列 先进先出的数据结构。 2、特点 先进先出，吃多了就拉！ 二、怎么实现队列 用数组来实现的叫做顺序队列，用链表来实现叫做链式队列。 1、顺序队列■ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940// 用数组实现的队列public class ArrayQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public ArrayQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队 public boolean enqueue(String item) &#123; // 如果 tail == n 表示队列已经满了 if (tail == n) return false; //将数据插入到尾部 items[tail] = item; //指向尾部的下标加、+1 ++tail; //返回ture return true; &#125; // 出队 public String dequeue() &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; //取出队头的第一个数据 （问题：队列头部的值还仍然存在数组中） String ret = items[head]; //队头下边向后移动+1 ++head; //将出队的元素返回 return ret; &#125;&#125; ■ 问题探讨 用两个指针来控制队列，频繁的出队和入队会产生head 和 tail 都会持续往后移动，当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。怎么解决呢？ ■ 解决一：数据迁移 每出队一个元素就进行数据搬移，导致的时间复杂度从 O(1) 上升到了 O(n)，可以继续进行优化。 ■ 优化：解决一 当数据出队的时候，不做任何数据搬移，当无法往数组中添加数据的时候，然后集中进行数据搬移，优化后出队的时间复杂度为 O(1)，入队的时间复杂度分析： 1、当队尾有空余空间，进行直接插入，时间复杂度为 O(1)。 2、当队尾没有空闲时间时，先进行搬移然后进行插入，时间复杂度为O(n)。用均摊分析方法求出平均时间复杂度为 O(1)。 ■ 优化后的代码1234567891011121314151617181920// 入队操作，将 item 放入队尾 public boolean enqueue(String item) &#123; // tail == n 表示队列末尾没有空间了 if (tail == n) &#123; // tail ==n &amp;&amp; head==0，表示整个队列都占满了 if (head == 0) return false; // 数据搬移 for (int i = head; i &lt; tail; ++i) &#123; items[i-head] = items[i]; &#125; // 搬移完之后重新更新 head 和 tail tail = tail - head; head = 0; &#125; //将入队列的元素插入到队尾 items[tail] = item; //队尾指针+1 ++tail; return true; &#125; 2、链式队列■ 代码实现1234567891011121314151617181920212223242526272829303132public class CircularQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public CircularQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队 public boolean enqueue(String item) &#123; // 队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true; &#125; // 出队 public String dequeue() &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; head = (head + 1) % n; return ret; &#125;&#125; ■ 三种常见的队列1、循环队列▍由来 数组实现队列，在 tail == n 的时候，需要进行数据搬移，入队就会受到影响，为了避免这次操作，出现了循环队列。 ▍定义 循环队列，顾名思义，队列首尾相接形成一个环。 ▍ 示意图 ▍工作方式 上图中，当 tail 指向 7 时，插入一个新数据并不更新 tail ,而是将 tail 指向下标为 0 的位置，当再次插入数据的时候，然后将 tail + 1更新为 1。 ▍判定条件 最重要的是队空和队满两种判空条件。 ① 队列的判空条件：head == tail 。 ② 队满的判断条件：(tail+1)%n=head。 补充： 当a=bq+r，q是整数，并使其达到最大，此时我们说a模除b等于r。以数学式子表示：a模除b。例如要计算100模除16，由于100/16是一个大于6且不大于7的整数，取q=6。100-16*6=4，而4就是答案。 注意： 当队列满时，tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。 ▍ 代码实现 1234567891011121314151617181920212223242526272829303132public class CircularQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public CircularQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队 public boolean enqueue(String item) &#123; // 队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true; &#125; // 出队 public String dequeue() &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; head = (head + 1) % n; return ret; &#125;&#125; 2、阻塞队列▍由来 通过队列实现安全高效的数据处理的功能。 ▍定义 阻塞队列，是在普通队列基础上实现了阻塞线程的功能（生产者—消费者模式）。 详细分析：在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回 ▍问题一：阻塞产生的问题 当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。 ▍问题解决： 通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。 ▍问题二：多线程引起的问题 配置多个 “消费者” 需要开启多线程。而多个线程同时操作队列，就会存在线性安全问题，使用到下方的并发队列来解决线性安全问题。 3、并发队列 线性安全队列叫做并发队列。 ▍实现方式 最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。 补充：实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。 三、队列的应用场景 队列可以应用在任何有限池中，用于排队请求，比如数据库的连接池等。对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”来实现请求排队。 三、本节思考■ 问题 当向固定大小的线程池请求一个线程的时候，如果线程没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种策略是怎么实现的呢？ ■ 解决1）非堵塞处理方式 直接拒绝任务请求； 2）阻塞处理方式 将请求排队，等到有空闲线程时，取出排队的请求继续处理。 ■ 链表和数组排队请求的区别 ① 基于链表的实现。实现一个无限排队的无界队列，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。 ② 基于数组实现。实现一个有界队列，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，对于响应时间比较敏感的系统更加合适。设置一个合理的队列大小是非常有讲究的，队列太大导致等待的请求太多，队列太小会导致无法充分资源，发挥最大性能。 四、扩展思考1、类似于线程池用到队列排队请求，还有哪些类似的池结构或者场景会用到队列请求呢？ 答：Android 中的 Handle 消息处理机制中的消息队列用到了队列请求（需扩展） 2、如何实现无锁并发队列呢？ 答： 五、队列的基本掌握1、用数组实现一个顺序队列2、用链表实现一个链式队列3、实现一个循环队列]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【栈】]]></title>
    <url>%2F2019%2F02%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E6%A0%88%E3%80%91%2F</url>
    <content type="text"><![CDATA[如何实现浏览器的前进后退功能？ 一、栈的基本常识1、什么是栈？ 先进后出的结构。 2、特点 先进后出。 二、怎么实现栈？ 用数组实现的栈，叫作顺序栈，用链表实现的栈，叫作链式栈。 1、顺序栈 基于数组实现的顺序栈。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package easy_test;/** * 功能:基于数组的顺序栈 * @author:小鹿 * */public class ArrayStack &#123; private String[] items; // 数组 private int count; // 栈中元素个数 private int n; // 栈的大小 // 初始化数组，申请一个大小为 n 的数组空间 public ArrayStack(int n) &#123; this.items = new String[n]; this.n = n; this.count = 0; &#125; /** * 功能:入栈 * 说明:数组入栈的入口为数组尾部 * @param item :入栈数据元素 * @return:是否入栈成功 */ public boolean push(String item) &#123; // 数组空间不够了，直接返回 false，入栈失败。 if (count == n) return false; // 将 item 放到下标为 count 的位置 items[count] = item; //数组长度+1 ++count; //入栈成功 return true; &#125; /** * 功能:出栈 * @return:返回出栈元素 */ public String pop() &#123; // 栈为空，则直接返回 null if (count == 0) return null; // 返回下标为 count-1 的数组元素 String tmp = items[count-1]; //数组长度-1 --count; //返回出栈数据元素 return tmp; &#125;&#125; 2、链式栈 基于链表实现的链式栈。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package easy_test;/** * 功能:基本链表实现栈，入栈、出栈、输出栈 * @author : 小鹿 * */public class StackBasedLinkedList &#123; //定义栈顶指针 private Node top = null; //定义栈结点 private static class Node &#123; //栈结点数据域 private int data; //栈结点指针域 private Node next; //构造函数 public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125; //get 获取数据域方法 public int getData() &#123; return data; &#125; &#125; /** * 功能:入栈 * @param value:要入栈的数据元素 */ public void push(int value) &#123; //创建一个栈结点 Node newNode = new Node(value, null); // 判断栈是否为空 if (top == null) &#123; //如果栈为空，就将入栈的值作为栈的第一个元素 top = newNode; &#125; else &#123; //否则插入到top栈结点前（所谓的就是单链表的头插法） newNode.next = top; top = newNode; &#125; &#125; /** * 功能 : 出栈 * @return: -1 为栈中没有数据 */ public int pop() &#123; // 如果栈的最顶层栈结点为null,栈为空 if (top == null) return -1; //否则执行出栈操作，现将栈顶结点的数据元素赋值给 Value int value = top.data; //将 top 指针向下移动 top = top.next; //返回出栈的值 return value; &#125; /** * 功能:输出栈中所有元素 */ public void printAll() &#123; //将栈顶指针赋值给p Node p = top; //循环遍历栈(遍历单链表) while (p != null) &#123; System.out.print(p.data + " "); //指向下一个结点 p = p.next; &#125; System.out.println(); &#125;&#125; 三、栈操作的性能1、时间复杂度 顺序栈和链式栈入栈和出栈只操作栈顶元素，所以时间复杂度为 O(1)。 2、空间复杂度 顺序栈和链式栈只需要大小为 n 的空间就可以，入栈和出栈需要一个临时空间来存储变量，空间复杂度为 O(1)。 3、栈的动态扩容 当栈满的时候，需要进行动态扩容，可以仿照数组的动态扩容。 1）出栈涉及不到扩容，时间复杂度为 O(1)；入栈当栈满的时候，需要进行扩容，数据进行搬移，时间复杂度为 O(n)。平均时间复杂度为 O(1)，进行摊还分析。 五、栈的实际应用 栈在解决实际问题中起着关键的作用。 LeedCode 第 20 题：有效的括号（简单） LeedCode 第 32 题：最长有效括号（困难） 1、应用一：函数调用栈 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。 ▉ 代码实现123456789101112131415int main() &#123; int a = 1; int ret = 0; int res = 0; ret = add(3, 5); res = a + ret; printf("%d", res); reuturn 0;&#125;int add(int x, int y) &#123; int sum = 0; sum = x + y; return sum;&#125; ▉ 代码实现 2、应用二：栈在表达式求值中的应用 编译器就是通过两个栈来实现的。其中一个保存操作数的栈 ，另一个是保存运算符的栈。从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。 ▉ 问题 将 3+5*8-6 这个表达式的计算过程画成了一张图，进行计算。 ▉ 图示 ▉ 分析 如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。 3、应用三：栈在括号匹配中的应用 用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(” 跟 “)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。 六、本节思考：怎样实现浏览器的前进后退？ 答：使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。 七、扩展思考1、为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？ 答： 1）因为函数调用的执行顺序符合后进者先出，先进者后出的特点。比如函数中的局部变量的生命周期的长短是先定义的生命周期长，后定义的生命周期短；还有函数中调用函数也是这样，先开始执行的函数只有等到内部调用的其他函数执行完毕，该函数才能执行结束。2）正是由于函数调用的这些特点，根据数据结构是特定应用场景的抽象的原则，优先考虑栈结构。 2、那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？ 答： JVM里面的栈和我们这里说的是一回事，被称为方法栈。和前面函数调用的作用是一致的，用来存储方法中的局部变量 八、栈的掌握程度1、用数组实现一个顺序栈2、用链表实现一个链式栈3、编程模拟实现一个浏览器的前进、后退功能]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之HTML标签7【元信息】]]></title>
    <url>%2F2019%2F02%2F24%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BHTML%E6%A0%87%E7%AD%BE7%E3%80%90%E5%85%83%E4%BF%A1%E6%81%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[head 里一共能写哪几种标签？ 元信息类标签 所谓元信息，描述自身的信息，元信息类标签，就是 HTML 用于描述文档自身的一类标签。 ■ head 标签 html 标签的第一个标签，必须包含一个 title，并且最多只能包含一个 base ，如果文档作为 iframe，或者有其他方式指定了文档的标题，可以允许不包含 title 标签。 ■ title 标签 title 表示文档的标题。 1、title 和 h1 的区别 title 作为元信息，可能会被用在浏览器收藏夹、微信推送卡片、微博等各种场景，这时侯往往是上下文缺失的，所以 title 应该是完整地概括整个网页内容的。 h1 仅仅表示页面展示，默认具有上下文，并具有链接辅助，所以可以简写。 ■ base 标签 给页面上所有的 URL 相对地址提供一个基础。实际开发中建议使用 javascript 来代替 base 标签，因为容易跟 javascript 造成配合问题。 ■ meta 标签 是一组键值对，是一种通用的元信息表示标签。一般的 meta 标签由 name 和 content 两个属性来定义。name 表示元信息的名，content 则用于表示元信息的值。 1&lt;meta name=application-name content="lsForums"&gt; 1、具有 charset 属性的 meta HTML 5 开始简写法，添加的 meta 没有了 name 和 content 属性，放到 head 的第一个。 1234&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;…… 1、浏览器在读到此标签之前，所有处理的字符是 ASCll 字符(ASCll 字符是 UTF-8 字符编码的子集)。 2、http 服务端会通过 http 头来指定正确的编码方式，但是有些特殊的情况如使用 file 协议打开一个 HTML 文件，则没有 http 头，这种时候，charset meta 就非常重要了。 2、具有 http-equiv 属性的 meta 表示执行一个命令。 12&lt;!-- 相当于添加了 content-type 这个 http 头，并且指定了 http 编码方式 --&gt;&lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; content - type 几种命令： content-language 指定内容的语言； default-style 指定默认样式表； refresh 刷新； set-cookie 模拟 http 头 set-cookie，设置 cookie； x-ua-compatible 模拟 http 头 x-ua-compatible，声明 ua 兼容性； content-security-policy 模拟 http 头 content-security-policy，声明内容安全策略。 3、name 为 viewport 的 meta 是移动端开发的事实标准。 1&lt;meta name="viewport" content="width=500, initial-scale=1"&gt; width：页面宽度，可以取值具体的数字，也可以是 device-width，表示跟设备宽度相等。 height：页面高度，可以取值具体的数字，也可以是 device-height，表示跟设备高度相等。 initial-scale：初始缩放比例。 minimum-scale：最小缩放比例。 maximum-scale：最大缩放比例。 user-scalable：是否允许用户缩放。 12&lt;!--如果已经做好移动端适配的网页，应该把用户的缩放功能禁止掉，宽度为设备宽度--&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【二分查找】]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E3%80%91%2F</url>
    <content type="text"><![CDATA[如何用最省内存的方式实现快速查找 ! 二分查找（上） 一般二分查找的都可以用散列表或者二叉查找树来解决。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。 一、适用条件1、二分查找依赖的是顺序结构（数组） 二分查找算法需要按照下标随机访问元素 ,因为时间复杂度为 O(1)，如果使用链表，下标随机访问时间复杂度变成为 O(n)。 2、二分查找针对的是有序数据 二分查找只能应用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用，使用二叉树。 3、二分查找不适合数据量太小 如果要处理的数据量太小，直接遍历就足够了。一个特殊情况，那就是数据之间比较操作非常耗时，无论数据量大小，推荐使用二分查找。 4、二分查找不适合数据量太大 由于二分查找底层依赖的是数组这种结构，内存空间要求是连续的。如果数据量太大，内存连续的空间不足，用数据存储起来比较吃力。 二、最简单的二分查找 最简单的情况就是有序数组中不存在重复的元素 1、最简单代码实现1234567891011121314151617181920public int simpleFind(int[] a,int n, int value) &#123; int low = 0; int high = n - 1; // 当两个指针同时指向一个数据时，必须用 &lt;= while(low &lt;= high) &#123; //注意:两者之和可能会溢出 //改进: low + (high - low)/2 或 low + ((high - low)&gt;&gt;2) int mid = (low + high)/2; if(a[mid] == value) &#123; return mid; &#125;else if(a[mid] &lt; value) &#123; // 如果不 + 或 - 会发生死循环 low = mid + 1; &#125;else &#123; high = mid - 1; &#125; &#125; return -1;&#125; 2、递归代码实现方式12345678910111213141516public int recursionTwoFind(int[] a,int low,int high,int value) &#123; //终止条件 if(low &gt; high) return -1; //计算中间结点 int mid = low + (high-low)/2; //进行递归 if(a[mid] == value) &#123; return mid; &#125;else if(a[mid] &lt; value)&#123; return recursionTwoFind(a, mid + 1, high, value); &#125;else &#123; return recursionTwoFind(a, low, mid - 1, value); &#125;&#125; 三、三个重点1、循环退出条件 注意是 low &lt;= height,而不是 low &lt; heigh。 原因：指向同一个数据，并不能查找到。 2、mid 的取值 mid=(low+high)/2 写法有问题。 原因：因为如果 low 比和 height 大的话，两者之和可能会溢出。 优化：应写成 low+(high-low)/2 ，如果优化到极致的话，改进为位运算符 low+((high-low)&gt;&gt;1)。 3、low 和 high 的更新 low=mid+1，high=mid-1。 原因：如果不进行 +1 和 -1 ，就有可能会发生死循环 二分查找（下）一、四个变体问题1、查找第一个值等于给定值的元素 有序数据集合中包含重复数据，之前的二分查找只适合于无重复数据，在这里就不适用了，查找第一个值等于给定值的元素。 ■ 代码实现 1234567891011121314151617181920212223242526272829303132/** * 变体一:查找第一个值等于给定值的元素 * @param a 数组 * @param n 数组的长度 * @param value 超找的值 * @return 该元素的数组下标 */ public int find1(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; // 当两个指针同时指向一个数据时，必须用 &lt;= while(low &lt;= high) &#123; //注意:两者之和可能会溢出 //改进: low + (high - low)/2 或 low + ((high - low)&gt;&gt;2) int mid = low + (high - low)/2; if(a[mid] == value) &#123; // 找出重复元素中第一个元素 if(mid == 0 || a[mid - 1] != value) &#123; return mid; &#125;else &#123; high = mid - 1; &#125; &#125;else if(a[mid] &lt; value) &#123; // 如果不 + 或 - 会发生死循环 low = mid + 1; &#125;else &#123; high = mid - 1; &#125; &#125; return -1; &#125; 2、查找对后一个值等于给定值的元素 查找对后一个值等于给定值的元素。 ■ 代码实现 123456789101112131415161718192021222324252627282930313233/** * 变体一:查找最后一个值等于给定值的元素 * @param a 数组 * @param n 数组的长度 * @param value 超找的值 * @return 该元素的数组下标 */public int find2(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; // 当两个指针同时指向一个数据时，必须用 &lt;= while(low &lt;= high) &#123; //注意:两者之和可能会溢出 //改进: low + (high - low)/2 或 low + ((high - low)&gt;&gt;2) int mid = low + (high - low)/2; if(a[mid] == value) &#123; // 找出重复元素中第一个元素 if(mid == n - 1 || a[mid + 1] != value) &#123; return mid; &#125;else &#123; low = mid + 1; &#125; &#125;else if(a[mid] &lt; value) &#123; // 如果不 + 或 - 会发生死循环 low = mid + 1; &#125;else &#123; high = mid - 1; &#125; &#125; return -1;&#125; 3、查找第一个大于等于给定值的元素 查找第一个大于等于给定值的元素。 ■ 代码实现 12345678910111213141516171819202122232425262728/** * 变体三:查找第一个大于等于给定值的元素 * @param a 数组 * @param n 数组的长度 * @param value 数组的值 * @return */ public int find3(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; // 当两个指针同时指向一个数据时，必须用 &lt;= while(low &lt;= high) &#123; // 注意:两者之和可能会溢出 // 改进: low + (high - low)/2 或 low + ((high - low)&gt;&gt;2) int mid = low + (high - low)/2; if(a[mid] &gt;= value) &#123; if((mid == 0) || (a[mid - 1] &lt; value )) &#123; return mid; &#125;else &#123; high = mid - 1; &#125; &#125;else &#123; low = mid + 1; &#125; &#125; return -1; &#125; 4、查找第一个小于等于给定值的元素 查找第一个小于等于给定值的元素。 ■ 代码实现 12345678910111213141516171819202122232425262728/** * 变体四:查找第一个小于等于给定值的元素 * @param a 数组 * @param n 数组的长度 * @param value 数组的值 * @return */ public int find4(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; // 当两个指针同时指向一个数据时，必须用 &lt;= while(low &lt;= high) &#123; // 注意:两者之和可能会溢出 // 改进: low + (high - low)/2 或 low + ((high - low)&gt;&gt;2) int mid = low + (high - low)/2; if(a[mid] &lt;= value) &#123; if((mid == n-1) || (a[mid + 1] &gt; value )) &#123; return mid; &#125;else &#123; low = mid + 1; &#125; &#125;else &#123; high = mid - 1; &#125; &#125; return -1; &#125; 二、扩展思考：如何快速定位一个 IP 地址的归属地？■ 问题： 如何在 12 万条数据中，快速定位一个 IP 地址的归属地？ ■ 解决： 1、首先预先处理这 12 万条数据，让其按照起始 IP 从小打到排序，将 IP 转化为 32 位的整型数，然后按照对应到的整型值的大小关系，从小到大进行排序。 2、将问题转化为变体四的问题，“查找最后一个小于等于某个给定值的元素”。 3、找到一个 IP 区间起始位置的IP 小于等于该查找 IP 的区间，然后检查该 IP 是否在区间内。 ■ 代码实践 Github：JS 快速定位一个 IP 地址归属地]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之浏览器如何工作的【浏览器】]]></title>
    <url>%2F2019%2F02%2F09%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%846%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[浏览器是如何工作的？ 浏览器是如何工作的？第一阶段：（通讯部分）HTTP 的请求过程一、浏览器的请求过程 DOM 树构建、CSS 计算、渲染、合成、绘制。 浏览器使用 HTTP 协议或者 HTTPS 协议，向服务器发送请求。 把请求回来的 HTML 代码经过解析，构成 DOM 树； 最后根据 CSS 属性对元素进行逐个渲染，得到内存中的位图。 一个可选的步骤是对位图进行合成，极大地增加后续绘制的速度； 合成之后，再绘制到界面上。 二、HTTP 协议 1、HTTP 是纯粹的文本协议，基于 TCP 协议出现的。TCP 是双向通信通道，HTTP 规定了 Request-Response 的模式，必须是由客户端首先发起。 2、浏览器是只需要 tcp 库或者现成的 http 库就能搞定网络通讯部分。 1、HTTP 请求 请求的方法 请求的路径 请求的协议 请求的版本 2、HTTP 响应 响应的协议 响应的版本 响应的状态 响应的文本 三、HTTP 协议格式 1、Method（方法） GET 通过浏览器访问的都是 GET 方法。 POST 表单提交使用 POST 方法。 HEAD HEAD 则是跟 GET 类似，只返回请求头，多数由 Js 发起。 PUT DELETE PUT 和 DELETE 分别表示添加资源和删除资源。 CONNECT 现在多用于 HTTPS 和 WebSocket。 OPTIONS TRACE OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。 2、Status code(状态码) 和 Status text(状态文本) 1XX ：临时回应，表示客户端请继续。 1xx 的状态被浏览器 http 库直接处理掉了，不会让上层应用知晓。 2XX ：请求成功。 200 ：请求成功 3XX ：表示请求的目标有变化，希望客户端进一步处理。 301 &amp;&amp; 302：永久性与临时性跳转。 实际上 301 更接近于一种报错，提示客户端下次别来了。 304 ：跟客户端缓存没有更新。 客户端本地已缓存资源，发送条件请求判断是否为最新版本，如果为最新版本，返回 304 状态码，读取本地缓存。 4XX ：客户端请求错误。 403 : 无权限。 404：表示请求的页面不存在。 418：超文本咖啡壶控制协议。 5XX :服务端请求错误。 500：服务端错误。 503：服务器暂时性错误，可以一会再试。 3、HTTP Head(HTTP 头) Request Header。 Response Header。 4、HTTP Request Body HTTP 请求的 body 主要用于提交表单场景。 application/json application/x-www-form-urlencoded (form 标签提交默认格式) multipart/form-data （文件上传） text/xml 第二阶段：DOM树是如何构建的？ 第一阶段用 HTTP/HTTPS 请求服务器，服务器返回数据进行第二阶段构建 DOM 树。 一、词（token）的拆分 这部分内容正是 HTTP 的 Response 的 body 部分内容，词（token）是最小的有意义的单元。就是将各类标签和属性拆分。 我们就收到字符串之后并不知道那个词，每读入一个字符都要进行决策，要想把字符流解析成词，我们就是用状态机。 二、状态机1、状态机的定义 大部分语言的词法部分都是使用状态机实现的。 HTML 共规定 80 个状态：https://html.spec.whatwg.org/multipage/parsing.html#tokenization 2、状态机的原理 状态机把每个词的特征字符逐个拆分开，然后再把所有词的特征字符链合并起来，形成联通图结构。 如果获得的是一个非 &lt; 字符，那么可以认为进入了一个文本节点； 如果获得的是一个 &lt; 字符，那么进入一个标签状态。 比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。 如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。 如果下一个字符是字母，那么可以确定进入了一个开始标签。 如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。 3、状态机的实现 每个函数就是一种状态，参数是接受的字符，返回值是下一个状态函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243var data = function(c)&#123; if(c=="&amp;") &#123; return characterReferenceInData; &#125; if(c=="&lt;") &#123; return tagOpen; &#125; else if(c=="\0") &#123; error(); emitToken(c); return data; &#125; else if(c==EOF) &#123; emitToken(EOF); return data; &#125; else &#123; emitToken(c); return data; &#125;&#125;;var tagOpenState = function tagOpenState(c)&#123; if(c=="/") &#123; return endTagOpenState; &#125; if(c.match(/[A-Z]/)) &#123; token = new StartTagToken(); token.name = c.toLowerCase(); return tagNameState; &#125; if(c.match(/[a-z]/)) &#123; token = new StartTagToken(); token.name = c; return tagNameState; &#125; if(c=="?") &#123; return bogusCommentState; &#125; else &#123; error(); return dataState; &#125;&#125;; 4、字符流转换成词 每一个状态是一个函数，通过 “if else” 来区分下一个字符做状态迁移。状态迁移，将当前状态函数返回下一个状态函数。 12345678910111213141516function HTMLLexicalParser()&#123; // 状态函数们…… function data() &#123; // …… &#125; function tagOpen() &#123; // …… &#125; // …… var state = data; this.receiveInput = function(char) &#123; state = state(char); &#125;&#125; 三、构建 DOM 树 DOM 树的构建，利用数据结构中的栈来实现。 接受字符串，转换成词，开始构建 DOM 树； 栈顶的最后为根元素，DOM 树的第一项就是 stack[0]； 不同的 HTML 节点对应不同的 Node 子类。 1、利用栈来构建 DOM 树 源代码完全遵守 xhtml，html 具有很强的容错能力，当栈顶和栈尾不匹配的时候，又有一套复杂的规则。 链接：http://w3c.github.io/html/syntax.html#tree-construction 栈顶元素就是当前节点； 遇到属性，就添加到当前节点； 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点； 遇到注释节点，作为当前节点的子节点； 遇到 tag start 就入栈一个节点，当前节点就是这个节… 遇到 tag end 就出栈一个节点（还可以检查是否匹配）。 第三阶段：CSS 的计算 当我们构建 DOM 树的时候，这个过程会被浏览器流式的处理，从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上，CSS属性也会同步计算。这一过程拿到元素会一次匹配规则，根据规则的优先级进行覆盖和调整， 一、选择器的各种符号 那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。 空格 &lt; + ~ || 二、匹配规则1、后代选择器“空格” 匹配规则：后代选择器的作用范围是父节点的所有子节点，因此规则是在匹配到本标签的结束标签时回退。 123a#b .cls &#123; width: 100px;&#125; 12345&lt;a id=b&gt; &lt;span&gt;1&lt;span&gt; &lt;span class=cls&gt;2&lt;span&gt;&lt;/a&gt;&lt;span class=cls&gt;3&lt;span&gt; 2、后继选择器“~” 匹配规则：后继选择器只作用于一层，上述的激活或者关闭规则不适用了。所以给选择器的激活，带上一个条件：父元素。这里的父元素是 。 123456789101112.cls~* &#123; border:solid 1px green;&#125;&lt;div&gt; &lt;span&gt;1&lt;span&gt; &lt;span class=cls&gt;2&lt;span&gt; &lt;span&gt; 3 &lt;span&gt;4&lt;/span&gt; &lt;span&gt; &lt;span&gt;5&lt;/span&gt;&lt;/div&gt; “后继”：cls 的后继有 2, 3, 5。 3、子代选择器“&gt;” 拿当前节点作为父元素，然后激活后边的 .cls 选择条件，并且指定了父元素必须是当前div，后续的构建 DOM 中就选中了相应的标签。 4、直接后继选择器“+” 直接对唯一元素生效，不用反复的激活和关闭规则。匹配到之后让其失效。 5、逗号分隔 逗号分隔看做是两条规则来处理。为了提高效率，可以把选择器构造成一课树： 12345678910#a .cls &#123;&#125;#a span &#123;&#125;#a&gt;span &#123;&#125; #a &lt;空格&gt;.cls &lt;空格&gt;span span 第四阶段：排版（确定元素位置） 所谓的排版，就是确定每一个文字的位置。 一、浏览器的排版 浏览器最基本的排版就是正常流排版（跟平时书写文字一样，所以叫正常溜），包括顺次排版和折行排版。 1、正常流排版 文字排版遵循公认的文字排版模型，包括行模型（行顶、行底、文字区域、基线）和文字在行模型中的排布。 ■ 浏览器所支持的元素 双向文字系统（不同语言文字书写顺序不同） 盒模型（元素和文字混排）—— 元素被定义为长方形区域（边框、留白、边距） 绝对定位元素 —— 不参加排版计算，直接由 top 和 left 等属性确定自身的位置，position 属性控制 浮动元素元素 —— 在正常流的位置向左或向右移动到边界，并占据一块排版空间，float 元素控制 ■ 正常流 —— 文字和盒混排 ① 文字 浏览器支持文字书写的方向为主轴，跟主轴垂直的叫做交叉轴。 advance 代表每一个文字排布后在主轴上的前进距离，文字之间的间距，文字中的重要属性。 多数元素被当做长方形盒来排版的，而 dispaly 为 inline 的元素，是被拆分成文本来排版的。 ■ 正常流中的盒 ■ 绝对定位元素 ■ 浮动元素排版 二、思考：打造自己的排版方式 课后练习。 第五阶段：在内存中进行渲染、合成、绘制一、渲染 渲染（render）:特指把模型变成位图的过程。 ■ 位图 内存中的一张二维表格，把一张图片每个像素的颜色值保存进去（位图是 DOM 树中占据浏览器内存中最多的信息，做内存优化应优先考虑）。 ■ 渲染过程 把每个元素对应的盒变成位图，元素包括 HTML元素 和伪元素，每一个盒对应一张位图。 图形 盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类，需要一个底层库来支持。 文字 盒中的文字也需要底层库来支持，叫做字体库，最常用的字体库（Freetype）。 二、 合成 渲染过程不会把子元素渲染到位图上面，合成的过程，就是为元素创建一个 “合成后的位图”，也称为合成层。 三、 绘制 绘制就是把位图按照 z-index 绘制到屏幕上，变成页面上的图像的过程。 过程 ① 重绘的频率过快，性能会下降，应该部分区域 重绘。 ② 脏矩形算法：就是把屏幕均匀的分为若干个矩形区域。 ③ 重绘部分的矩形区域就可以。 四、思考：js 实现一个浏览器]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之CSS结构5【css语法】]]></title>
    <url>%2F2019%2F02%2F07%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BCSS%E7%BB%93%E6%9E%845%E3%80%90css%E8%AF%AD%E6%B3%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[CSS 语法规则，你需要知道的 CSS 知识！ 目录 at 规则 13 个例子 普通规则 选择器 声明区块 属性 值（函数） 选择器语法结构 CSS语法 1、任何的 CSS 的特性都必须通过一定的语法结构表达出来的，所以必须通过语法才会发现大多数 CSS 特性。 2、CSS 的顶层样式表是由两种规则组成的规则列表构成，一种是 at 规则，另一种是普通规则（qualified rule）。其中普通规则是开发中最常用到的。 一、at 规则 @ charset : https://www.w3.org/TR/css-syntax-3/ charset 用于提示 CSS 文件使用的字符编码方式。 1@charset "utf-8"; @ import : https://www.w3.org/TR/css-cascade-4/ @ import 用于引入css文件，引入另一个 javascript 文件的全部内容。 12@import "mystyle.css";@import url("mystyle.css"); @ media : https://www.w3.org/TR/css3-conditional/ 它能够对设备的类型进行一些判断。 123@media print &#123; body &#123; font-size: 10pt &#125;&#125; @ page : https://www.w3.org/TR/css-page-3/ page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。 1234567891011@page &#123; size: 8.5in 11in; margin: 10%; @top-left &#123; content: "Hamlet"; &#125; @top-right &#123; content: "Page " counter(page); &#125;&#125; @ counter-style : https://www.w3.org/TR/css-counter-styles-3/ counter-style 产生一种数据，用于定义列表项的表现。 12345@counter-style triangle &#123; system: cyclic; symbols: ‣; suffix: " ";&#125; @ key-frames : https://www.w3.org/TR/css-animations-1/ keyframes 产生一种数据，用于定义动画关键帧。 12345678910111213@keyframes diagonal-slide &#123; from &#123; left: 0; top: 0; &#125; to &#123; left: 100px; top: 100px; &#125;&#125; @ fontface : https://www.w3.org/TR/css-fonts-3/ fontface 用于定义一种字体，icon font 技术就是利用这个特性来实现的。 123456@font-face &#123; font-family: Gentium; src: url(http://example.com/fonts/Gentium.woff);&#125;p &#123; font-family: Gentium, serif; &#125; @ supports : https://www.w3.org/TR/css3-conditional/ support 检查环境的特性，它与 media 比较类似。 @ namespace : https://www.w3.org/TR/css-namespaces-3/ 用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。 二、普通规则 普通规则：选择器 + 声明区块（属性 + 值 ） 1、选择器：语法角度语法结构： 普通规则 选择器 声明区块 属性 值 值的类型 函数 语法结构： complex-selector（单个元素选择器） combinator （连接符） 空格 > + ~ || compound-selector （可复合选择器） type-selector （标签选择器） subclass-selector id (#) （ID 选择器） class （类选择器） attribute （属性选择器） pseudo-class （伪类选择器） pseudo-element （伪元素选择器） 2、声明：属性和值 属性是由中划线、下划线、字母等组成的标识符，CSS 还支持使.用反斜杠转义。属性不允许使用连续的两个中划线开头，这样的属性会被认为是 CSS 变量。 12345678:root &#123; --main-color: #06c; --accent-color: #006;&#125;/* The rest of the CSS file */#foo h1 &#123; color: var(--main-color);&#125; CSS 属性值类型： CSS 范围的关键字：initial，unset，inherit。 字符串：比如 content 属性。 URL：使用 url() 函数的 URL 值。 整数 / 实数：比如 flex 属性。 维度：单位的整数 / 实数，比如 width 属性。 百分比：大部分维度都支持。 颜色：比如 background-color 属性。 图片：比如 background-image 属性。 2D 位置：比如 background-position 属性。 函数：来自函数的值，比如 transform 属性。 CSS 支持的计算型函数： calc () calc()函数是基本的表达式计算，它支持加减乘除四则运算。 12345section &#123; float: left; margin: 1em; border: solid 1px; width: calc(100%/3 - 2*1em - 2*1px);&#125; max () min () clamp () max()、min() 和 clamp()则是一些比较大小的函数。clamp() 则是给一个值限定一个范围，超出范围外则使用范围的最大或者最小值。 toggle () toggle() 函数在规则选中多于一个元素时生效,它会在几个值之间来回切换。 1ul &#123; list-style-type: toggle(circle, square); &#125; attr () 函数允许 CSS 接受属性值的控制。]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之JavaScript对象【对象分类】]]></title>
    <url>%2F2019%2F02%2F07%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8Bjavascript%E5%AF%B9%E8%B1%A14%E3%80%90%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB%E3%80%91%2F</url>
    <content type="text"><![CDATA[JavaScript对象：你知道全部的对象分类吗？]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 高级程序设计第五章【引用类型】]]></title>
    <url>%2F2019%2F02%2F02%2FJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%90%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[Object 类型、Array 类型、Date 类型、RegExp 类型、Function 类型、基本包装类型、单体内置对象。 第五章 引用类型5.15.2 Array 类型 js 中的数组与其他语言的数组不同。1、一项数组可以保存不同类型的数据。2、数组的大小是可以动态调整的。 1、创建数组的两种方式123456//Array 构造法var array = new Array();var array = new Array("1","2","3");var array = new Array(20);//数组字面量表示法var array = [1,2,3];//不会调用构造方法 2、length 的应用应用一： 移除末尾的项。 123var colors = ["1","2","3"];colors.length = 2;alert(colors[3]);//undefined 应用二： 设置为大于数组项数的值，新增每一项取得 undefined 值。 应用三： 在末尾添加新值。 12var colors = ["1","2","3"];colors[colors.length] = "4"; 5.2.1 检测数组 确定某个对象是不是数组。 1234//确定某个值是不是数组if(Array.isArray(value))&#123; &#125; 5.2.2 转换方法 数组转换字符串。如果数组中有 undefined 或者 null 都会返回空字符串。 1、toString() 数组转换为以逗号隔开的字符串。 2、valueOf() 数组转换为以逗号隔开的字符串。 3、toLocaleString() 与上边两者不同的是，调用数组每一项的 toLocaleString() 方法，而不是 toString 方法。 4、join(“符号”) 以自定义符号进行分隔开。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 高级程序设计第六章【面向对象】]]></title>
    <url>%2F2019%2F02%2F02%2FJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[面向对象的程序设计。 第六章、面向对象的程序设计6.1 理解对象1234567891011121314//方式一var o = new Object();o.name = "zhangsan";o.sayName = function()&#123; alert(this.name);&#125;//方式二var o = &#123; name: "zhangsan", syName: function()&#123; alert(this.name);&#125; 6.1.1 属性类型 描述了属性的各个特征。ECMAScript 有两种属性：数据属性和访问器属性。 1、数据属性■ [[Configurable]] : 表示能否通过 delete 删除属性（删除权限），从而重新定义属性，默认值为 true。 ■ [[Enumerable]] : 表示能否通过 for - in 循环返回属性。默认值为 true。 ■ [[Writable]] : 表示能否修改属性的值（读写权限）。默认值为 true。 ■ [[Value]] : 包含这个属性的数据值。默认值为 undefined。 12345var person = &#123;&#125;;object.definePropert(person,"name",&#123; Enumerable: false, Value: "zhangsan"&#125;) 补充：对于一个属性多次使用 definePropert 修改属性导致错误，Writable 属性除外。 2、访问器属性■ [[Configurable]] : 表示能否通过 delete 删除属性（删除权限），从而重新定义属性，默认值为 true。 ■ [[Enumerable]] : 表示能否通过 for - in 循环返回属性。默认值为 true。 ■ [[Get]]: 在读取属性的时候调用函数，默认值为 undefined。 ■ [[Set]]: 在写入属性的时候调用函数，默认值为 undefined。 12345678910111213141516171819var book = &#123; _year:2004, edition: 1&#125;;Object.defineProperty(book,"year",&#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue&gt;2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); //2 设置一个属性值导致其他属性值发生改变，访问器最常使用方式。 6.1.2 定义多个属性 通过 Object.defineProperties 定义多个属性。 1234567891011121314151617181920212223var book = &#123; &#125;;Object.defineProperties(book,&#123; _year:&#123; writable:true, value: 2004 &#125;, edition:&#123; writable:true, value: 1 &#125;, get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue&gt;2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;) 6.1.3 读取属性的特性 通过 Object.getOwnPropertyDescriptor（）方法取得对象属性的描述值。 123var descriptor = Object.getOwnPropertyDescriptor(book,"year");alert(descriptor.value);//2004alert(descriptot.configurable);//false 6.2 创建对象 通过 Object 构造器或者自变量都可以创建一个对象，但是存在一个缺点，同一接口（属性）创建很多对象，会产生大量的重复代码。 6.2.1 工厂模式 用函数来封装特定的接口创建对象的细节。 1234567891011fuction createPerson(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person = createPerson("Nicholas",29,"SoftWare Engineer") ■ 优点： 大大减少了代码量。 ■ 缺点： 没有解决对象识别（即对象的类型）。 6.2.2 构造器模式 构造器可以创建特定类型的对象。 12345678910fuction Person(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.sayName = function()&#123; alert(this.name); &#125;;&#125;var person = new Person("Nicholas",29,"SoftWare Engineer"); ■ 与工厂模式不同点 没有显示的创建对象。 直接将属性和方法赋值给了 this 对象。 没有 return 语句。 ■ new 创建对象的四个阶段 创建新对象 将构造函数的作用域赋值给新对象（this指向这个新对象）。 执行构造函数中的代码（为这个新对象添加属性）。 返回新对象。 Person 的有一个 construction (构造函数) 属性，该属性指向 Person。 1、将构造函数当做函数 通过 new 来操作都可以成为构造函数，不使用 new 来操作，和普通的函数没有什么区别。 1234567891011//当构造函数来使用(new 构造函数创建对象)var person = new Person("Nicholas",29,"SoftWare Engineer");//作为普通函数来调用(在全局作用域内创建，将属性添加到了全局对象)Person("Grey",27,"Doctor"); //添加到了浏览器 window 对象window.sayName();// Greg//在另一个作用域中调用（通过 apply/call 在特殊对象的作用域调用函数）var o = new Object();Person.call(o,"Kristen",25,"Nurse");o.sayName();//Kristen 2、构造函数问题 每个方法需要每个实例上重新创建一遍，那两个方法不是同一个 Function 的实例。会导致不同作用域链和标识符的解析。 注意：ECMAScript 中的都是对象。 123456789101112//创建两个相同任务的 Function 实例确实没有必要。fuction Person(name,age,job)&#123;个个 var o = new Object(); o.name = name; o.age = age;&#125;function()&#123; alert(this.name);&#125;;var person = new Person("Nicholas",29,"SoftWare Engineer"); ■ 缺点： 1、全局作用域中定义的函数实际上只能被某个对象调用，让全局变量名副其实。 2、定义多个方法，定义多个全局变量函数，自定义引用类型丝毫没有封装可言。 6.2.3 原型模式 解决多个对象共享同一属性。 1、理解原型对象 每个函数都有一个 prototype 属性，这个属性是一个指针，指向函数的原型对象，原型对象有个 construct 属性，指向函数对象。 【图】 isPrototypeof () ： 判断对象是否存在与(函数.prototype)原型对象存在某种关系。 123alter(Person.prototype.isPrototypeof（person1）);//true//ES5 新增加属性Object.getPrototypeof(person1)；//获取原型对象 hasOwnProtype () ：判断属性来自原型还是实例。 1alert(person1.hasOwnProtype(&quot;name&quot;))// false :原型 true:实例 属性搜索过程 访问对象属性 —&gt; 对象实例 —&gt; 原型对象。 ① 为实例添加与原型相同属性 会覆盖掉原型对象属性。 ② delete 删除属性 会删除实例的属性，而不是原型的属性。 2、原型与 in 操作符 两种使用方式：单独使用、for-in循环中使用。 ① 单独使用 in 操作符只要是对象能够访问到的都返回 true。hasOwnProtype 只存在实例中才返回 true。 1alert("name" in person1) ② object.keys(对象)方法 数组返回所有对象的属性。 1var keys = Object.keys(Person.prototype); ③ Object.getOwnPropertNames (对象名) 获取对象的所有属性。 1var keys = Object.getOwnPropertNames (Person.prototype); 3、更简单的原型语法 字面量重写原型对象。 1234567Person.prototype = &#123; name: "zhangsan", age: 29, sayName: function()&#123; alert(this.name); &#125;&#125; 注意： construct 属性不在指向 Person 了，因为字面量创建的 prototype 对象被重写，constructor 指向 Object 构造函数。每一个函数的创建都会自动创建 construct 属性并指向本对象。 4、原型的动态性 如果重写了整个原型对象，就切断了构造函数与原来远行对象的联系，导致 error 。 【图】 5、原生对象的原型 基本封装类型 Array 、String 等这种原生的引用类型都有原型对象，并且封装了方法，比如 String.prototype 中的 toString 方法。 6、原型模式的缺点 原型模式最大的问题就是有其共享的本性所导致的。在原型中添加数组为例。 原型属性值被修改，所有的实例共享原型属性都会被修改。 6.2.4 组合使用构造模式和原型模式（创建自定义类型最常用的方法）■ 优点 1、既能有一份实例属性的副本，同时又共享着对方的引用，最大节省了内存。 2、支持向构造函数传参。 123456789101112131415function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friend = ['zhang','li'];&#125;Person.prototype = &#123; constructor : Person, sayName :function()&#123; alert(this.name) &#125;&#125;//改变 person1 的 friend属性值 不会改变 person2 的属性值。 ■ 缺点 缺少封装性。 6.2.5 动态原型模式 将独立的构造函数和原型封装到构造函数中，为了在构造函数中初始化原型（必要情况下）。 12345678910111213//只有在 sayName 方法不存在的情况下，才在原型中初始化 sayName 方法。function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; //不支持字面量初始化原型 if(typeof this.sayName != "function")&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125; 6.2.6 寄生构造函数模式（类似工厂模式） 返回的对象和构造函数或者原型之间没有关系。 6.2.7 稳妥构造函数模式（安全性） 稳妥对象：没有公共属性，其方法不引用 this 的对象。不使用 new 来创建对象。 6.3 继承的 ECMAScript 只支持实现继承，是通过原型链实现的。 6.3.1 原型链 作用链的本质：就是指向一个指向变量对象（存放函数中的局部变量）的指针列表。 联系构造函数、原型以及实例的关系，如果把一个原型对象当做另一个原型对象的实例，这个原型对象有一个指向另一个原型的指针，另一个原型对象又是其他原型对象的实例，就构成了原型与实例的链条，也就是原型链。 ■ 代码实现 1234// SuperType 和 SubType 分别是两个构造函数// SubType 继承了 SuperType // SubType 没有用自己的原型对象，而是用了SuperType的新原型 SubType.prototype = new SuperType(); // SubType 的全部属性和方法来自于 SuperType ■ 图示 注意： 1) [[prototype]] 是实例所拥有的属性， 在原型链中，每个继承者都有该属性，因为是其他原型对象的实例。 2) 继承者的实例对象 constructor 属性指向的是父类的原型对象的构造函数。 ■ 原型搜索机制 搜索过程按照原型链向上搜索。 1）搜索实例 2）搜索 SubType.prototype 3）搜索 SuperType.prototype 4) 搜索 Object.prototype 1、默认的 Object 原型 所有的引用类型都继承于 Object ，所有的原型都包含一个内部指针，指向于 Object.protopyte 。这正是所有的引用类型都有 toString() 方法和 valueOf() 等默认方法存在的原因。 图示 2、判断原型和实例的关系 方式一：instanceof 1alert(实例 instanceof Object);//true 方式二：isPrototypeof() 1alert(Object.prototype.isPrototypeof(实例));//true 3、谨慎地定义子类方法 子类有时候覆盖超类中的某个方法或者添加超类中不存在的方法，一定放在替换原型语句之后。 代码实例 123456789101112SubType.prototype = new SuperType();//给 Subtype 添加新方法Subtype.prototype.getSubValue = function()&#123; return this.name;&#125;//重写 Supertype 方法Supertype.prototype.getSupertypeValue = function()&#123; return this.name; &#125; 注意： 1、Subtype 的实例调用重写的方法会调用重写方法； 2、Supertype 的实例调用重写方法会调用原来没有重写的方法； 3、Subtype 的实例调用新添加的方法； 字面量创建原型方法 不能用字面量创建原型方法，它会导致重写原型链。 4、原型链的问题 ① 原型链中所有属性共享。（修改某一对象的属性，会在另一对象反应出来） ② 子类不能向超类传递参数。 注意：原型链一般不单独使用！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【B+树】]]></title>
    <url>%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90B%2B%E6%A0%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[Mysql 数据库的索引是如何实现的？]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【链表】]]></title>
    <url>%2F2019%2F01%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[LRU 缓存淘汰算法是用链表怎么实现的？ [TOC] 链表一、什么链表？ 链表是由零散的内存块串联起来不连续的内存空间组成。 二、链表有什么特点？1、优点 1）插入、删除数据操作快。 2）支持动态扩容后。 2、缺点 1）随机访问效率低下。 2）需要额外的存储指针的内存空间。 三、三种常见的链表结构1、单链表▉ 定义 链表通过指针将一组零散的内存块串联在一起。内存块称为链表的结点，每个节点都有存储下一结点的地址。 ▉ 掌握算法 实现单链表的查询、插入、删除（点击查看代码实现）。 实现单链表从尾到头打印 (点击查看代码实现)。 实现链表中查找倒数第 K 个结点 (点击查看代码实现)。 实现反转链表 (点击查看代码实现)。 求链表的中间结点 (点击查看代码实现)。 合并两个有序链表 (点击查看代码实现)。 2、循环链表▉ 定义 循环链表的尾结点指针是指向链表的头结点。 要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。 ▉ 掌握算法 循环链表的插入、删除、查找操作 (点击查看代码实现)。 ▉ 实际用途 约瑟夫问题。 3、双向链表▉ 定义 双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。 ▉ 掌握算法 双向链表的插入、删除、查找 (点击查看代码实现)。 ▉ 实际用途 java 语言中 LinkedHashMap 的底部实现原理就是用双向链表实现的。 四、数组和链表的性能比较1、运行效率 数组： 1）数组简单易用，在内存的空间是连续的，可以有效的借助 CPU 的缓存机制预读数组中的数据，从而大大的增加了访问效率；而链表的内存空间不是连续的，对 CPU 缓存不友好，没有办法进行预读处理。 2）CPU 缓存实现了比内存访问速度更快的机制，也就是 CPU 缓存存在的意义:为了弥补内存访问速度过慢与 CPU 执行速度快之间的差异而引入。 3）对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到 CPU 缓存这样执行速度会快于存储空间不连续的链表存储。 链表： 1）链表在内存空间存储是不连续的，所有对 CPU 缓存不友好。 2、内存消耗 数组： 1）数组缺点就是大小固定，一旦生命就需要占内存中连续的空间，如果声明数组过大，系统可能没有足够连续的内存空间进行分配。如果声明数组过小，就会出现不够用的情况，然后我们需要再申请一个比较大的数组，将之前数组的数据拷贝进去，费时费力。 2）在 JAVA 中我们使用到的 ArrayList 容器也支持动态扩容，和数组一样，当容器中没有空间的时候，就会扩展到空间的1.5倍，之前的数据就会拷贝到新建空间容器上去，这个过程很耗时。 链表： 1）链表就不同了，支持动态扩容。 2）如果对内存的要求很苛刻，建议使用数组。因为链表中的每个结点都需要消耗额外的内存空间去存储指向下一个结点的指针，所以内存消耗会翻倍。 3）再加上对链表频繁的插入和删除，导致频繁的申请释放内存空间，容易遭成内存碎片，在 java 中就会导致频繁的 GC（垃圾回收）。 补充：什么是 CPU 缓存机制？ 1）CPU 在读取内存数据的时候，会先将读取到的数据加载到 CPU 缓存中，每次 CPU 在内存中读取数据时并不是访问特定地址的数据，而是在内存中读取一个数据块，并保存在 CPU 缓存中。 2）当 CPU 再次访问此数据时，先在 CPU 缓存查找，如果查找到了就不用去内存中查找了，实现了比内存访问快的 CPU 缓存机制，也就是 CPU 缓存存在的意义：为了弥补内存访问速度慢的与 CPU 访问速度快之间差异而引用的。 五、实例：基于链表如何实现 LRU 缓存淘汰算法？1、问题分析 1）假设有一个有序的单链表，在内存中，链表是有序链表，按照访问时间排序，访问时间值最晚的放到链表尾部，最早的放到链表头。当要淘汰一个数据时，直接删除链表尾部的结点，当要加入一个数据时，直接插入链表头部。 2）当一个新数据来插入到内存链表中，就从头开始遍历整个链表，然后该数据是否已在缓存中。 2、算法思路 情况一：数据已在缓存中 1）对缓存中的数据进行删除，然后将新数据插入到链表的头部。 情况二：数据不在缓存中 缓存未满 1）直接将新数据插入到链表的头部 缓存已满 2）先删除链表尾部的数据，然后将数据插入到链表的头部。 3、性能分析 答：时间复杂度为 O(n) 。 无论缓存有没有满，都要遍历一遍整个链表，所以缓存的访问时间复杂度为O(n)。 4、性能优化 答：使用散列表进行优化。 插入数据的时候，存到散了表中，再次查询数据的时候，直接从散列表中查询，查询的时间复杂度为 O（1）。 六、思考题1、用数组怎么实现 LRU 缓存淘汰算法？2、用单链表存储的字符串如何判断回文字符串？解题思路是什么？时间空间杂度多少？ 答： 1）循环这个回文链表 L1，在遍历到一半之前把逆文存在一个L2中； 例如L1 为 A-&gt;B-&gt;C-&gt;B-&gt;A，那么遍历到一半时，L2 为：B-&gt;A； 偶数和奇数的区别在与中间的节点要不要放在 L2 中。 2） 继续遍历比较 L1, L2 两个链表各个元素是否相等，如果不相等则立即返回；如果比较到最后遍历结束，则说明是回文；因此通过一次遍历就知道这个链表是否为回文。时间复杂度为 O(n)。 七、设计思想 当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。 空间换时间 时间换空间 1、概念 1）空间(去)换时间 当执行效率比较低时，适当加大内存消耗来提高执行效率，也就是时间换空间的设计思想。举例：缓存技术。 2）时间(去)换空间 当内存空间使用比较紧张时，适当的降低执行效率（延长执行时间）来缓解内存紧张的问题，也就是空间换时间的设计思想。 九、写出链表代码的五个技巧1、理解指针和引用的含义2、警惕指针丢失和内存泄漏3、利用哨兵简化实现难度▉ 链表代码不足 针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样实现的代码不简洁，很繁琐，考虑不全面会出错。 ▉ 添加哨兵改进 添加一个带头的链表，该头结点不存储任何数据。 使用哨兵简化编程的例子： 插入排序 归并排序 动态规划 ▉ 举例代码一：普通解决123456789101112131415161718// 在数组 a 中，查找 key，返回 key 所在的位置// 其中，n 表示数组 a 的长度int find(char* a, int n, char key) &#123; // 边界条件处理，如果 a 为空，或者 n&lt;=0，说明数组中没有数据，就不用 while 循环比较了 if(a == null || n &lt;= 0) &#123; return -1; &#125; int i = 0; // 这里有两个比较操作：i&lt;n 和 a[i]==key. while (i &lt; n) &#123; if (a[i] == key) &#123; return i; &#125; ++i; &#125; return -1;&#125; 代码二：哨兵思想12345678910111213141516171819202122232425262728293031323334353637// 在数组 a 中，查找 key，返回 key 所在的位置// 其中，n 表示数组 a 的长度// a = &#123;4, 2, 3, 5, 9, 6&#125; n=6 key = 7// a = &#123;4, 2, 3, 5, 9, 6&#125; n=6 key = 6int find(char* a, int n, char key) &#123; if(a == null || n &lt;= 0) &#123; return -1; &#125; // 这里因为要将 a[n-1] 的值替换成 key，所以要特殊处理这个值 if (a[n-1] == key) &#123; return n-1; &#125; // 把 a[n-1] 的值临时保存在变量 tmp 中，以便之后恢复。tmp=6。 // 之所以这样做的目的是：希望 find() 代码不要改变 a 数组中的内容 char tmp = a[n-1]; // 把 key 的值放到 a[n-1] 中，此时 a = &#123;4, 2, 3, 5, 9, 7&#125; a[n-1] = key; int i = 0; // while 循环比起代码一，少了 i&lt;n 这个比较操作 while (a[i] != key) &#123; ++i; &#125; // 恢复 a[n-1] 原来的值, 此时 a= &#123;4, 2, 3, 5, 9, 6&#125; a[n-1] = tmp; if (i == n-1) &#123; // 如果 i == n-1 说明，在 0...n-2 之间都没有 key，所以返回 -1 return -1; &#125; else &#123; // 否则，返回 i，就是等于 key 值的元素的下标 return i; &#125;&#125; 4、重点留意边界条件处理 如果链表为空，是否可以正常工作？ 如果链表只包含一个结点时，代码是否能够正常工作？ 如果链表只包含两个结点时，代码是否能够正常的工作？ 代码逻辑在处理头结点和尾结点的时候，是否可以正常的工作？ 5、举例画图，辅助思考6、多写多练，没有捷径十、链表掌握程度 要想掌握链表这一节的内容，还需要下功夫做练习。链表设计到很多指针的操作，也是面试的常考点，所以，文中有总结的练习题及其解题思路很详细，进入练习之前，我们先热热身，做个小练习题。用你所熟悉的语言，实现以下链表的几个功能： 1、基础练习 创建一个单链表 实现链表结点的增加 实现链表结点的删除 实现链表结点的查询 按索引值查询 按值查询 2、链表进阶 实现单链表从尾到头打印 (点击查看代码实现)。 实现链表中查找倒数第 K 个结点 (点击查看代码实现)。 实现反转链表 (点击查看代码实现)。 求链表的中间结点 (点击查看代码实现)。 合并两个有序链表 (点击查看代码实现)。 循环链表的插入、删除、查找操作 (点击查看代码实现)。 双向链表的插入、删除、查找 (点击查看代码实现)。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 高级程序设计第四章【内存问题】]]></title>
    <url>%2F2019%2F01%2F28%2FJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%90%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[变量、作用域和内存问题 第四章 变量、作用域和内存问题4.1 基本类型和引用类型的值基本类型的值 七种基本类型：Undefined、null、Number、String、Boolean、Symbol、Object。访问基本类型是按照值访问的。 引用类型的值 由多个值构成的对象。访问引用类型是按照引用（地址）访问的。 4.1.1 动态的属性基本类型： 不可以动态的添加属性，添加属性之后为 undefined 。 引用类型： 可以动态的进行添加属性，以便将来使用。 4.1.2 复制变量值12var num1 = 5;var num2 = num1; 基本类型： num1 会在 num2 变量上创建一个新值，将值复制给 num2 ，num1 和 num2 的值是相互独立的。 【此处加图】 1234var obj1 = new Object();var obj2 = obj1;obj1.name = “zhang”；alert(obj2.name); //zhang 引用类型： 复制后的对象(obj2)和原对象(obj1)指向堆内存中的同一个对象，一个变化，另一个对象的属性随之变化。 【此处加图】 4.1.3 传递参数① 什么是值传递？什么是引用传递？ 值传递：当我们往函数的形参传递实参的时候，修改形参的值并不会影响实参的值。 引用传递：函数的形参接受实参是隐示引用，改变形参的值就会改变实参的值。 ② js 传递参数 ECMAScript 中「所有」的函数参数都是按「值传递」的。也就是说，从外部的值复制给函数内部的参数就像一个变量的值复制给另一个变量的值一样。 4.1.4 检测类型基本类型 typeof : 一般用 typeof 检测undefined、String、Number、Boolean类型的数据。如果检测一个对象或者Null，都会返回一个 Object，从而无法判断是什么类型。 对象 instanceof： 用 instance 检测对象都会返回 true。 4.2 执行环境及作用域 执行环境：执行环境定义了变量或函数有权访问的其他数据，决定了各自的行为权限。 变量对象：每个执行环境都有一个变量对象，该执行环境中所有的变量和函数都存储到该变量对象中。 作用域链：保证对执行函数有权访问的所有变量和函数的有序访问。 ■ 浏览器和函数的执行环境 1、在 web 浏览器中，全局的执行环境被公认为 window 对象。 2、web 浏览器有自己的执行环境，函数也有当一个函数将被执行的时候，该函数的环境将被推进环境栈中，等函数执行完成，该函数的环境出栈，将执行权交给之前的函数。 ■ 作用域链 全局 —&gt; 局部，环境内部可以访问到环境外部作用域。 示例代码： 123456789var color = &apos;red&apos;;function changColor()&#123; var color1 = &apos;blue&apos;; function swapColor()&#123; var color2 = &apos;green&apos;; &#125;&#125; 作用域链图示：【图】 4.2.1 延长作用域链 (?) 当执行进入到一下两种语句时，作用链将会加长。 try - catch 语句和 catch 块 with 语句 4.2.2 没有块级作用域 在 if 语句或 for语句的 { } 语句块中，js 声明的变量将会添加到当前执行函数中去。与 java 等其他语言不同，在 { } 执行完会销毁。 例子： 1234for(var i = 1;i&lt;=10;i++)&#123; doSomething(i);&#125;alert(i); //10 1、声明变量用 var 声明的变量会被自动添加到最近的执行函数中去，而没有被 var 声明的变量，将会添加到全局变量环境中去。 注意：我们建议初始化变量之前一定要声明。 2、查询标识符 当我们读取一个标识符的时候，首先在作用域链的最前端进行搜索，如果有函数，就在函数局部搜索查看当前是否有该标识符，如果没有就继续沿作用域链向上搜，如果没有发现，则宣告未声明该标识符。当我们在局部查到了，就停止搜索，返回该执行环境变量的值。 4.3 垃圾回收 在浏览器中，javascript 有自己管理的垃圾回收机制。对内存进行自动管理，而无需操作员手动管理。垃圾回收器跟踪哪些变量有用，哪些变量没有用，对没有用的变量进行标记，以备在将来收回内存空间。 4.3.1 标记清除 标记所有内存变量标记 ——&gt; 删除标记进行使用 ——&gt; 使用完成添加删除标记 ——&gt; 对标记删除的进行内存清理。垃圾回收机制的运行间隔很重要，关系到性能问题。 4.3.2 内存问题■ 性能问题 因为为了安全起见，防止运行 js 网页耗尽系统的所有内存导致系统崩溃，所以 javascript 给浏览器分配的内存数量远小于桌面应用程序，也影响到了 js 在网页中的执行语句的条数。 ■ 性能优化 解除引用：为了占用最少的空间使网页得到最大的优化，所以我们将不用的变量设置为 null。适合全局变量和局部变量，局部变量通常会在函数执行完成之后自己解除引用。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【动态规划】]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美中的动态规划。 动态规划基础篇一、认识动态规划 问题：“双十一” 购物问题，选择购物车中商品尽最大的能够参与满减活动。 0 - 1 背包问题问题： 背包问题我们进行改进，对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？ 回溯算法可以解决这个问题，但是需要穷举所有的情况，时间复杂度非常高，接下来我们用动态规划来解决此问题。 回溯算法代码实现： 123456789101112131415// 回溯算法实现。注意：我把输入的变量都定义成了成员变量。private int maxW = Integer.MIN_VALUE; // 结果放到 maxW 中private int[] weight = &#123;2，2，4，6，3&#125;; // 物品重量private int n = 5; // 物品个数private int w = 9; // 背包承受的最大重量public void f(int i, int cw) &#123; // 调用 f(0, 0) if (cw == w || i == n) &#123; // cw==w 表示装满了，i==n 表示物品都考察完了 if (cw &gt; maxW) maxW = cw; return; &#125; f(i+1, cw); // 选择不装第 i 个物品 if (cw + weight[i] &lt;= w) &#123; f(i+1,cw + weight[i]); // 选择装第 i 个物品 &#125;&#125; 递归树实现： 递归中存在的问题在这个地方我们可以进行优化，就是重复计算问题。递归树的表现形式（i，w）,i 表示将要决策的第几个物品，w 是背包中已存在物品的总重量。 我们可以对地归树中存在的问题进行改进，通过散列表来存储已经计算过的值，当我们再次计算到该值的时候，我们就直接使用，而不是重复计算，降低效率。 1234567891011121314151617private int maxW = Integer.MIN_VALUE; // 结果放到 maxW 中private int[] weight = &#123;2，2，4，6，3&#125;; // 物品重量private int n = 5; // 物品个数private int w = 9; // 背包承受的最大重量private boolean[][] mem = new boolean[5][10]; // 备忘录，默认值 falsepublic void f(int i, int cw) &#123; // 调用 f(0, 0) if (cw == w || i == n) &#123; // cw==w 表示装满了，i==n 表示物品都考察完了 if (cw &gt; maxW) maxW = cw; return; &#125; if (mem[i][cw]) return; // 重复状态 mem[i][cw] = true; // 记录 (i, cw) 这个状态 f(i+1, cw); // 选择不装第 i 个物品 if (cw + weight[i] &lt;= w) &#123; f(i+1,cw + weight[i]); // 选择装第 i 个物品 &#125;&#125; 动态规划解决： 1、首先，我们将整个过程分解成 n 个阶段，每个阶段决策是否放入背包，每个决策完成之后会有多种情况，也就是对应递归树中不同的结点（不同状态）。 2、我们将每个阶段相同的情况进行合并，只记录一次，可以避免每个阶段情况数量的指数增长。 3、用二维数组来记录每个阶段不同的状态。 4、第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states[0][2]=true 来表示这两种状态。 5、以此类推，我们将做成二维数组图。 6、代码实现： 123456789101112131415161718weight: 物品重量，n: 物品个数，w: 背包可承载重量public int knapsack(int[] weight, int n, int w) &#123; boolean[][] states = new boolean[n][w+1]; // 默认值 false states[0][0] = true; // 第一行的数据要特殊处理，可以利用哨兵优化 states[0][weight[0]] = true; for (int i = 1; i &lt; n; ++i) &#123; // 动态规划状态转移 for (int j = 0; j &lt;= w; ++j) &#123;// 不把第 i 个物品放入背包 if (states[i-1][j] == true) states[i][j] = states[i-1][j]; &#125; for (int j = 0; j &lt;= w-weight[i]; ++j) &#123;// 把第 i 个物品放入背包 if (states[i-1][j]==true) states[i][j+weight[i]] = true; &#125; &#125; for (int i = w; i &gt;= 0; --i) &#123; // 输出结果 if (states[n-1][i] == true) return i; &#125; return 0;&#125; 动态规划的时间复杂度 回溯算法的时间复杂度为 O(2^n)，可知上述代码，动态时间复杂度为 O(n*w)。 n 表示物品个数，w 表示背包可以承载的总重量。 动态规划的空间复杂度 尽管执行效率很高，导师我们需要一个空间为 n*w+1 的二维数组，这是一种空间换时间的解决思路。 动态规划空间消耗改进 1234567891011121314public static int knapsack2(int[] items, int n, int w) &#123; boolean[] states = new boolean[w+1]; // 默认值 false states[0] = true; // 第一行的数据要特殊处理，可以利用哨兵优化 states[items[0]] = true; for (int i = 1; i &lt; n; ++i) &#123; // 动态规划 for (int j = w-items[i]; j &gt;= 0; --j) &#123;// 把第 i 个物品放入背包 if (states[j]==true) states[j+items[i]] = true; &#125; &#125; for (int i = w; i &gt;= 0; --i) &#123; // 输出结果 if (states[i] == true) return i; &#125; return 0;&#125; 补充：j 是按照从大到小来计算的，如果从小到大计算存在重复，我们可以进行改进。 0—1背包升级问题 增加的条件是，在满足以上条件的同时，要使的装入的物品价值最大，应该怎么做？ 实现思路 我们继续画递归树，然后用（i,w+1）来表示，w+1 不能用 boolean 类型了，而是代表最大价值。 代码实现 1234567891011121314151617181920212223242526272829public static int knapsack3(int[] weight, int[] value, int n, int w) &#123; int[][] states = new int[n][w+1]; for (int i = 0; i &lt; n; ++i) &#123; // 初始化 states for (int j = 0; j &lt; w+1; ++j) &#123; states[i][j] = -1; &#125; &#125; states[0][0] = 0; states[0][weight[0]] = value[0]; for (int i = 1; i &lt; n; ++i) &#123; // 动态规划，状态转移 for (int j = 0; j &lt;= w; ++j) &#123; // 不选择第 i 个物品 if (states[i-1][j] &gt;= 0) states[i][j] = states[i-1][j]; &#125; for (int j = 0; j &lt;= w-weight[i]; ++j) &#123; // 选择第 i 个物品 if (states[i-1][j] &gt;= 0) &#123; int v = states[i-1][j] + value[i]; if (v &gt; states[i][j+weight[i]]) &#123; states[i][j+weight[i]] = v; &#125; &#125; &#125; &#125; // 找出最大值 int maxvalue = -1; for (int j = 0; j &lt;= w; ++j) &#123; if (states[n-1][j] &gt; maxvalue) maxvalue = states[n-1][j]; &#125; return maxvalue;&#125; 二、思考：双十一凑单购物问题1、问题 淘宝双十一购物，满 200 减 100 ，为了尽最大条件满足减满，怎么选择购物车里的物品呢？ 2、问题分析 1、如果用回溯算法解决，穷举所有的可能，选择解决200的那套方案，但是效率很低下，时间服阿杜非常高，指数级别。 2、如果我们采用动态规划去解决，但是并不像 0-1 背包问题，满足最大限度，而是接近最大限度的最小值（超过200最小值）。 3、求出接近200的最小值之后，然后倒推出我们可以选择哪些购买的商品。 3、解决思路 1、购物车中有 n 个商品，针对每个商品进行决策是否购买，每次决策都对应不同的状态集合，我们用一个数组来表示。 2、我们设定一份最大上限值，比如 1001，我们要找的是大于等于 200（满减条件）的值中最小的。 4、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243// items 商品价格，n 商品个数, w 表示满减条件，比如 200public static void double11advance(int[] items, int n, int w) &#123; // 设置上限为 3 倍 boolean[][] states = new boolean[n][3*w+1]; // 第一行的数据要特殊处理（也就是第 0 个物品两种选择） states[0][0] = true; states[0][items[0]] = true; // 动态规划 for (int i = 1; i &lt; n; ++i) &#123; // 不购买第 i 个商品（结合二维图表来分析） for (int j = 0; j &lt;= 3*w; ++j) &#123; //对上一层状态集合改变下一层状态集合 if (states[i-1][j] == true) &#123; //进行标记true states[i][j] = states[i-1][j]; &#125; &#125; // 购买第 i 个商品 for (int j = 0; j &lt;= 3*w-items[i]; ++j) &#123; // 商品价格相加 if (states[i-1][j]==true) states[i][j+items[i]] = true; &#125; &#125; int j; for (j = w; j &lt; 3*w+1; ++j) &#123; // 输出结果大于等于 w 的最小值 if (states[n-1][j] == true) break; &#125; // 没有可行解 if (j == -1) return; // 倒推遍历可购买商品（i 表示二维数组中的行，j 表示列） for (int i = n-1; i &gt;= 1; --i) &#123; if(j-items[i] &gt;= 0 &amp;&amp; states[i-1][j-items[i]] == true) &#123; // 购买这个商品的价格 System.out.print(items[i] + " "); //总价格减去已购买商品的价格 j = j - items[i]; &#125; // else 没有购买这个商品，j 不变。 &#125; //如果遍历完成所有的商品价格，不等于大于200的最小值，就输出第一个商品价格 if (j != 0) System.out.print(items[0]);&#125; 所有的商品可购买状态是由上一层决策推导而来的。 1、如果 states[i-1][j] 可达，就说明我们没有买这个商品； 2、如果 states[i-1][j-value[i]] 可达，就说明，我们已购买该商品。 3、如果两者都可达到，我们就随意选择一种，继续迭代其他商品。 动态规划理论篇一、什么样的问题适合用动态规划？ 一个模型三个特征。 1、一个模型 多阶段策略最优解模型： ① 一般是用动态规划来解决最优问题。 ② 需要经历多个决策阶段。每个决策阶段都对应着一组状态。 ③ 寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。 2、三个特征① 最优子结构 问题的最优解包含子问题的最优解。后面阶段的状态可以通过前面阶段的状态推导出来。 ② 无后效性 1、在推导后边的状态时，只关心前边的状态，不关心前边的状态是怎么推到出来的。 2、某一决策状态一旦确认，就不受后边阶段的影响。 ③ 重复子问题 不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。 3、实例剖析■ 问题 有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？ ■ 一个模型分析 1、从 (0, 0) 走到 (n-1, n-1)，总共要走 2 (n-1) 步，也就对应着 2(n-1) 个阶段。每个阶段都对应着向右或者向左走两种决策，每个阶段对应一个状态集合，符合一个模型。 2、我们把状态定义为 min_dist(i,j) ,其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。 ■ 三个特征分析 重复子问题：通过回溯算法画出递归树，所有的情况就会列出，有多种路线，符合重复子问题。 无后效性：(i, j) 只能通过 (i-1, j)，(i, j-1) 这两个状态推导而来，之关心这两种状态，并不关心怎么这两种状态怎么达到的。仅仅允许往右往左移动，不能后退，前边的状态不会受到后边状态的改变，符合无后效性。 最优子结构：以上两种状态其中一种肯定是最优解，所以每个决策的子问题都对应最优解，符合最优子结构。 ■ 代码实现 12345678910111213141516171819public int minDistDP(int[][] matrix, int n) &#123; int[][] states = new int[n][n]; int sum = 0; for (int j = 0; j &lt; n; ++j) &#123; // 初始化 states 的第一行数据 sum += matrix[0][j]; states[0][j] = sum; &#125; sum = 0; for (int i = 0; i &lt; n; ++i) &#123; // 初始化 states 的第一列数据 sum += matrix[i][0]; states[i][0] = sum; &#125; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; states[i][j] = matrix[i][j] + Math.min(states[i][j-1], states[i-1][j]); &#125; &#125; return states[n-1][n-1];&#125; 二、动态规划解题思路 两种思路，状态转移表法和状态转移方程法。 1、状态转移法■ 解决思路 ① 动态规划问题一般可以使用回溯算法和暴力搜索解决，定义状态。 ② 画出每个状态的递归树，看是否有子节点问题。 ③ 直接用回溯加 ”忘备录“ 解决重复子问题；状态转移法； ■ 状态转移 画出状态表，根据决策先后过程，找出递归关系，分阶段填写表，然后将填写表这个过程翻译成代码，这就是动态规划代码了。 2、状态转移方程法 某个问题通过子问题来递归求解，所谓的最优子结构，写递推公式，也就是状态转移方程。两种实现方式：递归加 “忘备录” 、迭代递归。 ■ 状态转移方程 状态转移方程是解决动态规划的关键。 12//状态转移方程min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j)) ■ 代码实现 (?) 12345678910111213141516171819202122232425private int[][] matrix = &#123;&#123;1，3，5，9&#125;, &#123;2，1，3，4&#125;，&#123;5，2，6，7&#125;，&#123;6，8，4，3&#125;&#125;;private int n = 4;private int[][] mem = new int[4][4];// 调用 minDist(n-1, n-1);public int minDist(int i, int j) &#123; if (i == 0 &amp;&amp; j == 0) return matrix[0][0]; if (mem[i][j] &gt; 0) &#123; return mem[i][j]; &#125; int minLeft = Integer.MAX_VALUE; if (j-1 &gt;= 0) &#123; minLeft = minDist(i, j-1); &#125; int minUp = Integer.MAX_VALUE; if (i-1 &gt;= 0) &#123; minUp = minDist(i-1, j); &#125; int currMinDist = matrix[i][j] + Math.min(minLeft, minUp); mem[i][j] = currMinDist; return currMinDist;&#125; 三、四种算法思想 贪心算法、分治算法、回溯算法、动态规划。 1、回溯算法 ① 能用贪心、动态规划解决的问题都能用回溯算法解决。 ② 回溯穷举所有情况，指数级别的时间复杂度，只能解决小规模数据。 2、动态规划 ① 不是所有问题都能用动态规划，需要满足三个特征。 ② 在重复子问题上，动态规划和分治算法 有区分。 3、贪心算法 ① 动态规划里边的一种特殊情况。 ② 三个特征，最优子结构、无后效性、贪心选择性。 ③ 每个局部的最优选择，构成全局的最优选择。 4、分治算法 ① 分割成子问题，不能有重复子问题。 ② 动态规划高效的原因有很多重复子问题。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之JavaScript类型2【基本类型】]]></title>
    <url>%2F2019%2F01%2F27%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BJavaScript%E7%B1%BB%E5%9E%8B3%E3%80%90%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进重学前端中的基本类型！ javascript 基本类型 运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于 7 个类型之一。从变量、参数、返回值到表达式中间结果，任何 JavaScript 代码运行过程中产生的数据，都有运行时类型。 一、七大基本类型 Undefined; null; Boolean; String; Number; Symbol; Object; ■ Undefined、Null① Undefined MDN 官网解释： A primitive value automatically assigned to variables that have just been declared or to formal arguments for which there are no actual arguments。 Undefined 表示未定义，只有一个值为 undefined。 问题：为什么编程规范用 void（0）来代替 undefind ？ 答：因为 undefined 是一个变量，并非是一个关键字，这是 js 语言公认的设计失误之一，所以为了避免被篡改，所以建议用 void(0) 代替它。 ② Null Null 值为一个空对象的指针，用 type 检测类型为 object 类型。Null 为值定义了，但是为空，是 js 中的关键字。 ③ undefined/null 的区别 1、undefined 值是派生自 null 的值，所以 alter(undefined == null) // true。 2、声明的变量没有必要显示的赋值 undefined ,而 null 可以将即将保存的对象的变量赋值为 null。 ■ String 字符串类型：String 最大长度为 2^53 -1 。所谓的字符串长度并不是字符数，而是字符串的 uft16 编码的影响的。 ■ Number① 区分 +0 和 -0 。 加法运算没有区别，但是除法计算注意，除以 -0 会得到 -Infinity 从而导致错误。用 1/x 来检测 Infinity 或 -Infinity。 ② 为什么 0.1+0.2 不等于 0.3。 非整数类型不能用 == 或者 === 来比较。之所以上方不相等原因就是浮点型的预算精度问题，导致不是严格相等，只是相差了微小的值。 ③ 检测浮点型的方法（最小精度） J检查等式左右两边的差的绝对值是否小于最小精度来比较浮点数。 1console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON); //true ■ symbol Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合。 ① 创建 Symbol 变量。 1var mySymbol = Symbol("my symbol"); //使用全局的 symbol 函数来创建 ■ Object① 让对象的方法用在基本类型上。 运算符提供了装箱操作，它会根据基础类型构造一个临时对象。 1cosole.log(&quot;abc&quot;.charAt(0)); //a ② 在原型方法上添加方法和属性。 12345Symbol.prototype.hello = () =&gt; console.log(&quot;hello&quot;);var a = Symbol(&quot;a&quot;);console.log(typeof a); //symbol，a 并非对象a.hello(); //hello，有效 二、类型转换 “==” 运算是 js 设计的失误，“==” 运算试图跨类型比较，规则非常的复杂，很多实际中禁止使用 “==” 运算。我们通常进行显示的转换之后，用 “===” 来进行比较。 ■ StringToNumber 字符串到数字类型的转换。，类型转换支持十进制、二进制、八进制和十六进制。 注意： parseInt 和 parseFloat 转换语法与这里的转换不尽相同。 1、parseInt 不传入第二个参数，只支持 16 进制的转换，会忽略非数字和科学计数法。 2、parseFloat 直接将原字符串作为十进制来解析。 ■ NumberToString 1、在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。2 2、在Number 绝对值较大时，字符串是用科学计数法来表示的。（实际用途不大） ■ 装箱转换 装箱转换就是把基本类型转换成对应的对象类型。 1、Symbol 不能用 new 来调用，我们借助 call 方法强制装箱。 12345var symbolObject = (function()&#123; return this; &#125;).call(Symbol("a"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //true 注意：装箱机制会产生临时对象，在一些性能要求较高的场景下，尽量避免对基本类型做装箱操作。 2、使用 object 进行显示调用装箱操作 12345var symbolObject = Object((Symbol("a"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //true ■ 拆箱操作 将对象类型到基本类型的转换。 对象 string 和 Number 的转换遵循 “先拆箱再转换” 的规则，通过拆箱装换，把对象变成基本基本类型，再从基本类型转换为 Number 或者 String。 1、拆箱操作会尝试着调用 valueof 方法和 toString 方法，如果都不存在，则没有基本类型，就会产生类型错误 TypeError。 12345678910var o = &#123; valueOf : () =&gt; &#123;console.log("valueOf"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log("toString"); return &#123;&#125;&#125;&#125;o * 2//执行顺序// valueOf// toString// TypeError 12345678910var o = &#123; valueOf : () =&gt; &#123;console.log("valueOf"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log("toString"); return &#123;&#125;&#125;&#125;o + ""//执行顺序// toString// valueOf// TypeError]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之HTML语义2【呈现 wiki 网页】]]></title>
    <url>%2F2019%2F01%2F24%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BHTML%E8%AF%AD%E4%B9%892%E3%80%90%E6%90%AD%E5%BB%BAwiki%E7%BD%91%E9%A1%B5%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进重学前端之 HTML 语义2 【呈现 wiki 网页】。关注公众号「一个不甘平凡的码农」回复 “博客秘钥”，即可获取文章密码。 如何用 HTML 语义呈现 WIKI 页面？ 一、网页标签组成■ aside 侧边栏标签 左边「侧边栏」根据上一篇的语义定义，属于 aside 内容，是 导航性质的内容。 ■ article 文章标签 右侧部分是「文章主题内容」，因为主题部分需要明确的独立性，所以用 article 来包裹。 ■ hgroup, h1 , h2 主题标签 文章主题上边的「主标题和副标题」应用 hgroup 标签内分别用 h1 和 h2 语义来呈现。 1234&lt;hgroup&gt;&lt;h1&gt;World Wide Web &lt;/h1&gt;&lt;h2&gt;From Wikipedia, the free encyclopedia&lt;/h2&gt;&lt;/hgroup&gt; ■ abbr 缩写标签 abbr 标签表示缩写。正文中的 “www” 表示 World Wide Web 的缩写，所以我们用 abbr 标签。 1&lt;abbr title="World Wide Web"&gt;WWW&lt;/abbr&gt;. ■ hr 横线标签 hr 标签并不仅仅所有的横线就用 hr 标签，hr 的语义是故事的走向或者话题的转变，此处两个标题并非这种关系，所以使用 css 中的 border 表示。 ■ p 段落标签 下方的文章段落使用的是 p 标签，段落标签。 ■ strong 黑体标签 文中出现很多黑体字，我们用 strong 标签进行标记。 1234&lt;p&gt; A global map of the web index for countries in 2014&lt;strong&gt;The World Wide Web (WWW)&lt;/strong&gt;, also called &lt;strong&gt;the Web&lt;/strong&gt;,...... ■ blockquote ,q ,cite 引述标签 blockquote ：表示段落引述内容。 q : 表示行内的引述内容。 cite : 表示引述的作品名。 这里的是作品名称，所以用 cite 来引述。 1&lt;cite&gt;"What is the difference between the Web and the Internet?"&lt;/cite&gt;. W3C Help and FAQ. W3C. 2009. Archived from the original on 9 July 2015. Retrieved 16 July 2015. ■ time 日期标签 为了让机器阅读更加方便，我们加上 time 标签。 1&lt;cite&gt;"What is the difference between the Web and the Internet?"&lt;/cite&gt;. W3C Help and FAQ. W3C. 2009. Archived from the original on &lt;time datetime="2015-07-09"&gt;9 July 2015&lt;/time&gt;. Retrieved &lt;time datetime="2015-07-06"&gt;16 July 2015&lt;/time&gt;. ■ figure , figcaption 标签 右侧的文字加图片组成 figure 的语法现象。 1234&lt;figure&gt; &lt;img src="https://.....440px-NeXTcube_first_webserver.JPG"/&gt; &lt;figcaption&gt;The NeXT Computer used by Tim Berners-Lee at CERN.&lt;/figcaption&gt;&lt;/figure&gt; ■ dfn 被定义标签 dfn 标签是用来包裹被定义的名词。 1234//Internet是一个由相互连接的计算机网络组成的全球系统。The &lt;dfn&gt;Internet&lt;/dfn&gt; is a global system of interconnected computer networks.// 与此相反，万维网是全球的文件和资源管理的集合。In contrast, the &lt;dfn&gt;World Wide Web&lt;/dfn&gt; is a global collection of documents and ■ nav , ol ,ul 列表导航标签 下方文章的目录我们可以用 nav 来加 ol 有序列表来实现。 1234567891011121314&lt;nav&gt; &lt;h2&gt;Contents&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;&lt;a href="..."&gt;History&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="..."&gt;Function&lt;/a&gt; &lt;ol&gt; &lt;li&gt;&lt;a href="..."&gt;Linking&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="..."&gt;Dynamic updates of web pages&lt;/a&gt;&lt;/li&gt; ... &lt;/ol&gt; &lt;/li&gt; ... &lt;/ol&gt;&lt;/nav&gt; ■ pre, samp, code 代码或预先编译标签 pre ：有时候我们并不需要 html 的自动换行，所以我们使用 pre 标签能表示这部分内容是预先排版过的，不需要浏览器重新排版。 samp : 一段计算机的示例输出，所以我们可以使用 samp 标签。 code :用来显示 HTML 标签代码。 示例： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Example.org – The World Wide Web&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;The World Wide Web, abbreviated as WWW and commonly known ...&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 代码实现： 12345678910&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Example.org – The World Wide Web&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;The World Wide Web, abbreviated as WWW and commonly known ...&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt; 还有一些行内代码，我们也应该用 code 标签。 总结：]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【数组】]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E6%95%B0%E7%BB%84%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美的数组。 目录[TOC] 一、数组的基本知识1、什么是数组？ 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 2、数组有什么特点？▉ 优点 1）快速实现「随机访问」 ◆ 问题一：数组如何实现下标随机访问的 ？ 计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当我们进行下标随机访问某个元素的时候，通过寻址公式来计算该元素的位置。 12// base_address 首地址，data_type_size 每个元素的大小，int 类型为 4 个字节。a[i]_address = base_address + i * data_type_size ▉ 缺点 1）低效的插入和删除操作。 2）不支持动态扩容。 (数组的缺点是大小固定，如果数组的声明过大，内存没有连续的内存空间；如果数组声明过小，内存空间不够用，必须进行数据搬移，耗费时间) ◆ 问题一：数组插入、删除数据为什么会低效 ？ 数组为了「保持内存空间的连续性」，会导致插入、删除这两个操作比较低效。 ◆ 问题二：数组插入数据低效的具体原因？ 1）如果在数组的末尾插入元素，那就不需要移动数据了，最好时间复杂度为 O(1)。 2）如果在数组开头插入元素，那就将所有的数据往后移动一个，最坏时间复杂度为 O(n)。 3）因为在每个地方插入数据的概率是相同的，所以平均时间复杂度为 O(n)。 改进：数组插入新数据，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。 ◆ 问题三：数组删除数据低效的具体原因？ 1）如果删除末尾的数据，最好时间复杂度为 O(1)； 2）如果删除的头部的数据，最坏时间复杂度为 O(n)； 3）平均时间复杂度为 O(n)； 改进：为了避免数据的移动，我们可以先标记要删除的数据，而不是真正的删除。等内存空间不足的时候，我们一次性删除数据，大大较少了数据的搬移（JVM 标记清除垃圾回收机制算法的核心）。 二、数组使用的注意事项1、警惕数组的访问越界 1）在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。 2）根据数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。 3）其他高级语言 java 越界会抛出异常，而 javascript 会返回 undefined ，js 的数组长度是动态的。 123456789int main(int argc, char* argv[])&#123; int i = 0; int arr[3] = &#123;0&#125;; for(; i&lt;=3; i++)&#123; arr[i] = 0; printf("hello world\n"); // 无限循环打印 Hello Word &#125; return 0;&#125; 三、ArrayList 与 数组1、ArrayList 的特点 1）ArrayList 最大的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。 2）支持动态扩容。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。 2、数组适用条件 1）Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。 2）如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。 3）当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList array。 3、数组使用总结 1）一般的业务开发用 ArrayList 就足够了，性能的丢失的一小部分，几乎可以忽略。 2）做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。 四、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * 1) 数组的插入、删除、按照下标随机访问操作； * 2）数组中的数据是int类型的； * * Author:zheng * 注释人：小鹿 */public class Array05 &#123; //声明变量 private int data[]; private int n; private int count; /** * @param capacity:用户传参，数组的大小 * 功能：构造函数（初始化数据） */ public Array05(int capacity) &#123; //定义一个大小为 capacity 的数组 data = new int[capacity]; n = capacity; count = 0; &#125; /** * 功能：下标随机访问 * @param index:用户传参下标 * @return */ public int find(int index) &#123; //索引判断，课程中所讲的边界问题（不在数组的范围内函数返回-1） if (index &lt; 0 || index &gt;= count ) return -1; //否则返回该索引对应的数据 return data[index]; &#125; /** * 功能:小鹿改进数组下标随机访问 * 改进内容:index 与上述函数不同，该 index 一般表示用户访问的位于数组的第几个元素 * 对应的索引数据下标应该 -1 ，比如，访问第1个元素，在数组中对应的数据下标就是 * data[0],1 就是相当于用户输入的index。上述用户输入访问第一个元素直接输入0， * index就是0，个人认为改进的更为符合实际操作罢了，原理还是一样的，改进如下代码。 * @param index * @return */ public int improvmentFind(int index) &#123; //索引判断，课程中所讲的边界问题（不在数组的范围内函数返回-1） if (index-1 &lt; 0 || index-1 &gt;= count ) return -1; //否则返回该索引对应的数据 return data[index-1]; &#125; /** * 功能：根据用户输入索引删除数组中数据。 * 补充：这个索引也是可以改进的，自己可以仿照上边改进一下 * @param index * @return */ public boolean delete(int index) &#123; //首先判断删除的索引值是否在数组索引范围内（边界问题） if (index &lt; 0 || index &gt;= count) return false; //将删除元素的后边元素都向前依次移动 for(int i = index + 1; i &lt; count; ++i) &#123; data[i-1] = data[i]; &#125; //删除一个元素后，数组长度 -1 --count; return true; &#125; /** * 功能：数组插入元素 * @param index:数组下标索引 * @param value:要插入的元素值 * @return */ public boolean insert(int index, int value) &#123; //首先判断删除的索引值是否在数组索引范围内（边界问题） if (index &lt; 0 || index &gt;= count) return false; //还要考虑到一种情况就是，如果你一直删除元素知道把元素全部删除完，数组长度为0，无法进行插入元素，对于这种情况就需要进行判断 if (count == n) return false; //数组中数据从最后一依次向后移动，直到将用户指定索引元素空出空间 for (int i = count - 1; i &gt;= index; --i) &#123; data[i+1] = data[i]; &#125; //将元素插入到数组中 data[index] = value; //数组长度+1 ++count; return true; &#125; /** * 功能：插入的另一种情况，当我们向一个数组的尾部插入元素时，上述的插入方法就不适合了，所以我们单独写一个将元素插入到数组尾部的方法。 * @param value:要插入的元素值 * @return */ public boolean insertToTail(int value) &#123; if (count == n) return false; //在数组尾部追加空间，将新元素插入到数组尾部 data[count++] = value; return true; &#125; /** * 通过for循环输出数组所有元素 */ public void printAll() &#123; for (int i = 0; i &lt; count; ++i) &#123; System.out.print(data[i] + " "); &#125; System.out.println(); &#125;&#125; 五、思考题1、为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1开始？▉ 从 0 开始编号 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式： 1a[k]_address = base_address + k * type_size ▉ 从 1 开始编号 如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为： 1a[k]_address = base_address + (k-1)*type_size ▉ 具体原因 1）对比两个公式，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。 2）数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。 补充：以上证明并不是压倒性证明，更有可能是历史原因，其他语言都效仿 C 语言，编号从 0 开始。 2、 JVM 的标记清除垃圾回收算法的核心理念，说一说 JAVA 的标记清除垃圾回收算法？ 目前最基本的垃圾收集算法有四种。 标记-清除算法(mark-sweep) 标记-压缩算法(mark-compact) 复制算法(copying) 引用计数算法(reference counting) 标记-清除算法(mark-sweep)：先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 3、二维数组的内存寻址公式是怎样的呢？ 1） C语言中，对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址如下。 2） java 二维数组是分块连续的 。 1address = base_address + ( i * n + j) * type_size 六、面试问题1、数组和链表的区别 1、错误表述：“ 链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1) ”。实际上，数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。 2、正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。 七、练习题1、实现一个动态扩容的数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import javax.xml.crypto.Data;/** * 功能：实现一个支持动态扩容的数组 * 方法一:System.arraycopy() * 最好时间复杂度为O(1),最坏时间复杂度为 O(n),平均时间复杂度为 O(1). * * 方法二:ArrayList 实现自动扩容 * @author 小鹿 * */public class Array01 &#123; private int count; private int[] array; private int num; private int n; //初始化 public Array01(int number) &#123; count = 0; array = new int[number]; num = number; n = 1; &#125; public static void main(String[] args) &#123; Array01 data = new Array01(5); data.insert(1); data.insert(2); data.insert(3); data.insert(4); data.insert(5); data.insert(6); data.insert(7); data.insert(8); data.insert(9); data.insert(10); data.insert(11); data.insert(12); data.print(); &#125; //插入数据 public void insert(int value) &#123; if(count&gt;=num*n) &#123; //动态扩容 int[] newArray = new int[array.length*2]; //数组数据搬移 for(int j =0;j&lt;array.length;j++) &#123; newArray[j] = array[j]; &#125;// System.arraycopy(array, 0, newArray, 0, array.length); array = newArray; //然后再插入数组 array[count] = value; //下标移动 count++; //扩容计数 n++; &#125;else &#123; //插入数据 array[count] = value; //下标移动 count++; &#125; &#125; //打印数组内容 public void print() &#123; for(int i=0;i&lt;array.length;i++) &#123; System.out.print(array[i]+" "); &#125; &#125;&#125; 八、数组掌握程度 一定要自己动手练习哦！ 一、入门基础 实现一个支持动态扩容数组 实现一个大小固定的有序数组，支持动态增删改查操作 实现两个有序数组合并为一个有序数组]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【回溯算法】]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美中的10大算法之一回溯算法。 一、如何理解“回溯算法”？1、回溯思想 深度优先搜索用到的就是回溯算法思想，当我们某一条路行不通时，我们就退回上一个岔口选择其他路径。 2、举例① 八皇后问题 有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。第一幅图是满足条件的一种方法，第二幅图是不满足条件的的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。 ② 问题解答 将此问题分为八个阶段，我们拿着八个棋子从第一行开始开始放，每放一次，我们就不停的检查是否满足条件，如果满足，我们就放置下一个棋子；如果不满足，我们就尝试另一种方法。 ③ 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 全局或成员变量, 下标表示行, 值表示 queen 存储在哪一列int[] result = new int[8];// 调用方式：cal8queens(0);public void cal8queens(int row) &#123; if (row == 8) &#123; // 8 个棋子都放置好了，打印结果 printQueens(result); return; // 8 行棋子都放好了，已经没法再往下递归了，所以就 return &#125; for (int column = 0; column &lt; 8; ++column) &#123; // 每一行都有 8 中放法 if (isOk(row, column)) &#123; // 有些放法不满足要求 result[row] = column; // 第 row 行的棋子放到了 column 列 cal8queens(row+1); // 考察下一行 &#125; &#125;&#125;// 判断 row 行 column 列放置是否合适private boolean isOk(int row, int column) &#123; int leftup = column - 1, rightup = column + 1; for (int i = row-1; i &gt;= 0; --i) &#123; // 逐行往上考察每一行 if (result[i] == column) return false; // 第 i 行的 column 列有棋子吗？ if (leftup &gt;= 0) &#123; // 考察左上对角线：第 i 行 leftup 列有棋子吗？ if (result[i] == leftup) return false; &#125; if (rightup &lt; 8) &#123; // 考察右上对角线：第 i 行 rightup 列有棋子吗？ if (result[i] == rightup) return false; &#125; --leftup; ++rightup; &#125; return true;&#125;// 打印出一个二维矩阵private void printQueens(int[] result) &#123; for (int row = 0; row &lt; 8; ++row) &#123; for (int column = 0; column &lt; 8; ++column) &#123; if (result[row] == column) System.out.print("Q "); else System.out.print("* "); &#125; System.out.println(); &#125; System.out.println();&#125; 二、回溯算法的应用1、0 - 1 背包① 问题 有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？ ② 分析 1、我们第一想到的就是贪心算法，但是贪心算法前提条件是物品可以分割的，可以装某一物品的一部分放进背包，但是这个问题不能分割的，要么装下，要么不装，我们用回溯算法来解决。 2、每个物品我们有两种状态，总的装法就有 2^n 种，怎么才能不重复的穷举这些可能呢？ ③ 解决 我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。 ④ 代码实现 1234567891011121314151617181920// 存储背包中物品总重量的最大值public int maxW = Integer.MIN_VALUE; // cw 表示当前已经装进去的物品的重量和；i 表示考察到哪个物品了；// w 背包重量；items 表示每个物品的重量；n 表示物品个数// 假设背包可承受重量 100，物品个数 10，物品重量存储在数组 a 中，那可以这样调用函数：// f(0, 0, a, 10, 100)public void f(int i, int cw, int[] items, int n, int w) &#123; // cw==w 表示装满了 ;i==n 表示已经考察完所有的物品 if (cw == w || i == n) &#123; if (cw &gt; maxW) maxW = cw; return; &#125; // 已经超过可以背包承受的重量的时候，就不要再装了(已改) if (cw + items[i] &lt;= w) &#123; f(i+1,cw + items[i], items, n, w); &#125;else&#123; f(i+1, cw, items, n, w); &#125;&#125; 2、正则表达式① 问题 假设正表达式中只包含“ ”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“”匹配任意多个（大于等于0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？ ② 分析 我们依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。 ③ 解决 如果遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。 ③ 代码实现 12345678910111213141516171819202122232425262728293031323334public class Pattern &#123; private boolean matched = false; private char[] pattern; // 正则表达式 private int plen; // 正则表达式长度 public Pattern(char[] pattern, int plen) &#123; this.pattern = pattern; this.plen = plen; &#125; public boolean match(char[] text, int tlen) &#123; // 文本串及长度 matched = false; rmatch(0, 0, text, tlen); return matched; &#125; private void rmatch(int ti, int pj, char[] text, int tlen) &#123; if (matched) return; // 如果已经匹配了，就不要继续递归了 if (pj == plen) &#123; // 正则表达式到结尾了 if (ti == tlen) matched = true; // 文本串也到结尾了 return; &#125; if (pattern[pj] == '*') &#123; // * 匹配任意个字符 for (int k = 0; k &lt;= tlen-ti; ++k) &#123; rmatch(ti+k, pj+1, text, tlen); &#125; &#125; else if (pattern[pj] == '?') &#123; // ? 匹配 0 个或者 1 个字符 rmatch(ti, pj+1, text, tlen); rmatch(ti+1, pj+1, text, tlen); &#125; else if (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; // 纯字符匹配才行 rmatch(ti+1, pj+1, text, tlen); &#125; &#125;&#125; 补充 剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。 三、思考问题 现在我们对今天讲到的 0-1 背包问题稍加改造，如果每个物品不仅重量不同，价值也不同。如何在不超过背包重量的情况下，让背包中的总价值最大？ 解答]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【分治算法】]]></title>
    <url>%2F2019%2F01%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美中的10大算法之一分治算法。 一、分治算法 分治算法是一种处理问题的思想，递归是一种编程技巧。 1、什么分治算法？ 分治算法（divide and conquer），分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。 2、每层递归实现的三个操作 分解：将原问题分解成一系列的子问题。 解决：递归地求解各个子问题，若子问题足够小，则直接求解； 合并：将子问题的结果合并成原问题。 3、分治算法满足的条件 可分解：原问题与分解成的小问题具有相同的模式； 无关联：原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别【链接：动态规划与分治算法的区别】。 终止条件：具有分解终止条件； 合并不能太复杂：可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。 二、应用一：降低处理数据时间的复杂度1、问题 求 n 个数据的逆序度或有序度的个数。 2、一般解决方法 每个数据一一比较，时间复杂度为 O(n²)。 3、利用分治算法改进 将数组中的数据分为前后两半 A1、A2，分别计算 A1 、A2 的逆序个数 K1、K2，然后在计算 A1、A2 合起来的逆序个数 K3，那数组逆序个数等于 K1+K2+K3。 4、分治算法合并函数 我们会用到归并排序中的一个非常关键的操作，就是将两个有序的数组合并成一个有序数组。在合并的同时计算逆序对个数，把这些计算出来的逆序对个数求和。 5、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445// 全局变量或者成员变量private int num = 0;// a 为要求逆序的数组，n 为数组的长度public int count(int[] a, int n) &#123; num = 0; //分治求逆序 mergeSortCounting(a, 0, n-1); return num;&#125;//分治思想private void mergeSortCounting(int[] a, int p, int r) &#123; if (p &gt;= r) return; int q = (p+r)/2; //递归 mergeSortCounting(a, p, q); mergeSortCounting(a, q+1, r); //合并求逆序数 merge(a, p, q, r);&#125;//合并两个有序的数组private void merge(int[] a, int p, int q, int r) &#123; int i = p, j = q+1, k = 0; int[] tmp = new int[r-p+1]; while (i&lt;=q &amp;&amp; j&lt;=r) &#123; if (a[i] &lt;= a[j]) &#123; tmp[k++] = a[i++]; &#125; else &#123; num += (q-i+1); // 统计 p-q 之间，比 a[j] 大的元素个数 tmp[k++] = a[j++]; &#125; &#125; while (i &lt;= q) &#123; // 处理剩下的 tmp[k++] = a[i++]; &#125; while (j &lt;= r) &#123; // 处理剩下的 tmp[k++] = a[j++]; &#125; for (i = 0; i &lt;= r-p; ++i) &#123; // 从 tmp 拷贝回 a a[p+i] = tmp[i]; &#125;&#125; 6、练习题 二维平面上有 n 个点，如何快速计算出两个距离最近的点。 有两个 n n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=AB？ 三、应用二：在海量数据的中的应用 分治算法思想的应用是非常广泛的，并不仅限于指导编程和算法设计。它还经常用在海量数据处理的场景中。 1、问题 给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2、3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。 2、解决思路 可以利用分治的思想。可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。 3、解决方案 给 10GB 的订单排序，我们就可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。 四、思考：为什么说 MapReduce 的本质就是分治思想？ 1、实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS（Google File System 是谷歌面向大量数据处理的文件分布式系统）来存储数据，依赖 Borg（是 Google 面向大规模集群的管理器） 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。 2、尽管 MapReduce 的模型非常简单，但是在 Google 内部应用非常广泛 。它除了可以用来处理这种数据与数据之间存在关系的任务。比如 MapReduce 的经典例子，统计文件中单词出现的频率。 3、除此之外，它还可以用来处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理，效率低下，我们就可以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的网页。 收获： 创新并非离我们很远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这本身就是算法的的一个魅力所在。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之HTML语义1【基本入门】]]></title>
    <url>%2F2019%2F01%2F22%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BHTML%E8%AF%AD%E4%B9%891%E3%80%90%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进重学前端中的 HTML 语义之基本入门。 一、语义标签1、语义标签是什么？ 像 section 、nav、p 这样的语义类标签，每个标签都有自己表达的意思。 2、为什么要用语义标签？ 增强可读性，没有 css 也能清晰地看出网页的结构，便于团队维护和开发。 适合于机器阅读，文字表现力丰富，更适合于搜索引擎检索（SEO），有效提升网页的搜索量。 语义类标签支持读屏软件，根据文章可以自动生成目录等等。 3、怎么用语义标签？ 1、“用对”比“不用”好，“不用” 比 “用错” 好，我们要不断的追求“用对”。 2、错误的语义标签会造成阅读的混淆、增加嵌套，给 CSS 编写加重负担。 4、自然语言语义便签 表示强调某个关键词。 Example 12今天我吃了一个 &lt;em&gt; 苹果 &lt;/em&gt;。今天我吃了 &lt;em&gt; 一个 &lt;/em&gt; 苹果。 5、标题摘要语义标签■ hgroup 标签 ① 代码实例 123456789例如：&lt;h1&gt;HTML 语义 &lt;/h1&gt;&lt;p&gt;balah balah balah balah&lt;/p&gt;&lt;h2&gt; 弱语义 &lt;/h2&gt;&lt;p&gt;balah balah&lt;/p&gt;&lt;h2&gt; 结构性元素 &lt;/h2&gt;&lt;p&gt;balah balah&lt;/p&gt;...... ② 树形结构 HTML 语义 弱语义 结构性元素 …… ③ 缺点 h1 - h6 代表文章不同层次的标题，如果我们有副标题，也会用到 h1 - h6 那我们怎么办呢？ ④ 改进 123456&lt;hgroup&gt; &lt;h1&gt;JavaScript 对象 &lt;/h1&gt; &lt;h2&gt; 我们需要模拟类吗？&lt;/h2&gt;&lt;/hgroup&gt;&lt;p&gt;balah balah&lt;/p&gt;...... ⑤ 树形目录 JavaScript 对象——我们需要模拟类吗？ … ■ section 标签 section 不仅仅是一个 “ 有语义的 div ”，还会改变 h1 - h6 的语义。，他会使得其中的 h1 - h6 下降一级，所以只需要 section 和 h1 就能形成文档树形结构。 例子 12345678910111213&lt;section&gt; &lt;h1&gt;HTML 语义 &lt;/h1&gt; &lt;p&gt;balah balah balah balah&lt;/p&gt; &lt;section&gt; &lt;h1&gt; 弱语义 &lt;/h1&gt; &lt;p&gt;balah balah&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h1&gt; 结构性元素 &lt;/h1&gt; &lt;p&gt;balah balah&lt;/p&gt; &lt;/section&gt;......&lt;/section&gt; HTML 语义 弱语义 结构性元素 …… 6、作为整体结构的语义标签 很多浏览器推出「阅读模式」，以及非浏览器终端的出现，语义化的 HTML 适合机器阅读特性变的越来越重要。 实例 123456789101112131415161718&lt;body&gt; &lt;header&gt; &lt;nav&gt; …… &lt;/nav&gt; &lt;/header&gt; &lt;aside&gt; &lt;nav&gt; …… &lt;/nav&gt; &lt;/aside&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;footer&gt; &lt;address&gt;……&lt;/address&gt; &lt;/footer&gt;&lt;/body&gt; article 标签 一个典型的场景是多篇新闻展示在同一个新闻专题页面中，这种类似报纸的多文章结构适合用 article 来组织。 例子： 123456789101112131415161718192021222324&lt;body&gt; &lt;header&gt;……&lt;/header&gt; //文章一 &lt;article&gt; //头 &lt;header&gt;……&lt;/header&gt; //主体 &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; //尾 &lt;footer&gt;……&lt;/footer&gt; &lt;/article&gt; //文章二 &lt;article&gt; …… &lt;/article&gt; &lt;article&gt; …… &lt;/article&gt; &lt;footer&gt; &lt;address&gt;&lt;/address&gt; &lt;/footer&gt;&lt;/body&gt; header 标签 通常出现在前部，表示导航或者介绍性的内容。 footer 标签 通常出现在尾部，包含一些作者信息、相关链接、版权信息等。 aside 标签 跟文章主体不那么相关的部分，它可能包含导航、广告等工具性质的内容。「侧边栏是 aside，aside 不一定是侧边栏。」 aside 和 header 中的导航（nav）区别？ 1、header 中的导航多数是到文章自己的目录。 2、aside 中的导航多数是到关联页面或者是整站地图。 footer 中 address 标签 表示文章（作者）的联系方式。]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【复杂度分析】]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美的复杂度分析。关注公众号「一个不甘平凡的码农」回复 “博客秘钥”，即可获取文章秘钥。 复杂度分析 目录[TOC] 一、复杂度分析概念📚 1、什么是复杂度分析？ 1、数据结构是用来干嘛的？ 数据结构与算法的诞生是让计算机「执行的更快」、「更省空间」的。 2、用什么来评判数据结构与算法的好坏？ 从「执行时间」和「占用空间」两个方面来评判数据结构与算法的好坏。 3、什么是复杂度？ 用「时间复杂度」和「空间复杂度」来描述性能问题，两者统称为复杂度。 4、复杂度描述了什么？ 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。 📚 2、为什么要进行复杂度分析？ 1、和性能分析相比有什么优点？ 复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。 2、为什么要复杂度分析？ 将能编写出性能「更优的代码」，有利于降低系统「开发和维护成本」 📚 3、如何进行复杂度分析？ 1、什么方法可以进行复杂度分析？ 方法：「大 O 表示法」 2、什么是大 O 表示法？ 算法的「执行时间」与每行代码的「执行次数」成正比【T(n) = O(f(n)) 】=》其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。 3、大 O 表示法的特点？ 由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。 4、复杂度分析法则 [单段代码看频率]：看代码片段中「循环代码」的时间复杂度。 [多段代码看最大]：如果多个 for 循环，看「嵌套循环最多」的那段代码的时间复杂度。 [嵌套代码求乘积]：循环、递归代码，将内外嵌套代码求乘积去时间复杂度。 [多个规模求加法] : 法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 二、复杂度分析方法1、定义 1、什么是复杂度？ 所有代码的「执行时间 T(n)」 与每行代码的「执行次数n」 成正比【T(n) = O(f(n)) 】。 2、时间复杂度（分析方法） 2、分析的三个方法 最多法则 加法法则 乘法法则 ①最多法则 忽略掉公式中的常量、低阶、系数，取最大循环次数就可以了，也就是循环次数最多的那行代码。 例子： 12345678// 求n个数字之和int xiaolu(int n) &#123; int sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; sum = sum + i; &#125; return sum; &#125; 分析： 第二行是一行代码，也就是常量级别，与 n 没有关系，可以忽略，四、五行代码是我们重点分析对象，与 n 有关，时间复杂度就是反映执行时间和 n 数据规模的关系。求 n 个数据之和需要执行 n 次。所以时间复杂度为 O(n)。 ② 加法法则 总复杂度等于循环次数最多的那段复杂度。 例子： 1234567891011int xiaolu(int n) &#123; int sum = 0; //循环一 for (int i = 1; i &lt;= 100; j++) &#123; sum = sum + i; &#125; //循环二 for (int j = 1; j &lt;= n; j++) &#123; sum = sum + i; &#125; &#125; 分析： 上边有两个循环，一个循环 100 次，另一个循环 n 次，我们选择循环次数最多的那一个且和「数据规模 n 」相关的循环。由上可知，我们很容易选出循环二，即和数据规模 n 有关，循环次数最多，循环次数最多的那段代码时间复杂度就代表总体的时间复杂度，为 O(n) ; ③ 乘法法则 当我们遇到嵌套的 for 循环的时候，怎么计算时间复杂度呢？那就是内外循环的乘积。 例子： 1234for (int j = 1; j &lt;= n; j++) &#123; for(int i = 1; i &lt;= n; i++) sum = sum + i; &#125; 分析： 外循环一次，内就循环 n 次，那么外循环 n 次，内就循环 n*n 次。所以时间复杂为 O(n²)。 3、空间复杂度 表示算法的「存储空间」与「数据规模」之间的增长关系 例子： 12345int i = 0;int[] a = new int[n];for (i; i &lt;n; ++i) &#123; a[i] = i * i;&#125; 分析： 在所有代码中，我们很容易寻找到存储空间相关的代码，就是第二行，申请了一个 n 大小的存储空间，所以空间复杂度为 O(n)。 最常见的空间复杂度 O(1)、O(n)、O(n²)。 4、常见的时间复杂度 O(1) O(logn)、O(nlogn) O(m+n)、O(m*n) 1、O(1)常量级的时间复杂度表示方法，无论是一行代码，还是多行，只要是常量级的就用 O(1) 表示。 例子： 123int i = 1;int j = 2;int sum = i + j; 分析： 因为这三行代码，也就是常量级别的代码不随 n 数据规模的改变而改变。（循环、递归除外） 2、O(logn)、O(nlogn)「对数阶时间复杂度」，最难分析的一种时间复杂度。 例子： 1234i=1;while (i &lt;= n) &#123; i = i * 3;&#125; 分析： 要求这段代码的时间复杂度就求这段代码执行了多少次，看下图具体分析。 补充： 不管是以 2 为底、以 3 为底，还是以 10 为底，可以把所有对数阶的时间复杂度都记为 O(logn)，因为对数之间可以转换的，参照高中课本。 3、O(m+n)、O(m*n) 参照上边讲到的加法和乘法法则。 三、最好、最坏、平均、均摊时间复杂度 最好情况时间复杂度 最坏情况时间复杂度 平均情况时间复杂度 均摊时间复杂度 1、最好、最坏时间复杂度 所谓的最好、最坏时间复杂度分别对应代码最好的情况和最坏的情况下的执行。 例子： 123456//在一个 array 数组中查找一个数据 a 是否存在for (int i = 1; i &lt; n; i++) &#123; if (array[i] == a) &#123; return i; &#125; &#125; 分析： 1、最好情况就是数组的第一个就是我们要查找的数据，上边代码之执行一遍就可以，这种情况下的时间复杂度为最好时间复杂度，为 O(1)。 2、最坏的情况就是数组的最后一个才是我们要查找的数据，需要循环遍历 n 遍数组，也就对应最坏的时间复杂度为 O(n) 。 2、平均时间复杂度 平均时间复杂度需要借助概率论的知识去分析，也就是我们概率论中所说的加权平均值，也叫做期望值。 分析： 比如上方的例子，假设我们查找的数据在数组中的概率为 1/2；出现在数组中的概率为 n/1,根据下边的公式就可以算出出现的概率为 1/2n 。 然后我们再把每种情况考虑进去，就可以计算出平均时间复杂度。 3、均摊时间复杂度 顾名思义，均摊的意思就是把最多的那份平均到各个均等的份上，通常重点掌握使用均摊分析来求均摊时间复杂度。 摊还分析 比如我们每 n 次插入数据的时间复杂度为 O(1)，就会有一次插入数据的时间复杂度为 O(n)，我们将这一次的时间复杂度平均到 n 次插入数据上，时间复杂度还是 O(1)。 适用场景 一般应用于某一数据结构，连续操作时间复杂度比较低，但是个别情况时间复杂度特别高，我们将特别高的这一次进行均摊到较低的操作上。 四、总结1、各个时间复杂度]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【AC 自动机】]]></title>
    <url>%2F2019%2F01%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90AC%20%E8%87%AA%E5%8A%A8%E6%9C%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美的AC 自动机。 一、基于单模式串和 Trie 树实现敏感词过滤1、多模式串匹配 多模式串匹配是在多个模式串中和一个主串之间进行匹配，也就是在一个主串中查找多个模式串。 2、用单模式匹配敏感词缺点 用 BF 算法、RK 算法、BM 算法、KMP 算法，还有 Trie 树实现多模式串匹配算法可以实现，但是每个匹过程都要扫描用户输入的内容，整个过程需要扫描很多遍内容，如果用户输入很长，敏感词过多，匹配过程很低效。 3、Trie 树实现敏感词匹配 1、我们将敏感词进行预处理，形成 Trie 树结构，如果铭感次更新或者删除了，只需更新一下 Trie 树就可以了。 2、当用户输入一个文本内容后，我们把用户输入的内容作为主串，从第一个字符从 Trie 树开始匹配。当遇到叶子节点或者不匹配时，然后从下一个字符开始，重新匹配 Trie 树。 二、经典的多模式匹配算法：AC自动机定义 AC 自动机算法，全称 Aho-Corasick 算法。AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处构建在树上。 代码12345678910public class AcNode &#123; public char data; public AcNode[] children = new AcNode[26]; // 字符集只包含 a~z 这 26 个字符 public boolean isEndingChar = false; // 结尾字符为 true public int length = -1; // 当 isEndingChar=true 时，记录模式串长度 public AcNode fail; // 失败指针 public AcNode(char data) &#123; this.data = data; &#125;&#125; AC 自动机的构建 将多模式串构建成树。 在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【字符串匹配算法】]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法中的字符串匹配。 数据结构与算法之字符串匹配算法1、一串匹配一串： 简单的两种字符串匹配算法，BF算法、RK算法。 难理解、但是更加高效的算法，BM算法、KMP算法。 2、一串匹配多串： Trie 树和 AC 自动机。 BF 算法和 RK 算法 RK 算法是 BF 算法的优化。 一、BF 算法（Brute Force）1、定义 BF（Brute Force） 算法也叫暴力匹配算法，也叫做朴素匹配算法。 2、优点 简单、好懂。 3、缺点 性能差。 4、BF 算法思路 主串（n）：被查找的字符串。 模式串（m）：要查找的字符串。 我们在主串中，从起始位置到 0、1、2、 … m-n 开始检查能否和长度为 m 的字符串匹配。最多需要比较 n-m+1次。 5、性能分析 最坏时间复杂度O(m*n)：当主串为 aaa...aaa 时，模式串为 aaaaab 时，每次对比 m 个字符串，要比对 n-m+1 次。时间复杂度为 m*n+m²+1。 6、适用条件 虽然 BF 的时间复杂度非常高了，但是在实际开发中经常用到。因为绝大部分情况下，这种字符串匹配算法就够用了。 ① 大部分情况下，模式串和主串的长度不会太长。 ② 大多数情况下不会每次全匹配，总体来说算法的效率很高效的。 ③ 代码简单，不易出错，思想简单，有 bug 容易暴露和修复。在满足性能的条件下，简单是首选，也就是所说的 KISS 原则（KISS 原则是指在设计当中应当注重简约的原则）。 二、RK 算法(Rabin-Karp)1、由来 它是由 Rabin 和 Karp 两位发明者来命名的。 2、BF 算法的不足 上边也讲到了，在匹配字符串的时候，需要一个字符一个字符的比较，最坏情况下的时间复杂度为 O（m*n），需要引入哈希算法进行优化。 3、RK 算法思路① 实现：对 （n-m+1）个子串求哈希值，让模式串与逐个哈希值比较。 ② 分析： 总体来说时间复杂度没有提高。 需要遍历子串计算哈希值（耗时长）； 模式串与子串的比较效率高了（耗时短）。 ③ 提高计算子串的哈希值的效率： 要处理的字符串用 K（26） 进制进行表示（如 26 个字母，每个字母对应一个数字）； 然后转化为十进制作为哈希值（“cba” = “c” 26\26 + “b”*26 + “a”x1）； 规律：相邻的两个子串 s[i-1] 和 s[i] 有计算公式的交集，可以通过 s[i-1] 的哈希值计算出 s[i] 哈希值。 26^(m-1) 计算的值需要提前存储到数组中。 1h[i] = (h[i-1]-26^m-1 * (s[i-1]-'a')) * 26 + 26^0 * (s[i+m-1]-'a') 4、性能分析 性能的分析我们从两部分入手，一部分是计算子串的哈希值，另一部分是与子串的哈希值进行比较。 ① 计算子串的哈希值时，需要遍历所有的字符串，时间复杂度为O(n)； ② 子串与模式串进行哈希比较的操作时间复杂度为O(1)，总比较次数为 （n-m+1）,时间复杂度为O(n)； ③ 所以，RK 算法整体的时间复杂度为 O(n)。 5、存在的问题 如果模式串很长，计算哈希值的长度超过计算机的存储的整数范围的话，应该怎么解决？计算哈希值存在哈希冲突又该怎么解决呢？ 6、问题解决 第一种优化方法，我们可以优化一下计算哈希值的算法就可以，如：字符串对应素数一次类推等。第二种优化方法，就让存在哈希冲突，当遇到哈希冲突的时候，再对应模式串和子串的本身进行比较。 7、补充： 该方法还是主要取决于哈希算法的设计，我们还是要尽量将冲突的概率控制的较低，否则RK 算法的时间复杂度就会推化为 O(n*m)。总的来说，RK 算法的时间复杂度相对于 BF 算法效率还是很高的。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【深度和广度优先搜索】]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E3%80%91%2F</url>
    <content type="text"><![CDATA[广度优先遍历算法和深度优先遍历算法！ 一、搜索算法1、关于搜索算法 1）所谓的算法都是基于数据结构之上的，因为图这种数据结构表达能力极强，所以像搜素算法，如：广度优先遍历和深度优先遍历都是基于图来实现的。 2）大部分的搜索的场景都可以抽象成图 。 3）广度和深度优先既可以对无向图也可以对有向图。 2、搜索算法的基础（图） 图有两种存储方法，下面是用邻接表的方法存储实现无向图的代码。 123456789101112131415161718192021// 无向图public class Graph &#123; // 顶点的个数 private int v; // 邻接表中的散列表部分 private LinkedList&lt;Integer&gt; adj[]; // 初始化 public Graph(int v) &#123; this.v = v; adj = new LinkedList[v]; for (int i=0; i&lt;v; ++i) &#123; // 为每个邻接表添加链表 adj[i] = new LinkedList&lt;&gt;(); &#125; &#125; // 无向图一条边存两次 public void addEdge(int s, int t) &#123; adj[s].add(t); adj[t].add(s); &#125;&#125; 二、搜索算法※ 适用条件 广度深度优先搜索算法属于暴力破解法，没有什么可以优化的。比其他的搜索算法 A、IDE\ 要简单粗暴。‘ 适用条件：适合于状态空间不大（图不大）的情况下。 1、广度优先搜索▉ 定义 广度优先搜索（Breadth-First-Search），简称 BFS。可以简单理解为以一点为中心，逐渐层层向外搜索，形如雷达。 ▉ 算法思路 1）判断起止点位置是否为同一位置（s == t）; 2）初始化变量 visited（初始化为 0）、queue、prev（初始化 -1 ），并将起始点也进行初始化; 起始点在 visited[0] 为 true。 起始点入栈 queue。 3）先对第一层进行搜索终点顶点，出栈（上一层的顶点），遍历与上一层顶点相连接的顶点是否有我们要搜索的顶点 t。 出栈 根据邻接表遍历相邻顶点； 判断该顶点是否访问过； 如果没有法访问，记录路径； 判断当前顶点是否为终止点（如果是，递归遍历路径）。 否则，该节点标记为已经访问过，visited[q] = true。 该顶点入栈（queue） ​ ▉ 代码实现 相关变量： s：起始点。 t：终止点。 visited：存储所有访问过的顶点（初始化为 0，访问过的顶点为 1 ）。 queue：存储每一层的顶点（依次出队进行判断来自哪一个顶点）。 prev：存储搜索路径（下标为当前顶点，存储的元素为当前下标顶点来自哪一顶点）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//广度优先搜索public void bfs(int s, int t) &#123; //判断起止点位置是否为同一位置（s == t）; if (s == t) return; //用来存储已访问的顶点（v为图的顶点个数） boolean[] visited = new boolean[v]; //将第一个顶点置为true visited[s]=true; //定义一个队列，用来存储已经被访问但相连的顶点还没有被访问的顶点 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); //现将第一个节点存储 queue.add(s); //用来存储搜索路径（v为图的顶点个数） //将数组 prev 全部置为 -1 int[] prev = new int[v]; for (int i = 0; i &lt; v; ++i) &#123; prev[i] = -1; &#125; // 出栈（上一层的顶点），遍历与上一层顶点相连接的顶点是否有我们要搜索的顶点 t。 while (queue.size() != 0) &#123; // 出栈 int w = queue.poll(); // 根据邻接表遍历相邻顶点 for (int i = 0; i &lt; adj[w].size(); ++i) &#123; // 邻接表第 i 个元素 int q = adj[w].get(i); // 判断当前顶点是否为终止点 if (!visited[q]) &#123; // 如果没有法访问，记录路径； prev[q] = w; //判断当前顶点是否为终止点（如果是，递归遍历路径）。 if (q == t) &#123; print(prev, s, t); return; &#125; //否则，该节点标记为已经访问过 visited[q] = true; //该顶点入栈（queue） queue.add(q); &#125; &#125; &#125;&#125;// 递归打印 s-&gt;t 的路径private void print(int[] prev, int s, int t) &#123; if (prev[t] != -1 &amp;&amp; t != s) &#123; print(prev, s, prev[t]); &#125; System.out.print(t + " ");&#125; ▉ 性能分析 时间复杂度：O（E）。最坏的情况就是图为连通图，且终止顶点距离起始点很远，需要遍历整个图，每个顶点和边都要至少访问一次，所以时间复杂度为 O(E + V)。因为连通图的边数一定大于等于顶点 V 。所以时间复杂度为 O（V）。 空间复杂度： O（V）。三个变量 visited、queue、prev 的空间永远超不出所有顶点的个数，所以空间复杂度为O（V）。 2、深度优先搜索▉ 定义 深度优先搜索（Depth-First-Search），简称 DFS。所用到的算法为回溯算法，就像走迷宫， 每当发现前方的道路不通时，就会回到上一岔路口走另一条路。 ▉ 算法思路 1）初始化变量，初始化变量 visited（初始化为 0）、prev（初始化 -1 ） found：默认为 false。，并将起始点也进行初始化。 起始点在 visited[0] 为 true。 2）判断 found 是否为 true （终止条件）。 3）判断起始顶点和终止顶点是否相等，如果相等，将 found 置为 true ，return 返回。 4）遍历邻接表，判断当前的顶点是否访问过。 5）如果未访问过，记录当前顶点。 6）以当前顶点为起点，继续递归调用。 ▉ 代码实现 相关变量： s：起始点。 t：终止点。 found：标识已经找到终点顶点，不再继续递归。 visited：存储所有访问过的顶点（初始化为 0，访问过的顶点为 1 ）。 queue：存储每一层的顶点（依次出队进行判断来自哪一个顶点）。 prev：存储搜索路径（下标为当前顶点，存储的元素为当前下标顶点来自哪一顶点）。 123456789101112131415161718192021222324252627282930// 深度优先搜索boolean found = false; public void dfs(int s, int t) &#123; found = false; boolean[] visited = new boolean[v]; int[] prev = new int[v]; for (int i = 0; i &lt; v; ++i) &#123; prev[i] = -1; &#125; recurDfs(s, t, visited, prev); print(prev, s, t);&#125;private void recurDfs(int w, int t, boolean[] visited, int[] prev) &#123; if (found == true) return; visited[w] = true; if (w == t) &#123; found = true; return; &#125; for (int i = 0; i &lt; adj[w].size(); ++i) &#123; int q = adj[w].get(i); if (!visited[q]) &#123; prev[q] = w; recurDfs(q, t, visited, prev); &#125; &#125;&#125; ▉ 性能分析 时间复杂度：O（E）。每条边最多访问两次，一次遍历，另一次回退。所以时间复杂度为 O（E）E：边。 空间复杂度：O（V）。根据变量存储额外的空间大小为顶点的个数，所以空间复杂度为O（V）。 三、思考：如何找出社交网络中的三度好友关系？ 答：借助广度优先搜索，每一层是一度关系好友，用一个数组来记录每个顶点与起始顶点的距离，就可以找出三都好友。 四、实际运用 数据结构最难的不是掌握其原理，而是能够将实际问题和抽象问题转成成数据结构与算法。 举例：怎么将迷宫存储到计算机呢？ 答：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【图的表示】]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%9B%BE%E3%80%91%2F</url>
    <content type="text"><![CDATA[如何存储微博、微信等社交网站中的好友关系？ 一、图的基本知识1、什么是图？ 树的元素称为节点，图中的元素叫做顶点。图中的顶点可以与任意其他顶点建立连接关系，叫做边（edge）。跟顶点连接的边的条数，就叫做顶点的度。 2、图的分类 根据图有无方向，我们分为有向图和无向图。 1）有向图：把度分为入度（有多少条边指向这个顶点）和出度（有多少条边指向其他顶点）。 2）无向图：没有方向的图称为无向图。 3）带权图：每条边都有一个权重的图为带权图。 3、图的实际例子 1）微信：互相加为好友，就添加一条边，微信好友之间的关系可以用一张无向图来表示。 2）微博：单向关注或互相关注，微博好友之间的关系可以用有向图来表示。 3）QQ：不仅是好友关系，还有记录好友之家的亲密关系以及用户的亲密度。 二、如何存储图？1、邻接矩阵存储法 基于数组实现的空间换时间思想。 ▉ 图示 ▉ 实现 1）对于无向图来说，如果顶点 i 与顶点 j 之间有边，就将A[i][j] 和 A[j][i] 标记为 1； 2）对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，就将 A[i]/[j] 标记为 1。如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j]/[i] 标记为 1 3）对于带权的图，数组中就存储相应的权重。 ▉ 优点 1）邻接矩阵存储方式简单、直接，因为基于数组，所以获取两边的顶点关系的时，就非常高效。 2）计算高效，可以将图转化为矩阵进行计算。如：求最短路径问题：Floyd-Warshall 算法。 ▉ 缺点 比较浪费空间。 分析： 1） 对于无向图来说，A[j][i] 和 A[i][j] 存储的都是 1，实际上存储一个就可以了，对角线只不过是白白浪费了内存空间。 2）如果存储稀疏图（顶点多，边不多），所以邻接矩阵更浪费空间。 2、邻接表存储方法 基于链表实现的时间换空间思想。 ▉ 图示 ▉ 实现 邻接表有点像（链接：散列表），每个顶点对应一条链表，链表中存储的是这个顶点相连接的其他顶点。 ▉ 优点 基于链表的邻接表，可以有效节约内存空间。 ▉ 缺点 链表存储对缓存不友好，所有在查询两个节点之间的关系就不是那么高效了。链表过长导致查询耗时过长，可以将链表换换成其他的数据结构。 ▉ 优化 如果上述的链表过长，导致查询数据太过于耗时，为了提高效率，可以将链表转换成更高效的数据结构，比如平衡二叉树(红黑树)、跳表、散列表、二叉查找树。还可以转化成有序的动态数组，通过二分查找的方法来快速定位两个顶点是否存在边。 三、本节思考：怎么存储微博、微信中的好友关系？1、问题： 要实现微博用户功能。 判断用户 A 是否关注了用户 B； 判断用户 A 是否是用户 B 的粉丝； 用户 A 关注了用户 B； 用户 A 取消关注了用户 B； 根据用户首字母进行排序，分页获取用户的粉丝列表； 根据用户名称的首字母排序，分页获取用户的关注列表； 2、问题分析■ 判断用户 A 是否关注了用户 B。 挂钩数据结构：微博是一个大的社交网络，是一张稀疏图，存储方式选择邻接表。 ■ 判断用户 A 是否是用户 B 的粉丝。 灵活运用：一个邻接表只能知道用户关注了哪些，而不知道自己有哪些粉丝，应该怎么做？加一个逆邻接表用来存储一个用户有哪些粉丝。 ■ 微博人数太多，邻接表导致两个用户关系的查询慢 数据结构的缺点：将邻接表中的链表改为支持快速增删改查的数据结构平衡二叉树、跳表、散列表、二叉查找树、基于数组动态数据的二分查找。 ■ 根据用户首字母进行排序 问题特点精选：用户名称的首字母来排序的，使用跳表来实现。 3、性能分析■ 选用的数据结构 跳表性能分析：跳表支持快速增删改查，非常高效，时间复杂度是O(logn)，空间复杂度较高，是 O（n）。但是跳表存储本来就是有序的，所以分页获取粉丝列表或关注列表就非常高效。 ■ 内存消耗（数据规模） 1、小规模：数据（几万，几十万），直接加载到内存中去。 2、大规模： 数据（上亿级）。 ▍方法一：内存 利用哈希数据分片的方式进行存储，存储到不同的机器。 方法二：外存 外部存储宽裕，因为数据库是我们经常用来持久化存储关系数据的，所以考虑数据库的一种方式。表可以存储两个用户之间对应的关系，为了高效的支持前边的操作，就用数据库索引，对字段都建立索引。 四、扩展思考1、微信这种无向图怎么存储? 2、关于图的实例还有哪些？ 多对多：地图、网络、电话。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【堆】]]></title>
    <url>%2F2019%2F01%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%A0%86%E3%80%91%2F</url>
    <content type="text"><![CDATA[为什么说堆排序没有快速排序快？ 一、什么是堆？ 堆是一个完全二叉树；堆中的每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 1、堆的分类 大顶堆：每个节点的值大于等于子树每个节点值的堆。 小顶堆：每个节点的值小于等于子树中每个节点值的堆。 2、堆的特点 堆是一个完全二叉树； 堆中的每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 二、如何实现一个堆？1、堆的存储 数组中下标为 i 的节点的左子节点就是下标为 i*2 的节点，右子节点就是下标为 i * 2+1 的节点，父节点就是下标为 i/2 的节点。 2、堆中插入一个数据 从下往上进行堆化。 ■ 代码实现12345678910111213141516171819202122232425262728/** * 时间:2019/2/28 * 功能:插入数据 * 分析: * 1)插入到数组尾部(堆最后的节点) * 2)自下而上堆化(比较和交换) * 边界条件: * 1)判断是否已经堆满 * @param data 插入的数据 */public void insert(int data) &#123; //判断堆是否已满 if(count &gt;= n) return; //计数+1(下标 0 不存储数据) count++; //将数据插入最后节点 a[count] = data; //自下往上堆化 int i = count; //判断插入数据的根节点是否大于 0 且插入的数据是否大于根节点数据 while(i/2 &gt; 0 &amp;&amp; a[i] &gt; a[i/2]) &#123; //交换下标为 i 和 i/2 的元素 swap(a,i,i/2); //继续堆化比较交换 i = i/2; &#125;&#125; 2、堆中删除一个数据 把堆顶的元素删除之后，将最后一个节点放到堆顶，然后按照上边的方法进行交换，直到父子节点满足大小关系为止，从上往下堆化方法。 ■ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445 /** * 时间:2019/2/28 * 功能:删除堆顶数据 * 分析: * 1)判断堆是否为空 * 2)数组长度 -1 * 3)从下标为 1 的数据从上到下进行堆化 * 4)在左右节点中选出最大元素进行交换 * 边界分析: * 1)判断堆是否为空 * 2)堆中是否只有一个元素 * @param data 要删除的数据 */public void removeMax() &#123; //如果堆中无数据,则返回 if(count == 0) return; //删除堆顶的第一个元素,与最后一个元素进行交换 a[1] = a[count]; //数组长度-1 count--; //从上到下进行堆化 heapify(a,count,1);&#125;/** * 功能:从上自下堆化 * @param a 堆化的数组 * @param count 当前堆中的数据 * @param i */private void heapify(int[] a,int n,int i) &#123; while(true) &#123; int maxPos = i; //选择子节点中最大的数据作交换 if(i*2 &lt; n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2; if(i*2+1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos = i*2+1; //如果堆顶只剩一个元素,break if(maxPos == i) break; //进行交换 swap(a, i, maxPos); //继续往下堆化 i = maxPos; &#125;&#125; 三、堆插入、删除的时间复杂度分析 n 个节点的完全二叉树，树的高度不会超过 log2n，堆化的过程就是顺着路径进行交换的过程，时间复杂度与树的高度成正比，也就是 O(logn)。 四、堆排序 借助于堆这种数据结构实现的排序算法，就叫作堆排序。这种排序方法的时间复杂度非常稳定，是 O(nlogn)，并且是原地排序算法。 1、 建堆■ 方法一： 借助前边讲的堆插入一个数据元素，就好比从1到n ，插入n个数据。数组操作就是从前到后处理数据，堆排序需要从下向上堆化。 ■ 方法二：（最常用的方法） 与第一种截然相反，数组从后向前处理（数组的中间位置），堆排序是从上到下堆化。 ■ 代码实现12345678910111213141516171819202122232425262728293031323334/** * 时间:2019/2/28 * 功能:建堆 * 1)取数组中间从后往前 * @param a 数组 * @param n 数组的大小 */public static void buildHeap(int[] a,int n) &#123; for (int i = n/2; i &gt;= 1; i++) &#123; heapify(a,n,i); &#125;&#125;/** * 功能:从上自下堆化 * @param a 堆化的数组 * @param count 当前堆中的数据 * @param i */private static void heapify(int[] a,int n,int i) &#123; while(true) &#123; int maxPos = i; //选择子节点中最大的数据作交换 if(i*2 &lt; n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2; if(i*2+1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos = i*2+1; //如果堆顶只剩一个元素,break if(maxPos == i) break; //进行交换 swap(a, i, maxPos); //继续往下堆化 i = maxPos; &#125;&#125; 注意： 从 n/2 开始堆化，下标是 n/2 +1 到 n 的结点都是叶子节点，不需要堆化。对于完全二叉树来说，下标从 n/2+1到n的节点都是叶子节点。 ■ 建堆的时间复杂度分析 1、堆化的时间复杂度为 O(logn)，需要堆化 n/2 + 1个结点，时间复杂度为 O(nlogn)，不够精确，叶子节点并没有参与堆化。 2、需要在倒数第二层进行堆化，所以将每层堆化的结点数和每层的高度相乘总体相加得出时间复杂度。 3、建堆的时间复杂度为 O(n)。 2、排序 借助删除堆顶元素的方法来对堆元素进行排序。 ■ 代码实现12345678910111213141516171819/** * 功能:排序 * @param a 数组 * @param n 数据的个数 */public static void sort(int[] a, int n) &#123; //建堆 buildHeap(a, n); //堆排序 int k = n-1; while (k &gt; 1) &#123; //交换堆顶元素和最后一个元素 swap(a, 1, k); //堆元素减一 --k; //从上向下进行堆化 heapify(a, k, 1); &#125;&#125; ■ 堆排序的时间复杂度分析 建堆的时间复杂度为 O(logn) ，n 个结点排序的时间复杂度为 O(nlogn)。 3、堆排序的性能▍堆排序是否为原地排序算法？ 答：是 分析：数据交换只需要变量级别的临时空间，所以空间复杂度为 O(1)。 ▍堆排序是否为稳定排序算法？ 答：不是 分析：在整个堆排序的过程中，存在将堆的最后一个节点和堆顶节点的互换的操作，所以有可能改变相同数据的原始相对顺序。所以堆排序不是稳定排序。 ▍堆排序的时间复杂度？ 答：O(nlogn) 分析：建堆的时间复杂度为 O(n)，堆排序的时间复杂度为 O(nlogn)，所以总的时间复杂度为 O(nlogn); 五、为什么快速排序比堆排序性能好？1、堆排序数据访问的方式没有快速排序友好 对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。比如，堆排序中，最重要的一个操作就是数据的堆化。堆排序访问元素会跳这访问，不像快速排序一样局部顺序访问，这样对 CPU 缓存不友好。 2、对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。 堆排序经过建堆，会将数据的逆序度降低，本来一组数据是有序的，经过建堆之后就会变得无序。而快速排序整个排序过程中，数据交换的次数不会比逆序度多。 六、扩展思考1、对于完全二叉树来说，下标从 n/2 + 1 到 n的都是叶子节点，怎么推导出出来的？ 七、堆的应用1、应用一：优先级队列■ 定义 顾名思义，队列是先进先出，而这里的优先级队列的出队顺序不是先进先出，而是按照优先级来的，优先级越高就先出队。 ■ 思路 用堆实现优先级队列是最直接、最高效的一种方式，因为堆和优先级队列最为相似。一个堆可以看成一个优先级队列，往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列删除一个元素，就相当于取出一个堆顶元素。 ■ 优先级队列一：合并有序小文件▍问题： 假设有 100 个小文件，每个文件的大小是 100 MB，每个文件存储的都是有序的字符串。希望将这些 100 小文件合并成一个有序的大文件。 ▍解决： 归并排序中的合并函数，先分别从 100 个文件中各提取一个字符串，放入数组中，然后比较大小，选择最小的字符串合并到大文件中，然后在数组中删除改元素，从该文件中重新选择一个字符串放到数组中重新比较。 ▍不足; 用数组其实不是最高效的方法，我们需要在数组中遍历所有元素进行比较，比较耗时。 ▍优化： 利用小顶堆来实现。 ▍时间复杂度分析： 1、数组的实现方式：对数组删除、插入以及比较取出最小值操作时间复杂度为 O(n)。 2、小顶堆实现方式：每个堆总数据为 100 ，删除堆顶、往堆中插入数据的时间复杂度为 O(logn)。 ■ 优先级队列二：高性能定时器▍问题： 假设有一个定时器，定时器维护了很多任务，每个任务都设定了出发的时间点，定时器每过一秒都要扫描一下任务，判断当前的任务有没有达到执行时间的，如果达到了，就拿出来执行。 ▍解决： 小顶堆来解决，小顶堆存放的数据就是任务时间和当前时间差。 1、堆顶元素就是最先执行的任务。 2、堆顶的任务执行完毕之后，然后重新计算差值，得出首任务。 2、应用二：利用堆求 Top K▍问题： 如何在包含 n 个数据的数组中，查找前 K 大数据呢？1、静态数据；2、动态数据。 ▍ 静态数据： 1、首先维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。 2、如果取出的数据比堆顶大，我们呢就将堆顶元素删除，然后将数据进行插入。 3、如果比堆顶的元素小，我们就不做处理。 4、将数组全部遍历完成之后，堆中的数据就是前K大数据**。 ▍静态数据复杂度 遍历数组时间复杂度为 O(n)，一次堆化时间复杂度为 O(logK) 。 1、最坏的情况下：数据从小到大排列，时间复杂度为 O(nlogK) 。 2、最好的情况下：数据从大到小排列，时间复杂度为 O(n)。 ▍动态数据复杂度 实时的求前 k 大数据。 1、一直维护一个 K 大小的小顶堆，当有数据被添加进来的时候，就拿着它与堆顶的元素对比。如果比堆顶元素大，我们就删除堆顶元素，将此元素进行插入，如果比堆顶小，我们就不做任何处理。 3、堆的应用三：利用堆求中位数▍问题： 如果数据的个数是奇数的时候，中位数为 n/2 + 1。如果是偶数的话，中位数有两个，分别为 n/2 和 n/2 + 1。如何求动态数据集合的中位数? ▍静态数据求中位数： 关于静态数据，中位数是固定的，我们先可以进行排序，第 n/2 个数据就是中位数。 缺点：排序的代价有点大。 优点：边际成本会很小。 ▍动态数据求中位数： 1、需要维护两个堆，一个大顶堆，一个是小顶堆。大顶堆存储前半部分数据，小顶堆存储后半部分数据。且小顶堆的数据都大于大顶堆的数据。 2、如果有 n 个数据，n 是偶数，从小到大排序，那前 n/2 个数据存储在大顶堆中,也就是堆顶就是中位数。如果 n 是奇数，大顶堆就存储 n/2 + 1个数据，小顶堆就存储 n/2 个数据。 3、如果新加入的数据小于等于大顶堆的堆顶元素，就将这个新数据插入到大顶堆；如果新加入的数据大于等于小顶堆的堆顶元素，就将这个新数据插入到小顶堆。 4、插入新数据会导致两个堆的数据不符合前边约定的情况，导致 n 是偶数的时候，两个堆的数据都是 n/2 个数据。奇数大顶堆有 n/2 + 1 个数据，小顶堆有 n/2 个数据。 5、可以不停的移动一个堆顶的元素向另一个堆顶移动，这样就可以调整了。 ▍时间复杂度分析 1、插入数据需要涉及到堆化，时间复杂度为O(logn) 。 2、求中位数直接返回堆顶元素就行了，所以时间复杂度为 O(1)。 八、本节思考：如何快速获取到Top 10最热门的搜索关键词？▍问题： 有 10 亿个搜索关键字的日志文件，如何快速获取 Top 10 的搜索关键词呢？ ▍方法选择 1、一般用 MapReduce 去解决，解决思想：请跳转《哈希算法》中的数据分片的应用解决方法。 2、如果是单机操作，上述方法就不能使用了。 ▍分析： 1、关键词是用户重复输入搜索的，首先要统计关键词出现的次数，选用一些支持快速实现增、删、改、查的数据结构（散列表、平衡二叉树等）。 2、散列表来实现，顺序遍历 10 亿关键词。散列表中不存在插入数据计数1，存在关键字就+1. 3、建立一个大小为 10 的小顶堆，遍历散列表，关键词出现的次数和顶堆进行比较，如大于顶堆元素，删除顶堆元素，插入这条数据。 ▍附加条件： 10 亿的关键词很多，假如我们不重复的关键词为 1 个亿，每个搜索关键词的长度为 50 个字节，需要 5 G 的内存空间，散列表需要避免冲突，不会选择太大的装载因子，所以消耗内存空间更多。假设机器只有 1 G 的存储空间，无法一次性将数据加载到内存中。 ▍改进： 1、使用哈希算法的相同数据经过哈希算法得到相同的哈希值一样的特性，通过这一个特性，将 10 亿个关键词通过哈希算法分片到 10 个文件中。 2、创建 10 个空文件，00,01,02…09，遍历 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后同 10 取模， 3、每个文件只有 1 亿个关键词，去掉重复的也就是 1000 万个，每个关键词平均 50 字节，所以总的大小为 500 MB，1 G的内存空间完全可以容下。 4、每个文件利用散列表和堆进行求 Top 10,然后将十个文件中的 Top10 放在一起，然后取 100 个关键词中的前十个。 九、扩展思考▍问题： 有一个访问量非常大的新闻网站，我们希望将点击量排名 Top 10 的新闻摘要，滚动显示在网站首页 banner 上，并且每1 小时更新一次。如果你是负责开发这个功能的工程师，你会如何来实现呢？ ▍解答： 1、首先，用户每点击一个新闻摘要的关键字，就通散列函数进行计数。 2、每过一个小时就遍历计算出散列表中的点击次数。 3、维护一个大小为 10 的小顶堆，遍历散列表中所有关键词出现的次数，与小顶堆的堆顶进行比较，如果大于堆顶元素就删除，将数据插入堆顶，否则就忽略，直到所有数据遍历完成。 ▍时间复杂度分析： 1、遍历所有新闻关键词，时间复杂度为 O(n)。 2、插入堆数据最坏时间复杂度为 O(klog2(10))——这里的 k 应该小于 n 的。 3、总体的时间复杂度为 O(n)。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【红黑树】]]></title>
    <url>%2F2019%2F01%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[为什么工程中都用红黑树这种二叉树！ 红黑树(上)一、什么是平衡二叉树 二叉树中任意一个节点的左右子树的高度相差不能大于 1。最早出现的平衡二叉树是 AVL 树。（完全二叉树、满二叉树，AVL树） 二、红黑树 1、红黑树的由来 为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。 2、红黑树（Red-Black Tree） 顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。红黑树，简称 R-B Tree。它是一种不严格的平衡二叉树。 根节点是黑色的； 每个叶子的结点都是黑色的空节点（NIL），叶子节点不存储数据； 任何相邻（上下）的结点都不能同时为红色，红色结点是被黑色结点隔开的； 每个节点，从该节点到其可达叶子节点的所有路径，都包含相同数目的黑色节点； 三、红黑树的性能分析 『平衡』可以等价为性能不退化。『近似平衡』就等价为性能不会退化的太严重。 1、怎么判断红黑树平衡？ 二叉查找树的性能（时间复杂度）跟树的高度成正比，大约是 log2n ，只要分析「红黑树的高度是否趋近于 log2n 」。 2、红黑树的复杂度分析 红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。 ■ 分析1、先将红色结点去掉，单纯的看黑色节点的高度. 2、由上图可知，红黑树变成了四叉树。 3、仅包含黑色节点的四叉树高度比包含相同节点的二叉树高度要小，完全二叉树的高度近似log2n，去掉红色结点的红黑树也就是小于 log2n。 4、因为红黑树红黑结点相隔，加入红色节点之后，红黑树的高度近似 2log2n。 补充：红黑树的高度只比高度平衡的 AVL 树的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。 四、为什么喜欢在工程中用红黑树平衡二叉查找树？ 1、其他平衡而二叉树 Treap、Splay Tree 绝大情况下操作效率非常高，但是在极端情况下时间复杂度会退化，这种极端情况虽然出现的概率不大，对于单次操作时间非常敏感。 2、AVL树是一种高度平衡二叉树，查找的效率非常高，但是AVL树为了维持这种高度平衡，每次插入、删除都要做调整，就比较复杂、耗时。所以对于比较频繁的插入、删除操作的数据集合，使用AVL树代价比较高。 3、红黑树虽然只做到了近似平衡，并不是严格的平衡，所以在维护成本上比AVL树低。 4、红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，更倾向于这种性能稳定的平衡二叉查找树。 五、扩展思考1、还有哪些支持动态地数据插入、删除、查找操作的数据结构，各自的优缺点和应用场景怎么样的？ 答： 六、联系扩展1、跳表 红黑树实现比较复杂，更倾向用跳表来代替。]]></content>
      <categories>
        <category>数据结构</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github 开源项目工作流程【git】]]></title>
    <url>%2F2018%2F12%2F25%2F%E5%B0%8F%E5%AD%A6%E7%94%9F%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%20Git%20%E4%B9%8B%E3%80%90%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿详细分享 Github 开源项目工作流程。 Github 工作流程1、fork 开源项目 克隆别人好的开源项目在自己的远程仓库。 2、Clone 开源项目 将 fork 的项目 clone 到本地仓库，拥有本地的开发环境。 3、进行修改项目内容 注意：不建议直接在 master 分支上直接修改。 ① 我们需要另外创建一个分支（并且换分支）进行修改。 1$ git checkout -b 分支名字 查看当前分支命令： 1234//查看当前本地分支$ git branch//查看远程仓库当前分支$ git branch -a 切换分支命令： 1$ git checkout 分支名 ② 更改项目某些信息 1$ git add a.text 1$ git commit -m &apos;add a.text&apos; ③ 将分支合并到主分支 1$ git checkout master //切换到主分支 合并分支到主分支 1$ git merge 分支名 ④ 将本地从仓库修改的项目同步到远程仓库中 1$ git push 4、 Pull request(提交一个请求) 向原作者提交你的项目。 ① New pull request（新建一个请求） github 这时候自动对源仓库和自己的远程仓库进行代码对比，是否存在冲突，如果有冲突就会显示 Able to merge(可以合并) 。 ② Create pull request 我们就创建一个新的请求。（在请求里边备注向原作者提交的原因或改动内容） 5、原作者就会收到一个请求 Pull request 1. ① 原作者点进去可以看到别人对自己项目提交的请求。 ② merg pull request 如果觉得他人对自己的修改有帮助，就将请求内容合并到自己当前的分支。 6、fetch 原作者的项目变动，我们仓库的项目怎么进行同步呢？ 1$ git fetch 源项目地址 master:latest (源项目的分支：自己本地项目的分支) 注意：本地项目分支也可以是主分支。（不建议直接在主分支修改） 7、merge 我们将代码 fetch 到 latest 了，接下来怎么做？ ① 切换到主分支进行 fetch 的代码合并 12$ git checkout master //切换到主分支 $ git merge 分支名 8、Push 本地仓库的代码与原作者的仓库的代码同步了，但是我们的远程仓库还没有同步,我们进行代码同步。 1$ git push]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端项目总结]]></title>
    <url>%2F2018%2F12%2F24%2F%E5%89%8D%E7%AB%AF%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B9%8B%E3%80%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[前端项目总结 JavaScript 功能总结一、页面接受数据传参页面1admin?username=xiaolu&amp;password=123 接受页面123456789101112131415var url=location.search; //获取得到 ? 之后的部分var object = new Object(); //新建一个Request对象url = decodeURI(url); //中文转码if(url.indexOf(&quot;?&quot;)!=-1)&#123; //判断url中是否存在 ? 字符 var str = url.substr(1);//截取?之后的字符串 strs= str.split(&quot;&amp;&quot;); //将字符串以符号&quot;&amp;&quot;分隔成两段 for(var i = 0; i &lt; strs.length; i++)&#123; //将每一段字符串又以&quot;=&quot;分为两段,键存储到对象 object 中去 object[strs[i].split(&quot;=&quot;)[0]] = strs[i].split(&quot;=&quot;)[1]; &#125;&#125;//通过访问对象的属性获取值username = object[username]password = object[password] 二、JS 事件监听传「字符串」参数1onclick=&apos;member_edit(\&quot; &quot;+&apos;操作员编辑&apos;+&quot; \&quot;)&apos; 传参使用转义将引号转义。 三、背景图要 (no-repeat)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小学生都能学会的 Git 之【基础设置】]]></title>
    <url>%2F2018%2F12%2F23%2F%E5%B0%8F%E5%AD%A6%E7%94%9F%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%20Git%20%E4%B9%8B%E3%80%90%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你入门 Git 版本控制工具。 Git 入门配置1、配置 user 信息123$ git config --global user.name 'your_name'$ git config --global user.email 'your_email@domain.com' config 的三个作用域： 123$ git config --local //只对某个仓库有效$ git config --global //对当前用户所有仓库有效$ git config --system //对系统所有的登录用户有效 显示 config 的配置（加 –list） 123$ git config --list --local$ git config --list --global $ git config --list --system 2、建立 Git 仓库 注意：首先切换到你想建立仓库的本地文件夹。 初始化一个git仓库1git init 仓库名 //我这里的仓库名为 git_xaiolu 1cd git_xiaolu //切换到仓库文件夹中 里边会有一个叫做 .git 的隐藏文件。 后边会讲到文件夹中每个文件有什么作用。 设置新建仓库配置① 先查看仓库的当前配置 1git config --global --list 上边信息是我们之前设置过全局仓库的配置，所以本地所有的仓库配置都是统一 username 和 email 。 问题：我们想要单独配置该仓库的信息怎么办？ 那我们使用 --local 专门配置当前仓库的配置信息。 12$ git config --local user.name &apos;xiaolu&apos; //修改 name 为 xiaolu$ git config --local user.email &apos;2645299496@qq.com&apos; //修改email为另一个邮箱地 2645299496@qq.com ② 我们再使用命令查看一下配置信息是否更改。 1git config --local --list 已更改！ ③ 添加一个名叫做 xiaolu 的文件夹 1mkdir xiaolu ④ 我们在文件夹中添加一个叫做 test.txt 文件。 1234cd xiaolu //切换到新建文件夹中vi test.txt //新建一个文件输入 : wq 保存并退出。 查看当前目录下有有没有我们刚刚创建的 test.txt 文件。 1ls ⑤ 然后提交到 git 仓库中。 1git add test.txt 这个命令的作用就是我们将 test.txt 文件提交到缓存中，还有没有真正的提交到我们创建的仓库中去。 1git status 我们可以通过上边的命令查看当前提交缓存的文件是否已经在一个叫做「暂存区」的地方。 上图说明我们的文件已经在缓存中等待用户下一步的提交了。 下面我们进行真正的提交到仓库。 1$ git commit -m &apos;add new file&apos; 这句命令具体什么意思呢？ commit提交的意思，-m 后边要加上在这次提交的备注。 如果你不写备注，你的团队是知道你提交了什么东西。一个好的备注是至关重要的。 提交成功！ ⑥ 查看我们提交的记录 1$ git log //通过此命令可以查看提交的历史记录（也就是提交日志） 我们可以在日志汇总看到提交者、提交日期、提交备注等信息。]]></content>
      <categories>
        <category>Git版本控制</category>
      </categories>
      <tags>
        <tag>Git版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【二叉树】]]></title>
    <url>%2F2018%2F12%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[什么样的二叉树适合用数组来存储！ 二叉树（上） 什么样的二叉树适合用数组来存储！ 一、树（tree）1、树的定义 树中的每个元素叫做“节点”；用来连线的关系叫做“父子关系”；没有父节点的节点叫做根节点；我们没有子节点的节点叫做叶子节点。 2、树的三个概 高度(Height)、深度(Depth)、层(Level)。 节点的高度 = 节点到叶子节点的最长路径（边数）。 节点的深度 = 根节点到这个节点所经历的边的个数。 节点的层数 = 节点深度 + 1。 树的高度 = 根节点的高度。 二、二叉树（Binary Tree）1、特点 二叉树，最多只有两个节点。 2、两种二叉树 ■ 满二叉树 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。（上图二号树） ■ 完全二叉树① 叶子节点都在最底下两层 ，最后一层的叶子节点都靠左排列。 ② 并且除了最后一层，其他层的节点个数都要达到最大。 ③ 数组存储中最省内存的一种方式。 三、如何存储一棵二叉树 理解完全二叉树，先理解如何存储一棵树。 1、两种存储方法 基于指针或者引用的二叉链式存储法。 基于数组的顺序存储法。 ■ 链式存储法 ■ 顺序存储法 ① 根节点存储在下标 i = 1 的位置。 ② 左子节点存储在下标 i * 2 = 2 的位置。 ③ 右子节点存储在 i * 2 + 1 = 3 的位置。 ■ 链式和顺序的区别 1、完全二叉树可以节省存储空间，而下边这种情况浪费了大量的存储空间。 2、数组的存储方式不像链表一样需要额外的存储指针的空间。 四、二叉树的遍历1、三种方式（递归） 二叉树的前、中、后遍历就是一个递归的过程。 前序遍历： 根节点 ——&gt; 左子树 ——&gt; 右节点 中序遍历: 左子树 ——&gt; 根节点 ——&gt; 右子树 后序遍历: 左子树 ——&gt; 右节点 ——&gt; 根节点 2、递归公式※ 递归章节链接：如何写递归代码？ 写递归代码看是否能写出递归公式，递归公式的关键就是，解决 A 问题就要假设子问题 B、C已经解决，然后看利用 B、C来解决 A。 12345678前序遍历的递推公式：preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)中序遍历的递推公式：inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)后序遍历的递推公式：postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r 3、递归代码123456789101112131415161718192021//前序遍历void preOrder(Node* root) &#123; if (root == null) return; print root // 此处为伪代码，表示打印 root 节点 preOrder(root-&gt;left); preOrder(root-&gt;right);&#125;//中序遍历void inOrder(Node* root) &#123; if (root == null) return; inOrder(root-&gt;left); print root // 此处为伪代码，表示打印 root 节点 inOrder(root-&gt;right);&#125;//后序遍历void postOrder(Node* root) &#123; if (root == null) return; postOrder(root-&gt;left); postOrder(root-&gt;right); print root // 此处为伪代码，表示打印 root 节点&#125; 4、二叉树遍历的时间复杂度 每个树的结点需要遍历一遍，所以二叉树遍历时间复杂度为 O(n)。 五、扩展思考1、给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？ 放到数组中存储有多少种存储方式，n! 种方式。 2、二叉树按照层的遍历方式是怎么实现的？ 图的广度优先遍历（※ 章节链接：图的广度优先遍历）的问题。 二叉树（下） 有高效的散列表（※ 章节链接：散列表）为何还需要二叉树？ 一、二叉查找树■ 定义 二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。 ■ 特点 在树的任意节点，其左子树的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。 ■ 优点 实现快速的增删改查。 二、二叉查找树的操作1、查找操作■ 查找思想 要查找数据与根节点对比，如果等于要查找的数据，返回该数据。如果数据小于根节点，左子树进行递归。否则右子树进行递归查询。 ■ 代码实现12345678910111213141516171819202122232425262728293031323334353637 public class BinarySearchTree &#123; //声明一课树 private Node tree; //定义树结点 public static class Node &#123; //树的数据节点 private int data; //树的左子树 private Node left; //树的右子树 private Node right; //构造传值 public Node(int data) &#123; this.data = data; &#125; &#125; //查找树操作 //参数为要查找的数据 public Node find(int data) &#123; //给树赋值 Node p = tree; //如果这棵树不为空 while (p != null) &#123; //树的根节点与要查找数据进行比较 //如果小于根节点，就在左子树查找 if (data &lt; p.data) p = p.left; //如果大于节点，就在右子树查找 else if (data &gt; p.data) p = p.right; //否则等于根节点 else return p; &#125; //如果次树为空，则返回null return null; &#125;&#125; 2、插入操作■ 插入思想 如果插入的数据比结点大，并且节点的右子树为空，就将新数据插到右节点的位置，否则就递归遍历右子树，查找插入位置。如果数据小于根节点，那么就插入到左子树。 ■ 代码实现1234567891011121314151617181920212223242526272829public void insert(int data) &#123; if (tree == null) &#123; tree = new Node(data); return; &#125; Node p = tree; //如果树不为空 while (p != null) &#123; //如果插入的数据大于根节点的数据 if (data &gt; p.data) &#123; //且根节点的右子树为空 if (p.right == null) &#123; //将数据插入到右子树 p.right = new Node(data); return; &#125; //遍历下一个节点 p = p.right; // data &lt; p.data &#125; else &#123; if (p.left == null) &#123; p.left = new Node(data); return; &#125; p = p.left; &#125; &#125;&#125; 3、删除操作■ 情况一：如果删除的结点没有子节点 在父节点将指向删除结点的指针为 null。 ■ 情况二：如果删除的结点只有一个节点（左子节点或右子节点） 将父节点直接指向删除节点的子节点。 ■ 情况三：要删除的节点有两个子节点 1、首先找到该节点的右子树中最小的结点。将最小节点与删除节点进行替换。 2、删除这个最小节点，因为最小节点没有左子树。 ■ 删除节点改进 单纯的将将要删除的结点标记为已删除，但不是真正的删除，单数删除的结点还是存储到内存空间中，比较浪费内存，但是删除操作就变得很简单了。 ■ 代码实现123456789101112131415161718192021222324252627282930313233public void delete(int data) &#123; Node p = tree; // p 指向要删除的节点，初始化指向根节点 Node pp = null; // pp 记录的是 p 的父节点 while (p != null &amp;&amp; p.data != data) &#123; pp = p; if (data &gt; p.data) p = p.right; else p = p.left; &#125; if (p == null) return; // 没有找到 // 要删除的节点有两个子节点 if (p.left != null &amp;&amp; p.right != null) &#123; // 查找右子树中最小节点 Node minP = p.right; Node minPP = p; // minPP 表示 minP 的父节点 while (minP.left != null) &#123; minPP = minP; minP = minP.left; &#125; p.data = minP.data; // 将 minP 的数据替换到 p 中 p = minP; // 下面就变成了删除 minP 了 pp = minPP; &#125; // 删除节点是叶子节点或者仅有一个子节点 Node child; // p 的子节点 if (p.left != null) child = p.left; else if (p.right != null) child = p.right; else child = null; if (pp == null) tree = child; // 删除的是根节点 else if (pp.left == p) pp.left = child; else pp.right = child;&#125; 4、查找最大节点和最小节点■ 查找最大节点1234567891011121314/*** 时间:2019/2/24* 功能:寻找最大节点*/public Node findMax() &#123; //如果树为空树,直接返回 if(tree == null) return null; //否则遍历右子树寻找最大点 Node p = tree; while(p.right != null) &#123; p = p.right; &#125; return p;&#125; ■ 查找最小节点12345678910111213/*** 时间:2019/2/24* 功能:寻找最小节点*/public Node findMin() &#123; if(tree == null) return null; //否则遍历左子树寻找最大点 Node p = tree; while(p.left != null) &#123; p = p.left; &#125;return p;&#125; 5、查找前驱结点和后继节点■ 代码实现12 6、输出有序数据序列 二叉查找树(二叉排序树)，中序遍历二叉树。时间复杂度为 O(n)。 三、二叉查找树存储对象 在实际开发，用二叉查找树存储多个字段的对象，以对象的某个值来构建二叉查找树，其他字段叫做卫星数据。 1、存储相同的值■ 方法一： 二叉查找树中每一个节点不仅会存储一个数据，因此通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储到同一个节点上。 ■ 方法二： ① 插入数据时，将相同的值作为大于根节点的值，放在该结点的右子树，继续遍历，直到结束为止。 ② 查找数据时，遇到相同值的结点，我们并不停止查找操作，我们继续在右子树进行查找，直到遇到叶子节点，停止。这样才能把键值等于要查找值的所有节点都找出来。 ③ 删除数据时，需要先查找到每个要删除的节点，然后再按前面讲的删除操作方法，依次进行删除。 四、二叉查找树的时间复杂度1、时间复杂度分析■ 最糟糕的情况 二叉查找树插入数据失去平衡，退化成单链表，查找的时间复杂度为 O(n)。 ■ 最理想的情况 完全二叉树：求查找、插入、删除操作的时间复杂度，时间复杂度其实都跟树的高度成正比，也就是O(height)，如何求n个节点的完全二叉树的高度？ ■ 具体分析 ① 高度 = 层数 - 1，转化成层来计算，第一层一个结点，第二层两个节点，第三层四个结点…… 第 K 层结点数为 2^(K-1)。 ② 完全二叉树最后一层的节点个数在 1 个到 2^(L-1) 个之间（假设最大层数是 L），把每层的节点加起来就等于 n。 123//完全二叉树n &gt;= 1+2+4+8+...+2^(L-2)+1n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1) ③ 等比数列求和，可以计算出范围 [log2(n+1), log2n +1] ，所以完全二叉树的高度小于等于 log2n 。 ■ 改进 平衡二叉树:搭建一种平衡的二叉树，树的高度接近于 logn ,插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。 五、相对于散列表，为什么还用二叉查找树呢？ 1、散列表中的数据无序存储的，输出数据需要先排序。而二叉查找树直接中序遍历，在 O(n）时间复杂度内，输出有序的数据序列。 2、散列表扩容耗时，遇到散列冲突时。性能不稳定。二叉查找树尽管不稳定，工程中最常用的是平衡二叉查找树性能非常稳定，时间复杂度稳定在 O(logn)。 3、笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。 4、 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。 5、浪费大量内存空间。为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。 六、扩展思考：如何通过编程，求出一棵给定二叉树的确切高度呢？]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【跳表1】]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E8%B7%B3%E8%A1%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[为什么 Redis 一定要用跳表来实现有序集合？而不是红黑树？ 跳表的实现 一、什么是跳表？ 用单链表来实现二分查找进行稍加修改，支持类似于“二分”的查找算法。我们把改造之后的数据结构叫做跳表。 二、优点是什么？ 支持快速的增、删、改、查，写起来也不复杂，可以完全代替红黑树。 三、怎么实现跳表？ 对单链表进行添加索引层，能够快速的实现查找某一个结点。 1、快速查找的原因 加上一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查询效率提高了不少。 2、改进 为了再改进查询效率，我们会再添加二级索引、三级索引… 3、举例 原本 65 个结点需要遍历 65 次进行查找，现在建立了五层索引，查找次数只用了 11 次。数据越多，效果越来越明显。 三、跳表的时间复杂度 跳表的时间复杂度。 1、 索引个数的计算 假设每两个结点设置一个索引，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2^k)。 2、时间复杂度分析 1、假设索引有 h 级，最高级的索引有 2 个结点，可得 n/(2^h)=2，h=log2n - 1如果包含原来的这一层，跳表的高度就是 log2n 。 2、查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn）。 3、按照前边的错音，只需要遍历 3 个就可以了，也就是 m=3 3、m = 3 是怎么来的？我们规定每层索引的节点与节点之间的只有三个结点。 4、时间复杂度 跳表的时间复杂度为 O(logn) ,和二分查找的时间复杂度是相同的。 四、跳表的空间复杂度 跳表的实现，需要存储多级索引，会消耗掉更多的存储空间。 1、结点空间分析 每个索引层需要额外的存储空间，以三个结点为例，一级索引需要 n/3 ,二级索引需要 n/9 ,以此类推。 跳表的时间复杂度为：O(n) 。 2、怎么降低跳表的空间复杂度？ 增加结点之间的间距，尽管时间复杂度没有改变，但是索引的存储空间减少了一半。不用过多的在乎这些，当单链表中的存储有很大对象的时候，索引额外的空间就可以忽略了。 五、跳表高效的动态插入和删除1、插入数据 会以时间复杂度为 O(logn) 进行查找，然后以 O(1) 进行插入数据。 2、删除数据 删除也是使用同样的方法来解决，删除的同时一定要获取前驱结点，但是记住，删除数据的同时要删除索引。 六、跳表索引动态更新 我们不断的往跳表中添加数据，导致某一个结点数据很多。极端情况下，会退化成单链表。 1、动态更新 通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第K 级这 K 级索引中。 2、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * 跳表的一种实现方法。 * 跳表中存储的是正整数，并且存储的是不重复的。 * * Author：ZHENG */public class SkipList &#123; private static final int MAX_LEVEL = 16; private int levelCount = 1; private Node head = new Node(); // 带头链表 private Random r = new Random(); public Node find(int value) &#123; Node p = head; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; &#125; if (p.forwards[0] != null &amp;&amp; p.forwards[0].data == value) &#123; return p.forwards[0]; &#125; else &#123; return null; &#125; &#125; public void insert(int value) &#123; int level = randomLevel(); Node newNode = new Node(); newNode.data = value; newNode.maxLevel = level; Node update[] = new Node[level]; for (int i = 0; i &lt; level; ++i) &#123; update[i] = head; &#125; // record every level largest value which smaller than insert value in update[] Node p = head; for (int i = level - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; update[i] = p;// use update save node in search path &#125; // in search path node next node become new node forwords(next) for (int i = 0; i &lt; level; ++i) &#123; newNode.forwards[i] = update[i].forwards[i]; update[i].forwards[i] = newNode; &#125; // update node hight if (levelCount &lt; level) levelCount = level; &#125; public void delete(int value) &#123; Node[] update = new Node[levelCount]; Node p = head; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; update[i] = p; &#125; if (p.forwards[0] != null &amp;&amp; p.forwards[0].data == value) &#123; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; if (update[i].forwards[i] != null &amp;&amp; update[i].forwards[i].data == value) &#123; update[i].forwards[i] = update[i].forwards[i].forwards[i]; &#125; &#125; &#125; &#125; // 随机 level 次，如果是奇数层数 +1，防止伪随机 private int randomLevel() &#123; int level = 1; for (int i = 1; i &lt; MAX_LEVEL; ++i) &#123; if (r.nextInt() % 2 == 1) &#123; level++; &#125; &#125; return level; &#125; public void printAll() &#123; Node p = head; while (p.forwards[0] != null) &#123; System.out.print(p.forwards[0] + " "); p = p.forwards[0]; &#125; System.out.println(); &#125; public class Node &#123; private int data = -1; private Node forwards[] = new Node[MAX_LEVEL]; private int maxLevel = 0; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); builder.append("&#123; data: "); builder.append(data); builder.append("; levels: "); builder.append(maxLevel); builder.append(" &#125;"); return builder.toString(); &#125; &#125;&#125; 七、为什么 Redis 要用跳表来实现有序集合，而不是红黑树？1、Redis 中的有序集合支持的核心操作主要有下面这几个 插入一个数据； 删除一个数据； 查找一个数据； 按照区间查找数据（比如查找值在 [100, 356] 之间的数据）； 迭代输出有序序列。 2、跳表比红黑树的优势 1、查找操作比红黑树要快。 2、插入、删除和红黑树差不多，但是按照区间查找O(logn)就能完成。 2、跳表更容易代码实现，意味着可读性好，不容易出错。 3、跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。 3、红黑树的优势 红黑树直接拿来用就可以了，跳表必须自己实现。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【散列表】]]></title>
    <url>%2F2018%2F11%2F28%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E6%95%A3%E5%88%97%E8%A1%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[Word文档中的单词拼写检查功能是如何实现的？ 散列表（一）一、什么是散列表 散列表的英文也叫做 “Hash Table”,平时我们叫他 “哈希表” 或者 “Hash表”。散列表用的是「数组支持下标随机访问的特性」，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说没有数组就没有散列表。 二、散列表的特点 散列思想：把数组下标叫做键（key）或者关键字，把数组中的值转化为数组的下标的映射方法叫做散列函数（”Hash”函数或者“哈希函数”），通过散列函数计算得到的值叫做散列值（“Hash值” “哈希值”）。 三、散列表的优点（随机访问） 1、散列表就是利用数组支持下标随机访问，时间复杂的O（1）的特性，通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应的下标位置。 2、通过键值查询数据元素的时用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取数据。 四、散列表的缺点（散列冲突）1、散列冲突 即使再完美的散列表也会出现散列冲突的情况。 2、开放寻址法 当我们遇到散列冲突的时候，就重新探测一个空闲位置，将其插入。 ■ 优点 ① 散列表都存储在数组中，可以有效的利用 CPU 缓存加快查询速度。 ② 序列化起来简单，链表包含指针，序列化起来没那么容易。（？） ■ 缺点 ① 删除数据的时候比较麻烦，需要特殊的标记已经删除的数据。 ② 开放寻址所有的数据存储到一个数组中，比起链表法来说，冲突的代价更高。 ③ 使用开放寻址的散列表，转载因子不能太大，这种方法比链表法更浪费内存空间。 ■ 两种探测方法 1、线性探测 插入操作 ​ 插入数据，若位置被占用，则从当前位置开始往后依次寻找空闲位置，直到插入。 查找操作 查找元素，如果求得的元素不相等，我们就依次向后查找。 删除操作 前提：通过线性探测，找到一个空闲位置，我们就认定散列表不存在该值。 方法：将删除的元素标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下测。 2、二次探测和双重散列 ① 所谓的二次探测，跟线性探测很像，线性探测每次探测步长为1，而二次探测是原来的二次方。它探测的下标序列就是 hash(key)+0，hash(key)+1²hash(key)+2²… ② 所谓的双重散列，不仅要使用一个散列函数，我们要使用一组散列函数，先用一组散列函数计算得到存储位置，如果已经被占用，就再用第二个散列函数，以此类推，直到找到空闲存储位置。 3、装载因子 表示散列表空位的多少。装载因子越大，空闲位置越少，冲突越多，散列表的性能就会下降。 1散列表的装载因子 = 填入表中的元素个数 / 散列表的长度 3、链表法 当插入数据的时候，计算出散列表的槽位，将其插入到槽位后对应的链表中。 1、插入的时间复杂度为 O(1)。 2、查找、删除的时间复杂度为O(k) 。 ■ 优点 ① 链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创键，并不需要提前申请好。 ② 链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适合装载因子小于1 的情况。接近1时就会有可能大量的散列冲突，导致大量的探测、再散列等。链表法只不过是链表变长了，查找效率有所下降，比起顺序查找还是快很多。 ■ 缺点 ① 链表的因为需要存储指针，所以对于比较小的对象存储，是比较消耗内的。可能让内存进行翻倍。 ② 因为链表的结点是散列的分布到内存的，不是连续的，对 CPU 不友好。 五、散列函数1、定义 散列函数，把它定义成 hash（key）,其中 key 表示元素的键值，hash（key）的值表示经过散列函数计算得到的散列值。 2、散列函数的设计要求① 散列函数计算得到的散列值是一个非负整数； 解释：数组下标是从 0 开始的。 ② 如果 key1 = key2,那 hash（key） == hash（key2）; 解释：相同的 key 的到的散列值也相同。 ③ 如果 key1 ≠ key2,那 hash（key） ≠ hash（key2）; 解释：有可能不能达到此要求，因为会有散列冲突现象。 六、应用思考：Word文档中的单词拼写检查功能是如何实现的？ 答：常见的英文单词有 20 万个左右，假设单词的平均长度是 10 个单词，平均一个单词占用 10 个字节的内存空间，20 万大约占用 2 MB，这个大小完全可以存储的开，我们用散列表来实现。当用户输入单词的时候，我们拿着单词去散列表中查找，如果查找到了，则说明拼写正确，如果没有，则拼写错误，基于提示。 七、扩展思考1、假设我们有 10 万条 URL 访问日志，如何按照访问次数给URL 排序？ 答：首先，我们遍历这 10 万条数据，URL 为 key，访问次数是value，将他们存入散列表。然后借助排序算法中的快排。 2、有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？ 答：先以第一个数组为例建立一个散列表，key 字符串，value 全部设置为 0，另一个数组中的字符串作为 key 在散列表中进行查找，如果可以找到，则为两个数组共同的字符串。 散列表（二）一、何为工业级的散列表 支持快速的查询、插入、删除操作； 内存占用合理。不能浪费过多的内存空间； 性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况。 二、如何实现这样一个散列表？ 设计一个合适的散列函数 定义装载因子阈值，并且设计动态扩容策略 选择合适的散列冲突解决方法 1、如何设计散列函数？ 散列表设计不能太复杂；散列函数生成的值尽可能的随机并且均匀分布。 数据分析（重点） 直接寻址法 平方取中法 折叠法 随机数法 2、如何根据装载因子动态扩容 散列表的装载因子越大，散列表中的元素越多，空闲位置越少，散列冲突的概率越大。多次寻址导致消耗很长时间，链表法导致拉很长的链，查找过程非常慢。 ■ 静态数据 很容易根据特点设计出合适的散列表。 ■ 动态数据 随着数据不断的插入，装载因子不断的慢慢变大，到达一定程度的时候，散列冲突不得不发生。 动态扩容 我设置一定的阈值来进行散列空间的扩容，在装载因子小于某个值的时候进行缩容，超过某个阈值进行扩容。 两个问题 扩容过大，导致内存浪费。 散列空间过小，导致三列散列冲突。 两个方法 如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值； 如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。 二、如何避免低效地扩容？1、什么是低效的扩容？ 当装载因子到达阈值时，需要先进行扩容，再插入数据，在这个种极端的情况下插入数据会非常慢。 2、怎么解决低效的扩容？ 当达到装载因子阈值之后，申请新空间，但是不进行数据搬移，当有新数据插入的时候，从老散列表拿出数据往新的散列表进行插入。重复此过程，在极端的情况下复杂度也是O（1）。 三、如何选择冲突解决方法？ 最常用解决冲突的方法为链表法和开放寻址法。 java中的 LinkedHashMap 就采用了链表法解决冲突。 而 ThreadLocalMap 就采用了线性探测的开放寻址法来解决冲突。 1、开放寻址法■ 优势： ① 散列表都存储在数组中，可以有效的利用 CPU 缓存加快查询速度。 ② 序列化起来简单，链表包含指针，序列化起来没那么容易。（？） ■ 缺点： ① 删除数据的时候比较麻烦，需要特殊的标记已经删除的数据。 ② 开放寻址所有的数据存储到一个数组中，比起链表法来说，冲突的代价更高。 ③ 使用开放寻址的散列表，转载因子不能太大，这种方法比链表法更浪费内存空间。 ■ 适用条件： 当数据量比较小、装载因子小的时候，适合采用开放寻址法。 2、链表法■ 优势： ① 链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创键，并不需要提前申请好。 ② 链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适合装载因子小于1 的情况。接近1时就会有可能大量的散列冲突，导致大量的探测、再散列等。链表法只不过是链表变长了，查找效率有所下降，比起顺村查找还是快很多。 ■ 缺点： ① 链表的因为需要存储指针，所以对于比较小的对象存储，是比较消耗内的。可能让内存进行翻倍。 ② 因为链表的结点是散列的分布到内存的，不是连续的，对 CPU 不友好。 ■ 改进： 我们将链表法中的链表改造为其他高效动态的数据结构，比如跳表、红黑树。这样，即便出现的散列冲突，极端情况下，所有数据都散列到同一个桶内，最终退化成的散列表的查询时间也只不过是O(logn)。 ■ 适用条件： 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。 五、举例：工业级散列表 HashMap1、初始化大小 HashMap默认的初始化大小16，当然这个默认值可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始化大小，减少动态扩容的次数，这样大大提高HashMap的性能。 2、装载因子和动态扩容 最大转载因子是0.75，当 HashMap 中的元素个数超过0.75 * capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都是原来的两倍大小。 3、散列冲突解决方法 使用链表法来解决冲突的。负载因子和散列函数设计的再合理，也避免不了会出现拉链过长的情况，一旦拉链过长，则会影响 HashMap 的性能。 4、对链表法的优化 当链表长度太长（默认超过8）时，链表就转化成了红黑树，利用红黑树快速增删改查的特点，提高HashMap的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。 散列表（三）一、LRU 缓存淘汰算法1、淘汰数据 维护一个按照访问时间从大到小有序排序的链表结构。因为缓存大小有限，我们遍历整个链表，当缓存空间不足时，需要淘汰一个数据，直接将头部的结点删除。 2、缓存数据 当缓存某个数据的时候，先在链表中查找这个数据，如果没有找到，直接将数据添加到尾部，如果找到了，将它移动到尾部。再遍历链表的时候需要遍历整个链表，时间复杂度为O(n)。 3、主要操作 一下三种操作都涉及“查找”操作，时间复杂度为 O(n)，我们将链表和散列表两种数据结构组合到一起，将复杂度降为O(1)。 往缓存添加一个数据 从缓存删除一个数据 在缓存查找一个数据 4、散列表和(双向)链表结合 除了双向链表存储数据之外，我们还有一个 hnext 指针，一个链是在我们的双向链表中，另一个hnext是我们散列表的拉链。hnext指针将我们的链表串在散列表中。 ① 查找一个数据 散列表查找数据的时间复杂度为 O(1)，查找到之后，我们将其移动到双链表的为尾部。 ② 删除一个数据 我们通过散列表在O(1)的时间复杂度之内找到数据之后，然后通过前驱指针O(1)的时间复杂度，直接获取双向链表前驱结点，删除只需要O(1)的时间复杂度。 ③ 添加一个数据 添加数据先要查看缓存中有没有该数据，如果没有就添加到双链表的尾部，添加的时候判断缓存有没有满，如果满了，需要先删除链表头部的数据，然后将数据插入到链表的尾部。如果没有满，就直接插到链表的尾部。 二、Redis 有序集合 为什么 Redis 要用跳表来实现有序集合，而不是红黑树？ 1、Redis 中的有序集合支持的核心操作主要有下面这几个 插入一个数据； 删除一个数据； 查找一个数据； 按照区间查找数据（比如查找值在 [100, 356] 之间的数据）； 迭代输出有序序列。 2、跳表比红黑树的优势 1、查找操作比红黑树要快。 2、插入、删除和红黑树差不多，但是按照区间查找O(logn)就能完成。 2、跳表更容易代码实现，意味着可读性好，不容易出错。 3、跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。 3、红黑树的优势 红黑树直接拿来用就可以了，跳表必须自己实现。 三、LinkedHashMap LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。 代码实例：12345678910111213// 10 是初始大小，0.75 是装载因子，true 是表示按照访问时间排序HashMap&lt;Integer, Integer&gt; m = new LinkedHashMap&lt;&gt;(10, 0.75f, true);m.put(3, 11);m.put(1, 12);m.put(5, 23);m.put(2, 22);m.put(3, 26);m.get(5);for (Map.Entry e : m.entrySet()) &#123; System.out.println(e.getKey()); //打印顺序为 1235&#125; 实现原理与LRU 缓存淘汰策略一样的，按照此分析。 四、为什么散列表经常和链表使用原因一： 1、虽然散列表可以非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。 2、它无法按照某种顺序快速的遍历数据，如果希望按照顺序遍历散列表中的数据，那我们就将散列表中的数据拷贝到数组中，然后排序，再遍历。 原因二： 因为散列表是动态数据结构，不停的进行插入、删除。每当我们进行遍历数据的时候，先要进行排序，那效率就会很低。 五、思考1、如果把双向链表改成单链表，还能否正常工作呢？为什么呢？ 答: 可以，但是删除操作时间复杂度会降到 O（n）。 2、假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作： 根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息； 答：散列表实现，时间复杂度为 O（1）。 查找积分在某个区间的猎头 ID 列表； 答：跳表。 查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。 答：需要排序，暂时无法实现。（？？？？？） 六、疑问 1、散列表和链表是怎么关联起来的？ 2、散列表怎么直接定位到结点的？答：散列表中存储少量的链表。 3、查找数据将其移动到尾部？答：需要维护一个指向尾部的指针。 4、插入的时候，内存已满，需要在链表头部插入数据，散列表对应的值是否也应该改变？]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax 全面解析]]></title>
    <url>%2F2018%2F11%2F15%2FAjax%20%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[小鹿带你全面了解 Ajax 。 Ajax 全面解析一、Ajax 概念介绍1、Ajax-XMLHttpRequest 对象的创建 IE5 和 IE6 不支持 new 一个 XMLHttpRequest 的，我们使用时需要进行判断。 123456var request;if(window.XMLHttpRequest)&#123; request = new XMLHttpRequest();//IE7+&#125;else&#123; request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE6.IE5&#125; 2、XMLHttpRequest 发送请求① open(method,url,async) method :发送请求的方法 （Post、Get） url : 请求地址（相对地址/绝对地址） async : 是否异步处理（同步或者异步） 实例： 3、XMLHttpRequest 取得相应 responseText: 获取字符串形式的响应数据 responseXML: 获取 XML 形式的响应数据 status 和 statusText : 以数字和文本形式返回 HTTP 状态码 getAllResponseHeader (): 获取所有的响应报头 getResponseHeader ():查询响应中的某个字段的值 监听服务器响应状态：readyState 属性 0：请求未初始化，open 还没有调用 1：服务器连接已建立，open 已经调用 2：请求已接收，也就是接收到头信息了 3：请求处理中，也就是接收到响应主体了 4：请求已完成，且响应已就绪，也就是响应完成了]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【排序】]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[冒泡排序、插入排序、选择排序、归并排序、快速排序、桶排序、计数排序、基数排序！ [TOC] 一、如何分析一个“排序算法”1、排序算法的执行效率 最好、最好、平均时间复杂度 分析三种复杂度，还要分析出最好、最坏时间复杂度对应的要排列的原始数据是什么样的。 时间复杂度的系数、常数、低阶 时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。数据规模可能很小，10、100、1000，我们就必须把系数、常数、低阶考虑进来。 比较次数和交换（或移动）次数 基于比较的排序算法的执行过程，会涉及到比较和交换。如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。 2、排序算法的内存消耗 算法的内存消耗可以通过空间复杂度来衡量。 原地排序算法 就是指特定空间复杂度是 O(1) 的排序算法。 稳定排序算法 如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。 例子： 稳定排序，电商系统按照金额的排序，相同金额按时间早晚排序（先排时间，后排金额 [相同的后操作紫自动调整]）。 二、插入排序、冒泡排序、选择排序 O(n²)1、冒泡排序■ 冒泡排序思路 每次冒泡对相邻的两个元素进行比较，看是否满足大小关系，不满足就进行互换，一次冒泡会让至少一个元素移动到它应该在的位置。有 n 个数据，需要重复 n 次。 ■ 冒泡排序优化 当某次冒泡过程已经没有数据交换时，说明已经达到完全有序，不用再执行后续的冒泡操作。 ■ 冒泡排序是原地排序算法吗？ 答：是 分析：冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。 ■ 冒泡排序是稳定的排序算法吗？ 答：是 分析：当有相邻的两个元素大小相等的时候，我们不做交换，所以冒泡排序是稳定的排序算法。 ■ 冒泡排序的时间复杂度是多少？ 最好的情况是数据已经排好序，我们只进行一次冒泡排序就可以了，最好时间复杂度为 O(n) 。最坏的情况是，要排序的数据刚好是倒序排列的，我们只进行 n 此冒泡操作，所以最坏的时间复杂度为 O(n²)。平均时间复杂度为 O(n²)。 ■ 代码实现 123456789101112131415161718// 冒泡排序，a 表示数组，n 表示数组大小public void bubbleSort(int[] a, int n) &#123; if (n &lt;= 1) return; for (int i = 0; i &lt; n; ++i) &#123; // 提前退出冒泡循环的标志位 boolean flag = false; for (int j = 0; j &lt; n - i - 1; ++j) &#123; if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; // 表示有数据交换 &#125; &#125; if (!flag) break; // 没有数据交换，提前退出 &#125;&#125; 2、插入排序■ 插入排序思想 将数据分为两个区间，未排序和已排序区间。初始化已排序只有一个元素（默认第一个），从未排序选出元素找到合适位置有序的插入，直到结束位置。 ■ 插入排序是原地排序算法吗？ 答：是。 分析：插入排序的运算并不需要额外的存储空间，所以空间复杂度是 O（1），是一个原地排序算法。 ■ 插入排序是稳定的排序算法吗？ 答：是。 分析： 对于值相同的元素，我们会将后边出现的元素插入到前边出现的元素的后边，所以插入排序是稳定排序。 ■ 插入排序的时间复杂度是多少？ 最好的情况就是数据元素已经排好序，最好的时间复杂度为 O（1）。如果数组是倒序的，最坏的时间复杂度是 O（n²）。在数组中插入数据的平均时间复杂度为 O（n），对于插入排序来说我们每次就相当于数组插入一个新的数据，循环执行n次插入数据，所以平均时间复杂度为 O（n²）。 ■ 插入排序代码实现 12345678910111213141516171819// 插入排序，a 表示数组，n 表示数组大小（从小到大进行排序）public void insertionSort(int[] a, int n) &#123; //如果数组大小为 1 直接返回 if (n &lt;= 1) return; //否则进行插入排序 for (int i = 1; i &lt; n; ++i) &#123; int value = a[i]; int j = i - 1; // 查找插入的位置 for (; j &gt;= 0; --j) &#123; if (a[j] &gt; value) &#123; a[j+1] = a[j]; // 数据移动 &#125; else &#123; break; &#125; &#125; a[j+1] = value; // 插入数据 &#125;&#125; 3、选择排序■ 选择排序算法思想 将在未排序期间寻找到最小的数据，并将其放到已排好区间的元素的尾部。 ■ 选择排序是原地排序算法吗? 答： 原地排序算法。 分析： 数组中的两个元素需要相互交换，需要用一个变量来存储交换值，选择排序的空间复杂度为O（1），所以，是一种原地排序算法。 ■ 选择排序是稳定的排序算法吗？ 答 ：不是。 分析：选择排序每次都要找到剩余未排序元素的最小值，并和前边的元素交换位置，这样破坏了稳定性。所以说，选择排序是一种不稳定的排序算法。 ■ 选择排序的时间复杂度是多少？ 最好的时间复杂度为 O（1），最坏的情况就是 O(n²)。平均时间复杂度就是 O（n²） 4、希尔排序 插入排序有很大的优化思路，进而有了希尔排序。 5、思考：为什么插入排序比冒泡排序更受欢迎 移动次数：冒泡排序和插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。 代码实现：，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。 1234567891011121314//冒泡排序中数据的交换操作：if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true;&#125;//插入排序中数据的移动操作：if (a[j] &gt; value) &#123; a[j+1] = a[j]; // 数据移动&#125; else &#123; break;&#125; 三、归并排序、快速排序 O(nlogn)1、归并排序■ 核心思想 假入排序一个数组，先把数组从中间分成前后两个部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就有序了。 ■ 实现过程 使用分治思想，分治思想用递归来实现，分析写出递归公式，找出终止条件，最后将递推公式翻译成递归代码。 ■ 递推公式 12345递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))终止条件：p &gt;= r 不用再继续分解 ■ 递归代码 123456789101112131415161718// 归并排序算法, A 是数组，n 表示数组大小merge_sort(A, n) &#123; merge_sort_c(A, 0, n-1)&#125;// 递归调用函数merge_sort_c(A, p, r) &#123; // 递归终止条件 if p &gt;= r then return // 取 p 到 r 之间的中间位置 q q = (p+r) / 2 // 分治递归 merge_sort_c(A, p, q) merge_sort_c(A, q+1, r) // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r] merge(A[p...r], A[p...q], A[q+1...r])&#125; ■ 合并函数（merge函数）+ 哨兵思想 仿照两个有序数组的合并。 12345678910111213141516171819202122232425merge(A[p...r], A[p...q], A[q+1...r]) &#123; var i := p，j := q+1，k := 0 // 初始化变量 i, j, k var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组 while i&lt;=q AND j&lt;=r do &#123; if A[i] &lt;= A[j] &#123; tmp[k++] = A[i++] // i++ 等于 i:=i+1 &#125; else &#123; tmp[k++] = A[j++] &#125; &#125; // 判断哪个子数组中有剩余的数据 var start := i，end := q if j&lt;=r then start := j, end:=r // 将剩余的数据拷贝到临时数组 tmp while start &lt;= end do &#123; tmp[k++] = A[start++] &#125; // 将 tmp 中的数组拷贝回 A[p...r] for i:=0 to r-p do &#123; A[p+i] = tmp[i] &#125;&#125; ■ 代码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.test.xiaolu;/** * 归并排序 * @author 小鹿 * */public class MergeSort &#123; public static void main(String[] args) &#123; MergeSort mSort = new MergeSort(); int[] a = new int[] &#123;4,3,7,2,9,1&#125;; mSort.mergeSort(a,0,a.length-1); for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i]); &#125; &#125; /** * 功能:递归分治数据 * @param a 要分治的数组 * @param p 数组起始位置 * @param r 数组终止位置 */ public void mergeSort(int[] a,int p,int r) &#123; //终止条件 if(p &gt;= r) return; //取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值 int q = p + (r - p)/2; //递归分治 mergeSort(a,p,q); mergeSort(a,q+1,r); //两个有序数组的合并 merge(a, p, q, r); &#125; /** * 功能: 合并 mergr * @param a 要合并的数组 * @param p 数组起始的下标 * @param q 第二个数组起始的下标 * @param r 数组结束的下标 */ public void merge(int[] a,int p,int q,int r) &#123; int i = p,j = q+1,k = 0; int[] temp = new int[r-p+1]; //两个有序数组合并 while(i &lt;= q &amp;&amp; j &lt;= r) &#123; if(a[i] &lt;= a[j]) &#123; temp[k++] = a[i++]; &#125;else &#123; temp[k++] = a[j++]; &#125; &#125; int s = i; int e = q; if(j &lt;= r) &#123; s = j; e = r; &#125; //剩余的数据添加到尾部 while(s &lt;= e) &#123; temp[k++] = a[s++]; &#125; //将 temp 数据搬移到原数组 for (int l = 0; l &lt;= r-p; l++) &#123; a[p+l] = temp[l]; &#125; &#125;&#125; ■ 性能分析 归并排序是否是稳定排序算法？ 答：是的。 分析：只看 merge 合并函数，如果有两个相同的元素，当然先放排在最前边的元素，两个相同元素的位置不变，所以说，归并排序是稳定排序。 归并排序是否是原地排序算法？ 1、不能用递归思想了，用完系统直接释放掉了。 2、merge 额外的空间 temp。在任意时刻，CPU 只有一个函数在使用，也就是说我们呢开辟一个 n 大小数组空间就可以了，空间复杂度为 O(n)。因此，归并排序不是原地排序算法。 归并排序的时间复杂度是多少？ 答：O(nlogn)。 分析： 1、 A 问题分为 B 问题和 C 问题，时间复杂度为 B 问题加上 C 问题再加上合并的时间。 2、假设对 n 个元素进行归并排序的时间复杂度为 T(n) 。分解两个子数组的时间为 2*T(n/2)。合并两个有序子数据的时间复杂度为 n(n)，我们就可以推导出时间复杂度的计算公式。 121T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。O(n) = 2T(n) = 2*T(n/2) + n； n&gt;1 1234567T(n) = 2*T(n/2) + n = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n ...... = 2^k * T(n/2^k) + k * n ...... 可以推导出 T(n) = 2^kT(n/2^k)+kn ，当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n ，我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。所以归并排序的时间复杂度为 O(nlogn) 。 稳定性 归并排序和原始数据的有序程度无关，所以时间复杂度与是非常稳定的。 2、快速排序■ 核心思想 有一组数据，数组中的下标是 p 到 r 。在 p 到 r 之间任意选择一个数据作为 pivot (区分点)。大于区分点的放到右边（q+1 到 r），小于区分点的放到左边（p 到 q-1），将 pivot 数据放中间。 ■ 递推公式 12345递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)终止条件：p &gt;= r ■ 代码实现 12345678910111213// 快速排序，A 是数组，n 表示数组的大小quick_sort(A, n) &#123; quick_sort_c(A, 0, n-1)&#125;// 快速排序递归函数，p,r 为下标quick_sort_c(A, p, r) &#123; if p &gt;= r then return // 获取分区点（一般情况，选择最后一个元素） q = partition(A, p, r) quick_sort_c(A, p, q-1) quick_sort_c(A, q+1, r)&#125; ■ partition() 分区函数 12345678910111213141516171819private static int partition(int[] a, int p, int r) &#123; int pivot = a[r]; int i = p; for(int j = p; j &lt; r; ++j) &#123; if (a[j] &lt; pivot) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; ++i; &#125; &#125; int tmp = a[i]; a[i] = a[r]; a[r] = tmp; System.out.println("i=" + i); return i;&#125; 注意：要想实现原地排序，不能用两个数组的合并了，必须在数组内完成，所以有了下边的操作。 交换技巧 如果插入数据，数据搬移，非常耗时。上述的数据插入正是一种交换的技巧，在 O(1) 时间内进行插入小于pirot 的位置。 ■ 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.test.xiaolu;/** * 功能:快速排序 * @author 小鹿 * */public class QuickSort &#123; public static void main(String[] args) &#123; QuickSort quickSort = new QuickSort(); int[] a = new int[] &#123;4,3,7,2,9,1&#125;; quickSort.quickSort(a, 6); for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i]+" "); &#125; &#125; public void quickSort(int a[],int n) &#123; quickSortInternally(a,0,n-1); &#125; /** * 功能:快速排序递归函数 * @param a 数组 * @param i 起始位置 * @param j 终止位置 */ private void quickSortInternally(int[] a, int p, int r) &#123; //终止条件 if(p &gt;= r) return; //获取区分点 pivot int q = partition(a, p, r); //区分点两端开始递归 quickSortInternally(a,p,q-1); quickSortInternally(a,q+1,r); &#125; /** * 功能:获取区分点 * @param a 数组 * @param p 起始位置 * @param r 终止位置 * @return 返回区分点 */ public int partition(int[] a,int p,int r) &#123; //将最后一个元素作为区分点 int pivot = a[r]; int i = p; for (int j = p; j &lt; r; ++j) &#123; if(a[j] &lt; pivot) &#123; //确保 i 永远指向第一个大于 pivot 的数 if(i == j) &#123; i++; &#125;else &#123; int tmp = a[i]; a[i++] = a[j]; a[j] = tmp; &#125; &#125; &#125; int temp = a[i]; a[i] = a[r]; a[r] = temp; System.out.println("i=" + i); return i; &#125;&#125; ■ 性能分析 快排是否为稳定排序算法？ 答：不是。 分析：排序函数 partition 随机的位置，交换会导致相同元素位置会发生改变，所以快排是不稳定算法。 快排是否为原地排序算法？ 答：是的。 分析：在空间复杂度 O(1) 内进行对数据的排序，所以是原地排序算法。 快排的复杂度分析？ 最好时间复杂度：O(nlogn)。 分析：每次选择的 pivot 合适，正好将区间一分为二，但是不切合实际情况。 最坏时间复杂度： O(n2) 。 一个有序数据，每次分区点都是最后一个，需要进行 n 次分区才能完成快排，每次分区扫描 n/2 个元素，时间复杂度退化到 O(n2) 。 平均时间复杂度：O(nlogn)。 分析：快排的大部分情况的时间复杂度为 O(nlogn)，只有极端情况为 O(n²) , 有很多方法可以降低这种极端情况下的概率。 4、归并排序和快速排序的区别 1、归并排序数据的有序性是从下到上的，而快速排序的数据有序性是从上到下的。 2、归并排序是稳定的排序算法（和数据的有序性无关），但是不是原地排序算法，合并不能在原地执行，空间复杂度为O(n)。 3、快速排序解决了归并排序占用太多内存空间的问题，在原地就可以实现排序。 6、思考：如何用快排思想在 O(n) 内查找第 K 大元素？■ 实现思路 求某数据中第 K 大数据，先将 r[n-1] 作为区分点划分，如果 p+1 = k，则 a[p] 就是要找到的数据（数组下标从 0 开始的）。如果 k &lt; p+1 第 k 大数据在 [0，p] 之间，如果 k &gt; p+1 ,第 k 大数据在 [p+1,r] 之间。进而继续划分查找。 ■ 代码实现 ■ 复杂度分析 每次查找都是数据的一半，所以查找的时间复杂度就是（n/2+n/4+n/8+… = 2n-1）,O(n)。另一种方法是每次寻找数据中的最小值放到数据的首部，查找 n 次就可以了，时间复杂度为 K*n,当 k 小的时候可以，当 k 为 n/2 或者 n 的时候，时间复杂度退化成 O（n²）; 7、扩展提高现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？ 同时指向10个文件的第一条数据，进行比较选出最小时间戳的数据放入新文件，一次类推，有 n个数据需要比较 n 次，时间复杂度为 O(n) ，空间复杂度为 O(1) 。 四、桶排序、计数排序、基数排序1、桶排序（Bucket sort）■ 算法思想 对每个桶划定范围，将数据分别放到不同的桶中进行排序，然后依次取出每个桶中的数据，组成的序列就是有序的了。 ■ 时间复杂度分析 答：O(n)。 分析：假设有 n 个数据，分到 m 个桶中，每个桶中平均放 k=n/m 。每个桶中的数据以时间复杂度 O(k logk) 进行排序，m 个桶时间复杂度为 mk*logk ,因为 k = n/m ,所以时间复杂度为 O(n*log(n/m)) 。当桶的个数趋近于数据的个数的时候（m-&gt;n），桶排序的时间复杂度为 O(n)。 ■ 适用条件 1、桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。 2、各个桶内的数据必须是均匀分布的。在极端情况下，分布到同一个桶中，时间复杂度退化到 O(nlogn)。 ■ 实例分析 问题 有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？ 解决思路 步骤一： 扫描一遍文件，假设订单金额数据范围，最小 1 元，最高 10 万元。然后划定金额平均分到 100 个桶中，每个桶中 1 - 1000 ，以此类推。然后从 0 编号，到 99 号桶。 步骤二： ① 情况一：平均分配到桶中。 每个桶进行快速排序，100 个桶排好之后，依次按照编号进行取出数据。 ② 情况二：不平均分配每个桶。 每个桶中的数据各不相同，有的桶中的数据会大于内存，继续划分桶内数据多的，比如 1 - 1000 比较多，我们划分 10 个区间，然后进行快速排序。 2、计数排序（Counting sort）■ 算法思想 计数排序是桶排序的一种特殊情况，当要排序 n 个数据的时候，所处的范围并不大，最大值为 K ，将数据划分为 K 个桶，每个桶内的值都是相同的，省去了桶内排序的时间。 ■ 适用条件 ① 计数排序应用于数据范围不大的场景中，如果数据范围 k 要比排序的数据 n 大很多，就不适用了。 ② 计数排序只能给非负整数排序，可以再不改变相对大小的情况下，转化为非负整数。 ■ 算法过程 实例分析 有八个考生，分数分别再0-5之间，将这八个考生的成绩放入到数组A【8】中，它们分别是 2，5，3，0，2，3，0，3 。 步骤 ① 给定一组数据 ，先寻找数组中的最大值 max。（上述中是 5） ② 再新定义一个数组 C[max+1] ，将其初始化为 0。（计数数组，下标对应着分数 0-5 分） ③ 将遍历所有的数据根据下标（分数）统计的相同分数的学生个数放入到对应下标分数的数组 C 。 ④ 对数组 C 中存储的相同分数学生的个数顺序依次求和，重新放回数组 C 中。 ⑤ 从数组 A[8] 中，倒序依次取数据做判断，根据数组中存取的数据与数组 C 找下标相同的数据，C 中与该分数相同的数字下标存储的就是当前包括该分数在内的小于该分数的学生个数。 ⑥ 我们将新定义一个数组R，其实该个数就是该学生的排名，放在 R 数组中就需要 -1 （毕竟数组是从 0 开始的）。 ⑦ 依次倒序遍历上述的数组 A 中的数据，重复上述过程，直到将数据排好序，将排序结果复制到 A 数组中。 ■ 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。public void countingSort(int[] a, int n) &#123; // 判断数组是否有数据 if (n &lt;= 1) return; // 1、查找数组中数据的最大值，给定范围 int max = a[0]; for (int i = 1; i &lt; n; ++i) &#123; if (max &lt; a[i]) &#123; max = a[i]; &#125; &#125; // 2、申请一个计数数组 c，下标大小 [0,max] int[] c = new int[max + 1]; for (int i = 0; i &lt;= max; ++i) &#123; c[i] = 0; &#125; // 3、计算每个元素的个数，放入 c 中 for (int i = 0; i &lt; n; ++i) &#123; c[a[i]]++; &#125; // 4、依次累加 for (int i = 1; i &lt;= max; ++i) &#123; c[i] = c[i-1] + c[i]; &#125; // 5、6、临时数组 r，存储排序之后的结果 int[] r = new int[n]; for (int i = n - 1; i &gt;= 0; --i) &#123; int index = c[a[i]]-1; r[index] = a[i]; c[a[i]]--; &#125; // 7、将结果拷贝给 a 数组 for (int i = 0; i &lt; n; ++i) &#123; a[i] = r[i]; &#125;&#125; ■ 实际实例 在高考中怎么知道自己排名？假如有 50 万考生，最高分是 900 分，最低分是 0 分，我们就划分为 901 个桶。将 50 万的学生成绩分别放到这 901 个桶中。然后遍历桶中的数据依次放入一个数组中，那么就排好序了！ ■ 技巧扩展 1、如果是小数，精确到小数点后一位，先将所有数据乘以 10，转化成整数，再放到 9010 个桶中。 2、如果排序的数据有负数，数据范围为【-1000,1000】，需要先对每个数据加 1000，转化成非负数。 3、基数排序（Radix sort）■ 算法思路 借助稳定排序算法，先将低位的进行排序（或相同数据），然后以此类推。 ■ 适用条件 1、数据分割成 “位” 来比较，位之间有递进关系。 2、每一位的数据范围不能太大，否则无法做到时间复杂度为 O(n) 了。 ■ 时间复杂度 如果要排序的数据有 k 位，就要进行 k 次桶排序或者计数排序，总时间复杂度为 O(K*n)。当 K 不大的时候，基数排序的复杂度就接近于 O(n)。 ■ 举例分析 问题 对十万个手机号从小到大进行排序。 解决 先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。 ■ 扩展思考 给牛津的 20 万单词进行排序。单词长短不齐，我们补充 0 ，因为所有字母都大于 “0”,不会影响顺序，然后进行基数排序。 4、思考：如何根据年龄给 100 万用户排序？ 答：桶排序 分析： 假设年龄范围为 1 到 120 岁，分为 120 个桶并编号 0 - 119，将 100 万数据放到相对应的桶中，然后依次按照桶的编号取出数据，这样都得到了 100 万的数据，时间复杂度为 O(n)。]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【递归】]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E9%80%92%E5%BD%92%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿整理的递归调用的知识架构体系。 目录[TOC] 一、递归满足的三个条件 用一下三个条件来判断是否可以用递归来解决。 一个问题可不可以分解为多个问题的解。 该问题是否和子问题的求解思路相同。 该问题是否有终止条件。 二、如何编写递归代码 将问题分解为子问题。 然后寻找递归终止条件。 写出递推公式。 最终转化成递归代码。 三、怎么理解递归 1、如果试图想清楚递归的每个步骤，会让我们陷入思维误区，从而导致我们出现理解障碍。 2、我们应该这样想：假设问题 A 可以分解为 B、C、D 三个子问题，我们可以假设 B、C、D已经解决了，在此基础上考虑问题 A。我们只需要思考问题 A 和 问题 B、C、D 的关系即可，从而屏蔽掉递归细节。 四、递归的特点优点： 递归是一种高效、简洁的编码技巧，只要满足递归的三个条件我们就可以用递归代码来解决。 缺点：1、 问题一：递归警惕堆栈溢出■ 具体问题 因为函数的调用是使用栈来保存临时变量的，每调用一个函数，我们就将临时的变量压入栈中，等函数执行完成之后，然后临时变量才出栈。因为我们的系统栈或者虚拟机栈空一般都不会很大，如果我们的递归规模很大，调用层次很深，递归过程中，函数的临时变量一直压入栈，导致堆栈溢出。 1Exception in thread "main" java.lang.StackOverflowError ◆ 如何避免堆栈溢出？ 我们采用在代码中限制递归深度来解决，比如超过递归深度 1000 我们就不在往下递归，直接返回错误。 不足点： 因为允许最大递归深度跟当前线程剩余的栈空间大小有关，事先计算栈的大小。如果实时计算，代码过于复杂，影响代码的可读性。只能说对于比较小的递归深度可以用这种方法。 2、问题二：递归警惕重复计算■ 具体问题 如果我们有个递归代码是 f(n) = f(n-1) + f(n-2)，当 n 分别为 4 和 5 的时候，我们都要计算两次 f(3) 值，导致了递归重复计算，从而影响效率。 ◆ 如何解决？ 我们可以借助散列表来保存已经求解过的值，当我们递归计算该值的时候，我们先在散列表查找是否已经记录过该值，如果求解过了，我们就从散列表中取值，不需要递归重复计算。 12345678910111213public int f(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n) if (hasSolvedList.containsKey(n)) &#123; return hasSovledList.get(n); &#125; int ret = f(n-1) + f(n-2); hasSovledList.put(n, ret); return ret;&#125; 3、问题三：递归的高空间复杂度 递归代码里有很多的函数带哦用，每次调用都要在栈中保存数据，因为在栈中保存数据都要额外的考虑这部分的开销，比如最简单的递归 f(n) = f(n-1)+1 ,空间辅助度并不是 O(1)，而是 O(n) 。 五、递归代码转换为非递归代码 递归有缺点也有优点，实际开发中，我们还是需要是否采用递归来实现。 ■ 递归： 递归是借助系统的栈和虚拟机的栈来实现的，所有的递归代码都可以用非递归代码来表示。 ■ 非递归： 非递归代码实现递归代码，只不过是用手动模拟入栈、出栈的过程，所以看上去并不是递归代码的样子。 不足： 非递归实现并没有解决递归的弊端，徒劳的增加了实现的复杂度。 六、递归的掌握程度1、编程实现斐波那契数列求值 f(n)=f(n-1)+f(n-2）2、编程实现求阶乘 n!3、编程实现一组数据集合的全排列]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美|【复杂度分析】]]></title>
    <url>%2F2018%2F09%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你体验数据结构之美！ 数据结构与算法之美 要想真正的学习一门有多么难多么简单的技术也好，知识也好首先我们要有一个正确的学习方法。 最普通不过的就是从三问来入手，也就是一下三种。 为什么 是什么 怎么学 为什么要学习数据结构与算法? 想要通关大厂面试，千万别让数据结构和算法拖了后腿 很多大公司，比如 BAT、Google、Facebook，面试的时候都喜欢考算法、让人现场写代码。有些人虽然技术不错，但每次去面试都会“跪”在算法上，很是可惜。那你有没有想过，为什么这些大公司都喜欢考算法呢？校招的时候，参加面试的学生通常没有实际项目经验，公司只能考察他们的基础知识是否牢固。 业务开发工程师，你真的愿意做一辈子 CRUD boy 吗？ 如果你能弄明白这些底层原理，你就能更好地使用它们。即便出现问题，也很容易就能定位。因此，掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。 基础架构研发工程师，写出达到开源水平的框架才是你的目标！ 我觉得，高手之间的竞争其实就在细节。这些细节包括：你用的算法是不是够优化，数据存取的效率是不是够高，内存是不是够节省等等。这些累积起来，决定了一个框架是不是优秀。所以，如果你还不懂数据结构和算法，没听说过大 O 复杂度分析，不知道怎么分析代码的时间复杂度和空间复杂度，那肯定说不过去了，赶紧来补一补吧！ 对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！ 何为编程能力强？是代码的可读性好、健壮？还是扩展性好？我觉得没法列，也列不全。但是，在我看来，性能好坏起码是其中一个非常重要的评判标准。但是，如果你连代码的时间复杂度、空间复杂度都不知道怎么分析，怎么写出高性能的代码呢？ 有的人写代码的时候，从来都不考虑非功能性的需求，只是完成功能，凑合能用就好；做事情的时候，也从来没有长远规划，只把眼前事情做好就满足了。 我曾经面试过很多大龄候选人，简历能写十几页，经历的项目有几十个，但是细看下来，每个项目都是重复地堆砌业务逻辑而已，完全没有难度递进，看不出有能力提升。久而久之，十年的积累可能跟一年的积累没有任何区别。这样的人，怎么不会被行业淘汰呢？ 如果你在一家成熟的公司，或者 BAT 这样的大公司，面对的是千万级甚至亿级的用户，开发的是 TB、PB 级别数据的处理系统。性能几乎是开发过程中时刻都要考虑的问题。一个简单的 ArrayList、Linked List 的选择问题，就可能会产生成千上万倍的性能差别。这个时候，数据结构和算法的意义就完全凸显出来了。 其实，我觉得，数据结构和算法这个东西，如果你不去学，可能真的这辈子都用不到，也感受不到它的好。但是一旦掌握，你就会常常被它的强大威力所折服。 小结 我们的目的是建立时间复杂度、空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维， 如何抓住重点，系统高效地学习数据结构算法？ 什么是数据结构？什么是算法？ 从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。 学习的重点在什么地方？ 想要学习数据结构与算法，首先要掌握一个数据结构与算法中最重要的概念——复杂度分析。 这个概念究竟有多重要呢？可以这么说，它几乎占了数据结构和算法这门课的半壁江山，是数据结构和算法学习的精髓。 数据结构和算法学着 20 个知识点就够了 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树； 10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。 学习技巧 我还给你分享了我总结的一些学习技巧，比如边学边练、多问、多思考，还有两个比较通用的学习方法，打怪升级法和沉淀法。掌握了这些学习技巧，可以让你学习过程中事半功倍。 03 | 由浅入深学数据结构和算法 由浅入深的计划 为了由浅入深地带你学习，分成四个递进的模块。 入门篇时间、空间复杂度分析是数据结构和算法中非常重要的知识点，贯穿整个专栏的学习过程。但同时也是比较难掌握的，所以我用了 2 节课来讲这部分内容，而且还举了大量的实例，让你一边学一边练，真正能掌握复杂度分析，为后面的学习铺路。 我希望通过这一模块，你能掌握时间、空间复杂度的概念，大 O 表示法的由来，各种复杂度分析技巧，以及最好、最坏、平均、均摊复杂度分析方法。之后，面对任何代码的复杂度分析，你都能游刃有余、毫不畏惧！ 基础篇这部分是专栏中篇幅最大的内容，也是我们学习的重点，共有 26 节内容，涵盖了最基础、最常用的数据结构和算法。针对每种数据结构和算法，我都会结合具体的软件开发实例，由浅入深进行讲解，并适时总结一些实用“宝典”，保证你印象深刻、学有所用。 比如递归这一节，我会讲到，为什么递归代码比较难写？如何避免堆栈溢出？如何避免递归冗余计算？如何将递归代码转化为非递归代码？ 高级篇这部分我会讲一些不是那么常用的数据结构和算法。虽然不常用，但是这些内容你也需要知道。设置这一部分的目的，是为了让你开拓视野，强化训练算法思维、逻辑思维。如果说学完基础部分可以考 80 分，那掌握这一部分就能让你成为尖子生！ 实战篇我们整个专栏都是围绕数据结构和算法在具体软件实践中的应用来讲的，所以最后我会通过实战部分串讲一下前面讲到的数据结构和算法。我会拿一些开源项目、框架或者系统设计问题，剖析它们背后的数据结构和算法，让你有一个更加直观的感受。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reach]]></title>
    <url>%2F2018%2F09%2F14%2FReact%2F</url>
    <content type="text"><![CDATA[小鹿带你一起学 React。 React 详细教程React 安装首先安装 Node.js在Node.js 使用 npm 包管理工具来安装React步骤一：安装全局的 React ，在哪里都可以创建 React 文件1npm install -g create-react-app 注意：如果是 max 系统 在命令前增加 sudo 全局。 步骤二：在你的文件夹中创建项目（脚手架）1create-react-app 项目名 步骤三：切换到该目录下，可以启动该项目1npm start Rect基础入门文件结构和 JSX 语法React的目录结构在 Package.json 配置文件中的一些依赖包。 &quot;react&quot;: &quot;^16.5.2&quot; 为 React 库 &quot;react-dom&quot;: &quot;^16.5.2&quot;将一些 JSX 语法渲染到 DOM中 &quot;react-scripts&quot;: &quot;1.1.5&quot; JSX 语法 React 使用 JSX 来替代常规的 JavaScript，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 优点： JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。 它是类型安全的，在编译过程中就能发现错误。 使用 JSX 编写模板更加简单快速。 使用 JSXJSX 看起来类似 HTML ，我们可以看下实例: 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;example&apos;)); 添加自定义属性需要使用 data- 前缀。 1234567&lt;div&gt; &lt;h2&gt;欢迎学习 React&lt;/h2&gt; &lt;p data-myattribute = &quot;somevalue&quot;&gt;这是一个很不错的 JavaScript 库!&lt;/p&gt;&lt;/div&gt;,document.getElementById(&apos;example&apos;)); React 组件的作用自定义组件名：HelloMessage 方法一：用函数来自定义创建组件 123456789101112131415function HelloMessage(props) &#123; return &lt;h1&gt;Hello World!&lt;/h1&gt;;&#125;//ES6语法函数定义//const HelloMessage = () =&gt; &#123;// return &lt;h1&gt;Hello World!&lt;/h1&gt;;//&#125; const element = &lt;HelloMessage /&gt;; ReactDOM.render( element, document.getElementById(&apos;example&apos;)); 方法二：使用 ES6 class 来定义一个组件: 创建一个模块 Person 123456789101112import React from &apos;react&apos;;import &apos;./Person.css&apos;;const person = ( ) =&gt; &#123; return ( &lt;div className=&quot;Person&quot;&gt; &lt;h1&gt;你好，我是,我已经拥有本书&lt;/h1&gt; &lt;/div&gt; )&#125;export default person;//暴露接口 其他文件调用 12345678910import Person from &apos;./Person/Person&apos;;//导入class App extends Component &#123; render() &#123; &lt;div&gt; &lt;Person /&gt; &lt;/div&gt; &#125;&#125;export default App; 调用自定义组件 123456import App from &apos;./App&apos;;ReactDOM.render( &lt;App /&gt;, document.getElementById(&apos;root&apos;)); 注意：原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。 组件 - 模块间通信在创建组件的 render（）函数中，调用模块函数的同时加入传值 12345678class App extends Component &#123; render() &#123; &lt;div&gt; &lt;Person name=&quot;张三&quot;/&gt; &lt;Person&gt;我是闭合标签，可以通过props.children获取&lt;/Person&gt; &lt;/div&gt; &#125;&#125; 12345678910111213import React from &apos;react&apos;;import &apos;./Person.css&apos;;const person = (props) =&gt; &#123; return ( &lt;div className=&quot;Person&quot;&gt; &lt;h1&gt;你好，我是&#123;props.name&#125;,我已经拥有本书&lt;/h1&gt; &lt;p&gt;&#123;props.children&#125;&lt;/p&gt; &lt;/div&gt; )&#125;export default person;//暴露接口 State 状态123456789101112131415161718192021222324252627282930class App extends Component &#123;state = &#123; persons:[ &#123;name:&quot;逯相强&quot;,count:1&#125;, &#123;name:&quot;Heimal&quot;,count:2&#125;, &#123;name:&quot;Aim&quot;,count:3&#125;, ], anything:&quot;张三&quot;, showPersons:false&#125;//定义一个函数switchNmmeHandle = (newName) =&gt;&#123; // console.log(&quot;你好&quot;); this.setState(&#123; persons:[ &#123;name:newName,count:1&#125;, &#123;name:&quot;Heimal&quot;,count:222&#125;, &#123;name:&quot;Aim&quot;,count:3&#125;, ] &#125;) &#125; render() &#123; &lt;button onClick=&#123;() =&gt; this.switchNmmeHandle(&quot;米修&quot;)&#125;&gt;更改&lt;/button&gt; &lt;div&gt; &lt;Person name=&#123;this.state.persons[0].name&#125; /&gt; &lt;/div&gt; &#125;&#125;export default App; state 与 props 的区别：state ：用于改变组件内容状态的值（动态） props：用于组件通信进行传值 属性传值1234567891011 class App extends Component &#123; render() &#123; &lt;div&gt; &lt;Person myClick=&#123;this.switchNmmeHandle.bind(this,&quot;米修missu&quot;)&#125; /&gt; &lt;/div&gt; &#125;&#125;export default App; 1234567891011const person = ( props) =&gt; &#123; return ( &lt;div className=&quot;Person&quot;&gt; &lt;h1 onClick=&#123;props.myClick&#125;&gt;你好，我是&#123;props.name&#125;,我已经拥有&#123;props.count&#125;本书&lt;/h1&gt; &lt;p&gt;&#123;props.children&#125;&lt;/p&gt; &lt;/div&gt; )&#125;export default person; 双向数据绑定123456789101112import React from &apos;react&apos;;import &apos;./Person.css&apos;;const person = ( props) =&gt; &#123; return ( &lt;div&gt; &lt;input type=&quot;test&quot; onChange=&#123;props.changed&#125; defaultValue=&#123;props.name&#125;&gt;&lt;/input&gt; &lt;/div&gt; )&#125;export default person; 12345678910111213141516171819202122 class App extends Component &#123; changedNameHandler = (event)=&gt;&#123; this.setState(&#123; persons:[ &#123;name:event.target.value,count:1&#125;, &#123;name:&quot;Heimal&quot;,count:222&#125;, &#123;name:&quot;Aim&quot;,count:3&#125;, ] &#125;)&#125; render() &#123; &lt;div&gt; &lt;Person changed=&#123;this.changedNameHandler&#125; name=&#123;this.state.persons[0].name&#125; count=&#123;this.state.persons[0].count&#125; /&gt; &lt;/div&gt; &#125;&#125;export default App; 组件样式的两种方式方式一： 在 CSS 文件中设置，然后倒入引用 Person.css: 12345678.Person&#123; width: 60%; margin: 16px auto; border: 1px solid #eee; box-shadow: 0 2px 3px #ccc; padding: 16px; text-align: center;&#125; Person.js引用 12345678import &apos;./Person.css&apos;;//用 className &lt;div className=&quot;Person&quot;&gt; &lt;h1 onClick=&#123;props.myClick&#125;&gt;你好，我是&#123;props.name&#125;,我已经拥有&#123;props.count&#125;本书&lt;/h1&gt; &lt;p&gt;&#123;props.children&#125;&lt;/p&gt; &lt;input type=&quot;test&quot; onChange=&#123;props.changed&#125; defaultValue=&#123;props.name&#125;&gt;&lt;/input&gt; &lt;/div&gt; 方式二：1234567891011121314151617class App extends Component &#123;state = &#123; persons:[ &#123;name:&quot;逯相强&quot;,count:1&#125;, &#123;name:&quot;Heimal&quot;,count:2&#125;, &#123;name:&quot;Aim&quot;,count:3&#125;, ], anything:&quot;张三&quot;, showPersons:false&#125;render( return( //引用样式 &lt;button style=&#123;style&#125; onClick=&#123;this.switchNmmeHandle.bind(this,&quot;missu&quot;)&#125;&gt;更改&lt;/button&gt; ))&#125; React的 if 分支 在React中的if判断使用的三元运算符 使用代码抽离，大大减少代码的冗余度。 12345678910111213141516171819202122232425262728class App extends Component &#123; render ( let person = null; if(this.state.showPersons)&#123; person = ( &lt;div&gt; &lt;Person changed=&#123;this.changedNameHandler&#125; name=&#123;this.state.persons[0].name&#125; count=&#123;this.state.persons[0].count&#125; /&gt; &lt;Person myClick=&#123;this.switchNmmeHandle.bind(this,&quot;米修missu&quot;)&#125; name=&#123;this.state.persons[1].name&#125; count=&#123;this.state.persons[1].count&#125; /&gt; &lt;Person name=&#123;this.state.persons[2].name&#125; count=&#123;this.state.persons[2].count&#125; &gt;你们好，欢迎购买书籍&lt;/Person&gt; &lt;/div&gt; ) return ( &lt;div className=&quot;App&quot;&gt; //调用 &#123;person&#125; &lt;/div&gt; ) &#125; React - 使用循环 使用ES6语法 1234567891011&lt;div&gt; &#123; this.state.persons.map((person,index) =&gt;&#123; return &lt;Person myClick=&#123;() =&gt; this.delectPersonHandler(index)&#125; key=&#123;person.id&#125; name=&#123;person.name&#125; count=&#123;person.count&#125;/&gt; &#125;) &#125; &lt;/div&gt; React 使用循环输出每个值都要有一个 key 与之对应，要映射到虚拟的 DOM 上，虚拟的DOM和真实的DOM通过key对应起来。 React 动态改变样式和添加类名1style.backgroundColor = &apos;red&apos; 12345678910111213141516// const classes = [&quot;red&quot;,&quot;bold&quot;].join(&quot; &quot;); const classes = []; if(this.state.persons.length &lt;= 2 )&#123; classes.push(&quot;red&quot;); &#125; if(this.state.persons.length &lt;= 1 )&#123; classes.push(&quot;bold&quot;); &#125; return ( &lt;h1&gt;Hello Word!&lt;/h1&gt; &lt;p className=&#123;classes.join(&quot; &quot;)&#125;&gt;Hello React&lt;/p&gt;//通过数组来动态改变值 &lt;/div&gt; ); 定义的css样式 1234567.red&#123; color: red;&#125;.bold&#123; font-weight: bold;&#125; React 的项目目录结构React元素渲染 元素是构成 React 应用的最小单位，它用于描述屏幕上输出的内容。 1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。 将元素渲染到 DOM 中首先我们在一个 HTML 页面中添加一个 id=”example” 的 : 1&lt;div id=&quot;example&quot;&gt;&lt;/div&gt; 要将React元素渲染到根DOM节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上： 12345const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;ReactDOM.render(element,document.getElementById(&apos;example&apos;)); 更新元素渲染React 元素都是不可变的。当元素被创建之后，你是无法改变其内容或属性的。 目前更新界面的唯一办法是创建一个新的元素，然后将它传入 ReactDOM.render() 方法： 实例： 12345678910111213function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;example&apos;) );&#125;setInterval(tick, 1000); 以上实例通过 setInterval() 方法，每秒钟调用一次 ReactDOM.render()。 我们可以将要展示的部分封装起来，以下实例用一个函数来表示： 语法： 123456789101112function Clock(props) &#123; return ( );&#125;function tick() &#123; ReactDOM.render( );&#125;setInterval(tick, 1000); 实例： 123456789101112131415function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById(&apos;example&apos;) );&#125;setInterval(tick, 1000); 除了函数外我们还可以创建一个 React.Component 的 ES6 类（需要使用 this.props 替换 props ） 语法： 12345678910111213class Clock extends React.Component &#123; render() &#123; return ( ); &#125;&#125;function tick() &#123; ReactDOM.render( );&#125;setInterval(tick, 1000); 实例： 1234567891011121314151617class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById(&apos;example&apos;) );&#125;setInterval(tick, 1000); 独立文件你的 React JSX 代码可以放在一个独立文件上，例如我们创建一个 helloworld_react.js 文件，代码如下： 1234&lt;body&gt;&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot; src=&quot;helloworld_react.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; JavaScript 表达式们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中。实例如下： 1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;&#123;1+1&#125;&lt;/h1&gt; &lt;/div&gt;,document.getElementById(&apos;example&apos;)); 在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false. 1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;&#123;i == 1 ? &apos;True!&apos; : &apos;False&apos;&#125;&lt;/h1&gt; &lt;/div&gt;,document.getElementById(&apos;example&apos;)); 样式 React 推荐使用内联样式。,我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px 。 12345678var myStyle = &#123; fontSize: 100, color: &apos;#FF0000&apos;&#125;;ReactDOM.render( &lt;h1 style = &#123;myStyle&#125;&gt;菜鸟教程&lt;/h1&gt;, document.getElementById(&apos;example&apos;)); 注释注释需要写在花括号中，实例如下： 1234567ReactDOM.render(&lt;div&gt;&lt;h1&gt;哈哈哈&lt;/h1&gt;&#123;/*注释...*/&#125;&lt;/div&gt;,document.getElementById(&apos;example&apos;)); 数组12345678var arr = [ &lt;h1&gt;react&lt;/h1&gt;, &lt;h2&gt;学的不仅是技术，更是梦想！&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById(&apos;example&apos;)); 参数传递函数定义的组件：props.name 12345678910function HelloMessage(props) &#123; return &lt;h1&gt;Hello &#123;props.name&#125;!&lt;/h1&gt;;&#125; const element = &lt;HelloMessage name=&quot;Runoob&quot;/&gt;; ReactDOM.render( element, document.getElementById(&apos;example&apos;)); ES6创建的组件：this.props.name 123456789101112131415class HelloMessage extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125; HelloMessage.defaultProps = &#123; name: &apos;Runoob&apos; &#125;; const element = &lt;HelloMessage/&gt;; ReactDOM.render( element, document.getElementById(&apos;example&apos;) ); 复合组件1234567891011121314151617181920212223function Name(props) &#123; return &lt;h1&gt;网站名称：&#123;props.name&#125;&lt;/h1&gt;;&#125;function Url(props) &#123; return &lt;h1&gt;网站地址：&#123;props.url&#125;&lt;/h1&gt;;&#125;function Nickname(props) &#123; return &lt;h1&gt;网站小名：&#123;props.nickname&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Name name=&quot;菜鸟教程&quot; /&gt; &lt;Url url=&quot;http://www.runoob.com&quot; /&gt; &lt;Nickname nickname=&quot;Runoob&quot; /&gt; &lt;/div&gt; );&#125; ReactDOM.render( &lt;App /&gt;, document.getElementById(&apos;example&apos;)); React State(状态) React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。 以下实例创建一个名称扩展为 React.Component 的 ES6 类，在 render() 方法中使用 this.state 来修改当前的时间。 12345678910111213141516171819class Clock extends React.Component &#123;//构造函数 constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;example&apos;)); 将生命周期方法添加到类中 在具有许多组件的应用程序中，在销毁时释放组件所占用的资源非常重要。 ① 每当 Clock 组件第一次加载到 DOM 中的时候，我们都想生成定时器，这在 React 中被称为挂载。 ② 每当 Clock 生成的这个 DOM 被移除的时候，我们也会想要清除定时器，这在 React 中被称为卸载。 1234567891011121314151617181920212223class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; //生成定时器 componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; //卸载定时器 componentWillUnmount() &#123; clearInterval(this.timerID); &#125; //给stata赋值 tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125;&#125; 实例解析： ① componentDidMount()与 componentWillUnmount()方法被称作生命周期钩子。 ② 在组件输出到 DOM 后会执行 componentDidMount()钩子，我们就可以在这个钩子上设置一个定时器。 ③ this.timerID为计算器的 ID，我们可以在 componentWillUnmount()钩子中卸载计算器。 代码执行顺序： 当 &lt;Clock /&gt; 被传递给 ReactDOM.render() 时，React 调用 Clock 组件的构造函数。 由于 Clock 需要显示当前时间，所以使用包含当前时间的对象来初始化 this.state 。 我们稍后会更新此状态。 React 然后调用 Clock 组件的 render() 方法。这是 React 了解屏幕上应该显示什么内容，然后 React 更新 DOM 以匹配 Clock 的渲染输出。 当 Clock 的输出插入到 DOM 中时，React 调用 componentDidMount() 生命周期钩子。 在其中，Clock 组件要求浏览器设置一个定时器，每秒钟调用一次 tick()。 浏览器每秒钟调用 tick() 方法。 在其中，Clock 组件通过使用包含当前时间的对象调用 setState() 来调度UI更新。 通过调用 setState()，React 知道状态已经改变，并再次调用 render() 方法来确定屏幕上应当显示什么。 这一次，render() 方法中的 this.state.date 将不同，所以渲染输出将包含更新的时间，并相应地更新 DOM。 一旦 Clock 组件被从 DOM 中移除，React 会调用 componentWillUnmount() 这个钩子函数，定时器也就会被清除。 State 和 Props以下实例演示了如何在应用中组合使用 state 和 props 。我们可以在父组件中设置 state， 并通过在子组件上使用 props 将其传递到子组件上。在 render 函数中, 我们设置 name 和 site 来获取父组件传递过来的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041class WebSite extends React.Component &#123; constructor() &#123; super(); this.state = &#123; name: &quot;菜鸟教程&quot;, site: &quot;https://www.runoob.com&quot; &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;Name name=&#123;this.state.name&#125; /&gt; &lt;Link site=&#123;this.state.site&#125; /&gt; &lt;/div&gt; ); &#125;&#125; class Name extends React.Component &#123; render() &#123; return ( &lt;h1&gt;&#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125; class Link extends React.Component &#123; render() &#123; return ( &lt;a href=&#123;this.props.site&#125;&gt; &#123;this.props.site&#125; &lt;/a&gt; ); &#125;&#125; ReactDOM.render( &lt;WebSite /&gt;, document.getElementById(&apos;example&apos;));]]></content>
      <categories>
        <category>Reach</category>
      </categories>
      <tags>
        <tag>Reach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView详细解析]]></title>
    <url>%2F2018%2F09%2F14%2FWebView%20%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Android WebView详细解析。 Android WebView详细解析简介 WebView是一个基于webkit引擎、展现web页面的控件。 作用 WebView 控件功能强大，除了具有一般 View 的属性和设置外，还可以对url请求、页面加载、渲染、页面交互进行强大的处理。 显示和渲染 Web 页面 直接使用 html 文件（网络上或本地 assets 中）作布局 可和 JavaScript 交互调用 使用方法 Webview 自身的常见方法； Webview 的最常用的子类 （WebSettings 类、WebViewClient 类、WebChromeClient 类) Android 和 Js 的交互 Webview常用方法WebView的状态1234567//销毁Webview//在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview//但是注意：webview调用destory时,webview仍绑定在Activity上//这是由于自定义webview构建时传入了该Activity的context对象//因此需要先从父容器中移除 webview,然后再销毁webview:rootLayout.removeView(webView); webView.destroy(); 关于前进 / 后退网页123456789//是否可以后退Webview.canGoBack() //后退网页Webview.goBack()//是否可以前进 Webview.canGoForward()//前进网页Webview.goForward() 常见用法：Back键控制网页后退 问题：在不做任何处理前提下 ，浏览网页时点击系统的“Back”键,整个 Browser 会调用 finish()而结束自身 目标：点击返回后，是网页回退而不是推出浏览器 解决方案：在当前Activity中处理并消费掉该 Back 事件 1234567public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if ((keyCode == KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) &#123; mWebView.goBack(); return true; &#125; return super.onKeyDown(keyCode, event);&#125; 清除缓存数据常用类WebSettings 类 作用：对WebView进行配置和管理 步骤： 1、添加访问网络权限（AndroidManifest.xml） 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 2、生成一个WebView组件（有两种方式） 1234567891011//方式1：直接在在Activity中生成WebView webView = new WebView(this)//如果访问的页面中要与Javascript交互，则webview必须设置支持JavascriptwebSettings.setJavaScriptEnabled(true); //支持通过JS打开新窗口 webSettings.setJavaScriptCanOpenWindowsAutomatically(true);//方法2：在Activity的layout文件里添加webview控件：WebView webview = (WebView) findViewById(R.id.webView); 3、进行配置-利用WebSettings子类 12//声明WebSettings子类WebSettings webSettings = webView.getSettings(); WebViewClient 类 作用：处理各种通知 &amp; 请求事件 常用方法： 方法一：shouldOverrideUrlLoading() 作用：打开网页时不调用系统浏览器， 而是在本 WebView 中显示；在网页上的所有加载都经过这个方法,这个函数我们可以做很多操作。 123456789101112131415161718192021//步骤1. 定义Webview组件Webview webview = (WebView) findViewById(R.id.webView1);//步骤2. 选择加载方式 //方式1. 加载一个网页： webView.loadUrl(&quot;http://www.google.com/&quot;); //方式2：加载apk包中的html页面 webView.loadUrl(&quot;file:///android_asset/test.html&quot;); //方式3：加载手机本地的html页面 webView.loadUrl(&quot;content://com.android.htmlfileprovider/sdcard/test.html&quot;);//步骤3. 复写shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示 webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); return true; &#125; &#125;); 方法二：onPageStarted() 作用：开始载入页面调用的，我们可以设定一个 loading 的页面，告诉用户程序在等待网络响应。 123456webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; //设定加载开始的操作 &#125; &#125;); 方法三：onPageFinished() 作用：在页面加载结束时调用。我们可以关闭 loading 条，切换程序动作。 123456 webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageFinished(WebView view, String url) &#123; //设定加载结束的操作 &#125;&#125;); WebChromeClient 类 辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。 常用方法： 方法一：onProgressChanged（） 作用：获得网页的加载进度并显示 12345678910webview.setWebChromeClient(new WebChromeClient()&#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; if (newProgress &lt; 100) &#123; String progress = newProgress + &quot;%&quot;; progress.setText(progress); &#125; else &#123; &#125; &#125;) 方法二：onReceivedTitle（） 作用：获取Web页中的标题 （每个网站都有自己的标题） 123456webview.setWebChromeClient(new WebChromeClient()&#123; @Override public void onReceivedTitle(WebView view, String title) &#123; titleview.setText(title)； &#125; 如何避免WebView内存泄露？① 不在 xml 中定义 Webview ，而是在需要的时候在 Activity 中创建，并且 Context 使用 getApplicationgContext() 1234LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); mWebView = new WebView(getApplicationContext()); mWebView.setLayoutParams(params); mLayout.addView(mWebView); ② 在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。 123456789101112@Override protected void onDestroy() &#123; if (mWebView != null) &#123; mWebView.loadDataWithBaseURL(null, &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null); mWebView.clearHistory(); ((ViewGroup) mWebView.getParent()).removeView(mWebView); mWebView.destroy(); mWebView = null; &#125; super.onDestroy(); &#125;]]></content>
      <categories>
        <category>APP混合开发</category>
      </categories>
      <tags>
        <tag>APP混合开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracel 高级数据库]]></title>
    <url>%2F2018%2F09%2F05%2FOracel%20%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[小鹿带你学习 Oracel 高级数据库（企业级）。 Oracel 高级数据库入门命令01|基本命令使用超级管理员登录 :1$ sys/密码 as sysdba 用户切换到超级管理员1$ conn sys/密码 as sysdba 新建用户并设置密码：1$ create user 用户名 identified by 口令[即密码]； 删除用户：1$ drop user 用户名; 锁定用户：1$ alter user 用户名 account lock; 解锁用户：1$ alter user 用户名 account unlock; 授予用户登录的权限：1grant create session to 用户名； 授予用户操作数据库的权限：1grant resource to 用户名； 登录被创建的用户：1connect 用户名/密码 02|查询操作查询表中的年龄并分组显示：12select Tname,to_char(sysdate,&apos;yyyy&apos;)- to_char(生日日期字段，&apos;yyyy&apos;)as agefrom teacher; 查询某一字段不为空的信息：123select *from 表名where 字段名 is null; 查询日期在一个范围之内：123select *from 表名where to_char(生日日期字段，&apos;yyyy&apos;) between &apos;年月日&apos; and &apos;年月日&apos; 授予用户创建表空间的权限1grant create tablespace to user10; 授予用户修改表空间的权限、1grant unlimited tablespace to user10; 修改表空间的名字1alter tablespace tbs10 rename to tbs20; 将表空间设置为脱机装状态1alter tablespaace tbs20 offline; 先将表表空间设置为联机再设置为只读状态12alter tablespaace tbs20 online;alter tablespace tbs20 read only; 删除表空间,并删除数据文件1drop tablespace tbs20 including contents; 表的创建和管理基本步骤（整个操作在超级管理员的环境下运行的） 所有用到的表名之前要加上用户名。 登录超级管理员系统 创建用户 授权用户 创建一个表空间 创建表并添加到已创建的表空间中 基本命令使用创建表空间12SQL&gt; create tablespace 表空间名 2 datafile &apos;C:\app\Administrator\admin\orcl\tbs02.dbf&apos; size 10m; 创建表并添加到已创建的表空间中12345SQL&gt; create table 用户名.表名( 2 BT_ID char(2) primary key, 3 BT_Name varchar2(20), 4 BT_Info VARCHAR2(50) 5 ) tablespace 表空间名; 将一个表从一个表空间添加到另一个表空间中1SQL&gt; alter table 用户名.表名 move tablespace 表空间名; 创建表并设置外键12345678910create table 用户名.表名(b_id char(10) primary key,b_name varchar2(40),author varchar2(20),bt_id char(2),p_id char(4),pubdate date,price number(5,2),constraint 外键新名字 foreign key(外键) references 用户名.参照的另一个表名(主键))tablespace 表空间名; 主键约束12Alter table 设置主键的表add constraint(约束) 主键字段别名 primary key(主键字段) 外键约束123Alter table 设置外键表名add constraint(约束) 外键别名 foreign key(外键) references 用户名.参照的另一个表名(主键)on delete cascade);//级联删除 非空约束12Alter table 表名modify 字段名 not null; 删除表中的字段12Alter table 表名drop column 字段名； 添加表中的字段12Alter table 表名 add 字段名 数据类型;]]></content>
      <categories>
        <category>Oracel</category>
      </categories>
      <tags>
        <tag>Oracel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 基本命令]]></title>
    <url>%2F2018%2F09%2F04%2FLinux%20%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[小鹿带你一览 Linux 的魅力！ Shell 命令简单命令who 命令 列出所有用户正在使用系统的用户，所使用的终端名和注册系统的时间。 who -b 最近用户登陆的时间 who-H,--heading 打印出各列的标题 who -m 仅显示与stdin(标准输入)相关的主机名和用户。 who -q,--count 显示所有注册用户名和注册用户数目。 echo 命令 将命令行输入的字符输出在屏幕上 echo -n 表示输出字符之后不换行 date 命令 在屏幕上显示或设置系统的日期和时间 cal 命令显示某一个月或者某一年的日历 1$ cal 10 //将列出公元 10 年的日历 clear 命令 清除屏幕上的信息 passwd 命令 更改自己的密码 1$ Changing password for user 用户名. 控制台效果 1234(current)UNIX password:▍(输入旧密码。输入密码正确，按Enter键)Enter new UNIX password:▍(输入新密码, 然后按Enter键)Retype new UNIX password:▍(重新输入一遍新密码, 认证，最后按Enter键)passwd:all authentication tokens updated successfully.(表示修改成功) ls 命令 ls 命令列出指定目录的内容 1$ ls /home/mengqc/dir pwd 命令 显示当前目录的路径 su 命令 可更改用户的身份。 1$ su //普通用户切换到超级用户（需要输入密码） 1# su 普通用户名 //超级用户切换到普通用户 文件常用命令cat 命令 创建文件；显示文件的内容；连接两个或多个文件。 一般格式： cat [选项][FILE] 1234$ cat &gt;文件名 //输入此命令之后，用户依次输入文件内容【Enter】之后【Ctrl+D】结束输入$ cat m1 //显示文件的内容$ cat m1 m2 //显示两个文件内容$ cat m1 m2 &lt; file //合并两个文件m1、m2合并后的文件名为 file more 命令 显示文件的内容，每次显示一屏 less 命令 分屏显示文件内容 head 命令 显示文件的前十行 tail 命令 在屏幕上显示指定文件FILE 的末尾 10 行 123$ tail mfile //显示文件的最后十行$ tail -n +20 mfile //显示文件内容从20行到文件末尾$ tail -c 10 mfile //显示文件mfile的最后十个字符 文件及其类型文件概念文件 文件通常存放到外存，可以作为一个独立的单位存放和实时操作（如打开、关闭、读、写） 文件的成分 索引节点：系统利用其中的信息对相应文件实时控制和管理（包括文件权限、） 数据：文件的实际内容 文件的命名 尽量反映文件的内容 可由 ASCLL 组成 文件名通配符① 星号（*） 与0个或多个任意的字符相匹配。 星号匹配的是当前目录下的所有文件，但以点（.）开头的隐含文件除外。 .*只与隐含文件匹配。 ② 问号（?） 问号只与单个任意的字符匹配。你可以使用多个问号。 ③ 方括号（[ ]） ​]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 进阶之链接数据库]]></title>
    <url>%2F2018%2F08%2F31%2F%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%20java%20%E4%B9%8B%E3%80%90%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[最常用到的 Java 之连接数据库，详细解析，保证你看了之候明明白白。 （超详细的） Java 进阶之连接数据库Java 连接之前我们需要准备好连接数据库的 jar 包，里边封装了我们需要的连接数据库的工具和类，都给我们封装好了，连接数据库就 so eary 了。 连接数据库步骤准备① 下载：在网上下载连接数据库的 jar 包，或者到我的公众号：一个不甘平凡的码农，回复：“ 数据库jar ” 就可以下载了。 ② 放到新建 libs 文件夹下：下载完之后我们将 jar 包放到我们创建的 java 项目的根目录下新建文件夹 libs 下。 ③ 加载 jar 包：虽然我们把连接数据库的 jar 包放到我们项目了，但是我们还没有加载 jar 包，也就是说代码中无法调用，我们要做的是加载 jar 包。 在项目中点击 jar 包鼠标右键，选择 Build Path → configure Build Path 出现如下页面： ④ 选择上边的第三个标签 Librarise，选择 Add External JARs… 选择需要加载的 jar，就会出现在左边栏中： ⑤ 然后选择第四个标签 Order and Export 在我们 jar 包前打钩然后保存就可以了。 写代码连接数据库新建一个j ava 类 DBOP.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*** 功能：连接数据库**/public class DBOP &#123; //加载驱动的变量 String driver="com.mysql.jdbc.Driver"; //url 包括数据库的 ip（这里用到的是本机就是localhost/127.0.0.1 ） 以及 3306端口，DBName 为你的数据库的名字 String url="jdbc:mysql://localhost:3306/DBName?useSSL=true"; //数据库的用户名 String user="root"; //数据库的密码 String password="root"; //功能：连接数据库并执行Sql语句之后关闭数据库 //参数：HashMap&lt;String,Object&gt;&gt;：map 类型变量，sql ：sql语句 public ArrayList&lt;HashMap&lt;String,Object&gt;&gt; query(String sql) throws ClassNotFoundException, SQLException&#123; //定义查询结果返回的数据在 ResultSet 集合 ResultSet resultSet=null; //定义 connection 对象 Connection connection=null; //定义执行 sql 语句的对象 Statement statement=null; //创建一个List对象，里边的类型为HashMap数据类型 ArrayList&lt;HashMap&lt;String,Object&gt;&gt;list=new ArrayList&lt;&gt;(); //加载驱动 Class.forName(driver); //接下来的连接数据库操作要在try...catch 语句中执行 try &#123; //开始尝试连接数据库（传入url（包含ip、端口、数据库名等信息），数据库用户名和密码），连接结果返回一个 Connection 对象 connection =(Connection) DriverManager.getConnection(url,user,password); //通过 connection 对象的 createStatement 方法创建一个能够执行 sql 语句的 Statement 对象 statement=(Statement) connection.createStatement(); //通过 statement 对象执行 sql 语句将执行结果返回一个 ResultSet 对象集合 resultSet=statement.executeQuery(sql); //通过 ResultSet 对象可获取到 ResultSetMetaData 对象集合(目的是可以获取到表中的字段名) ResultSetMetaData resultSetMetaData=(ResultSetMetaData) resultSet.getMetaData(); // 遍历我们的查询结果集合 resultSet，我们将查询到的每条结果封装成 map（表字段名:对应的值）放到 List 中去。 while (resultSet.next()) &#123; //如果查询结果的 resultSet 集合中还有数据就执行 while 循环 //创建一个 map 对象 HashMap&lt;String, Object&gt;map = new HashMap&lt;&gt;(); //通过for循环，将查询结果中的对应数据库表的字段名和查询值封装到map中 for(int i=0;i&lt;resultSetMetaData.getColumnCount();i++) &#123; //通过resultSetMetaData.getColumnName(i) 可获取到对应字段名 map.put(resultSetMetaData.getColumnName(i), resultSet.getObject(i)); &#125; //将每个 map 对象添加到 list 当中 list.add(map); &#125; &#125; catch (Exception e) &#123; // 连接数据库中途出错时就会执行 catch 语句块 e.printStackTrace(); &#125;finally &#123; //无论连接数据库出错还是成功，程序在最后总会执行 finally 语句（我们就在里边执行关闭数据库的操作） //关闭 resultSet 对象集合 if(resultSet!=null)&#123; resultSet.close(); &#125; //关闭 statement 执行 sql 语句的对象 if(statement!=null)&#123; statement.close(); &#125; //最后关闭数据库连接 if(connection!=null)&#123; connection.close(); &#125; &#125; //将结果集返回一个List对象，方便我们取出查询结果数据 return list; &#125;&#125; 尊重他人劳动成果，转载请说明出处：http://luxiangqiang.xn--6qq986b3xl/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java 进阶</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Next + github 搭建个人博客详细教程]]></title>
    <url>%2F2018%2F08%2F27%2FHexo%20%E4%B9%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E3%80%90%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91%2F</url>
    <content type="text"><![CDATA[每个程序员必不可少的就是博客网站了，一开始我们并不知道可以搭建属于自己的个人博客网站，通常会在CSDN、博客园等别人搭建的博客网站写博客，当你写久了以后会感觉很 low, 一些文章需要审核通过才能发布。索性我们还不如自己搭建一个个人博客，个人博客的设计美化和内容都按照自己喜欢的要求来，然后在阿里云买一个高大上的域名，岂不是很装逼？尽管你没有学过网页 web 开发，但是通过这篇小鹿详细教程可以亲自搭建起属于自己的个人博客。 Hexo + Next + github 搭建个人博客详细教程小鹿的博客网址：小鹿的博客 建站前的准备建站之前我们先要做好准备工作，将相关的工具准备好。 安装 Node.js Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 安装网址：https://nodejs.org/zh-cn/ 验证是否安装成功：打开cmd命令行(win+r 输入cmd回车)执行 ： 12node -vnpm -v 安装成功之后显示版本号： 安装 Git 通常使用 github 的对 git 并不陌生，Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 [1] Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 安装网址：https://www.git-scm.com/download/win 验证是否安装成功：打开cmd命令行(win+r 输入cmd回车)执行 ： 1git --version 安装成功之后显示版本号： 安装 Hexo Hexo 是一个快速、简洁且高效的博客框架。 了解更多关于 Hexo 请查看官方网站：Hexo 安装 hexo 框架 1$ npm install -g hexo-cli 这里安装的是hexo最新版本，如果想安装以前的的版本请运行命令$ npm install -g hexo 以上步骤不出问题的话就已经在本地机器上搭建起了 Hexo 环境。 下面介绍 Hexo 的具体使用方法。 初始化Hexo创建hexo工程1$ hexo init blog 创建一个文件夹blog（blog 为文件夹的名字，可改成自己想要的名字），使用 Hexo 命令初始化 blog 为 hexo 工程目录。 新建POST12$ cd blog$ hexo new “HelloWorld” 进入初始化后的blog文件夹，创建名为HelloWorld的文件，此时会在/blog/sources/_post/目录下生成HelloWorld.md文件。 生成静态文件1$ hexo generate 使用 Hexo 引擎将 Markdown 格式的文件解析成可以使用浏览器查看的 HTML 文件，HTML 文件存储在blog/public 目录下。 运行hexo服务器1$ hexo server 打开命令行提示的地址，一般是 http://localhost:4000/，既可以看到我们的Hexo网站。 此时 Helloworld 文章中没有任何内容。打开 /blog/sources/_post/ 目录，使用编辑器打开其中的 HelloWorld.md 并在其中添加 markdown 格式的内容保存，然后重新运行以下命令： 12$ hexo generate$ hexo server 命令的含义：hexo generate 生成静态文件， hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 如果重新改变端口号请详细查看官网文档，这里不多介绍。 注意：如果在 HelloWorld.md 文件中有中文，在网页进行浏览可能出现乱码，解决方式通过编辑器打开HelloWorld.md 文件把编码方式改成 utf-8 就可以了。 安装主题Hexo 提供了默认主题 landscape，主题的位置在 blog -&gt;themes 文件夹下。主题根据自己喜好可以在网上找到，通过 Git 进行相应的下载。下面小鹿贴出几个主题可以进行相应的下载，喜欢哪一个可以进行配置到自己的个人博客了。 主题一：hexo-theme-next（小鹿用的主题是这一个，后期是自己改进美化的） 主题二：Casper 主题三：daleanthony 主题四：hexo-theme-yilia 主题五：jacman 主题六：hexo-theme-apollo 小鹿给大家找了一个主题链接可以选择自己喜欢的主题：更多主题 配置主题打开 git-bash 切换到 blog -&gt; themes 目录下，如果在目录 blog -&gt;themes 右键选择启动 git-bash 就不用切换了。如果在桌面直接启动 git-bash ,可通过下边命令切换到 blog -&gt;themes目录下。 1$ cd /blog/themes 选好一个主题，复制主题的 github 地址，通过 git 命令进行下载。（例：https://github.com/iissnan/hexo-theme-next 为一个主题的 github 地址） 1git clone https://github.com/iissnan/hexo-theme-next 下载完之后我将文件夹改成 next 了（也可以不改，我为了名字简洁点）。 然后在修改 /blog/config.yml 文件，将其中的 theme 改成 next。（这个是改变主题的地方，如果你用的是其他的主题，将这个 next 改成你下载下来的主题的文件夹的名称） 重新运行以下命令，查看更换主题后的效果 ： 12$ hexo generate$ hexo server 申请 Github 免费静态内容空间注册 Github 账号我们去 Github 的官网进行账号注册 ，注册完成之后我们根据官方文档进行配置 ，然后我们使用自己的账户创建一个 Repository （仓库）。 点击网站右上角的 + 号，选择 New Repository( 注意：创建仓库的名字要你的注册的用户名一致。其他默认，确定创建)。 之后你的静态内容空间就已经创建好了，在浏览器输入你的 your username（用户名）.github.io 就可以访问了。 将 Hexo 上传 Github 上。步骤一：安装 deployer-git （安装部署工具，方便以后更新） 1$ npm install hexo-deployer-git --save 步骤二：在 /blog/_config.yml 中修改 deploy 属性(注意“：”之后有空格 ) 否则配置失败。 1234deploy: type: git repository: https://github.com/luxiangqiang/luxiangqiang.github.io.git branch: master 将上方的 Repository 换成你申请的 Git 仓库地址 使用 https 的方式部署每次提交到 Github 都要输入用户名和密码，如果嫌麻烦请使用 SSH 的方式，百度/谷歌自行搜索。 步骤三：初始化本地仓库。 1git init 步骤四：连接远程仓库 ( 如果是第一次使用 git，在使用 git 的时候会提示输入用户名和密码，用户名是自己的注册邮箱。 ) 1git remote add origin https://github.com/luxiangqiang/luxiangqiang.github.io.git 步骤五：发布 hexo 到 github page 12//等于一次性执行了，清空、刷新、部署三个命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 步骤六：推送到远程仓库（github） 1git push origin 这里建议创建一个新的分支 hexo，用于管理 hexo 文件。提交的的时候只提交 hexo 网站 html、css 等源文件。 创建并切换到新建分支： 1git checkout -b hexo 将分支推送到远程仓库： 1git push origin hexo 记得提交以后去 github 上把 hexo 分支设置默认，以后写文章等都要部署。 文章在 hexo 目录下的 \source\ _posts 文件夹中，是 md 格式，也就是 Markdown 格式。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零学习微信小程序（一）]]></title>
    <url>%2F2018%2F08%2F27%2F%E4%BB%8E%E9%9B%B6%E5%85%A5%E9%97%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%90%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你从零学习微信小程序。 从零学习微信小程序配置全局配置在 app.json 配置文件下的 pages 中添加页面名称和路径（刷新）： 页面配置在小程序的 app.js 中添加一下代码; 1234567891011121314151617181920212223242526"tabBar": &#123; "color":"black", "selectedColor":"blue", "borderStyle":"black", "position":"bottom", "list": [ &#123; "pagePath": "pages/index/index", "text": "电影推荐", "iconPath": "images/index.png", "selectedIconPath":"images/index_act.png" &#125;, &#123; "pagePath": "pages/mov/mov", "text": "优惠", "iconPath":"images/kou.png", "selectedIconPath": "images/kou_act.png" &#125; , &#123; "pagePath": "pages/about/about", "text": "我的", "iconPath":"images/about.png", "selectedIconPath": "images/about_act.png" &#125; ] &#125; ① list 中的对象表示小程序页面下方有几个导航（至少两个） pagePath：页面路径，必须在 pages 中先定义 text：tab 上按钮文字 iconPath：图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，不支持网络图片。当 postion 为 top 时，不显示 icon。 selectedIconPath：选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，不支持网络图片。 当 postion 为 top 时，不显示 icon。 ② tabBar 下的字段属性： color：tab 上的文字默认颜色 selectedColor： tab 上的文字选中时的颜色 borderStyle：tabbar上边框的颜色， 仅支持 black / white position： tabBar的位置，仅支持 bottom / top 逻辑层注册程序小程序的生命周期在小程序的 app.js 文件中配置: 12345678910111213141516//app.js//功能：注册小程序（小程序的生命周期）App(&#123; //监听小程序初始化 onLaunch:function(e)&#123; console.log(e+&quot;初始化成功&quot;) &#125;, //监听小程序显示 onShow:function()&#123; console.log(&quot;显示&quot;) &#125;, //监听小程序隐藏 onHide:function()&#123; console.log(&quot;隐藏&quot;) &#125;,&#125;) getApp(Object)全局的 getApp() 函数可以用来获取到小程序 App 实例。 在小程序的 app.js 文件中添加 name 变量： 1234567891011121314151617//app.js//功能：注册小程序（小程序的生命周期）App(&#123; //监听小程序初始化 onLaunch:function(e)&#123; console.log(e+&quot;初始化成功&quot;) &#125;, //监听小程序显示 onShow:function()&#123; console.log(&quot;显示&quot;) &#125;, //监听小程序隐藏 onHide:function()&#123; console.log(&quot;隐藏&quot;) &#125;, name:&quot;李文木&quot;&#125;) 在 index.js 文件中通过 var app = getApp(); 获取变量的值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//index.jsvar app = getApp();Page(&#123; name:&quot;&quot;, /** * 页面的初始数据 */ data: &#123; &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; this.setData(&#123; name:app.name &#125;) &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125;&#125;) 然后通过在 index.wxml 文件中显示出来： 1&lt;text&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; 注册页面初始数据在某一页面下的 about.js 文件中定义变量： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// pages/about/about.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; header:&quot;我是&quot;, array:[ &#123;name:&quot;爱奇艺&quot;&#125;, &#123;age:67&#125;, &#123;class:&quot;清华大学&quot;&#125; ] &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125;&#125;) 在页面中引用以上定义的变量和数组 123456789101112131415&lt;!--pages/about/about.wxml--&gt;//引用变量&lt;text&gt;&#123;&#123;header&#125;&#125;&lt;/text&gt;//引用数组（方法一）&lt;view&gt;&#123;&#123;array[0].name&#125;&#125;&lt;/view&gt;&lt;view&gt;&#123;&#123;array[1].age&#125;&#125;&lt;/view&gt;&lt;view&gt;&#123;&#123;array[2].class&#125;&#125;&lt;/view&gt;//引用数组（方法二）&lt;block wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt; &lt;view&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;item.age&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;item.class&#125;&#125;&lt;/view&gt;&lt;/block&gt; 页面的生命周期回调123456789101112131415161718192021222324252627282930313233343536373839/** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; //页面初始化 console.log(&quot;页面初始化&quot;); &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; //页面渲染完成 console.log(&quot;页面渲染完成&quot;); &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; //页面显示 console.log(&quot;页面显示&quot;); &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; //页面隐藏 console.log(&quot;页面隐藏&quot;); &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; //页面关闭 console.log(&quot;页面关闭&quot;); &#125;, 下拉刷新在小程序的 app.json 中，添加下拉事件 1&quot;enablePullDownRefresh&quot;:true 在页面中的下拉刷新函数调用函数 123456onPullDownRefresh: function () &#123; console.log(&quot;下拉中...&quot;); this.setData(&#123; msg:&quot;改变了&quot; &#125;) &#125; 上拉触顶可设置页面底部的加载动画。 1234//上拉触顶 onReachBottom:function()&#123; console.log(&quot;上拉触顶...&quot;); &#125; 实现页面跳转（1）正常跳转 123wx.navigateTo(&#123; url: &apos;页面路径&apos; &#125;) （2）重定向跳转 123wx.redirectTo(&#123; url: &apos;页面路径&apos;, &#125;) 两者区别：有无返回箭头 视图层数据绑定简单绑定数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于： 在页面的 .js 文件中添加变量： 12345Page(&#123; data: &#123; data:&quot;我是一条数据&quot; &#125;&#125;) 在 wxml 页面中引用： 1&lt;view&gt; &#123;&#123; data &#125;&#125; &lt;/view&gt; 数组绑定在页面的 .js 文件中添加数组变量： 1234567891011Page(&#123; data: &#123; array:[ &#123; id: &quot;item_1&quot; &#125;, &#123; id: &quot;item_2&quot; &#125;, &#123; id: &quot;item_3&quot; &#125;, &#123; id: &quot;item_4&quot; &#125;, &#123; id: &quot;item_5&quot; &#125;, ] &#125;&#125;) 在 wxml 页面中引用：item 指 array 中的每一项 123&lt;block wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt; &lt;view class=&quot;item.id&quot;&gt;这条数据的id为&#123;&#123;item.id&#125;&#125;&lt;/view&gt;&lt;/block&gt; 注意： &lt;block/&gt; 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 逻辑判断（1）if判断 12345Page(&#123; data: &#123; bool:false &#125;&#125;) 在 wxml 页面中引用： 1&lt;view wx:if=&quot;&#123;&#123;bool&#125;&#125;&quot;&gt;这是一台电脑&lt;/view&gt; 结果不会显示到界面。 列表渲染修改默认变量名 wx:for默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item 1234567891011Page(&#123; data: &#123; array:[ &#123; id: &quot;item_1&quot; &#125;, &#123; id: &quot;item_2&quot; &#125;, &#123; id: &quot;item_3&quot; &#125;, &#123; id: &quot;item_4&quot; &#125;, &#123; id: &quot;item_5&quot; &#125;, ] &#125;&#125;) 在 wxml 页面中引用： 使用 wx:for-item 可以指定数组当前元素的变量名， 使用 wx:for-index 可以指定数组当前下标的变量名： 123&lt;block wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-item=&quot;for-item&quot; wx:for-index=&quot;for-index&quot;&gt; &lt;view class=&quot;item.id&quot;&gt;&#123;&#123;for-index&#125;&#125;这条数据的id为&#123;&#123;for-item.id&#125;&#125;&lt;/view&gt;&lt;/block&gt; wx:key如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 &lt;input/&gt; 中的输入内容，&lt;switch/&gt; 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。 如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 123&lt;block wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:key=&quot;this&quot; wx:for-item=&quot;number_item&quot; wx:for-index=&quot;number_index&quot;&gt; &lt;view class=&quot;item.id&quot;&gt;&#123;&#123;number_index&#125;&#125;这条数据的id为&#123;&#123;number_item.id&#125;&#125;&lt;/view&gt;&lt;/block&gt; 条件渲染（1）if 、elif、else 判断 12345 Page(&#123; data: &#123; length:7 &#125;&#125;) 在 wxml 页面中引用： 1234&lt;!--条件判断--&gt;&lt;view wx:if=&quot;&#123;&#123;length&lt;6&#125;&#125;&quot;&gt;这是小于六的数字&lt;/view&gt;&lt;view wx:elif=&quot;&#123;&#123;length&gt;9&#125;&#125;&quot;&gt;只是大于六的数字&lt;/view&gt;&lt;view wx:else=&quot;&#123;&#123;length&lt;6&#125;&#125;&quot;&gt;没有你要找的数据&lt;/view&gt; （2）block wx:if 因为 wx:if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 &lt;block/&gt; 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。 1234&lt;block wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt; &lt;view&gt; view1 &lt;/view&gt; &lt;view&gt; view2 &lt;/view&gt;&lt;/block&gt; 注意： &lt;block/&gt; 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 模板123456789 Page(&#123; data: &#123; items:&#123; name: &quot;逯相强&quot;, age: &quot;21&quot;, class: &quot;软件工程1602&quot; &#125; &#125;&#125;) 定义模板123456&lt;!--定义模板--&gt;&lt;template name=&quot;msg&quot;&gt;&lt;view&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/view&gt;&lt;view&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/view&gt;&lt;view&gt;班级：&#123;&#123;class&#125;&#125;&lt;/view&gt;&lt;/template&gt; 使用模板12&lt;!--使用模板--&gt;&lt;template is=&quot;msg&quot; data=&quot;&#123;&#123;...items&#125;&#125;&quot;/&gt; 事件定义点击事件： 1234567891011 Page(&#123; data: &#123; &#125;， //点击事件 change: function () &#123; this.setData(&#123; data:&quot;我是第二条数据&quot; &#125;) &#125;,&#125;) 使用点击事件 12&lt;!--点击事件--&gt;&lt;button bindtap=&quot;change&quot;&gt;点击&lt;/button&gt; 引用WXML 提供两种文件引用方式import和include。 importimport可以在该文件中使用目标文件定义的template，如： 在 item.wxml 中定义了一个叫item的template： 1234&lt;!-- item.wxml --&gt;&lt;template name=&quot;item&quot;&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;&lt;/template&gt; 在 index.wxml 中引用了 item.wxml，就可以使用item模板： 12&lt;import src=&quot;item.wxml&quot;/&gt;&lt;template is=&quot;item&quot; data=&quot;&#123;&#123;text: &apos;forbar&apos;&#125;&#125;&quot;/&gt; includeinclude 可以将目标文件除了 &lt;template/&gt; &lt;wxs/&gt; 外的整个代码引入，相当于是拷贝到 include 位置，如： 1234&lt;!-- index.wxml --&gt;&lt;include src=&quot;header.wxml&quot;/&gt;&lt;view&gt; body &lt;/view&gt;&lt;include src=&quot;footer.wxml&quot;/&gt; 12&lt;!-- header.wxml --&gt;&lt;view&gt; header &lt;/view&gt; 12&lt;!-- footer.wxml --&gt;&lt;view&gt; footer &lt;/view&gt;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 基础之快速入门]]></title>
    <url>%2F2018%2F08%2F23%2FPython%20%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[此篇文章适合于具有一定编程语言基础的开发者快速入门学习 Python。 一、Python 基础语法Python 标识符 1、以下划线开头的标识符是有特殊意义的。 ① 以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入； ② 以双下划线开头的 _ _foo 代表类的私有成员； ③ 以双下划线开头和结尾的 foo 代表 Python 里特殊方法专用的标识，如 _ _ init _ _() 代表类的构造函数。 行和缩进 学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 { } 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。 缩进的空白数量是可变的，但是·所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示： 1234if True: print "True"else: print "False" 以下代码将会执行错误 1234567if True: print "Answer" print "True"else: print "Answer" # 没有严格缩进，在执行时会报错 print "False 执行以上代码，会出现如下错误提醒： 1234 File "test.py", line 10 print "False" ^IndentationError: unindent does not match any outer indentation level ① IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。 ② 如果是 IndentationError: unexpected indent 错误, 则 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是 tab 和空格没对齐的问题“，所有 python 对格式要求非常严格。 ③ 建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用 。 Python注释1、 python 中单行注释采用 # 开头。 2、python 中多行注释使用三个单引号 (‘’’) 或三个双引号 (“””)。 1234567891011'''这是多行注释，使用单引号。这是多行注释，使用单引号。这是多行注释，使用单引号。'''"""这是多行注释，使用双引号。这是多行注释，使用双引号。这是多行注释，使用双引号。""" Python空行1、函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 2、空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 等待用户输入下面的程序执行后就会等待用户输入，按回车键后就会退出： 1raw_input("按下 enter 键退出，其他任意键显示...\n") Print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾 加上逗号 , 12345678910111213x=&quot;a&quot;y=&quot;b&quot;# 换行输出print xprint yprint &apos;---------&apos;# 不换行输出print x,print y,# 不换行输出print x,y 以上实例执行结果为： 1234ab---------a b a b 多个语句构成代码组① 缩进相同的一组语句构成一个代码块，我们称之代码组。 ② 像 if、while、def 和 class 这样的复合语句，首行以关键字开始，以冒号 ( : ) 结束，该行之后的一行或多行代码构成代码组。 如下实例： 123456if expression : suite elif expression : suite else : suite 二 、Python 变量类型1、Python 中的变量赋值不需要类型声明。 2、每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。 3、每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 例如： 1234567counter = 100 # 赋值整型变量miles = 1000.0 # 浮点型name = "John" # 字符串 print counterprint milesprint name 执行以上程序会输出如下结果： 1231001000.0John 标准数据类型Python 有五个标准的数据类型： Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） Python字符串1、字符串或串 (String) 是由数字、字母、下划线组成的一串字符。 2、python 的字串列表有 2 种取值顺序: 从左到右索引默认 0 开始的，最大范围是字符串长度少 1 从右到左索引默认 -1 开始的，最大范围是字符串开头 3、如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。 123&gt;&gt;&gt; s = 'abcdef'&gt;&gt;&gt; s[1:5]'bcde' 上面的结果包含了 s[1] 的值 b，而取到的最大范围不包括尾下标，就是 s[5] 的值 f。 Python列表1、List（列表） 是 Python 中使用最频繁的数据类型。 2、列表用 [ ] 标识，是 python 最通用的复合数据类型。 123456789list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]tinylist = [123, 'john'] print list # 输出完整列表print list[0] # 输出列表的第一个元素print list[1:3] # 输出第二个至第三个元素 print list[2:] # 输出从第三个开始至列表末尾的所有元素print tinylist * 2 # 输出列表两次print list + tinylist # 打印组合的列表 以上实例输出结果： 123456['runoob', 786, 2.23, 'john', 70.2]runoob[786, 2.23][2.23, 'john', 70.2][123, 'john', 123, 'john']['runoob', 786, 2.23, 'john', 70.2, 123, 'john'] Python 元组1、元组是另一个数据类型，类似于List（列表）。 2、元组用 “()” 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 实例： 123456789tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )tinytuple = (123, 'john') print tuple # 输出完整元组print tuple[0] # 输出元组的第一个元素print tuple[1:3] # 输出第二个至第三个的元素 print tuple[2:] # 输出从第三个开始至列表末尾的所有元素print tinytuple * 2 # 输出元组两次print tuple + tinytuple # 打印组合的元组 以上实例输出结果： 123456('runoob', 786, 2.23, 'john', 70.2)runoob(786, 2.23)(2.23, 'john', 70.2)(123, 'john', 123, 'john')('runoob', 786, 2.23, 'john', 70.2, 123, 'john') 以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的： 1234tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]tuple[2] = 1000 # 元组中是非法应用list[2] = 1000 # 列表中是合法应用 Python 字典1、字典(dictionary)是除列表以外 python 之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。 2、两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 3、字典用“{ }”标识。字典由索引 (key) 和它对应的值 （value） 组成。 实例： 1234567891011dict = &#123;&#125;dict['one'] = "This is one"dict[2] = "This is two" tinydict = &#123;'name': 'john','code':6734, 'dept': 'sales'&#125; print dict['one'] # 输出键为'one' 的值print dict[2] # 输出键为 2 的值print tinydict # 输出完整的字典print tinydict.keys() # 输出所有键print tinydict.values() # 输出所有值 输出结果为： 12345This is oneThis is two&#123;'dept': 'sales', 'code': 6734, 'name': 'john'&#125;['dept', 'code', 'name']['sales', 6734, 'john'] 三、Python 运算符Python逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False Python成员运算符除了以上的一些运算符之外，Python 还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 实例： 1234567891011121314151617181920a = 10b = 20list = [1, 2, 3, 4, 5 ]; if ( a in list ): print "1 - 变量 a 在给定的列表中 list 中"else: print "1 - 变量 a 不在给定的列表中 list 中" if ( b not in list ): print "2 - 变量 b 不在给定的列表中 list 中"else: print "2 - 变量 b 在给定的列表中 list 中" # 修改变量 a 的值a = 2if ( a in list ): print "3 - 变量 a 在给定的列表中 list 中"else: print "3 - 变量 a 不在给定的列表中 list 中" 以上实例输出结果： 1231 - 变量 a 不在给定的列表中 list 中2 - 变量 b 不在给定的列表中 list 中3 - 变量 a 在给定的列表中 list 中 Python身份运算符身份运算符用于比较两个对象的存储单元 。 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 实例： 123456789101112131415161718192021222324a = 20b = 20 if ( a is b ): print "1 - a 和 b 有相同的标识"else: print "1 - a 和 b 没有相同的标识" if ( a is not b ): print "2 - a 和 b 没有相同的标识"else: print "2 - a 和 b 有相同的标识" # 修改变量 b 的值b = 30if ( a is b ): print "3 - a 和 b 有相同的标识"else: print "3 - a 和 b 没有相同的标识" if ( a is not b ): print "4 - a 和 b 没有相同的标识"else: print "4 - a 和 b 有相同的标识" 以上实例输出结果： 12341 - a 和 b 有相同的标识2 - a 和 b 有相同的标识3 - a 和 b 没有相同的标识4 - a 和 b 没有相同的标识 is 与 == 区别： is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 四、python 条件语句1、Python 编程中 if 语句用于控制程序的执行，基本形式为： 1234if 判断条件： 执行语句……else： 执行语句…… 2、当判断条件为多个值时，可以使用以下形式： 12345678if 判断条件1: 执行语句1……elif 判断条件2: 执行语句2……elif 判断条件3: 执行语句3……else: 执行语句4…… 3、由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。 五、Python 循环语句Python提供了for循环和while循环（在Python中没有do..while循环）: 循环类型 描述 while 循环 在给定的判断条件为 true 时执行循环体，否则退出循环体。 for 循环 重复执行语句 嵌套循环 你可以在while循环体中嵌套for循环 1、while 循环12while 判断条件： 执行语句…… 实例： 123456count = 0while (count &lt; 9): print 'The count is:', count count = count + 1 print "Good bye!" 以上代码执行输出结果: 12345678910The count is: 0The count is: 1The count is: 2The count is: 3The count is: 4The count is: 5The count is: 6The count is: 7The count is: 8Good bye! 循环使用 else 语句在 python 中，while … else 在循环条件为 false 时执行 else 语句块： 123456count = 0while count &lt; 5: print count, " is less than 5" count = count + 1else: print count, " is not less than 5" 以上实例输出结果为： 1234560 is less than 51 is less than 52 is less than 53 is less than 54 is less than 55 is not less than 5 2、for 循环语句Python for 循环可以遍历任何序列的项目，如一个列表或者一个字符串。 语法： 12for iterating_var in sequence: statements(s) 实例： 12345678for letter in 'Python': # 第一个实例 print '当前字母 :', letter fruits = ['banana', 'apple', 'mango']for fruit in fruits: # 第二个实例 print '当前水果 :', fruit print "Good bye!" 以上实例输出结果: 12345678910当前字母 : P当前字母 : y当前字母 : t当前字母 : h当前字母 : o当前字母 : n当前水果 : banana当前水果 : apple当前水果 : mangoGood bye! 通过序列索引迭代另外一种执行循环的遍历方式是通过索引，如下实例： 12345fruits = ['banana', 'apple', 'mango']for index in range(len(fruits)): print '当前水果 :', fruits[index] print "Good bye!" 以上实例输出结果： 1234当前水果 : banana当前水果 : apple当前水果 : mangoGood bye! 以上实例我们使用了内置函数 len() 和 range(),函数 len() 返回列表的长度，即元素的个数。 range 返回一个序列的数。 循环使用 else 语句在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样 实例： 12345678for num in range(10,20): # 迭代 10 到 20 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print '%d 等于 %d * %d' % (num,i,j) break # 跳出当前循环 else: # 循环的 else 部分 print num, '是一个质数' 以上实例输出结果： 1234567891010 等于 2 * 511 是一个质数12 等于 2 * 613 是一个质数14 等于 2 * 715 等于 3 * 516 等于 2 * 817 是一个质数18 等于 2 * 919 是一个质数 六、Python pass 语句1、Python pass 是空语句，是为了保持程序结构的完整性。 2、pass 不做任何事情，一般用做占位语句。 实例： 12345678# 输出 Python 的每个字母for letter in 'Python': if letter == 'h': pass print '这是 pass 块' print '当前字母 :', letterprint "Good bye!" 以上实例执行结果： 12345678当前字母 : P当前字母 : y当前字母 : t这是 pass 块当前字母 : h当前字母 : o当前字母 : nGood bye! 七、Python 列表(List)1、序列是 Python 中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是 1，依此类推。 2、创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示： 123list1 = ['physics', 'chemistry', 1997, 2000]list2 = [1, 2, 3, 4, 5 ]list3 = ["a", "b", "c", "d"] 与字符串的索引一样，列表索引从 0 开始。列表可以进行截取、组合等。 访问列表中的值使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示： 12345list1 = ['physics', 'chemistry', 1997, 2000]list2 = [1, 2, 3, 4, 5, 6, 7 ] print "list1[0]: ", list1[0]print "list2[1:5]: ", list2[1:5] 以上实例输出结果： 12list1[0]: physicslist2[1:5]: [2, 3, 4, 5] 更新列表你可以对列表的数据项进行修改或更新，你也可以使用 append() 方法来添加列表项，如下所示： 1234list = [] ## 空列表list.append('Google') ## 使用 append() 添加元素list.append('Runoob')print list 以上实例输出结果 ： 1['Google', 'Runoob'] 删除列表元素可以使用 del 语句来删除列表的元素，如下实例： 123456list1 = ['physics', 'chemistry', 1997, 2000] print list1del list1[2]print "After deleting value at index 2 : "print list1 以上实例输出结果： 123['physics', 'chemistry', 1997, 2000]After deleting value at index 2 :['physics', 'chemistry', 2000] Python 列表脚本操作符 Python 表达式 结果 描述 len([1, 2, 3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print x, 1 2 3 迭代 八、Python 元组1、Python 的元组与列表类似，不同之处在于元组的元素不能修改。 2、如下实例： 123tup1 = ('physics', 'chemistry', 1997, 2000)tup2 = (1, 2, 3, 4, 5 )tup3 = "a", "b", "c", "d" 创建空元组 1tup1 = () 元组中只包含一个元素时，需要在元素后面添加逗号 1tup1 = (50,) 访问元组元组可以使用下标索引来访问元组中的值，如下实例: 12345tup1 = ('physics', 'chemistry', 1997, 2000)tup2 = (1, 2, 3, 4, 5, 6, 7 ) print "tup1[0]: ", tup1[0]print "tup2[1:5]: ", tup2[1:5] 以上实例输出结果 : 12tup1[0]: physicstup2[1:5]: (2, 3, 4, 5) 修改元组元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例: 123456789tup1 = (12, 34.56)tup2 = ('abc', 'xyz') # 以下修改元组元素操作是非法的。# tup1[0] = 100 # 创建一个新的元组tup3 = tup1 + tup2print tup3 以上实例输出结果： 1(12, 34.56, 'abc', 'xyz') 删除元组元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例: 123456tup = ('physics', 'chemistry', 1997, 2000) print tupdel tupprint "After deleting tup : "print tup 以上实例元组被删除后，输出变量会有异常信息，输出如下所示： 123456('physics', 'chemistry', 1997, 2000)After deleting tup :Traceback (most recent call last): File "test.py", line 9, in &lt;module&gt; print tupNameError: name 'tup' is not defined 元组运算符与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 Python 表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 (‘Hi!’,) * 4 (‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’) 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print x, 1 2 3 迭代 无关闭分隔符任意无符号的对象，以逗号隔开，默认为元组，如下实例： 123print 'abc', -4.24e93, 18+6.6j, 'xyz'x, y = 1, 2print "Value of x , y : ", x,y 以上实例运行结果： 12abc -4.24e+93 (18+6.6j) xyzValue of x , y : 1 2 九、Python 字典(Dictionary)1、字典是另一种可变容器模型，且可存储任意类型对象。 2、字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示： 1d = &#123;key1 : value1, key2 : value2 &#125; 键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。 12345&gt;&gt;&gt;dict = &#123;'a': 1, 'b': 2, 'b': '3'&#125;;&gt;&gt;&gt; dict['b']'3'&gt;&gt;&gt; dict&#123;'a': 1, 'b': '3'&#125; 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 一个简单的字典实例: 1dict = &#123;'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'&#125; 也可如此创建字典： 12dict1 = &#123; 'abc': 456 &#125;;dict2 = &#123; 'abc': 123, 98.6: 37 &#125;; 访问字典里的值把相应的键放入熟悉的方括弧，如下实例: 1234dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; print "dict['Name']: ", dict['Name'];print "dict['Age']: ", dict['Age']; 以上实例输出结果： 12dict[&apos;Name&apos;]: Zaradict[&apos;Age&apos;]: 7 修改字典向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例: 12345678dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; dict['Age'] = 8; # update existing entrydict['School'] = "DPS School"; # Add new entry print "dict['Age']: ", dict['Age'];print "dict['School']: ", dict['School']; 以上实例输出结果： 12dict[&apos;Age&apos;]: 8dict[&apos;School&apos;]: DPS School 删除字典元素1、能删单一的元素也能清空字典，清空只需一项操作。 2、显示删除一个字典用del命令，如下实例： 12345678dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; del dict['Name']; # 删除键是'Name'的条目dict.clear(); # 清空词典所有条目del dict ; # 删除词典 print "dict['Age']: ", dict['Age'];print "dict['School']: ", dict['School']; 但这会引发一个异常，因为用del后字典不再存在： 12345dict['Age']:Traceback (most recent call last): File "test.py", line 8, in &lt;module&gt; print "dict['Age']: ", dict['Age'];TypeError: 'type' object is unsubscriptable 字典键的特性字典值可以没有限制地取任何 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。 两个重要的点需要记住： 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例： 123dict = &#123;'Name': 'Zara', 'Age': 7, 'Name': 'Manni'&#125;; print "dict['Name']: ", dict['Name']; 以上实例输出结果： 1dict['Name']: Manni 2）键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行，如下实例： 123dict = &#123;['Name']: 'Zara', 'Age': 7&#125;; print "dict['Name']: ", dict['Name']; 以上实例输出结果： 1234Traceback (most recent call last): File "test.py", line 3, in &lt;module&gt; dict = &#123;['Name']: 'Zara', 'Age': 7&#125;;TypeError: list objects are unhashable 十、Python 函数1、函数能提高应用的模块性，和代码的重复利用率。你已经知道 Python 提供了许多内建函数，比如 print()。但你也可以自己创建函数，这被叫做用户自定义函数。 定义一个函数你可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的 return 相当于返回 None。 语法1234def functionname( parameters ): "函数_文档字符串" function_suite return [expression] 默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。 实例1234def printme( str ): "打印传入的字符串到标准显示设备上" print str return 函数调用这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 提示符执行。 如下实例调用了 printme（）函数： 123456789# 定义函数def printme( str ): "打印任何传入的字符串" print str; return; # 调用函数printme("我要调用用户自定义函数!");printme("再次调用同一函数"); 以上实例输出结果： 12我要调用用户自定义函数!再次调用同一函数 参数传递在 python 中，类型属于对象，变量是没有类型的： 123a=[1,2,3] a="Runoob" 以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。 可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身 la 没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如 fun（a），传递的只是 a 的值，没有影响 a 对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 python 传不可变对象实例123456def ChangeInt( a ): a = 10 b = 2ChangeInt(b)print b # 结果是 2 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 传可变对象实例1234567891011# 可写函数说明def changeme( mylist ): "修改传入的列表" mylist.append([1,2,3,4]); print "函数内取值: ", mylist return # 调用changeme函数mylist = [10,20,30];changeme( mylist );print "函数外取值: ", mylist 实例中传入函数的和在末尾添加新内容的对象用的是同一个引用，故输出结果如下： 12函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数以下是调用函数时可使用的正式参数类型： 必备参数 关键字参数 默认参数 不定长参数 必备参数必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 12345678#可写函数说明def printme( str ): "打印任何传入的字符串" print str; return; #调用printme函数printme(); 以上实例输出结果： 1234Traceback (most recent call last): File "test.py", line 11, in &lt;module&gt; printme();TypeError: printme() takes exactly 1 argument (0 given) 关键字参数1、关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 2、使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 以下实例在函数 printme() 调用时使用参数名： 12345678#可写函数说明def printme( str ): "打印任何传入的字符串" print str; return; #调用printme函数printme( str = "My string"); 以上实例输出结果： 1My string 下例能将关键字参数顺序不重要展示得更清楚： 123456789#可写函数说明def printinfo( name, age ): "打印任何传入的字符串" print "Name: ", name; print "Age ", age; return; #调用printinfo函数printinfo( age=50, name="miki" ); 以上实例输出结果： 12Name: mikiAge 50 缺省参数调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的 age，如果 age 没有被传入： 12345678910#可写函数说明def printinfo( name, age = 35 ): "打印任何传入的字符串" print "Name: ", name; print "Age ", age; return; #调用printinfo函数printinfo( age=50, name="miki" );printinfo( name="miki" ); 以上实例输出结果： 1234Name: mikiAge 50Name: mikiAge 35 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下： 1234def functionname([formal_args,] *var_args_tuple ): "函数_文档字符串" function_suite return [expression] 加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下： 123456789101112# 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print "输出: " print arg1 for var in vartuple: print var return; # 调用printinfo 函数printinfo( 10 );printinfo( 70, 60, 50 ); 以上实例输出结果： 123456输出:10输出:706050 匿名函数python 使用 lambda 来创建匿名函数。 lambda 只是一个表达式，函数体比 def 简单很多。 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 语法lambda 函数的语法只包含一个语句，如下： 1lambda [arg1 [,arg2,.....argn]]:expression 如下实例： 123456# 可写函数说明sum = lambda arg1, arg2: arg1 + arg2; # 调用sum函数print "相加后的值为 : ", sum( 10, 20 )print "相加后的值为 : ", sum( 20, 20 ) 以上实例输出结果： 12相加后的值为 : 30相加后的值为 : 40 return 语句return 语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的 return 语句返回 None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做： 123456789# 可写函数说明def sum( arg1, arg2 ): # 返回2个参数的和." total = arg1 + arg2 print "函数内 : ", total return total; # 调用sum函数total = sum( 10, 20 ); 以上实例输出结果： 1函数内 : 30 变量作用域一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。 变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下： 全局变量 局部变量 全局变量和局部变量1、定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 2、局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例： 1234567891011total = 0; # 这是一个全局变量# 可写函数说明def sum( arg1, arg2 ): #返回2个参数的和." total = arg1 + arg2; # total在这里是局部变量. print "函数内是局部变量 : ", total return total; #调用sum函数sum( 10, 20 );print "函数外是全局变量 : ", total 以上实例输出结果： 12函数内是局部变量 : 30函数外是全局变量 : 0 十一、Python 文件I/O读取键盘输入Python 提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下： raw_input input raw_input函数raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）： 12str = raw_input("请输入：")print "你输入的内容是: ", str 这将提示你输入任意字符串，然后在屏幕上显示相同的字符串。当我输入”Hello Python！”，它的输出如下： 12请输入：Hello Python！你输入的内容是: Hello Python！ input函数nput([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个 Python 表达式作为输入，并将运算结果返回。 12str = input("请输入：")print "你输入的内容是: ", str 这会产生如下的对应着输入的结果： 12请输入：[x*5 for x in range(2,10,2)]你输入的内容是: [10, 20, 30, 40] 打开和关闭文件Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作 open 函数你必须先用 Python 内置的 open() 函数打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。 语法： 1file object = open(file_name [, access_mode][, buffering]) 各个参数的细节如下： file_name：file_name 变量是一个包含了你要访问的文件名称的字符串值。 access_mode：access_mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读 (r)。 buffering :如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 不同模式打开文件的完全列表： 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 File对象的属性一个文件被打开后，你有一个 file 对象，你可以得到有关该文件的各种信息。 以下是和 file 对象相关的所有属性的列表： 属性 描述 file.closed 返回 true 如果文件已被关闭，否则返回 false。 file.mode 返回被打开文件的访问模式。 file.name 返回文件的名称。 file.softspace 如果用 print 输出后，必须跟一个空格符，则返回 false。否则返回 true。 如下实例： 123456# 打开一个文件fo = open("foo.txt", "w")print "文件名: ", fo.nameprint "是否已关闭 : ", fo.closedprint "访问模式 : ", fo.modeprint "末尾是否强制加空格 : ", fo.softspace 以上实例输出结果： 1234文件名: foo.txt是否已关闭 : False访问模式 : w末尾是否强制加空格 : 0 close()方法语法： 1fileObject.close() write()方法1、write() 方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python 字符串可以是二进制数据，而不是仅仅是文字。 2、write() 方法不会在字符串的结尾添加换行符(‘\n’)： 语法： 1fileObject.write(string) 在这里，被传递的参数是要写入到已打开文件的内容。 例子： 123456# 打开一个文件fo = open("foo.txt", "w")fo.write( "www.runoob.com!\nVery good site!\n") # 关闭打开的文件fo.close() 上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容: 123$ cat foo.txt www.runoob.com!Very good site! read()方法**方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python** 字符串可以是二进制数据，而不是仅仅是文字。 语法： 1fileObject.read([count]) 在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。 例子： 123456# 打开一个文件fo = open("foo.txt", "r+")str = fo.read(10)print "读取的字符串是 : ", str# 关闭打开的文件fo.close() 以上实例输出结果： 1读取的字符串是 : www.runoob 文件定位tell() 方法告诉你文件内的当前位置 ,seek（offset [,from]）方法改变当前文件的位置。Offset 变量表示要移动的字节数。From 变量指定开始移动字节的参考位置。 例子： 123456789101112131415# 打开一个文件fo = open("foo.txt", "r+")str = fo.read(10)print "读取的字符串是 : ", str # 查找当前位置position = fo.tell()print "当前文件位置 : ", position # 把指针再次重新定位到文件开头position = fo.seek(0, 0)str = fo.read(10)print "重新读取字符串 : ", str# 关闭打开的文件fo.close() 以上实例输出结果： 123读取的字符串是 : www.runoob当前文件位置 : 10重新读取字符串 : www.runoob Python 异常处理python 提供了两个非常重要的功能来处理 python 程序在运行中出现的异常和错误。你可以使用该功能来调试python 程序。 异常处理。 断言(Assertions)。 python标准异常 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告 异常处理1、捕捉异常可以使用 try/except 语句。 2、try/except 语句用来检测 try 语句块中的错误，从而让 except 语句捕获异常信息并处理。 3、如果你不想在异常发生时结束你的程序，只需在 try 里捕获它。 语法： 12345678try:&lt;语句&gt; #运行别的代码except &lt;名字&gt;：&lt;语句&gt; #如果在try部份引发了'name'异常except &lt;名字&gt;，&lt;数据&gt;:&lt;语句&gt; #如果引发了'name'异常，获得附加的数据else:&lt;语句&gt; #如果没有异常发生 try 的工作原理是，当开始一个 try 语句后，python 就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try 子句先执行，接下来会发生什么依赖于执行时是否出现异常。 如果当 try 后的语句执行时发生异常，python 就跳回到 try 并执行第一个匹配该异常的 except 子句，异常处理完毕，控制流就通过整个 try 语句（除非在处理异常时又引发新的异常）。 如果在 try 后的语句里发生了异常，却没有匹配的 except 子句，异常将被递交到上层的 try，或者到程序的最上层（这样将结束程序，并打印缺省的出错信息）。 如果在 try 子句执行时没有发生异常，python 将执行 else 语句后的语句（如果有 else 的话），然后控制流通过整个 try 语句。 实例1下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，且并未发生异常： 12345678try: fh = open("testfile", "w") fh.write("这是一个测试文件，用于测试异常!!")except IOError: print "Error: 没有找到文件或读取文件失败"else: print "内容写入文件成功" fh.close() 以上程序输出结果： 1234$ python test.py 内容写入文件成功$ cat testfile # 查看写入的内容这是一个测试文件，用于测试异常!! 实例2下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，但文件没有写入权限，发生了异常： 12345678try: fh = open("testfile", "w") fh.write("这是一个测试文件，用于测试异常!!")except IOError: print "Error: 没有找到文件或读取文件失败"else: print "内容写入文件成功" fh.close() 在执行代码前为了测试方便，我们可以先去掉 testfile 文件的写权限，命令如下： 1chmod -w testfile 再执行以上代码： 12$ python test.py Error: 没有找到文件或读取文件失败 使用 except 而不带任何异常类型你可以不带任何异常类型使用 except，如下实例： 12345678try: 正常的操作 ......................except: 发生异常，执行这块代码 ......................else: 如果没有异常执行这块代码 以上方式 try-except 语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。 使用 except 而带多种异常类型你也可以使用相同的 except 语句来处理多个异常信息，如下所示： 12345678try: 正常的操作 ......................except(Exception1[, Exception2[,...ExceptionN]]]): 发生以上多个异常中的一个，执行这块代码 ......................else: 如果没有异常执行这块代码 try-finally 语句try-finally 语句无论是否发生异常都将执行最后的代码。 12345try:&lt;语句&gt;finally:&lt;语句&gt; #退出try时总会执行raise 当在 try 块中抛出一个异常，立即执行 finally 块代码。 异常的参数1、一个异常可以带上参数，可作为输出的异常信息参数。 2、你可以通过 except 语句来捕获异常的参数，如下所示： 12345try: 正常的操作 ......................except ExceptionType, Argument: 你可以在这输出 Argument 的值...]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 进阶之最全面的命名规范]]></title>
    <url>%2F2018%2F08%2F22%2FAndroid%20%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[今天分享一下 Android 的命名规范，要养成一个良好的规范习惯对以后工作很重要！ Android 进阶之最全面的命名规范目录 1. 为什么规范 Android 代码命名？ 增强代码的可读性 增强代码的可维护性 正由于上述两个作用，从而使得 开发效率 &amp; 维护效率 得到大幅度的提高。 2. Android需要命名的代码（对象）有哪些？ 3. 具体命名规范下面，我将对 Android 代码对象中的命名规范进行详细讲解 注：由于 Android主要用Java实现，所以Android规范会涵盖部分Java规范 3.1 包 基础规则：小写、单词间连续无间隔、反域名法（分为4级，具体如下图） 第4级包名会随着功能的不同而不同。下面我列举出一些常见 &amp; 需要规范的4级功能包名 3.2 类 基础规则 类型 = 名词 / 名词短语； 形式 = 驼峰形式中的 大骆驼拼写法（UpperCamelCase） 即名称中的每个词的首字母都大写，如 AndroidStudio 在具体命名类时，会根据 该类的类型不同而附加额外的命名规则。具体如下图 3.3 变量 基础规则 类型 = 名词 / 名词短语； 形式 = 驼峰形式中的 小骆驼拼写法（LowerCamelCase） 即名称中的第1个词的首字母小写，后面每个词的首字母大写，如androidStudioTool 在具体命名变量时，会根据该变量的类型不同而 附加额外的命名规则。具体如下图 3.4 方法 基础规则 类型 = 动词 / 动词短语； 形式 = 驼峰形式中的 小骆驼拼写法（LowerCamelCase） 即名称中的第1个词的首字母小写，后面每个词的首字母大写，如androidStudioTool 在具体命名 方法名时，会根据 该方法名的作用不同而 附加额外的命名规则。具体如下图 3.5参数名 基础规则：驼峰形式中的 小骆驼拼写法（LowerCamelCase） 即名称中的第1个词的首字母小写，后面每个词的首字母大写，如androidStudioTool 附加命名规则：功能名，如userName 3.6 资源 Android的资源包括： 下面，我将对每种Android资源的命名规则进行详细讲解 3.6.1 布局文件资源 3.6.2 图片资源 3.6.3 参数值资源 3.6.4 动画资源 3.7 额外 至此，关于Android的代码命名规范讲解完毕 4. 附录：常见使用单词缩写表 使用单词缩写的原则：只使用约定俗成的单词缩写 严禁自由缩写单词 具体如下图]]></content>
      <categories>
        <category>Android 初级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 基础之服务的基本用法]]></title>
    <url>%2F2018%2F08%2F21%2FAndroid%20%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[服务是Android 四大组件之一，是非常重要的知识点，下面是 Android 服务的基本用法入门基础讲解。 Android 四大组件之一服务（service）定义一个服务1、新建服务new —&gt; Service — &gt; .java 文件（定义一个服务就必须在里边实现相应的操作） 123456789101112131415//服务创建的时候会调用@Override public void onCreate() &#123; super.onCreate(); &#125;//每次服务启动的时候调用(一旦启动服务，在其方法执行的工作) @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125;//会在服务销毁的时候调用 @Override public void onDestroy() &#123; super.onDestroy(); &#125; 以上是服务最常用到的三个方法。 2、使用服务之前，需要在 AndroidManifest.xml 中注册服务 123456&lt;!--服务注册--&gt;&lt;service android:name=".MyService" //服务的类名 android:enabled="true" //是否允许除当前程序之外的其他程序访问 android:exported="true"&gt; //是否启动这个服务&lt;/service&gt; 启动和停止服务启动服务12Intent startintent = new Intent(this,MyService.class);startService(startintent); 停止服务12Intent stopIntent = new Intent(this,MyService.class);stopService(stopIntent); 活动和服务进行通信 上面我们学习到了服务的启动和停止，我们也知道服务实在活动中启动的，但是活动怎么才能知道服务去干吗了呢？怎么样用活动去指挥服务去完成什么样的任务呢？ 实例1、在 MyService.java 类中创建一个管理下载的 DownloadBinder 类 123456789101112// 用Binder对象来对下载功能进行管理class DownloadBinder extends Binder &#123; public void startDownload()&#123; Log.d("MyService","开始下载..."); &#125; public void getProgress()&#123; Log.d("获取下载进度","获取到了下载进度"); return; &#125;&#125; 我们在布局中创建两个按钮分别（绑定服务）和（取消绑定服务）。 2、创建 ServiceConnection 的匿名类，里边重写了两个方法，分别会在活动与服务成功绑定以及活动与服务的连接断开的时候调用，绑定成功时就会调用相应的方法 123456789101112131415161718192021222324252627 private MyService.DownloadBinder downloadBinder;//活动连接服务的对象private ServiceConnection connection = new ServiceConnection() &#123; /** * 功能：绑定成功 * @param componentName * @param iBinder */ @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; downloadBinder = (MyService.DownloadBinder) iBinder; //开始下载 downloadBinder.startDownload(); //获取下载进度 downloadBinder.getProgress(); &#125; /** * 功能：服务和活动断开时调用 * @param componentName */ @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125;&#125;; 3、绑定服务 12345678Intent bindIntent = new Intent(this,MyService.class);/** * 功能：将 MainActivity与 MyService进行绑定 * 参数一：bindIntent 启动服务Intent对象 * 参数二：connection 活动和服务的连接 * 参数三：BIND_AUTO_CREATE 活动和服务绑定成功后自动创建服务（使MyServiced的onCreate执行） */bindService(bindIntent,connection,BIND_AUTO_CREATE);//绑定服务 4、解除服务 12unbindService(connection);break; 服务的生命周期1、项目的任何位置调用了 Context 的 startService() 方法，服务就会回调 onStartCommand（）方法启动服务。 2、如果这个服务之前没有创建过，onCreate（）方法就会比 onStartCommand（）先执行。服务启动一直保持运行状态，直到 stopService（）或 stopSelf（）方法被调用。 3、每调用一次 startService（）方法，onStartCommand（）方法就会执行一次。 4、调用 Context 的 bindService（）来获取一个服务的持久连接，之后回调 onBind 方法。 5、如果这个服务之前没有创建过，onCreate（）方法就会比 onBind（）方法先执行。]]></content>
      <categories>
        <category>Andoid</category>
      </categories>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2F2018%2F08%2F16%2F%E5%85%B3%E4%BA%8E%E6%88%91%2F</url>
    <content type="text"><![CDATA[关于小鹿的一篇自我介绍！ 自我介绍编程能力Ai、Fw、Fl、Br、Ae、Pr、Id、Ps 等软件的安装与卸载，精通 CSS、JavaScript、PHP、ASP、C、C++、C#、Java、Ruby、Perl、Lisp、Python、Objective-C、ActionScript、Pascal 等单词的拼写，熟悉 Windows、Linux、OS X、Android、iOS、WP8 等系统的开关机。 项目经验本人学识渊博、经验丰富、代码风骚、效率恐怖、C/C++、JAVA、php无不精通、深山苦练20余年、一天只睡4个小时、电话通知出 BUG 后秒登 VPN，千里之外定位问题、瞬息之间修复上线。身体强壮、健步如飞、可连续编程 100 小时不休息、讨论技术方案5小时不喝水，上至带项目、出方案，下至盗账号、威胁 PM，什么都能干。 泡面矿泉水已备好，学校不支持编程已辍学、家人不支持编程已断绝关系、老婆不支持编程已离婚、小孩不支持编程已送孤儿院，备用电源百兆光纤永不断电断网，门口已埋地雷无人打扰。 联系我公众号： 微信：lxq17853556107 欢迎来搞事情！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 进阶之百度推送]]></title>
    <url>%2F2018%2F08%2F16%2FAndroid%20%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%99%BE%E5%BA%A6%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[小鹿带你学会百度推送！ Android 进阶之百度推送步骤第一步：首先在百度云注册账号 （） 第二步：注册好账号之后，创建应用。 第三步：点击创建新应用。 第四步：填写应用名称 第五步：点击创建好应用之后进行应用配置。 第六步：选择终端（这里我们选择 Android），将项目包名填写进去。 第七步：要记住 API KEY 项目中要用到。 第八步：下载百度推送 SDK（官网），添加到项目中。 第九步：开始新建 Android 项目为 BaiDu_Push_Demo。 第十步：在 build.gradle 中添加依赖。 12//加载jar包compile files('src/main/JniLibs/pushservice-6.1.1.21.jar') 第十一步：新建 PushServiceReceiver.java 类（类中都是关于百度推送的回调）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247package com.example.boybaby.baidu_pust_demo;/** * Created by apple on 2018/4/25. */import android.content.Context;import android.text.TextUtils;import android.util.Log;import android.widget.Toast;import org.json.JSONException;import org.json.JSONObject;import java.util.List;/* * Push消息处理receiver。请编写您需要的回调函数， 一般来说： onBind是必须的，用来处理startWork返回值； *onMessage用来接收透传消息； onSetTags、onDelTags、onListTags是tag相关操作的回调； *onNotificationClicked在通知被点击时回调； onUnbind是stopWork接口的返回值回调 * 返回值中的errorCode，解释如下： *0 - Success *10001 - Network Problem *10101 Integrate Check Error *30600 - Internal Server Error *30601 - Method Not Allowed *30602 - Request Params Not Valid *30603 - Authentication Failed *30604 - Quota Use Up Payment Required *30605 -Data Required Not Found *30606 - Request Time Expires Timeout *30607 - Channel Token Timeout *30608 - Bind Relation Not Found *30609 - Bind Number Too Many * 当您遇到以上返回错误时，如果解释不了您的问题，请用同一请求的返回值requestId和errorCode联系我们追查问题。 * */public class PushMessageReceiver extends com.baidu.android.pushservice.PushMessageReceiver &#123; /** * TAG to Log */ public static final String TAG = PushMessageReceiver.class .getSimpleName(); /** * 调用PushManager.startWork后，sdk将对push * server发起绑定请求，这个过程是异步的。绑定请求的结果通过onBind返回。 如果您需要用单播推送，需要把这里获取的channel * id和user id上传到应用server中，再调用server接口用channel id和user id给单个手机或者用户推送。 * * @param context BroadcastReceiver的执行Context * @param errorCode 绑定接口返回值，0 - 成功 * @param appid 应用id。errorCode非0时为null * @param userId 应用user id。errorCode非0时为null * @param channelId 应用channel id。errorCode非0时为null * @param requestId 向服务端发起的请求id。在追查问题时有用； * @return none */ @Override public void onBind(Context context, int errorCode, String appid, String userId, String channelId, String requestId) &#123; String responseString = "onBind errorCode=" + errorCode + " appid=" + appid + " userId=" + userId + " channelId=" + channelId + " requestId=" + requestId; Log.d(TAG, responseString); if (errorCode == 0) &#123; // 绑定成功 Log.d(TAG, "绑定成功"); &#125; &#125; /** * 接收透传消息的函数。 * * @param context 上下文 * @param message 推送的消息 * @param customContentString 自定义内容,为空或者json字符串 */ @Override public void onMessage(Context context, String message, String customContentString) &#123; String messageString = "透传消息 onMessage=\"" + message + "\" customContentString=" + customContentString; Log.d(TAG, messageString); // 自定义内容获取方式，mykey和myvalue对应透传消息推送时自定义内容中设置的键和值 if (!TextUtils.isEmpty(customContentString)) &#123; JSONObject customJson = null; try &#123; customJson = new JSONObject(customContentString); String myvalue = null; if (!customJson.isNull("mykey")) &#123; myvalue = customJson.getString("mykey"); &#125; &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; /** * 接收通知到达的函数。 * * @param context 上下文 * @param title 推送的通知的标题 * @param description 推送的通知的描述 * @param customContentString 自定义内容，为空或者json字符串 */ @Override public void onNotificationArrived(Context context, String title, String description, String customContentString) &#123; String notifyString = "通知到达 onNotificationArrived title=\"" + title + "\" description=\"" + description + "\" customContent=" + customContentString; Log.d(TAG, notifyString); //Toast.makeText(context,description,Toast.LENGTH_LONG).show(); //Intent intent=new Intent(context,Main2Activity.class); //context.startActivity(intent); // 自定义内容获取方式，mykey和myvalue对应通知推送时自定义内容中设置的键和值 if (!TextUtils.isEmpty(customContentString)) &#123; JSONObject customJson = null; try &#123; customJson = new JSONObject(customContentString); String myvalue = null; if (!customJson.isNull("mykey")) &#123; myvalue = customJson.getString("mykey"); &#125; &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; // Demo更新界面展示代码，应用请在这里加入自己的处理逻辑 // 你可以參考 onNotificationClicked中的提示从自定义内容获取具体值 &#125; /** * 接收通知点击的函数。 * * @param context 上下文 * @param title 推送的通知的标题 * @param description 推送的通知的描述 * @param customContentString 自定义内容，为空或者json字符串 */ @Override public void onNotificationClicked(Context context, String title, String description, String customContentString) &#123; String notifyString = "通知点击 onNotificationClicked title=\"" + title + "\" description=\"" + description + "\" customContent=" + customContentString; Log.d(TAG, notifyString); Toast.makeText(context,description,Toast.LENGTH_LONG).show(); // 自定义内容获取方式，mykey和myvalue对应通知推送时自定义内容中设置的键和值 if (!TextUtils.isEmpty(customContentString)) &#123; JSONObject customJson = null; try &#123; customJson = new JSONObject(customContentString); String myvalue = null; if (!customJson.isNull("mykey")) &#123; myvalue = customJson.getString("mykey"); &#125; &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; /** * setTags() 的回调函数。 * * @param context 上下文 * @param errorCode 错误码。0表示某些tag已经设置成功；非0表示所有tag的设置均失败。 * @param failTags 设置失败的tag * @param requestId 分配给对云推送的请求的id */ @Override public void onSetTags(Context context, int errorCode, List&lt;String&gt; sucessTags, List&lt;String&gt; failTags, String requestId) &#123; String responseString = "onSetTags errorCode=" + errorCode + " sucessTags=" + sucessTags + " failTags=" + failTags + " requestId=" + requestId; Log.d(TAG, responseString); &#125; /** * delTags() 的回调函数。 * * @param context 上下文 * @param errorCode 错误码。0表示某些tag已经删除成功；非0表示所有tag均删除失败。 * @param failTags 删除失败的tag * @param requestId 分配给对云推送的请求的id */ @Override public void onDelTags(Context context, int errorCode, List&lt;String&gt; sucessTags, List&lt;String&gt; failTags, String requestId) &#123; String responseString = "onDelTags errorCode=" + errorCode + " sucessTags=" + sucessTags + " failTags=" + failTags + " requestId=" + requestId; Log.d(TAG, responseString); &#125; /** * listTags() 的回调函数。 * * @param context 上下文 * @param errorCode 错误码。0表示列举tag成功；非0表示失败。 * @param tags 当前应用设置的所有tag。 * @param requestId 分配给对云推送的请求的id */ @Override public void onListTags(Context context, int errorCode, List&lt;String&gt; tags, String requestId) &#123; String responseString = "onListTags errorCode=" + errorCode + " tags=" + tags; Log.d(TAG, responseString); &#125; /** * PushManager.stopWork() 的回调函数。 * * @param context 上下文 * @param errorCode 错误码。0表示从云推送解绑定成功；非0表示失败。 * @param requestId 分配给对云推送的请求的id */ @Override public void onUnbind(Context context, int errorCode, String requestId) &#123; String responseString = "onUnbind errorCode=" + errorCode + " requestId = " + requestId; Log.d(TAG, responseString); if (errorCode == 0) &#123; // 解绑定成功 Log.d(TAG, "解绑成功"); &#125; &#125;&#125; 第十二步：在 AndroidManifest.xml 中配置权限和相关服务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.boybaby.baidu_pust_demo"&gt; &lt;!-- Push service 运行需要的权限 --&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt; &lt;uses-permission android:name="android.permission.WRITE_SETTINGS" /&gt; &lt;uses-permission android:name="android.permission.VIBRATE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.DISABLE_KEYGUARD" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;!-- 富媒体需要声明的权限 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_DOWNLOAD_MANAGER" /&gt; &lt;uses-permission android:name="android.permission.DOWNLOAD_WITHOUT_NOTIFICATION" /&gt; &lt;uses-permission android:name="android.permission.EXPAND_STATUS_BAR" /&gt; &lt;!-- 适配Android N系统必需的ContentProvider写权限声明，写权限包含应用包名 --&gt; &lt;uses-permission android:name="baidu.push.permission.WRITE_PUSHINFOPROVIDER.com.example.boybaby.com.example.boybaby.baidu_pust_demo" /&gt; &lt;permission android:name="baidu.push.permission.WRITE_PUSHINFOPROVIDER.com.example.boybaby.com.example.boybaby.baidu_pust_demo" android:protectionLevel="signature"&gt; &lt;/permission&gt; &lt;!-- 权限结束 --&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- push service start --&gt; &lt;!-- 用于接收系统消息以保证PushService正常运行 --&gt; &lt;receiver android:name="com.baidu.android.pushservice.PushServiceReceiver" android:process=":bdservice_v1"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;action android:name="android.net.conn.CONNECTIVITY_CHANGE" /&gt; &lt;action android:name="com.baidu.android.pushservice.action.notification.SHOW" /&gt; &lt;action android:name="com.baidu.android.pushservice.action.media.CLICK" /&gt; &lt;!-- 以下四项为可选的action声明，可大大提高service存活率和消息到达速度 --&gt; &lt;action android:name="android.intent.action.MEDIA_MOUNTED" /&gt; &lt;action android:name="android.intent.action.USER_PRESENT" /&gt; &lt;action android:name="android.intent.action.ACTION_POWER_CONNECTED" /&gt; &lt;action android:name="android.intent.action.ACTION_POWER_DISCONNECTED" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;!-- Push服务接收客户端发送的各种请求 --&gt; &lt;receiver android:name="com.baidu.android.pushservice.RegistrationReceiver" android:process=":bdservice_v1"&gt; &lt;intent-filter&gt; &lt;action android:name="com.baidu.android.pushservice.action.METHOD" /&gt; &lt;action android:name="com.baidu.android.pushservice.action.BIND_SYNC" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.PACKAGE_REMOVED" /&gt; &lt;data android:scheme="package" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;service android:name="com.baidu.android.pushservice.PushService" android:exported="true" android:process=":bdservice_v1"&gt; &lt;intent-filter&gt; &lt;action android:name="com.baidu.android.pushservice.action.PUSH_SERVICE" /&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;!-- 4.4版本新增的CommandService声明，提升小米和魅族手机上的实际推送到达率 --&gt; &lt;service android:name="com.baidu.android.pushservice.CommandService" android:exported="true" /&gt; &lt;!-- 适配Android N系统必需的ContentProvider声明，写权限包含应用包名 --&gt; &lt;provider android:name="com.baidu.android.pushservice.PushInfoProvider" android:authorities="com.example.boybaby.baidu_pust_demo.bdpush" android:exported="true" android:protectionLevel="signature" android:writePermission="baidu.push.permission.WRITE_PUSHINFOPROVIDER.com.example.boybaby.baidu_pust_demo.PushMessageReceiver" /&gt; &lt;!-- push应用定义消息receiver声明 --&gt; &lt;receiver android:name="com.example.boybaby.baidu_pust_demo.PushMessageReceiver"&gt; &lt;intent-filter&gt; &lt;!-- 接收push消息 --&gt; &lt;action android:name="com.baidu.android.pushservice.action.MESSAGE" /&gt; &lt;!-- 接收bind、setTags等method的返回结果 --&gt; &lt;action android:name="com.baidu.android.pushservice.action.RECEIVE" /&gt; &lt;!-- 接收通知点击事件，和通知自定义内容 --&gt; &lt;action android:name="com.baidu.android.pushservice.action.notification.CLICK" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;!-- push结束 --&gt; &lt;/application&gt;&lt;/manifest&gt; 注意：在配置文件中需要将包名换成自己项目的包名。 ① ② ③ 以上三个地方的包名需要改成自己的。 第十三步：在 MainAcitivity 中注册百度推送 API KEY。 12345678910111213141516171819package com.example.boybaby.baidu_pust_demo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import com.baidu.android.pushservice.PushConstants;import com.baidu.android.pushservice.PushManager;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //注册,第三个参数是要修改的API KEY的字符串 PushManager.startWork(getApplicationContext(), PushConstants.LOGIN_TYPE_API_KEY,"Cy1dU6vskzHqPmEmNu2aCZsR"); &#125;&#125; 第十四步：创建通知并发送。 第十五步：发送成功。 手机端收到通知：]]></content>
      <categories>
        <category>Android 初级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 进阶之 Spinner 下拉框]]></title>
    <url>%2F2018%2F08%2F16%2FAndroid%20%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%B8%8B%E6%8B%89%E6%A1%86%2F</url>
    <content type="text"><![CDATA[Android 中下拉框的使用是用 Spinner 来实现的，Sprinner 下拉框中的数据有两种添加方法。一种方法是使用 spinner.xml 布局文件的方式添加，另外一方式是用 Adapter 适配器的方法来实现的。之所以整理今天整理一下 Spinner 的两种方式的使用因为在实际的项目中都用到过，所以做了一个总结。 Android 进阶之 Spinner 下拉框Sprinner 的实现方式一：使用布局文件来传入数据。步骤： 第一步：新建 activity_sprinner.xml 布局文件 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="xml布局引用方式:" android:textSize="20dp"/&gt; &lt;Spinner android:id="@+id/spinner_xml" android:layout_width="120dp" android:layout_height="wrap_content"&gt; &lt;/Spinner&gt;&lt;/LinearLayout&gt; 第二步：在 values 文件夹下新建 spinner.xml 文件。 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;string-array name="spingArr"&gt; &lt;item&gt;中国&lt;/item&gt; &lt;item&gt;美国&lt;/item&gt; &lt;item&gt;俄国&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 第三步：新建 SpinnerActivity.java 类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class SpinnerActivity extends AppCompatActivity &#123; //声明控件 private Spinner spinner; private TextView textView; private ArrayAdapter arrayAdapter; private String spinnerStr; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.actvity_spinner); //关联控件 spinner = (Spinner) findViewById(R.id.spinner_xml); textView = (TextView) findViewById(R.id.tv_text); //使数据布局文件和Adapter适配器关联 relevanceSpinner(); //Spinner下拉框监听事件 spinner.setOnItemSelectedListener(new Spinner.OnItemSelectedListener() &#123; //选择下拉框数据监听 public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; spinnerStr = arrayAdapter.getItem(arg2).toString(); textView.setText(spinnerStr); &#125; //未选择下拉框监听 public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; spinnerStr = ""; &#125; &#125;); &#125; //使数据布局文件和Adapter适配器关联 public void relevanceSpinner()&#123; //R.array.spingArr 为 values 文件夹下 spinner.xml 中 string-array 的 name 值 arrayAdapter = ArrayAdapter.createFromResource(this, R.array.spingArr, android.R.layout.simple_spinner_item); //将 adapter2 添加到 spinner 中 spinner.setAdapter(arrayAdapter); &#125;&#125; 最终运行图示： Sprinner的实现方式二：在Activity中动态传入数据显示。步骤步骤一：新建 activity_main.xml布局文件。 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Activity引用方式:" android:textSize="20dp"/&gt; &lt;Spinner android:id="@+id/spinner_equment_name" android:layout_width="120dp" android:layout_height="wrap_content"&gt; &lt;/Spinner&gt; &lt;TextView android:id="@+id/tvText" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 步骤二：新建 MainActivity.java 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity &#123; //声明控件 private Spinner spinner; private ArrayAdapter arr_adapter = null; private List&lt;String&gt; list = new ArrayList&lt;String&gt;(); private TextView text; private String spinnerText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //关联控件 spinner = (Spinner) findViewById(R.id.spinner_equment_name); text = (TextView)findViewById(R.id.tvText); //list填充数据（如果是服务器接收的数据可动态填充） list.add("中国"); list.add("美国"); list.add("俄国"); //适配器 arr_adapter = new ArrayAdapter(this, android.R.layout.simple_spinner_item, list); //设置样式 arr_adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); //加载spinner适配器 spinner.setAdapter(arr_adapter); //Spinner 选择数据监听事件 spinner.setOnItemSelectedListener(new Spinner.OnItemSelectedListener() &#123; public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; spinnerText = arr_adapter.getItem(arg2).toString(); text.setText(spinnerText); &#125; public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; spinnerText = ""; text.setText(spinnerText); &#125; &#125;); &#125;&#125; 运行显示图示： 还有一些关于Spinner的属性等到用到时在补充，以上就是这些，谢谢！]]></content>
      <categories>
        <category>Android 初级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 之一切皆对象]]></title>
    <url>%2F2018%2F08%2F16%2F%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%20java%20%E4%B9%8B%E3%80%90%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[Java语言是面向对象的编程语言，当我们用Java做实际开发时，我们必须将思想转化到面向对象的世界中。这是作为一个Java程序员的基本功，如果你兼备使用这种语言的一种能力，会使你学起来更加简单。我们在项目开发中，经常做到会new对象、会使用对象已经足够了。想知道java对象在程序内怎么存储怎么使用的吗？今天的内容深入剖析java对象。 Java 之一切皆对象一、用引用操纵对象什么是引用在java程序中，尽管我们一切都将看作为对象，但实际上操作对象的标识符实际上是对象的一个“引用（referen）”。 为了读者方便理解，我们可以将操纵对象的标识符想象成电视机的遥控器（引用），电视机为对象。只要握住遥控器，我们就可以保持与电视机的连接。当我们减小电视机的音量时，我们的实际操控是遥控器（引用），再由遥控器操纵电视机（对象）。以上形象的比喻就是我们在 java 中使用对象时，不是直接对对象进行操作，而是通过引用进而对对象的控制操作。 即使我们没有电视机，遥控器也可以独立的存在。也就是说，我们可以单独的拥有一个引用，并不一定需要一个对象去关联。下面举个小例子详细说明，我们可以创建一个 String 的引用。 String s; 这里所创建的只是引用，并不是对象。如果此时此刻对s进行输出使用，运行时就会返回一个错误。因为s实际上没有与任何的事物关联。因此，为了安全起见，我们通常在项目中创建一个引用通常做初始化处理：String = “abc”; 这里用到的是字符串带文本的初始化，通常还有另外一种更通用的方法。 对象的创建与存储我们一旦创建了引用就必须关联一个对象，通常用new关键字来实现。new关键字的意思是“给我一个新对象”，所以另一种初始化字符串的方式为： String s = new String(“abc”); 除此之外，java中还有很多数据类型，以上只是举个小例子。 对象存储到了什么地方？很多人对会在程序中很轻松的new出一个对象，但是对象到底存储到什么地方呢？特别是内存会发生什么变化呢？下边的讲解会对你有很大的帮助。 寄存器。这是这是最快的存储区，因为这是位于不同于其他的存储位置—处理器内部。但是寄存器的数量有限，所以寄存器根据需求进行分配。 栈堆。位于 RAM（随机访问存储器）中，通过栈堆指针从处理器那获取直接支持。如果栈堆指针向下移动，则重新分配新的内存。若指针向上移动，则释放内存空间。某些的java数据就存储到栈堆中，比如上面讲到的遥控器（引用）就存储到该区域，而对象并不存储到其中。 堆。一种通用的内存池，（位于 RAM ）中，用于存放 java 所有的对象。堆不同于栈堆的好处就是：编译器不知道存储到堆里的数据存活多长时间。因此，在堆里分配存储有很大的灵活性。当需要一个对象时，只需要new写一行代码，当执行到该代码时，会自动在堆里进行存储分配。堆的分配清理空间比栈堆的花费的时间要长。 常量存储。常量值通常直接存放到程序的内部，这样做是安全的，因为他们的值永远不会被改变。在嵌入式系统开发中，常量本身会和其他部分分隔开，在这种情况下，我们可以选择将其存放到 ROM（只读存储器）中。 ​ 5. 非RAM存储。如果数据完全存活于程序之外，那么它可以不受程序任何控制，在程序没有运行时也可以存在。两个基本的例子就是流对象和持久化对象。在流对象中，数据转化为字节流，通常被发送到另一个机器。在“持久化对象”中，对 象被存放于磁盘上，因此即使程序终止，他们仍可以保持原有的状态。这种存储方式的技巧在于：把对象转化成可以存放在其他媒体的事物，在需要时，再恢复成常规，基于RAM的对象]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 进阶之 OKHttp 与服务器通信]]></title>
    <url>%2F2018%2F08%2F12%2FAndroid%20%E8%BF%9B%E9%98%B6%E4%B9%8B%20Okhttp%20%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[人生中第一次写博客，也就是大学大二期间。我认为记录这些点点滴滴的经验和知识有两点必要。第一，是能够记录自己在学习IT之路的一些经验和知识的整理；第二，把自己所理解的知识点更能详细分享给喜欢编程的每一个人，希望读者看了这些能够有所帮助，虽然别人也写到同样的知识，但是我通过学习这个知识点再加上我的个人理解来记录下来，有些知识说的不到位请各位批评改正！ ​ 言归正传，下面来讲一下利用okhttp做服务器通信（socket通信），之前大多数开发者用的是流的通信方式，自从安卓提供okhttp框架之后，实现客户端与服务器的通信更方便快捷了，废话不多说，下面我进行一一讲解！TT 搭建OkHTTP框架之前注意： 1、在 build 中加入okhttp，Gson 的架包，修改 build.gradle（app）中加上： 1compile 'com.squareup.okhttp:okhttp:2.4.0' 2、在 AndroidManifest 中增加请求网络的权限（如不加，APP连不上网络）； 1&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 搭建步骤： 1、首先创建okhttp对象，设置为全局（以下操作都围绕该对象来做的） 1OkHttpClient okHttpClient = new OkHttpClient(); 2、对该对象进行封装（里边携带往服务器发送的相关参数（如果不是自己服务器参考该服务器开发文档）和URL（服务器提供的接口API）） 123456789101112131415161718192021222324252627Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; MediaType JSON = MediaType.parse("application/json; charset=utf-8"); List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();//将JSON数据以Map形式存储到list中去,以List数组形式存储着数据; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //建立Map对象，向Map添加数据; map.put("StartTime", "2018-01-11 09:14"); map.put("EndTime", ""); map.put("Interval", "5"); map.put("Start", "0"); map.put("Limit", "1"); map.put("Order", "1"); list.add(map); JSONObject jsonObject = new JSONObject(map); //创建JSONObject对象; String string = jsonObject.toString(); //将jsonObject对象转换成字符串; RequestBody body = RequestBody.create(JSON, string);//将JSON数据打包成Body通过post上传; Request request = new Request.Builder() .url(Get_All_url) //该服务器的api（URL） .addHeader("userkey", "55656535336494b84c749b31453ea55") .post(body) .build(); executeRequest(request); &#125; &#125;); t1.start(); 做服务器连接是一个耗时的工作要在线程里完成，这里我将发往服务器的相关参数封装到 Map 里边然后将 Map 放到 List 中将 List 打包成 JSONobject 对象，然后将对象转化成字符串才能封装成传输数据的 body 才能上传服务器，body “相当于人的身体”，将其封装到 request 对象中，如果相关服务器有相关的 key 标识的话，可以通过 addHeader 键值对方式存到 request 头部，这样一个完整的数据包打包成功了，可以通 executeRequest(request)发送到服务器！ 补充：在以上封装数据的时候可能与别的博主写的不同，但是用这个List/map的格式封装感觉更易懂一些，下面就详细说一下。 我们通常看到别人的 okhttp 上传都是用到的 FormEncodingBuilder 可以简单理解为表单的形式，代码如下： 123456789FormEncodingBuilder builder = new FormEncodingBuilder ();builder.add("username","admin");builder.ass("password","123");Request request = new Request.Builder() .url(https://mp.csdn.net/) //该服务器的api（URL） .addHeader("userkey", "2312333321323") //头部标识（不需要可去掉） .post(builder.builde()) .build(); executeRequest(request); 我们都知道网络通信的格式大多数 Json 数据，我们要利用 map 和 List 的结合打包成 Json 数据，下面举个例子,比如我们要打包成这种形式的 Json 数据： 123456Map&lt;String, String&gt; map1 = new HashMap&lt;&gt;();//生成一个Map类型对象map1 Map&lt;String, String&gt; map2 = new HashMap&lt;&gt;();//生成一个Map类型对象map2map1.add("Name","T1");map1.add("Value","1");map2.add("Name","01H1");map2.add("Value","96.2")； 在 Json 数据中一个{}里的内容就称为一个对象，{“Name”:”T1”,”Value”,”1”} 称为一个对象，我们将这个对象数据以 Map 键值对类型存到 map1 中，同理将第二个 Json 对象存放到 map2 中去，map1、map2就可以封装成{“Name”:”T1”,”Value”,”1”}，{“Name”:”01H1”,”Value”,”96.2”} 的形式，我们可以清楚的看到两个{}对象最外层还包含着一个 [ ] 的括号，我们就可以将 [ ] 用 List 来表示，那 List 存放的数据类型是什么呢？不明思义，当然是{}两个 json 对象咯，{ } 两个对象用 map 封装的，所以 List 中存放着 Map 类型的数据，我们可以这样声明并添加： 123456789List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();//我们将封装好的map1和map2添加到list中去list.add(map1);list.add(map2);//我们将list装换成JsonArray数组形式JsonArray jsonarray = new JSONArray(list);//我们再把jsonarray形式转化成字符串就可以上传了String str = jsonarray.toString();RequestBody body = RequestBody.create(JSON, str); 经过以上的层层封装，我们终于把数据封装成想要的样子，简单总结一下， { } 的数据用 Map 键值对进行封装，而 [] Json 数组形式用 List 封装，最后那 List 转化成 JsonArray 数组形式就可以得到想要的数据了！ 注意：如果Json 数据只由 {} 对象形式封装成的，我们可以将 map 转化成 JsonObject 对象,然后将 JsonObject 妆化成字符串上传服务器！ 12JsonObject jsonobject = new JSONObject(map1);String str = new jsonobjct.toString(); 经过上边的讲解你是否可以封装任意 Json 数据了呢？ 3、第三步是来对服务器返回的数据做处理 该 OKHTTP 框架也提供了简单的服务器回调方法，下边我们来看一下 12345678910111213141516171819202122232425//服务器返回调用函数private void executeRequest(Request request) &#123; //3.将Request封装为Call Call call = new OkHttpClient().newCall(request); //4.执行call call.enqueue(new Callback() &#123; @Override//回调错误时 public void onFailure(Request request, IOException e) &#123; &#125; @Override//回调成功时 public void onResponse(Response response) throws IOException &#123; final String relsult = response.body().string();//接收服务器返回来的信息 try &#123; JSONArray jsonarray = new JSONArray(relsult);//将返回的信息转换成JSON形式 &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; 当服务器进行响应时，会自动的调用 executeRequest() 函数，回调函数中自带的两种相应方法分别为服务器响应失败和服务器响应成功，开发人员可以在其中做相应的解析和回调！]]></content>
      <categories>
        <category>Android 初级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 深入剖析四种启动模式]]></title>
    <url>%2F2018%2F08%2F08%2FAndroid%20%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在 Android 应用开发中，打造良好的用户体验是非常重要的。 Android 系统中的 Activity 可以说一件很赞的设计，它在内存管理上良好的设计，使得多任务管理在Android系统中运行游刃有余。下面小鹿带你全面解析 Android 的四大启动模式 Android 深入剖析四种启动模式一、四大启动模式 ​ 在实际项目中，根据特定的需求需要对每个活动指定恰当的启动模式。Android 页面的启动模式分为四种：standard、singleTop、singleTask和singleInstance，可以通过 AndroidManifest.xml 中通过给标签指定 android:launchMode 属性来选择启动模式。 1、standard​ standard 是活动默认的启动模式。在不进行设置的情况下，所有的活动都是自动使用这种启动模式。在这里讲启动模式之前，先说一下 Android 是利用返回栈来管理活动的。对于基础差的开发者还不理解 Android 活动（页面）是怎么进行管理的，就是用到刚刚上边说到的返回栈来管理活动的。 ​ 我们详细来看一下，根据我自己对任务的理解来详细说一下，Android 是使用任务（Task）来管理活动的，一个任务就是存放到栈里的活动（页面）的集合，这个栈也成为返回栈（Back Stack）,栈是一种先进后出的的数据结构，在默认的情况下，每当启动一个活动，它会在返回栈中入栈，并位于栈的顶端位置，每当用户按Back键或调用finish()方法去毁掉一个活动时，处于栈顶的活动就会出栈，这时，前一个入栈的活动就会处于栈顶位置。也就是说，用户可以看到的活动（页面）就是处于栈顶的活动！（为了更好的理解我的给大家大体画了个图） 我新建了一个项目，代码如下，我启动三次第一个页面进行测试： 123456789101112@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //控制台打印本页面的存标识 Log.d("FirstActivity",this.toString()); setContentView(R.layout.activity_first);&#125;//启动本页面public void Start_Intent(View v)&#123; Intent intent = new Intent(FirstActivity.this,FirstActivity.class); startActivity(intent);&#125; 控制台打印信息为： 从控制台打印信息可以看到，每点击一下按钮都会创建一个 FirstActivity 实例，这时，返回栈中也有三个实例，当我们按 Back 键退出时需要按三下才能退出程序！（如图）: 2、singleTop 当活动的启动模式指定为 singleTop，在启动活动如果发现返回栈栈顶已经是该活动时，就直接去使用它，不会创建新的活动实例。 代码如下： 12345678&lt;activity android:name=".FirstActivity" android:launchMode="singleTop"&gt;//启动模式singleTop &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 123456789101112131415public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //控制台打印本页面的存标识 Log.d("FirstActivity",this.toString()); setContentView(R.layout.activity_first); &#125; //启动本页面 public void Start_Intent(View v)&#123; Intent intent = new Intent(FirstActivity.this,SecondActivity.class); startActivity(intent); &#125;&#125; 1234567891011121314public class SecondActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Log.d("SecondActivity",this.toString()); &#125; //启动本页面 public void Start_Intent(View v)&#123; Intent intent = new Intent(SecondActivity.this,FirstActivity.class); startActivity(intent); &#125;&#125; 从打印信息可以看出，创建了两个 FirstActivity 实例，因为我们在 FirstActivity 跳转到 SecondActivity 时，位于栈顶的是 SecondActivity ,因此会再创建一个新的实例 FirstActivity .当用户按下 Back 三次才可以退出程序。下面看示意图： 3、singleTask​ 开发者使用 singleTask 可以解决上边 singleTop 模式重复创建栈顶活动的问题，为了避免活动不处于栈顶重复创建活动实例的情况，我们可以使用 singleTask 的模式。这个模式的特点是什么呢？当每次用户启动一个活动时，系统先检查返回栈的是否存在该活动，如果不存在就创建一个新的实例，如果存在该活动，位于该活动顶部的活动全部出栈，使该活动处于栈顶！代码改一下上方的 android：launchMode=”singleTask” 可以自己试一下！示意图如下： 4、singleInstance​ singleInstance模式比前边的三种模式要复杂一些，与前边的三个模式不同的是指定为 singleIntance 模式的活动会启动一个新的返回栈来管理这个活动，什么时候可以用到这个模式呢？当我们这个程序的活动允许其他程序调用时，要实现这个程序和其他程序共享这个活动的话，前边的三种模式都实现不了，因为每个程序都有自己的返回栈，同一个活动在不同的返回栈中入栈的时候会创建一个新的实例。而 singleIntance 模式可以解决这个问题，以为这个模式有一个独立的返回栈来管理这个活动，无论有多少程序来调用这个活动，都共用同一个返回栈。 ​ 举个例子：我们建立三个页面，分别为FirstActivity、SecondActivity、ThirdActivity 每个页面都要分别用 123Log.d(&quot;FirstActivity&quot;,&quot;getTaskId()&quot;);Log.d(&quot;SecondActivity&quot;,&quot;getTaskId()&quot;);Log.d(&quot;ThirdActivity&quot;,&quot;getTaskId()&quot;); 来查看创建返回栈的 id,我们将 singleIntance 模式指定为 SecondActivity 页面，我们实现三个页面的连续跳转，控制台打印出信息为：121、122、121。可以很明白的看出 SecondActivity 单独位于一个返回栈中。 ​ FirstActivity*页面跳转到 SecondActivity 页面，我来解释一下，因为 FirstActivity 和 ThirdActivity 位于同一个返回栈中，所以 ThirdActivity 位于栈顶出栈，FirstActivity 页面位于栈顶，所以 ThirdActivity 页面直接跳转到 FirstActivity 页面，再按 Back 键时，FirstActivity 和 ThirdActivity 的返回栈为空，就会显示另一个返回栈的活动，当另一个返回栈的活动出栈时，程序才会退出！ 示意图如下： 二、四大启动模式深入剖析 Activity 的启动模式也是一个难点，原因是形形色色的启动模式和标志位太容易混淆，但是 Activity 作为四大组件之首，它的确非常重要，为了满足项目的需求，必须使用 Activity 的启动模式。 1、Activity 的 LaunchMode1.1 启动模式​ 之所以 Activity 使用启动模式，因为 Activity 的创建是在任务栈中的，当我们启动同一个 Activity 时，系统就会创建多个 Activity 实例放入任务栈中，当我们按 back 键时，任务栈中的实例就会一一出栈。栈我想并不陌生，具有的特点：先进先出。如果我们不允许系统重复创建相同的 Activity ，我们就会用到 Activity 的启动模式进行设置。Activity 的启动模式分为四种 standard、singleTop、singleTask和 singleInstance,之前的那篇文章也有相关介绍，下面就简单提一下。 （1）standard 标准模式 :​ 这是系统默认的启动模式，每次启动一个 Activity 都会创建一个新的实例，不管这个实例是否存在。如果 A 启动了 B，B 的活动就会进入到 A 的任务栈中。 （2）singleTop 栈顶复用模式 :​ 在这种启动模式下，新的 Activity 已经位于栈顶，如果再次启动该 Activity ，此 Activity 不会被重新创建。同时系统的 onNewIntent 方法被回调，通过此方法的参数我们可以取出当前的请求信息。当然 Activity 的 onCreate、onStart 和 onResume 方法不会重新被调用。如果该 Activity 没有位于栈顶，该活动就会重新被创建。 （3）singleTask 栈内复用模式 :​ 这是一种单例模式，在这种模式下，只要栈中存在该实例，该实例不会被重新创建。比如：我们想要创建一个实例 A，系统就会先判断任务栈中是否存在和 A 同样的实例。如果实例存在任务栈中，系统就会把 A 调用到栈顶并调用它的 onNewIntent 方法，同时 A 以上的 Activity 实例都会被移除出栈直到 A 位于栈顶位置；如果实例不存在，系统就会创新创建一个新的实例 A 并将其压入栈顶。 （3）singleInstance 单实例模式 :​ 我通常把这种模式的 Activity 称为 singleTask 模式的加强版，除了具有 singleTask 模式具有的特点外，以 singleInstance 启动的 Activity 实例单独存在一个任务栈中，后续的请求不会创建新的实例。 1.2 任务栈什么是任务栈？各个 Activity 是怎么样分配到各个任务栈的？以下情况都是在 singleTask 模式情况下来说的。 从一个参数说起，TaskAffinity ，翻译为任务的相关性，这个参数标识了一个 Activity 所需要得任务栈的名字，默认情况下，Activity 所需要的任务栈的名字为应用的包名。任务栈分为前台任务栈和后台任务栈，后台任务栈中的 Activity 处于暂停状态，用户可以将后台任务栈切换到前台。 ——任务栈 1.3 设置启动模式的两种方式 第一种方式 : 通过 AndroidMenifest 配置文件设置启动模式 12345678910&lt;activity android:name=".MonitoringActivitys.MonitorActivity" android:label="@string/title_activity_monitor" android:theme="@style/AppTheme.NoActionBar" android:launchMode="singleTask"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 第二种方式 : 通过 Intent 中设置标志位来设置启动模式 123Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 区别： ① 第二种优先级要高于第一种 ② 第一种无法给 Activity 设定 FLAG_ACTIVITY_CLEAR_TOP 标识，第二种无法为 Activity 指定 singleInstance 模式。]]></content>
      <categories>
        <category>Android 高级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 深入剖析生命周期]]></title>
    <url>%2F2018%2F08%2F08%2FAndroid%20%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Activity 生命周期是研究Android开发最基础的知识点之一，熟练掌握生命周期的特性可以在实际开发中避免踩坑。比如，一些UI的初始化和回收操作、框架库的注册于反注册（摧毁）、线程的启动和停止等。 Android 的生命周期深入剖析一、正常情况下生命周期 onCreate : 表示页面（Activity）的创建。（生命周期第一个阶段）功能：完成初始化工作，如：加载页面布局资源、初始化数据。 onStart : 表示页面（Activity）正在被启动，即将开始。功能：页面为可见状态，但是无法与用户交互。 onResume : 表示页面（Activity）出现在前台。功能：与 onStart 相比，onStart 处于后台，OnResume 才显示到前台。 onPause : 表示页面（Activity）正在停止。功能：页面处于后台，正常情况下，onStop 紧接着执行。此时会做一些数据存储、停止动画不太耗时的工作。onPause 执行完新的页面（Activity）的 onResume 才会执行。 onStop : 表示页面（Activity）即将停止。功能：页面为不可见状态，做稍微轻量级的不太耗时的回收工作。 onDestroy : 表示页面（Activity）即将销毁。（生命周期最后一个阶段）功能：回收工作和资源的释放。 onRestart : 表示页面（Activity）重新启动。功能：页面从不可见状态转化为可见状态时会调用此方法。如：Home 键切换页面（打开新的 Activity），然后回到页面过程中。 问题：1、onStart 和 onResume、onPause和onStop从描述上来看差不多，对我们来说有什么实质上的不同？ 答：onStart 和 onStop 是从 Activity 是否可见这个角度来回调的，而 onResume 和 onPause 是从是否位于前台来回调的。 2、假设当前 Activity 为 A。如果用户打开一个新的 Activity B，那么 B 的 onResume 和 A 的 onPause 哪个先执行？ 答：根据 Android 的基本运行机制，不能再 onPause 中执行重量级的操作，因为必须 onPause 执行完成以后新 Activity 才能 onResume。onPause 和 onResume 都不能执行耗时的操作，尤其是 onPause，这就意味着我们应该在 onStop 中做操作。从而使新的 Activity 显示出来并切换到前台。 二、异常情况下生命周期1、情况一：资源相关的系统配置发生改变导致 Activity 被杀死并重新创建 比如当前Activity处于竖屏状态，如果突然旋转屏幕，由于系统配置发生改变，在默认情况下，Activity 就会被销毁并且重新创建。 （1）异常生命周期调用过程： ​ ① Activity 会被销毁，其中 onPause、onStop、onDestory均会被调用，同时由于 Activity 是在异常情况下终止的 ​ ② 系统会调用 onSavaInstanceState 来保存当前的 Activity 的状态。这个方法的调用时机是在 onStop 之前，它和 onPause 没有既定的时序关系，它既可能在 onPause 之前或者之后调用。这种情况只会出现在 Activity 被异常终止的条件下。 ​ ③ 当 Activity 被重新创建后，系统会调用 onRestoreInstanceState,并且把 Activity 销毁时的 onSaveInstanceState 方法所保存的 Bundle 对象作为参数同时传递给 onRestoreInstanceState 和 onCreate 方法。因此我们可以通过判断 onRestoreInstanceState 和 onCreate 方法是否被重建。 ​ ④ 如果被重建了，我们会取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceState 的调用在 onStart 之后。 （2）需要注意的两点： ★ 我们销毁 Activity 重新创建获取数据状态时，有两种方式，接收位置可以选择 onRestoreInstanceState（官方建议使用）或者 onCreate 两者的区别。 ​ ① onRestoreInstanceState 一旦被调用，其参数 Bundle saveInstanceState 一定是有值的，我们不用额外的判断是否为空。 ​ ② onCreate 正常启动的话，其参数 Bundle saveInstanceState 为 null,所以必须进行额外的判断。 ​ ③ 系统只有在 Activity 异常终止的时候才会调用 onSaveInstanceState 和 onRestoreInstanceState 来存储和恢复数据，其他情况不会出发这个过程。 2、情况二：资源内存不足导致低优先级的 Activity 被杀死（1）先描述一下 Activity 的优先级情况，Activity 的优先级从高到底，可分为一下三种： ​ ① 前台 Activity —— 正在和用户交互的 Activity ，优先级最高。 ​ ② 可见但非前台的 Activity —— 比如 Activity 中弹出了一个对话框，导致 Activity 可见但是位于后台和无法与用户直接交互。 ​ ③ 后台 Activity —— 已经被暂停的 Activity ，比如执行了 onStop ，优先级最低。 （2）资源内存不足时的过程分析： ​ ① 当系统资源不足时，系统会按照上述优先级去杀死目标的 Activity 所在的进程，并在后续通过 onSaveInstanceState 和 onRestoreInstanceState 来存储和恢复数据。如果一些后台的进程脱离了四大组件而独立运行，那么这个进程很快就被杀死。我们常常将后台工作放到 Service 中保持进程具有一定的优先级。 （3）问题：当系统发生改变时，我们不想让 Activity 发生改变，比如，当我们旋转屏幕时，不想重新创建新的 Activity ，我们会怎么操作？ ​ 如果我们没有在 configChanges 属性中指定选项的话，当系统配置发生改变的话 Activity 就会被重新创建。我们常用到的三个属性： ​ ① locale : 设备的本地位置发生了改变，一般指切换了系统语言。 ​ ② keyboardHidden : 键盘可访问性发生了改变，比如用户调用了键盘。 ​ ③ orientation ： 屏幕方向发生了改变，这个是最常用到的，比如旋转的手机屏幕，一般与 screenSize 属性值配合使用。 ​ 这样，Activity 不会被创建，onSaveInstanceState 和 onRestoreInstanceState 方法不会被调用，取而代之，系统调用了 onConfigurationChanged 方法，这个时候我们可以做一些特殊的处理了。]]></content>
      <categories>
        <category>Android 高级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 深入剖析消息机制]]></title>
    <url>%2F2018%2F07%2F31%2FAndroid%20%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android 的消息机制主要是指 Handler 的运行机制，对于大家来说Handler已经是轻车熟路了，可是真的掌握了Handler？本文主要通过几个问题围绕着Handler展开深入并拓展的了解。 小鹿带你全面深入了解 Android 消息机制。 Android 的消息机制深入剖析Android 的消息机制主要是指 Handlerr 的运行需要底层的 MessageQueue 和 Looper 的支撑。 （1）MessageQueue 的中文翻译是消息队列。以队列的形式对外提供插入和删除工作。虽然叫做消息队列，但是内部存储结构并不是真正的队列，而是以单链表的数据结构来存储消息列表。 （2）Looper 的中文翻译为循环，我们叫它消息循环。由于 MessageQueue 只是一个存储单元，不会去处理消息。而 Looper 确弥补了这个功能，Looper 会以无限无限循环的形式去查找是否有新的消息，有的话就去处理消息，否则就一直等待。 学习思维导图： 一、Android 消息机制概述 Android 消息机制主要是指 Handler 的运行机制以及 Handler 所附带的 MessageQueue 和 Looper的工作过程。Handler 的主要作用就是将一个任务切换到某个指定的线程中去执行。 1、概述（1）、思考：为什么 Android 要提供这个功能呢？答：因为 Android 规定访问 UI 线程只能在主线程中进行的，如果在子线程中访问 UI ，那么程序就会抛出异常。 （2）、源码：经过查看看源码的 checkThread（）方法对更新 UI 是否在主线程中更新，进行抛出异常信息提示开发者（相信在开发中都遇到过这个种情况）。 （3)、过程：由于以上限制，这就要求开发者必须在主线程中更新 UI，但是 Android 又建议不要在主线程中进行过于耗时的工作，否则会产生应用程序无响应 ANR。考虑到这种情况，当我们在服务器拉去一些信息并显示到 UI 上时，拉去工作我们将在子线程中进行，拉取完毕之后不能再子线程中直接更新 UI ，没有 Handler ，那我们的确没有办法将访问 UI 的工作切换到主线程去执行。因此，系统之所以给我们提供 Handler，主要原因是为了解决在子线程中无法访问 UI 的矛盾。 （4)、问题： ① 为什么不能再子线程中更新 UI？答 ： 因为 Android 的 UI 控件不是线性安全的。如果在多线程中并发的访问可能会导致 UI 控件处于不可预期的状态。 ② 为什么不对 UI 控件的访问加上锁机制呢？答 ：首先，加上锁机制会让访问 UI 变的复杂，其次锁机制会降低 UI 的访问效率，因为锁机制会阻塞某些线程的执行。 最简单最高效的就是采用单线程模型来处理 UI 操作，只需通过 Handlerr 切换一下 UI 访问的执行线程即可。 2、Handler 的工作原理 Handler 创建时就会采用当前的 Looper 来构建内部的消息循环系统，如果当前没有 Looper ,那么就会报错。 怎么解决上述问题？两个方法： ① 为当前线程创建 Looper 即可。② 在 Looper 的线程中创建 Handler 也可以。 工作原理：（1）Handler 创建过程： Handler 被创建之后，内部的 MessageQueue 和 Looper 就与 Handler 一起工作协同工作了， 然后通过 Handler 的 post 方法将一个 Runnable 投递给 Handler 内部的 Looper 去处理；也可以通过 Handler 的 send 方法发送一个消息，也是通过 Looper 去处理的，其实 Post 方法最终也是通过 send 方法来完成的.. （2）send 方法的工作过程：当 Handler 的 send 方法被调用时，它会调用 MessageQueue 的 enqueueMessage 方法将这个消息放到消息队列中，然后 Looper 发现新消息，就会处理这个消息，最终消息的 Runnable 或者 Handler 的 handlerMessage 方法就会被调用。 二、 Android 的消息机制分析1、消息队列的工作原理 消息队列在 Android 主要是指 MessageQueue ，MessageQueue 主要包括两个操作：插入和删除。消息队列的内部实现并不是队列，实际上通过一条单链表的数据结构来维护消息队列，单链表在插入删除上很有优势。 ① 插入（enqueueMessage）：往消息队列中插入一条消息。（源码实现就是单链表的插入） ② 删除（next）：从消息队列中取出一条消息并将其从消息队列中移除。（next 是一个无限循环的方法，消息队列没有信息就处于阻塞状态，有新消息到来就执行单链表的删除） 2、Lopper 的工作原理 Looper 在 Android 消息机制中扮演着消息循环的角色，作用：不停地从 MessageQueue 中查看是否有新的消息，如果有消息就会立刻处理，如果没有消息就会处于阻塞状态。 （1) Looper 的构造方法① 创建一个 MessageQueue 消息队列。 ② 将当前线程的对象保存起来。 （2）如何为一个线程创建 Looper（Handle 的工作需要 Looper，没有 Looper 就会报错） ① 通过 Looper.prepare() 方法为线程创建一个 Looper 。 ② 通过 Looper.loop() 方法来开启消息循环。 （3）创建线程的另一种方法① 主线程 Looper 的获取。 Looper 这个方法主要给线程也就是 ActivityThread 创建 Looper 使用的，本质也是通过 prepare 来实现的，由于主线程的 Looper 比较特殊，所以 Looper 提供了一个 getMainLopper 的方法获取主线程的 Looper。 ② Looper 的退出。** Looper 提供了两个方法：quit 方法和 quitSafely** 方法。 两者区别： quite 直接退出 Looper。 而 quitSafely 只是设定一个退出标记，先把消息队列中的消息处理完之后再退出（4）Looper.loop() 方法实现原理loop 是一个死循环，唯一能跳出循环的方法就是 MessageQueue 的 next 方法返回了 null。当 Looper 的 quit 方法被调用时，MessageQueue 的 quit 方法或者 quitSafely 方法就会通知消息队列退出，当消息队列被标记为退出状态时，next 就会返回一个 null。Looper 是必须退出的，否则 loop 会永远循环下去。loop 方法会调用 MessageQueue 的 next 方法获取消息，如果 MessageQueue 没有消息，next 就会处于阻塞状态，loop 方法也会处于阻塞状态。 3、详解 Handler 的工作原理 Handler 的主要工作就是发送和接收消息。消息的发送可以通过 post 一系列方法以及 send 的一系列方法来实现，post 的一系列方法最终都是通过 send 一系列方法来实现的。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HandlerActivity extends Activity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //开启线程 handler(); &#125; //主线程 Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 1: // 获取Message里面的复杂数据 Bundle date = new Bundle(); date = msg.getData(); String name = date.getString(&quot;name&quot;); int age = date.getInt(&quot;age&quot;); String sex = date.getString(&quot;sex&quot;); //这里是主线程，可进行对UI的更新 textView.setText(name) &#125; &#125; &#125;; //子线程 public void handler()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Message message = new Message(); message.what = 1; // Message对象保存的数据是Bundle类型的 Bundle data = new Bundle(); data.putString(&quot;name&quot;, &quot;李文志&quot;); data.putInt(&quot;age&quot;, 18); data.putString(&quot;sex&quot;, &quot;男&quot;); // 把数据保存到Message对象中 message.setData(data); // 使用Handler对象发送消息 handler.sendMessage(message); &#125; &#125;).start(); &#125;&#125; （1）发送消息通过对源码分析，Handler 发送消息的过程仅仅是向消息队列中插入一条信息，MessageQueue 的 next 方法就会返回这条信息给 Looper ,Looper 接收到消息之后就立即处理，由 Looper 交给 Handler 去处理消息，Handler 的 dispatchMessage 方法就会被调用，这时候 Handler 就进入了消息处理阶段。 （2）消息处理深入 dispatchMessage 的源代码进行分析，Handler 处理消息如下： ① 首先检查 Message 的 callback 是否为 null, 不为 null 就通过 handlerCallback 来处理消息。（Message的 callback 是一个 Runnable d 对象，实际上就是 post 方法所递的 Runnable 参数） ② 其次检查 mCallback 是否为 null，不为 null 就调用 mCallback 的 handlerMessage 方法来处理消息。Callback 是个接口。 ③ 我们通过 Callback 可以采用如下的方式来创建 Handle 对象。 1Handler handler = new Handler(callback); 这样创建的意义就是创建一个实例但是并不需要派生 Handler 的子类。 ③ 但是，在我们的日常开发中，经常派生一个 Handler 的子类并重写其 handleMessage 方法来处理具体的消息，如果不想创建派生子类，就可以通过 Callback 来实现。 4、主线程的消息循环 Android 的主线程就是 ActivityThread，主线程的入口方法为 main ，在 main 方法中系统会通过 Looper.prepareMainLooper() ；来创建主线程的 Looper 以及 MessageQueue ，并通过 Looper.loop() 来开启主线程的消息循环。 主线程的消息循环开始了以后，ActivityThread 还需要一个 Handler 来和消息队列进行交互，这个 Handler 就是 ActivityThread.H 。ActivityThread 通过 ApplicationThread 和 AMS 进行进程间通信，AMS 以进程间通信的方式完成 ActvityThread 的请求后会回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 向 H 发送消息，H 收到消息会将 ApplicationThread 中的逻辑切换到 ActivityThread 中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。]]></content>
      <categories>
        <category>Android 高级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
</search>
