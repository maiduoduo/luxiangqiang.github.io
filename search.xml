<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据分析之爬虫【基本流程】]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E7%88%AC%E8%99%AB%E3%80%90%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[本篇文章教你数据分析爬虫的基本流程！ 一、爬虫的基本流程 三个基本流程： 打开网页: Request 访问网页，得到服务器返回的数据，包括 HTML 和 JSON 数据。 提取数据: 针对 HTML 使用 XPath 元素定位；针对 JSON 使用 JSON 进行解析。 保存数据：使用 Pandas 保存数据，最后导出 XSL 或 CSV 文件。 1、Request 访问页面 Request 是 Python 的 HTTP 的客户端库，两种访问方式 GET 和 POST 。请求回来的数据可以通过 text 或 content 来获取 HTML 的正文。 1234// get 方式r = requests.get('http://www.douban.com')// post 方式r = requests.post('http://xxx.com', data = &#123;'key':'value'&#125;) 2、XPath 定位 XPath 是 XML 的路径语言，通过元素和属性进行导航，定位位置。 1）XPath 有 100 多个内置函数进行快速的定位。 2）XPath 需要借助一个解析库 lxml 。例如: 1234// 得到 HTML 的所有列表项目from lxml import etreehtml = etree.HTML(html)result = html.xpath('//li') 3、JSON 对象 Python 中有 JSON 库，可以将 Python 对象和 JSON 对象相互转换。 4、使用 JSON 数据爬取实战 抓取的页面时动态页面，需要关注 XHR 数据，动态页面是通过原生的 XHR 数据对象发送 HTTP 请求，得到服务器返回的值，在进行处理。（使用谷歌开发工具可以查看） ▉ 导包123# coding:utf-8import requestsimport json ▉ 查看 XHR 请求的页数1234# range(开始，结束，步长) for i in range(0,23287,20): # XHR 请求的路径 url = 'https://www.douban.com/j/search_photo?q=' + query + '&amp;limit=20&amp;start=' + str(i) ▉ 进行 XHR 请求12# 获取服务器返回的文本html = requests.get(url).text ▉ 将 JSON 对象转化为 Python 对象进行解析12# 将 JSON 转化为 Python 对象response = json.loads(html,encoding='utf-8') ▉ 循环遍历出内容1234567# images: [&#123;src: "https://img3.doubanio.com/view/photo/thumb/public/p637714342.jpg", author: "華生",…&#125;,…]# 获取内容数组response['images']# 获取数组中的每个对象for image in response['images']# 获取每个对象中的值image['src'] ▉ 下载图片12345678910111213def download(src,id): # 设置路径和图片命名 dir = './' + str(id) + '.jpg' try: # timeout 设置爬虫超时操作 pic = requests.get(src,timeout = 10) # 内置函数 open 用于打开文件(wb 二进制文件只写入) fp = open(dir,'wb') # 以二进制方式写入本地文件 fp.write(pic.content) fp.close() except requests.exceptions.ConnectionError: print('图片无法下载') 5、使用 XPath 爬取数据 网页除了用 XHR 做请求，也会用 JS 做请求，如果用到 JS 做请求，那么我们就用 XPath 做解析。用 XPath 做解析必须 JS 请求后接受到整个页面之后，才能进行解析。 1）快速定位 XPath 的方法就是使用谷歌插件 XPath Helper 使用快捷键 Ctrl + Shift + X ,直接定位你想要的元素。 2）使用 lxml 库来进行对获取的网页进行解析。 1、Selenium 模拟测试工具 因为 XPath 的使用必须在页面加载完成才可以，所以使用 Request 获取页面的 HTML 时候，发现 XPath 并不存在，所以必须借助 Selenium 模拟工具（模拟用户操作页面的工具）。 1）必须下载 Driver 执行程序才能正常打开浏览器。 2、代码实现▉ 加载浏览器程序1browser = webdriver.Chrome('C:/Program Files (x86)/Google/Chrome/Application/chromedriver.exe') ▉ 打开指定网址12// 尽情请求browser.get(url) ▉ 获取网页源代码1234// 获取打开网页的源代码browser.page_source// 转化为可以被 lxml 解析的对象html = etree.HTML(browser.page_source) ▉ 获取到 XPath 匹配的元素12src_xpath = "//div[@class='result']/div[@class='pic']/a[@class='nbg']/img/@src"srcs = html.xpath(src_xpath) ▉ 遍历获取数据1234# zip 将对象中对应的元素打包成元组for src,title in zip(srcs,titles): print(src) download(src,title.text)]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吃透 JQuery 之【完整篇】]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%90%83%E9%80%8F%20JQuery%20%E4%B9%8B%E3%80%90%E5%AE%8C%E6%95%B4%E7%AF%87%E3%80%91%2F</url>
    <content type="text"><![CDATA[一篇 JQuery 核心内容文章！ 一、选择器1、基本选择器1.1 按 ID 查找 返回 jQuery 对象，jQuery 对象类似数组，每个元素都是引用了 DOM 节点的对象。[&lt;div id=&quot;abc&quot;&gt;...&lt;/div&gt;]，如果找不到该对象，返回 [] 空对象。 123// 按照 ID 查找&lt;div id="abc"&gt;&lt;/div&gt;var div = $('#abc'); jQuery 对象与 DOM 对象之间的转化： 123var div = $('#abc'); // 获取 jQuery 对象 ‘#abc’ 执行了 document.getElementById('#abc');var divDOM = div.get(0);// 获取第一个 DOM 对象var anthor = $(divDOM); // 重新把 DOM 封装为 jQuery 对象 1.2 按 tag 查找12var ps = $('p');//获取所有的 &lt;p&gt; 节点ps.length; //统计 &lt;p&gt; 节点的个数 1.3 按 class 查找 查找之前要加一个 ‘.’； 1var ps = $('.red');// 所有节点包含`class="red"`都将返回 1.4 按属性查找 DOM 节点很多属性，可以根据属性来快速定位节点。 1234567// 找出属性为 [name=email] 的节点var email = $('[name^=email]');// 按属性查找使用前缀或后缀查找var icons = $('name^= icon') // 找出所有 name 属性值以 icon 开头的 DOMvar names = $('[name$=with]'); // 找出所有 name 属性值以 with 结尾的 DOMvar icons = $('[class^="icon-"]'); // class 经常使用到 1.5 组合查找 通常选择会选择所有的属性，但是有时我们只选择某标签里的属性进行使用。 1234// 标签和属性组合var emilInput = $('input[name = email]');// 标签和 Class 组合var tr = $('tr.red'); 1.6 多项选择器 多个选择器用 ， 组合起来一块选。选出来的元素是按照它们在 HTML 中出现的顺序排列的，而且不会有重复元素。 1234// 把 &lt;p&gt; 和 &lt;div&gt; 都选出来$('p,div')// 把 &lt;p class="red"&gt; 和 &lt;p class="green"&gt; 都选出来$('p.red,p.green') 2、层级选择器 由于 DOM 的结构是层级结构，经常需要根据层级来进行选择，所以 jQuery 层级选择器更加灵活。 优点： 层级选择器的好处就是在于缩小了选择的范围，定位父元素后再定位子元素，避免了不相干页面的干扰。 2.1 层级选择器 如果两个 DOM 元素有层级结构，可以使用 $(&#39;ancestor descendant&#39;) 来选择，层级之间需要用空格隔开。 1$('form[name=upload] input'); 2.2 子选择器（Child Selector） 类似层级选择器，但是限定了只能选择父元素的子元素。 1$('ul &gt; li') //选择 &lt;ul&gt; 父节点下的子节点 &lt;li&gt; 2.3 过滤器（Filter） 过滤器通常不单独使用，附加到选择器中使用，更精确的定位元素。 12345678910$('ul.lang li'); // 选出 JavaScript、Python 和 Lua 3个节点// 选择节点的第一个节点$('ul.lang li:first-child'); // 仅选出 JavaScript// 选择最后一个元素$('ul.lang li:last-child'); // 仅选出 Lua// 选出第 n 的元素，n 从 1 开始$('ul.lang li:nth-child(2)'); $('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素$('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素 2.4 表单相关 针对表单，jQuery 有一组特殊的选择器。 :input：可以选择 &lt;input&gt;，&lt;textarea&gt;，&lt;select&gt; 和 &lt;button&gt;； :file：可以选择 &lt;input type=&quot;file&quot;&gt; 和 input[type=file] 一样； :checkbox：可以选择复选框，和 input[type=checkbox] 一样； :radio：可以选择单选框和 input[type=radio] 一样； :focus：可以选择当前输入焦点的元素，例如把光标放到一个 &lt;input&gt; 上，用 $(&#39;input:focus&#39;) 就可以选出； :checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$(&#39;input[type=radio]:checked&#39;)； :enabled：可以选择可以正常输入的 &lt;input&gt;、&lt;select&gt; 等，也就是没有灰掉的输入； :disabled：和 :enabled 正好相反，选择那些不能输入的。 12$('div:visible'); // 所有可见的div$('div:hidden'); // 所有隐藏的div 3、查找和过滤 最常用的是在某个节点的所有子节点中查找，使用 find 方法，接受一个选择器进行选择。 1234567&lt;ul class="lang"&gt; &lt;li class="js dy"&gt;JavaScript&lt;/li&gt; &lt;li class="dy"&gt;Python&lt;/li&gt; &lt;li id="swift"&gt;Swift&lt;/li&gt; &lt;li class="dy"&gt;Scheme&lt;/li&gt; &lt;li name="haskell"&gt;Haskell&lt;/li&gt;&lt;/ul&gt; 1234var ul = $('ul.lang'); // 获得 &lt;ul&gt;var dy = ul.find('.dy'); // 获得 JavaScript, Python, Schemevar swf = ul.find('#swift'); // 获得 Swiftvar hsk = ul.find('[name=haskell]'); // 获得 Haskell 向上查找使用 parent() 方法： 123var swf = $('#swift'); // 获得Swiftvar parent = swf.parent(); // 获得 Swift 的上层节点 &lt;ul&gt;var a = swf.parent('.red'); // 获得 Swift 的上层节点 &lt;ul&gt;，同时传入过滤条件。如果ul不符合条件，返回空 jQuery 对象 同级元素使用 next（） 和 prev（） 方法： 1234567var swift = $('#swift');swift.next(); // Schemeswift.next('[name=haskell]'); // 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell]swift.prev(); // Pythonswift.prev('.dy'); // Python，因为 Python 同时符合过滤器条件.dy 3.1 过滤 函数式编程中的 map、filter类似，jQuery 也有自己类似的方法。 filter() 方法： 12var langs = $('ul.lang li');// 拿到 JavaScript, Python, Swift, Scheme 和 Haskellvar a = langs.filter('.dy') // 拿到 JavaScript, Python, Scheme 12345678//传入一个函数var langs = $('ul.lang li'); // 拿到 JavaScript, Python, Swift, Scheme 和 Haskelllangs.filter( function () &#123; // 函数内部的 this 被绑定为 DOM 对象，不是 jQuery 对象 return this.innerHTML.indexOf('S') === 0; // 检查每个子节点，返回 S 开头的节点 &#125;); // 拿到Swift, Scheme map() 方法：把一个 jQuery 对象包含的若干 DOM 节点转化为其他对象 。 12345var langs = $('ul.lang li'); // 拿到 JavaScript, Python, Swift, Scheme 和 Haskellvar arr = langs.map(function () &#123; return this.innerHTML;&#125;).get(); // 用 get() 拿到包含 string 的 Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell'] 一个jQuery对象如果包含了不止一个DOM节点，first()、last()和slice()方法可以返回一个新的 jQuery对象，把不需要的 DOM 节点去掉： 1234var langs = $('ul.lang li'); // 拿到 JavaScript, Python, Swift, Scheme 和 Haskellvar js = langs.first(); // JavaScript，相当于 $('ul.lang li:first-child')var haskell = langs.last(); // Haskell, 相当于 $('ul.lang li:last-child')var sub = langs.slice(2, 4); // Swift, Scheme 参数和数组的 slice() 方法一致 1234567var inputs = $(&apos;#test-form :input&apos;).not(&apos;button&apos;);var obj = &#123;&#125;;inputs.filter(function()&#123; if(this.type !== &quot;radio&quot; || this.checked); obj[this.name] = this.value;&#125;)json = JSON.stringify(obj); 二、操作 DOM1. 操作 DOM1.1 修改 Text 和 HTML jQuery 对象的 text() 和 html() 方法分别获取节点文本和原始的 HTML 文本。 1）jQuery 可以获取一组数据进行统一设置文本。 2）jQuery 如果不存在结点对象，将不会报错。 1234&lt;ul id="test-ul"&gt; &lt;li class="js"&gt;JavaScript&lt;/li&gt; &lt;li name="book"&gt;Java &amp;amp; JavaScript&lt;/li&gt;&lt;/ul&gt; 1234567// 获取文本$('#test-ul li[name=book]').text(); // 'Java &amp; JavaScript'$('#test-ul li[name=book]').html(); // 'Java &amp;amp; JavaScript'// 设置文本$('#test-ul li[name=book]').text('JavaScript &amp; ECMAScript'); $('#test-ul li[name=book]').html('&lt;span style="color: red"&gt;JavaScript&lt;/span&gt;'); 1.2 修改 CSS 调用 jQuery 对象的 css(&quot;name&quot;,&quot;value&quot;) 方法。 1）CSS 属性可以使用 &#39;background-color&#39; 和 &#39;backgroundColor&#39;两种格式。 2）css() 方法将作用于 DOM 节点的 style 属性，具有最高的优先级。 12// 注意：jQuery 的所有方法返回的是对象，可以链式调用。$('#test-css li.dy&gt;span').css('background-color', '#ffd351').css('color', 'red'); 修改 class 属性，jQuery 提供一下方法： 1234var div = $('#test');div.hasClass('container');// 判断该结点 class 是否包含 container 属性div.addClass('container');// 添加 container 这个 Classdiv.removeClass('container'); // 删除 container 这个 Class 1.3 显示和隐藏 DOM 显示或隐藏 DOM 需要设置 CSS 属性的 display 属性。 1）隐藏 DOM 需要设置 CSS 的 display 属性为 none。 2）显示 DOM 需要知道 display 之前的属性（block,inline）。 3）jQuery 对象提供的 show() 和 hide() 方法。 123var a = $('div');a.hide(); // 隐藏a.show(); // 显示(并没有删除 DOM 结点，影响了 DOM 结点的显示) 1.4 获取 DOM 信息 无序针对特定的浏览器编写特定的代码，jQuery 对象的方法直接获取。 1）操作 DOM 节点的属性：attr() 和 removeAttr() 方法。 2）操作 H5 中无值属性：prop() 但会 boolean 值，也可以用 is 判断。 1234567891011121314// 浏览器可视窗口大小:$(window).width(); // 800$(window).height(); // 600// HTML文档大小:$(document).width(); // 800$(document).height(); // 3500// 某个div的大小:var div = $('#test-div');div.width(); // 600div.height(); // 300div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效 123456var div = $('#test-div');div.attr('data');// undefined 属性值不存在div.attr('name');// test 获取属性值div.attr('name','Hello'); // 设置属性值div.removeAttr('name'); //删除 name 属性div.attr('name'); // undefined 123456&lt;input id="test-radio" type="radio" name="test" checked value="1"&gt;var radio = $('#test-radio');radio.prop('checked'); // trueradio.is(':checked'); // trueis(':selected');// 下拉属性判断 1.5 操作表单 对于 jQuery 操作表单，统一使用 val() 方法获取和设置对应的 value 属性： 12345678910111213141516171819202122/* &lt;input id="test-input" name="email" value=""&gt; &lt;select id="test-select" name="city"&gt; &lt;option value="BJ" selected&gt;Beijing&lt;/option&gt; &lt;option value="SH"&gt;Shanghai&lt;/option&gt; &lt;option value="SZ"&gt;Shenzhen&lt;/option&gt; &lt;/select&gt; &lt;textarea id="test-textarea"&gt;Hello&lt;/textarea&gt;*/var input = $('#test-input'), select = $('#test-select'), textarea = $('#test-textarea');input.val(); // 'test'input.val('abc@example.com'); // 文本框的内容已变为abc@example.comselect.val(); // 'BJ'select.val('SH'); // 选择框已变为Shanghaitextarea.val(); // 'Hello'textarea.val('Hi'); // 文本区域已更新为'Hi' 2、修改 DOM 原生的浏览器 API 修改 DOM 需要根据不同的浏览器进行写不同的代码。 2.1 添加 DOM 添加 DOM 结点除了使用 html() 方法外还可以使用 append() 方法。 1) append() 方法可以接收一下几个参数： DOM 对象 jQuery 对象 函数对象(该函数要返回一个字符串、DOM 对象、jQuery对象) 2）append() 把DOM添加到最后，prepend() 则把 DOM 添加到最前。 3）after() 方法和 before() 方法将 DOM 插入指定位置。 123456789/*&lt;div id="test-div"&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Python&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;Swift&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;*/var ul = $('#test-div&gt;ul');ul.append('&lt;li&gt;&lt;span&gt;Haskell&lt;/span&gt;&lt;/li&gt;'); 12345678910111213// 创建DOM对象:var ps = document.createElement('li');ps.innerHTML = '&lt;span&gt;Pascal&lt;/span&gt;';// 添加DOM对象:ul.append(ps);// 添加jQuery对象:ul.append($('#scheme'));// 添加函数对象:ul.append(function (index, html) &#123; return '&lt;li&gt;&lt;span&gt;Language - ' + index + '&lt;/span&gt;&lt;/li&gt;';&#125;); 注意：jQuery的 append() 可能作用于一组 DOM 节点，只有传入函数才能针对每个 DOM 生成不同的子节点。 12var js = $('#test-div&gt;ul&gt;li:first-child');js.after('&lt;li&gt;&lt;span&gt;Lua&lt;/span&gt;&lt;/li&gt;'); 2.2 删除节点 拿到 jQuery 对象之后，直接执行 remove() 方法可以删除一组或单个节点。 3、事件 1) 浏览器获取到鼠标事件，自动在对应的 DOM 结点上触发响应的时间，如果该结点绑定了函数，函数就触发响应的事件，然后调用绑定了对应的 javascript 处理函数，该函数就会自动调用。 2) 不同浏览器的代码是不一样的，jQuery 屏蔽了不同浏览器的差异。 123a.on('click', function () &#123; alert('Hello!');&#125;); 3.1 鼠标事件 click : 单击事件 dbclick: 双击事件 mouseenter: 鼠标进入时触发 mouseleace: 鼠标离开时触发 mousemove: 鼠标在 DOM 内部移动时触发 hover: 鼠标进入和退出时触发两个函数，相当于 mouseenter 加上 mouseleave。 3.2 键盘事件 键盘事件仅作用在当前焦点 DOM 上，通常是 &lt;imput&gt; 和 &lt;textarea&gt;。 keydown：键盘按下时触发 keyup：键盘松开时触发 keypress：按一次键后触发 3.3 其他事件 focus：当 DOM 获取焦点时触发； blur：当 DOM 失去焦点时触发； change：当 &lt;input&gt;、&lt;select&gt; 或 &lt;textarea&gt; 的内容改变时触发； submit：当 &lt;form&gt; 提交时触发； ready：当页面被载入并且 DOM 树完成初始化后触发（仅作用于 document 对象）。 12 3.4 事件参数 有些事件需要传入参数，获取到按键的值和鼠标的位置。所有事件都传入 Event 对象作为参数。 12345$(function () &#123; $('#testMouseMoveDiv').mousemove(function (e) &#123; $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY); &#125;);&#125;); 3.5 取消绑定 一个绑定的事件可以被解除，通过 off（‘click’, function） 实现： 1) off 无参会一次性移除已绑定的所有类型的事件处理函数。 12345678910function hello() &#123; alert('hello!');&#125;a.click(hello); // 绑定事件// 10秒钟后解除绑定:setTimeout(function () &#123; a.off('click', hello);&#125;, 10000); 3.6 事件触发条件 事件的触发是由用户操作引发的。 1）change 事件的触发是由用户改变文本框内容触发的，在 js 修改文本框内容则不会触发。 2）用代码触发 change 事件，可以直接调用无参数的 change() 方法来触发事件。 1234var input = $('#test-input');input.change(function () &#123; console.log('changed...');&#125;); 123var input = $('#test-input');input.val('change it!');input.change(); // 触发change事件,相当于 input.trigger('change') 3.7 浏览器安全限制 有些 javascript 代码只有用户触发才能执行，如 window.open() 函数。 1234// 无法弹出新窗口，将被浏览器屏蔽:$(function () &#123; window.open('/');&#125;);]]></content>
      <categories>
        <category>前端</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之题型篇【链表】]]></title>
    <url>%2F2019%2F04%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A2%98%E5%9E%8B%E7%AF%87%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[有关链表的所有操作和题型的详细解析和扩展。 [TOC] 一、链表相关题目1、单链表从头到尾打印1.1 问题分析与解决▉ 问题分析 1）看到题目第一想到的就是反转链表在打印输出，一种反转链表的方法，但是这种方法改变了原有的链表结构。 2）从问题中可以得出，我们想要从尾到头打印链表，正常情况下是从头到尾打印的，我们就会想到最后的数据先打印，开始的数据最后打印，有种“先进后出”的特点，我们就能想到用“栈”这种结构，用栈来实现。 3）提到栈这种数据结构，我们就会想到“递归”的实现就是用栈这种数据结构实现的。既然栈能实现，那么递归也能实现。 实现方式： 反转链表法 栈实现 递归实现 ▉ 算法思路 1）反转链表实现： 从尾到头输出链表的内容，一般的思路就是将链表反转过来，然后从头到尾输出数据。 缺点：使得链表的结构发生改变了。如果不改变链表结构应该怎么解决？ 2）栈实现 从头到尾遍历单链表，将数据存储按照顺序存储到栈中。然后遍历整个栈，打印输出数据。 缺点：代码不够简洁。 优点：鲁棒性好（在不确定的情况下，程序仍然可以正确的执行）。 2）递归实现： 可以通过递归的方式来实现单链表从尾到头依次输出，递归过程涉及到“递”和“归”，反转链表输出数据，正式利用了循环“递”的过程，所以数据先从头部输出，那么递归采用的是“归”的过程来输出内容，输出当前结点先要输出当前节点的下一节点。 缺点：如果链表很长，递归深度很深，导致堆栈溢出。 优点：代码简洁、明了。 ▉ 测试用例 在写代码之前，要想好测试用例才能写出健全、鲁棒性的代码，也是为了考虑到边界情况，往往也是整个程序最致命的地方，如果考虑不全面，就会出现 bug，导致程序崩溃。 测试用例： 1）输入空链表； 2）输入的链表只有一个结点； 3）输入的链表有多个结点。 ▉ 代码实现：反转链表法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 //定义结点class Node&#123; constructor(data)&#123; this.data = data; this.next = null; &#125;&#125;//定义链表class LinkedList&#123; constructor()&#123; this.head = new Node('head'); &#125; // 功能：单链表反转 // 步骤: // 1、定义三个指针(pre=null/next/current) // 2、判断链表是否可反转(头节点是否为空、是否有第二个结点) // 3、尾指针指向第一个结点的 next // 4、尾指针向前移动 // 5、当前指针(current)向后移动 // 6、将 head 指向单转好的结点 reverseList = () =&gt;&#123; //声明三个指针 let current = this.head; //当前指针指向头节点 let pre = null;//尾指针 let next;//指向当前指针的下一个指针 //判断单链表是否符合反转的条件(一个结点以上)？ if(this.head == null || this.head.next == null) return -1; //开始反转 while(current !== null)&#123; next = current.next; current.next = pre; pre = current; current = next; &#125; this.head = pre; &#125; //输出结点 print = () =&gt;&#123; let currentNode = this.head //如果结点不为空 while(currentNode !== null)&#123; console.log(currentNode.data) currentNode = currentNode.next; &#125; &#125;&#125; ▉ 代码实现：循环栈12345678910111213//方法三：栈实现const tailToHeadOutput = (currentNode)=&gt;&#123; let stack = []; //遍历链表，将数据入栈 while(currentNode !== null)&#123; stack.push(currentNode.data); currentNode = currentNode.next; &#125; //遍历栈，数据出栈 while(stack.length !== 0)&#123; console.log(stack.pop()); &#125;&#125; ▉ 代码实现：递归1234567891011121314151617// 步骤:// 1、判断是否为空链表// 2、终止条件（下一结点为空）// 3、递归打印下一结点信息const tailToHeadOutput = (head)=&gt;&#123; // 判断是否空链表 if(head !== null)&#123; // 判断下一结点是否为空 if(head.next !== null)&#123; // 下一结点不为空，先输出下一结点 tailToHeadOutput(head.next) &#125; console.log(head.data); &#125;else&#123; console.log("空链表"); &#125;&#125; ▉ 性能分析 反转链表实现： 时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。 空间复杂度：O(1)。不需要额外的栈存储空间，空间复杂度为 O(1)。 循环栈实现： 时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。 空间复杂度：O(n)。需要额外的栈存储空间，空间复杂度为 O(n)。 递归实现： 时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。 空间复杂度：O(n)。需要额外的栈存储空间，空间复杂度为 O(n)。 2.2 小结▉ 考察内容 1）对单链表的基本操作。 2）代码的鲁棒性。 3）循环、递归、栈的灵活运用。 ▉ 扩展思考：循环和递归 适用条件：如果需要进行多次计算相同的问题，将采用循环或递归的方式。 递归的优点：代码简洁。 递归的缺点： 1）堆栈溢出：函数调用自身，函数的临时变量是压栈的操作，当函数执行完，栈才清空，如果递归的规模过大，在函数内部一直执行函数的自身调用，临时变量一直压栈，系统栈或虚拟机栈内存小，导致堆栈溢出。 2）重复计算：递归会出现很多的重复计算问题，重复计算对程序的性能有很大影响，导致消耗时间成指数增长，但是可以通过散列表的方式解决。 3）高空间复杂度：递归的每次函数调用都要涉及到在内存开辟空间，压栈、出栈等操作，即耗时又耗费空间，导致递归的效率并不如循环的效率。 扩展： 1）递归—栈：递归的本质是栈，通常用栈循环解决的问题适合于递归。 2）递归-动态规划：动态规划解决问题经常用递归的思路分析问题。关于递归重复计算问题，我们通常使用自下而上的解决思路（动态规划）来解决递归重复计算的问题。 ▉ 注意事项： 1）涉及到循环解决的问题，可以想一想能不能使用递归来解决。 2）用递归解决一定要铭记递归的缺点带来的性能问题。 3）递归解决的问题，能不能用动态规划来解决，使得性能更高。 4）用到栈这种数据结构，想一想递归是否可以实现呢。 二、链表使用总结]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶深入系列之【跨域问题】]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%90%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[AJAX 以及跨域问题完整详细解析，面试、日常项目常用点。 [TOC] 跨域问题一、同源策略1.1 同源策略的由来 为了防止网站遭到恶意攻击，这里所谓恶意攻击就是从自己服务器的页面代码 js 中通过别人的 URL 去请求别人的服务器资源，这样通俗一点。这会导致信息被窃取，所以浏览器设计了同源策略。 例如：A 网站的服务器存有 A 网站用户的登录、账户等信息，该信息通常是由 A 网站的用户可获取的，但是如果没有同源策略，那么 B 网站的用户可以通过 AJAX 请求 A 网站服务器的资源，从而获取到用户的信息，导致用户信息被窃取。 2.2 什么是同源策略 1995年，同源政策由 Netscape 公司引入浏览器。 所谓的「同源」，浏览器规定 AJAX 做请求时，请求的服务器的 URL 的域名必须和当前页面的 URL 「域名相同」浏览器才会让你做请求（同源才会进行通信）。相同包括三个部分： 域名相同 协议相同 端口号相同 举例：假设网址为 http://www.xiaolu.com/example/index.html ，请求的服务器 URL 必须在一下三个方面做到相同才可以请求： 1234567891011//协议如果服务器使用 https 的协议： https://www.xiaolu.com/example/index.html （不同源，不能请求）//端口号如果服务器使用 8016 端口号：http://www.xiaolu.com：8016/example/index.html （不同源，不能请求）//域名如果服务器使用其他域名：http://www.lu.xiaolu.com：8016/example/index.html （不同源，不能请求）//三者必须都相同http://www.xiaolu.com/example/index.html （同源，可以请求） 2.3 同源策略的问题 虽然浏览器引入了同源策略，防止了恶意网站获取资源导致信息泄露。但是，会导致一下几个问题。 Cookie、LocalStorage 和 IndexDB 无法读取。 DOM 无法获得。 AJAX 请求不能发送。 1、不同源获取 Cookie 同源策略导致不同源的页面是不可以获取 Cookie 值的，如果有存在不同源的两个页面（一级域名相同，二级域名不同），想要共享 Cookie ，怎么做呢？ 12345678910//假设两个共享 Cookie 的网址A 网址：http://v1.xiaolu.com/index.htmlB 网址：http://v2.xiaolu.com/index.html// 方法一：通过设置两个页面的 domain 值相同，就可以共享 Cookie// 注意：只是适用于二级域名不同 Cookie 和 iframe,对于 LocalStorage 和 IndexDB 不适用。 document.domain = '.xiaolu.com'//方法二：服务器设置 Cookie 的时候，指定 Cookie 所属一级域名，上述如果一级域名不同也不会存在限制Set-Cookie: key=value; domain=.xiaolu.com; path=/ 二、AJAX 跨域共享2.1 架设代理服务器 同源域名下架设代理服务器，JavaScript负责把请求发送到代理服务器，代理服务器将结果返回，准守了浏览器的同源策略。 缺点：需要额外的服务器做开发 1&apos;/proxy?url=http://www.baidu.com.cn&apos; 2.2 domain 同一主域的不同子域可以设置document.domain为主域来让他们同域,并且子域的协议和端口都要一致。 document.domain只能设置往上设置域名,需要载入iframe来相互操作。 2.3 JSONP 一些带 src 的 html 标签都可以实现跨域，link、font-face、img、video、audio、script等。 1、本质 利用浏览器允许跨域引用 JavaScript 资源的功能。 2、缺点 只能用 Get 请求，并且返回 javascript。 3、优点 简单适用，老式浏览器全部支持，服务器改造非常小 4、基本流程 JSONP 通常以函数的形式返回，需要在页面写好返回的函数，页面动态的添加一个&lt;script&gt;节点，动态读取外域的 javascript 资源，然接受回调。（在外域的 javascript 文件中返回一个函数，函数中有我们需要的数据，我们在本地触发该函数就可以完成跨域）。 12345678910111213141516&lt;script&gt; function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = src; document.body.appendChild(script); &#125; window.onload = function () &#123; addScriptTag('http://ip.jsontest.com/?callback=ip'); &#125; function ip(data) &#123; alert(data.ip); &#125;;&lt;/script&gt; 5、安全性 当这个接口没有验证Referer头的时候,就存在JSONP劫持漏洞,即在任何域下都能窃取到传输的数据。 当接口返回的是一些敏感数据时(如CSRF TOKEN,用户个人信息等),危害是很大的。 2.4 WebSocket1、概念 WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 2、基本流程 浏览器发出的WebSocket请求的头信息。 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 因为请求头部信息中的 origin 字段，所以 websocket 没有同源策略。服务器根据这个字段进行相应。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 2.5 CORS CORS 是 “跨域资源共享” （Cross-origin resource sharing ）的缩写，解决 AJAX 只能同源通信的限制问题。 1、简介 1）基本流程 ：整个 CORS 是浏览器自动完成的，浏览器一旦发现 AJAX 是跨域请求，自动添加一些信息在头部，只要服务器端能够识别在头部的信息，就可以完成跨域通信。 2）设计思想：CORS 的设计思想就是使用自定义 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还应该是失败。 2、兼容性 CORS 需要浏览器和服务器同时支持，IE 不能低于 IE10。 3、CORS 两种请求方式 CORS 分为两种请求方式： 普通请求: 简单的进行 AJAX 跨域请求，不需要服务器设置对请求的一些限制条件。 高级请求 : 服务器对 AJAX 跨域请求设置限制条件，如：请求方法必须使用 Get 或者 Post、SSL 认证等。 4、请求流程 当浏览器发现是 AJAX 跨域请求时，就会识别此次跨域请求是普通请求还是高级请求，怎么识别普通请求和高级请求呢？根据浏览器发现 ajax 进行跨域请求时自动添加上的头部信息进行识别，如果头部信息符合一下两个条件就为「普通请求」，如果不符合一下两个条件，就判断为「高级请求」。 1234567891011// 1）普通请求使用一下请求方法之一● HEAD ● GET● POST// 2）自动添加的头部信息小于等于一下几个字段● Accept● Accept-Language● Content-Language● Last-Event-ID● Content-Type：application/x-www-form-urlencoded、multipart/form-data、text/plain 三个类型之一 4.1 普通请求▉ 判断请求方式 AJAX 发送跨域请求，通过以上几个条件判断该请求是否为普通请求，如果满足条件，此次跨域请求为普通求请求。 ▉ 普通请求的基本流程 浏览器发现 AJAX 是跨域请求，然后再请求的头部添加一个 Origin 字段信息（发出请求的源地址）。然后浏览器检查请求信息确定此次的跨域的请求方式，如果为普通请求，请求信息相关字段如下： 123456GET /cors HTTP/1.1 //请求方法Origin: http://xiaolu.com //跨域字段（该字段的值为请求的源地址信息，包括域名、端口号、协议）Host: api.alice.com //主机地址Accept-Language: en-US //语言类型Connection: keep-alive //连接方式User-Agent: Mozilla/5.0... //浏览器版本 ▉ 服务器端 请求到达服务器，服务器提取 Origin信息，看是谁给我发来的请求信息，判断 Origin 是否为之前在服务器设置好的 Origin 字段信息，如果没有此信息，就返回一个正常的 HTTP 响应。如果有此信息，就在 HTTP 回应的头部添加几个字段，让浏览器根据服务器添加的几个字段再判断此次跨域请求是否同意了。 如果此次请求被允许，HTTP 响应的头部添加一下几个字段： 12345678910111213141516// 1)用来让浏览器判断该信息服务器是否允许了此次请求。// 2)如果值为 * ，表示服务器可以接收任意域名的请求。// 3）否则，代表服务器之允许设置好的域名进行跨域请求。Access-Control-Allow-Origin: http://xiaolu.com // 1）该字段表示浏览器是否可以向服务器发送 Cookie，默认情况 Cookie 不存在 CORS 请求中的。// 2) 设置为 true，允许 Cookie 信息包含在请求中的。// 3) 如果服务器不要浏览器发送Cookie，删除该字段即可Access-Control-Allow-Credentials: true// 1）如果不设置此字段，浏览器接受到请求之后，只能通过 XMLHttpRequest 对象的 getResponseHeader()拿到最基本的 6 个字段。// 2）如果想要拿到其他字段，需要在下面字段中指定。(下面设置了允许获取取 name 字段信息,通过 getResponseHeader('FooBar') 获取字段的值)Access-Control-Expose-Headers: name//1）响应类型和字符编码Content-Type: text/html; charset=utf-8 ▉ 客户端（AJAX 请求端） 当浏览器接收到服务器的响应信息后，判断响应头中是否包含 Access-Control-Allow-Origin 字段，如果没有包含，浏览器就不会将响应信息让开发人员做处理，直接抛出一个错误，回调 XMLHttpRequest的onerror 方法（虽然服务器返回的状态码可能是 200，但是被浏览器拦截了，就会被 onerror 所捕获）。 ▉ withCredentials 属性 CORS 请求默认不发送 Cookie 等认证信息。如果要发送 Cookie 信息，需要分别在服务器和 AJAX 请求中设置。 1234567//服务器端响应头部添加一下字段//注意：发送 Cookie ,服务器的 Access-Control-Allow-Origin 的字段不能设置为 * 。必须指定明确的、与请求网页一致的域名。只有这样，服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传。Access-Control-Allow-Credentials: true//客户端在 AJAX 请求中设置（即使服务器统一发送 Cookie ，但是浏览器不统一发送 Cookie 必须设置下字段）var xhr = new XMLHttpRequest();xhr.withCredentials = true; 4.2 高级请求▉ 判断请求方式 发送 AJAX 跨域请求，浏览器检测请求信息中存在 PUT 或 DELETE 方法，或者 Content-Type字段的类型是application/json ，就将此次跨域请求定义为「高级请求」。 ▉ 高级请求的基本流程 高级请求会在真正的请求之前，先和服务器“打电话”，问一下服务器当前网页的域名，以及请求方法能够进行此次通信。服务器说，这次通信可以使用 PUT 或 DELETE 方法，那么浏览器才会发出 AJAX 的正式请求，否则就会报错。 123456//Ajax 跨域请求的正式内容：var url = 'http://xiaolu.com ';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); ▉ preflight 预请求 上述中，在真正的请求之前，「浏览器」先和服务器“打电话”，打电话的过程称为 “preflight 请求“。preflight 预请求的内容如下： 12345678OPTIONS /cors HTTP/1.1Origin: 'http://xiaolu.com ' // 源地址 Access-Control-Request-Method: PUT //请求方法Access-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 步骤一：浏览器发出请求 该预请求信息通过浏览器的 OPTIONS 方法来询问服务器，发送该预请求的内容，就是用来让服务器接受判断这些信息是否符合服务器端的要求。 步骤二：服务器响应请求 服务器接受到信息之后，取出字段进行以预先设置好的字段值进行判断，然后做出回应。如果与服务器设置的不符合条件，此次拒绝了 preflight 预先请求，就会返回一个正常的 HTTP 响应给浏览器。否则响应以下信息给浏览器。 12345678910111213HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: 'http://xiaolu.com 'Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000 //服务器运行此源地址请求的时间，一旦超过这个时间，就重新进行预请求Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 步骤三：浏览器接收请求 1）浏览器接收到服务器的响应之后，发现只有简单的 HTPP 响应头部，没有任何的 CORS 请求信息，浏览器就知道了服务器拒绝这次 preflight 预请求，然后返回给开发人员一个错误信息，被 XMLHttpRequest对象的onerror 回调函数捕获 。 2）如果浏览器发现服务器返回的请求带有 CORS 请求头部，就获取字段判断，此次服务器允许了此次请求。 步骤四：AJAX 正常请求和回应 preflight 预请求一旦通过，浏览器就会向服务器发送正式的 AJAX 请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样。 5、安全性 安全漏洞：因为 Access-Control-Allow-Origin 设置成通配符”*”时,表示允许任何域名跨源，如果再把 Access-Control-Allow-Credentials 设置为 true,允许客户端带上 cookie 的话,无疑此时是非常危险的.因为攻击者很容易就能窃取到用户个人的数据。 保护机制：客户端不带 cookie 请求的话还是会正常呈现的,因为 cookie 是一种身份标识,一旦浏览器标识了用户身份,那么返回的数据必然属于用户个人,所以浏览器设计了这种措施来保护用户数据不被泄露。 ▉ 配置错误 尽管 CORS 在设计上考虑到安全问题，但是在用户配置时经常出现很多错误，如设置 ”Access-Control-Allow-Origin”的白名单时,正则写的不正确,导致预期外的域名可以跨域。 2.5 CORS 与 JSONP 比较 1、JSONP 只支持 GET 请求。CORS 支持所有的 HTTP 请求。 2、JSONP 支持老式浏览器以及向不支持 CORS 的服务器请求数据。CORS 只支持 IE10 版本以上浏览器。 2.6 IE 对 CORS 的实现 通过 XHR 实现 AJAX 通信是一个主要限制，默认情况下，XHR 对象只能访问与包含它页面在同一域下的资源 1、简介 微软在 IE8 中引入了 XDR 类型，部分实现了 CORS 的规范，使得 IE 可以完成跨域处理。 2、XDR 与 XHR 的不同 Cookie 不能随请求发送，也不会随响应返回。 只能设置请求头部的 Content-Type 字段。 不能访问响应头部的信息。 只支持 GET 和 POST 请求。 3、XDR 的使用 1、XDR 与 XHR 的 open 方法稍有不同，XDR 的 open 函数只有两个参数（只有异步操作），请求返回后，会触发 onload 事件，可以获取到返回的文本内容。 2、响应只能访问文本文件，没有状态码可用，如果缺少 Access-Control-Allow-Origin 头部就会触发 onerror 事件。（所有的请求错误只能用 onerror 来捕获） 123456789var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.onerror = function()&#123; alert('响应错误');&#125;xdr.open('get','http://xiaolu.com/index.html');xdr.send(null); 4、POST 请求 XDR 为了支持 post 请求，XDR 提供了 contentType 属性，用来表示发送数据的格式， 12xdr.Content-Type = "application/x-www-form-urlencoded"xdr.send("name1=value1&amp;name2=value2") 2.7 其他浏览器对 CORS 的实现 Firefox 3.5+、Safari 4+、Chrome、iso 和 Android 平台中的 webKit 都通过了 XMLHttpRequest 对象实现了对 CORS 的原生支持。 1、XHR 在尝试打开不同来源的资源时，无序额外的编码触发这个行为，只需在 open 中传入绝对的 URL 就可以触发浏览器的跨域。 12// 跨域的绝对 URL 路径xhr.open("get","http://www.xiaolu2.com/page/index.html") 2、XHR 的限制 不能使用 setRequestHeader() 设置自定义的头部。 不能发送和接受 Cookie。 调用 getAllResponseHeaders() 方法总返回空字符串。 2.7 跨浏览器的 CORS 浏览器对 CORS 的支持程度不一样，但是都能实现简单（不带 preflight）的请求，所以要实现一个跨浏览器的方案。 1、检测 XHR 是否支持 CORS ：检测是否存在 withCredentials 属性(该属性只存在 IE 10 以上版本)。 2、检测 XDomain 对象是否存在：该属性只存在 IE 8 以上浏览器中。 1234567891011121314151617181920function createCORSRequest(method,url)&#123; var xhr = new XMLHttpRequest(); if("withCredentials" in xhr)&#123; // IE 10+ xhr.open(method,url,true) &#125;else if(typeof XDomainRequest != "undefined")&#123; // IE 8+ var xhr = new XDomainRequest(); xhr.open('get','http://xiaolu.com/index.html'); &#125;else&#123; xhr = null; &#125; return xhr;&#125;var request = createCORSRequest("get","http://www.xiaolu.com");if(request)&#123; request.onload = function()&#123; // 对 request.responseText 进行处理 &#125; request.send&#125; 无论是 Firefox 3.5+、Safari 4+、Chrome 中的 XMLHttpRequest 对象还是 IE 中的XDomainRequest 对象，都可以使用以上的方法。 onerror：用于替代 onreadystatechange 检测错误。 onload：用于替代 onreadystatechange 检测成功。 三、跨域存在的两种攻击（XSS/CSRF）3.1 跨站请求伪造（CSRF） 跨站伪造请求（Cross-site request forgery ），缩写为 CSRF。CSRF 利用的是网站对用户网页浏览器的信任来进行恶意攻击的。 1、攻击原理 攻击者通过技术手段欺骗用户的浏览器去访问一个曾经认证过的网站，所以用户不用进行重新认证，这是一个用户身份验证的一个漏洞：简单身份认证只保证请求来自某个用户的浏览器，确不能保证请求的本身是用户自愿发出的。攻击者诱导用户在刚访问不久的网站中点击设定的链接（本页的论坛、博客等自动生成的链接内容）。 2、防御措施▉ 检查 Referer 字段 HTTP 头有一个 Referer 字段，用来标记请求来源于哪个地址。Referer字段应和请求的地址位于同一域名下。 服务器在处理请求的时候，可以判断该字段是否位于正确的源地址下发送的请求。如果是 CSRF 攻击，该字段会包含恶意的网址。 局限性：设置 Referer 有本身的局限性，攻击者可以篡改 Referer 字段来达到攻击的目的。 ▉ 添加校验 token 本质：CSRF 的本质是在于攻击者欺骗自己去访问设置的地址，如果在请求数据的时候，用户不把信息保存到浏览器的 Cookie 中，那么攻击者无法获取数据校验，从而不能进行 CSRF 攻击。 随机校验：服务器为客户端的窗体设置一个伪随机数，客户端在提交请求的时候，将随机数与请求内容一并提交服务器，正常访问时，客户端将会收到正确得到并传回这个伪随机数。CSRF 攻击无从事先知道这个伪随机数，所以导致 token 值为空，拒绝请求。 ▉ JSONP 劫持漏洞 如果 JSONP 没有验证 Referer 头的时候,就存在JSONP劫持漏洞,即在任何域下都能窃取到传输的数据。 参考资料： Javascript 高级程序设计 https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000 http://www.ruanyifeng.com/blog/2016/04/cors.html]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吃透 javascript 之【完整篇】]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%90%83%E9%80%8FJavaScript%E4%B9%8B%E3%80%90%E5%AE%8C%E6%95%B4%E7%AF%87%E3%80%91%20%2F</url>
    <content type="text"><![CDATA[Javascript 的重点学习路线完整篇。 一、JavaScript 简介1、诞生 最早期网景公司开启 web 时代的第一代互联网，早起网景公司只是做静态页面，为了能够在静态页面添加一些动态的效果，所以叫Brendan Eich 这两个人两星期之内设计出 javascript ，不出所料，这两人只用了短短的10天时间。为了使其能够借助 java 的盛行，所以起名 javascript。 2、ECMAScript 网景开发了 javascript 之后，微软也模仿开发了 Jscript，为了能够让 javascript 称为全球的开发标准，所以几个公司联合发布了 ECMA 标准。ECMAScript 是一种语言标准，而网景公司开发的 javascript 是这一标准的实现。 3、版本 因为 javascript 的标准在短时间实现的，其中存在很多的缺陷，所以 javascript 的标准 ECMAScript 不断发展，到目前的 ES6 版本 2015 年发布。这里的 javascript 版本一般说的就是实现了 ECMAScript 哪个版本。 二、数据类型和变量1、== 和 ===的区别？ == 是 javascript 的设计缺陷，一般使用 === 来比较。 == : 两种之间比较需要先进行转换，然后进行比较，有时候出现很奇怪的情况。 === : 先比较类型，如果类型相等，然后在比较值。 2、NAN 是 Number 特殊的值 NAN 与任何值都不相等，包括它本身自己。 1NaN === NaN; // false 唯一能判断 NaN 的方法是通过 isNaN() 函数 3、浮点型之间的比较 问题：浮点型在运算会产生误差，导致计算机无法准确表示无限循环小数，所以导致比较不相等。 解决：要比较浮点型之间的大小，要比较两个浮点型之差的绝对值是否小于某一个阈值。 4、null 和 undefined NULL 表示“空”。undefined 表示未定义。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 5、严格模式是什么？ 缘由：初期，为了方便，不强制要求 var 声明变量，所以会导致未被 var 声明的变量自动声明为全局变量，如果同一页面不同 js 文件都用到了 js 文件的相同变量，导致变量之间相互影响，也就是我们所说的污染全局环境变量。 strict模式：不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。 三、字符串1、多行字符串 多行字符串用 反引号来表示，ES6 新增加语法。 2、字符串拼接 关于字符串拼接用 ${name} 引用，ES6 新增加语法。 四、数组1、indexof 搜索一个指定的元素的位置 。 2、slice 字符串截取。单参数为从参数起到结束，双参数为中间元素（不包括尾元素），返回新数组。 3、push 和 pop 末尾添加元素和末尾删除元素。 4、unshift 和 shift 头部添加元素和头部删除元素。 5、sort 对当前数组进行排序。 6、reverse 将数组元素反转。 7、splice 可以删除元素也可以删除同时添加元素。 12// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); 8、concat 合并两个数组，返回新数组。 9、join 指定字符连接数组中的元素。 五、Map 和 Set1、Map 一组键值对，键必须为字符串类型。 1234var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);m.get(&apos;Michael&apos;);m.set(&apos;Bob&apos;,59)m.delete(&apos;Adam&apos;); 2、Set 一组 key 的集合，不存储 value。 123var s = new Set([1, 2, 3]);s.add(4);s.delete(3); 六、iterable▉ 普通 for 循环 当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率 。 ▉ foreach 循环 功能：可以获取到 key 和 value 数组的本身。 缺点： 不能用 break，continue 语句跳出循环。 函数内不能使用 return 语句。 注意：在不同浏览器下测试的结果都是 forEach 的速度不如 for 。 12345//item 为数组元素//index 为索引下标arr.forEach(function (item,index,arr) &#123; console.log(item,index,arr)&#125;,null) ▉ for…in 循环 for-in 循环遍历的是对象的属性。而不是数组的索引 ，除了遍历数组也可以遍历对象。 缺点： for-in 遍历的顺序并不是确定的。 它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性 （Array 中的 length 不能遍历到），for-in 不适合遍历 Array 。【链接】：https://juejin.im/entry/5a1654e951882554b8373622 ▉ for…of 循环 ES6 新增语法。 优点： 以正确响应 break, continue, return。 for-of 循环不仅支持数组，还支持大多数类数组对象。 for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。 for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历 七、函数 在函数中如果没有 return 语句，函数执行完返回 undefined。 1、arguments 此关键字只在函数内部起作用，并且永远指向当前函数调用者传入的所有参数。 1、即使函数不定义参数，也是可以通过 arguments 对象拿到传入的参数的。 2、通常用来判断传入参数的个数。 1234567function foo(x) &#123; console.log('x = ' + x); // 10 for (var i=0; i&lt;arguments.length; i++) &#123; console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30 &#125;&#125;foo(10, 20, 30); 2、reset 参数（ES6） 由于 arguments 获取额外的传参非常的别扭，所以 ES6 新增了 rest 参数用来处理额外的参数。 12345678function foo(a,b,...rest)&#123; console.log(rest)&#125;//传入多余两个参数foo(1,2,3,4,5); // Array[3,4,5]//传入少于定义参数的个数foo(1,2)//Array[] 空数组 3、注意 return 语句 javascript 引擎会有一个行末添加分号的机制。 123456789101112//正确写法function foo() &#123; return &#123; // 这里不会自动加分号，因为&#123;表示语句尚未结束 name: 'foo' &#125;;&#125;//错误写法function foo() &#123; return //这一行会可能被引擎自动加分号 &#123; name: 'foo'&#125;; &#125; 4、变量作用域和解构赋值▉ 全局作用域 javascript 只有一个全局作用域，如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。 ▉ 命名空间 全局变量会绑定到 windows 上，不同的 javascript 文件使用相同的全局变量会产生命名冲突，我们很难发现，所以一般减少冲突的方法就是所有变量和函数全部绑定到一个全局变量中。 1234567891011// 唯一的全局变量MYAPP:var MYAPP = &#123;&#125;;// 其他变量:MYAPP.name = 'myapp';MYAPP.version = 1.0;// 其他函数:MYAPP.foo = function () &#123; return 'foo';&#125;; 许多 js 库都是这么干的，jQuery，YUI等。 ▉ 局部作用域 所谓的 js 作用域是在函数内部的，for 循环等语句块中是无法定义具有局部作用域变量的。ES6 引用了 let 代替 var 声明块级作用域变量。 ▉ 对多个变量同时赋值 使用 ES6 新增加的解构赋值。 1var [x, y, z] = ['hello', 'JavaScript', 'ES6']; 适用场景： 1、交换两个变量 12var x = 1,y = 2;[x,y] = [y,x] 2、快速获取当前页面的域名和路径 1var &#123;hostname:domain, pathname:path&#125; = location; 3、函数接受对象的属性为参数 用解构直接将对象的属性绑定到变量中。 1234function buildDate(&#123;year, month, day, hour=0, minute=0, second=0&#125;) &#123; return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second);&#125;buildDate(&#123; year: 2017, month: 1, day: 1 &#125;); 5、方法▉ this 指针 如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming。如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25, 正常结果getAge(); // NaN 12var fn = xiaoming.age; // 先拿到xiaoming的age函数fn(); // NaN 以上是 js 的设计错误，ECMA决定，在 strict 模式下让函数的this指向undefined 。 123456789101112131415'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined 报错了，this 指针只在 age 方法的函数内指向 xiaoming 在函数内部定义的函数 ，this 指针指向 undefined ，他重新指向全局变量。 改进方法，用 that 进行捕获。 12345678910111213141516'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25 ▉ apply() 方法 作用： 指针函数的 this 指向哪个对象。 使用： 参数一：需要绑定的 this 变量。 参数二：传入的是 Array，表示函数本身的参数。 12345678910111213function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: '小明', birth: 1990, age: getAge&#125;;xiaoming.age(); // 25getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 ▉ call() 方法 把参数按照顺序传入。 ▉ 装饰器 利用apply()，我们还可以动态改变函数的行为。 123456789'use strict';var count = 0;var oldParseInt = parseInt; // 保存原函数window.parseInt = function () &#123; count += 1; return oldParseInt.apply(null, arguments); // 调用原函数&#125;; 6、高阶函数 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数 。 ▉ map 对元素自身进行计算 map() 方法定义在 JavaScript 的 Array 中 ,对数组中的每个数据做处理。 map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数 。 12345678'use strict';function pow(x) &#123; return x * x;&#125;var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]console.log(results); ▉ reduce 所有元素进行累加计算 Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算。 1234var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); // 25 ▉ filter 过滤元素 用于把 Array的某些元素过滤掉，然后返回剩下的元素。 和 map() 不同的是，filter() 把传入的函数依次作用于每个元素，然后根据返回值是 true 还是 false 决定保留还是丢弃该元素。 123456//在一个Array中，删掉偶数，只保留奇数var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] ● 回调函数 filter 有多个参数。 1、一个参数：仅使用一个表示 Array 的某个元素。 2、三个参数：回调函数可以接受另外两个参数，表示元素的位置和数组本身。 123456//去除重复元素依靠的是 indexOf 总是返回第一个元素的位置，后续的重复元素位置与 indexOf 返回的位置不相等，因此被 filter 滤掉了。var r,arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry'];r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;); ▉ sort 排序 1、比较字符或者字符串，根据 ASCLL 码进行排序的。 2、比较数字，先将数组中的数字转换成字符串，然后再进行排序。 sort 是一个高阶函数，可以传入函数来进行自定义的比较： 数字比较 传入一个比较函数，-返回值为 1，-1，0； 注意：sort 直接对 Array 进行修改，结果返回 Array。 12345678910111213141516'use strict'var arr = [10, 20, 1,2];//经断点调试，更像是一种插入排序arr.sort(function (x, y) &#123; //变 if (x &lt; y) &#123; return -1; &#125; //不变 if (x &gt; y) &#123; return 1; &#125; return 0;&#125;);console.log(arr); // [1, 2, 10, 20] 6、闭包 将闭包和 Java 类中的 get 获取内部私有变量做对比。 ▉ 什么是闭包？ 只有函数内部的子函数才能读取局部变量，定义在一个函数内部的函数 。 ▉ 作用 1）在函数的外部也可以获取到函数内部的局部变量。 2）让这些局部变量值始终保存在内存中，保证不会被 js “垃圾回收机制”回收。 ▉ 使用闭包注意事项 1）闭包会被保存到内存中，内存消耗很大，会造成网页性能问题，在 IE 会导致内存泄漏。在退出函数之前，将不适用的局部变量全部删除。 7、垃圾回收机制▉ 生命周期 1）分配内存： javascript 自动完成内存的分配 2）使用内存（读或写）：使用值的过程实际上是对分配内存进行读取与写入的操作 3）释放内存：在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。所以高级语言潜入垃圾回收机制。 ▉ 垃圾回收机制 主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。 1）引用 垃圾回收算法主要依赖于引用的概念 ，一个对象访问另一个对象就叫做引用。 2）引用计数垃圾收集 初级的垃圾回收算法，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 3）限制：循环引用 当该函数调用完成离开作用域之后，可以被回收了，但是两个对象相互引用，所以不会被回收。（IE 6, 7对 DOM 结点进行计数垃圾回收） 123456function f()&#123; var o = &#123;&#125;; var o2 = &#123;&#125;; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o&#125; 4）标记—清除算法 针对于“对象是否不再需要”。 1）算法假设有一个根对象（全局对象），垃圾回收器从根开始找所有从根开始引用的对象。 2）垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。 （零引用总不可获得的） 5）限制：那些无法从根对象查询到的对象都将被清除 8、箭头函数▉ 箭头中的 this 由于之前的函数中 this 绑定的错误处理，this 在箭头函数中被修复了。this 总是与词法作用域绑定（函数的作用域在函数定义的时候就决定了 ），由上下文确定 ，外层调用者 obj. 12345678910var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this指向window 或 undefined &#125;; return fn(); &#125;&#125;; ▉ 注意 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略。 9、generator 生成器▉ 定义 整个 Generator 函数封装了异步任务。 标注 yield 地方都是异步需要暂停的地方（yield 将任务分为几个阶段）。 1234function* gen(x)&#123; var y = yield x + 2; return y;&#125; ▉ 过程 1）调用 Generator 会返回一个指针对象（遍历器对象 ），调用指针对象的的 next 方法，会移动指针的位置（异步任务的第一阶段），也就是指向遇到第一个 yield 的位置。 2）next 方法会返回一个当前阶段的对象，表示当前阶段的信息（value:当前阶段的值，yield：布尔值 ）表示 generator 是否执行完毕。 1234var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; ▉ 数据交换 除了能够暂停、恢复之外，还可以作为函数体内外的数据交换。 1、不带有参数的 next 方法可以输出返回值。 2、带有参数的方法可以将参数作为上一阶段异步任务的返回结果，也就是输入。 12345678function* gen(x)&#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next(2) // &#123; value: 2, done: true &#125; ▉ 错误处理 Generator 内部可以部署错误处理代码，捕获函数体外抛出的错误。 1、在函数外用指针的throw抛出的错误，被函数体内的 try … catch 代码块进行捕获。 2、实现了出错代码和处理错误的代码时间和空间上的分离。 12345678910111213function* gen(x)&#123; try &#123; var y = yield x + 2; &#125; catch (e)&#123; console.log(e); &#125; return y;&#125;var g = gen(1);g.next();g.throw（'出错了'）;// 出错了 ▉ 作用 异步回调代码变成“同步”代码。 八、标准对象 总结一下，有这么几条规则需要遵守： 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === &#39;undefined&#39;； 函数内部判断某个变量是否存在用typeof myVar === &#39;undefined&#39;。 任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。 1、Date JavaScript的 Date 对象月份值从0开始，牢记0=1月，1=2月，2=3月，……，11=12月。 1234567891011var now = new Date();now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)now.getFullYear(); // 2015, 年份now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月now.getDate(); // 24, 表示24号now.getDay(); // 3, 表示星期三now.getHours(); // 19, 24小时制now.getMinutes(); // 49, 分钟now.getSeconds(); // 22, 秒now.getMilliseconds(); // 875, 毫秒数now.getTime(); // 1435146562875, 以number形式表示的时间戳 九、面向对象编程1、继承设计思想▉ js 的诞生 为了让静态页面进行交互，设计一种语言完成不需要借助服务器完成的操作，如：表单验证。 ▉ 模仿其他 oop 进行设计 js 不像其他语言是面向对象语言有类的概念，为了能够即不引入类又能实现继承，所以 js 设计者模仿 oop 语言进行设计。 1、其他语言通过 new 来生成实例，所以 js 也通过 new 生成实例。 2、其他语言有类可以通过 new 来实现，js 并没有类，所以借助 new 构造函数来生成实例。 3、不同对象有不同的属性，也有相同的属性，对于每个对象相同的属性都需要在内存中开辟多个空间存储。能否使相同的属性只存一个呢？然后拥有该属性的对象都去引用它。 ▉ prototype 属性 我们就给构造函数设计一个 prototype 属性，用来存储不同对象相同的属性，共享的属性都存到这里边，不共享的属性就存放到构造函数中。其实 prototype 属性存储的就是一个对象，构造函数里边存放的都是变量，具体看变量和对象在内存中的引用。 ▉ 继承 所有构造函数生成的对象都具有 prototype 对象里边的共享属性，就像是所有实例对象继承了 prototype 对象一样。 2、封装 其他语言因为有类的概念，对对象的封装是非常方便的，那么 js 是怎么封装对象的呢？ 12345//猫对象var Cat = &#123; name : '', color : ''&#125; ▉ 原始模式 下面简单的进行两个不同对象的封装，就会有两个问题： 问题： 1）生成多个实例对象写起来非常麻烦。 2）实例对象和原型对象之间没什么联系。 1234567var cat1 = &#123;&#125;; // 创建一个空对象cat1.name = "大毛"; // 按照原型对象的属性赋值cat1.color = "黄色";var cat2 = &#123;&#125;;cat2.name = "二毛";cat2.color = "黑色"; ▉ 原始模式改进 用函数来解决代码重复的问题。 问题： 1）但是不能反映他们来自于同一个原型对象。 123456789function Cat(name,color) &#123; return &#123; name:name, color:color &#125;&#125;//生成实例对象var cat1 = Cat("大毛","黄色");var cat2 = Cat("二毛","黑色"); ▉ 构造函数模式 为了解决原型对象生成实例的问题，引入构造函数模式。 1）构造函数就是一个普通函数。 2）内部使用 this 变量，对构造函数使用 new 就能生成实例对象，内部的 this 指针就会指向实例对象。 3）每个实例对象都有 constructor 属性，并指向他们的构造函数。 12345678910//1）function Cat(name,color)&#123; this.name=name; this.color=color;&#125;//2）var cat1 = new Cat("大毛","黄色");var cat2 = new Cat("二毛","黑色");//3)alert(cat1.constructor == Cat); //true 问题： 1）对于每个实例共享的属性，存在浪费内存的问题。 ▉ 原型模式（prototype 模式） 每个构造函数都有一个 prototype 属性指向原型对象，我们将共享的属性存放到原型对象上，所有实例的共享属性其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。 验证方法： 1）isPrototypeOf() ：验证实例与原型对象之间的关系。 12&gt; alert(Cat.prototype.isPrototypeOf(cat1)); //true&gt; 2）hasOwnProperty()：判断某个属性来自本地还是原型对象。 12&gt; alert(cat1.hasOwnProperty(&quot;name&quot;)); // true&gt; 3）in运算符：判断某个实例是否拥有某个属性。以及遍历某个实例的所有属性。 123&gt; alert(&quot;name&quot; in cat1); // true&gt; for(var prop in cat1) &#123; alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); &gt; 2、原型继承3、构造函数继承（五种） 两个构造函数。怎么让猫继承动物？ 123456789//动物构造函数function Animal()&#123; this.species = "动物";&#125;//猫的构造函数function Cat(name,color)&#123; this.name = name; this.color = color;&#125; ▉ 第一种：构造函数的绑定 用 call 或 apply 方法将父对象的构造函数绑定到子对象的构造函数。 123456function Cat(name,color)&#123; //改变 this 的绑定 Animal.apply(this, arguments); this.name = name; this.color = color;&#125; ▉ 第二种：原型模式 让猫构造函数的 prototype 等于 Animal 的实例，Animal 的实例拥有 Animal 的所有属性，所以相当于猫构造函数的 prototype 指向 Animal 实例了， 所有的猫的实例共享 Animal 里的属性了。 1) 每个实例都有 construct 属性，每个 prototype 也都有 construct 属性。 2）实例中的 construct 指向与 prototype 对象中 construct 指向同一个构造函数。也就是说改变 Cat 的原型对象之后，Cat 的实例对象 construct 属性指向的是 Animal 实例对象的 construct 属性，也就是 Animal 原型对象的 construct 属性，也就是构造函数 Animal 。 3）猫的实例对象是由 Cat 生成的，怎么能指向 Animal 呢，所以手动修改过来。 4）如果更换了 prototype对象 ，一定将 construct 属性修改过来。 12Cat.prototype = new Animal();Cat.prototype.constructor = Cat; ▉ 第三种：直接继承原型 第二种方式的改进，跳过 Animal 的实例，直接将 Animal 的原型对象赋值给 Cat.prototype; 优点：效率更高（不用执行和建立Animal的实例了 ） 缺点：Cat.prototype 和 Animal.prototype 现在指向了同一个对象，那么任何对 Cat.prototype 的修改，都会反映到 Animal.prototype。 12Cat.prototype = Animal.prototype;Cat.prototype.constructor = Cat; ▉ 第四种：空对象作为中介 对于第三种的缺点，第四种作为改进。F是空对象，所以几乎不占内存。 优点：修改Cat的prototype对象，就不会影响到Animal的prototype对象。 1234var F = function()&#123;&#125;;F.prototype = Animal.prototype;Cat.prototype = new F();Cat.prototype.constructor = Cat; 将其封装成方法: 这个 extend 函数，就是 YUI 库如何实现继承的方法。 1234567 function extend(Child, Parent) &#123; var F = function()&#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype;&#125; ▉ 第五种：拷贝继承 如果把父对象的 prototype 所有属性和方法，拷贝进子对象的 prototype 中 。 123456789// 浅拷贝继承function extend2(Child, Parent) &#123; var p = Parent.prototype; var c = Child.prototype; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; &#125; 4、非构造函数继承 让医生继承中国。 12345678//父对象var Chinese = &#123; nation:&apos;中国&apos;&#125;;//子对象var Doctor =&#123; career:&apos;医生&apos;&#125; ▉ 第一种：object()方法 让中国成为医生的原型对象。 12 ▉ 第二种：浅拷贝 把父对象的属性，全部拷贝给子对象，也能实现继承。 拷贝继承分为浅拷贝和深拷贝。 问题： 1）如果父对象的属性等于数组或另一个对象，子对象获得的只是一个内存地址 ，子对象改变，父对象的属性也将改变。 12345678function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; c.uber = p; return c;&#125; ▉ 第二种：深拷贝 弥补浅拷贝出现的问题，真正的将对象和数组及逆行拷贝，只要递归调用”浅拷贝”就行了 。 12345678910111213 function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === 'object') &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;//递归 deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c; &#125; jQuery库使用的就是这种继承方法。 5、class 继承 class 的作用就是让 JavaScript 引擎去实现原来需要我们自己编写的原型链代码。简而言之，用 class 的好处就是极大地简化了原型链代码。 十、浏览器1、浏览器对象▉ window window对象不但充当全局作用域，而且表示浏览器窗口。 1console.log('window inner size: ' + window.innerWidth + ' x ' + window.innerHeight); ▉ navigator navigator对象表示浏览器的信息，最常用的属性包括： navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 ▉ screen screen对象表示屏幕的信息，常用的属性有： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 ▉ location location对象表示当前页面的URL信息。 加载新页面：location.assign() 。 重新加载：location.reload() 。 12345678http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP//可以用location.href获取location.protocol; // 'http'location.host; // 'www.example.com'location.port; // '8080'location.pathname; // '/path/index.html'location.search; // '?a=1&amp;b=2'location.hash; // 'TOP' ▉ document document 对象表示当前页面。由于 HTML 在浏览器中以 DOM 形式表示为树形结构，document 对象就是整个 DOM 树的根节点。 Cookie 1) Cookie 是由服务器发送的 key-value 标示符。因为 HTTP 协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用 Cookie 来区分 。 2) 当一个用户成功登录后，服务器发送一个 Cookie 给浏览器，例如 user=ABC123XYZ(加密的字符串)...，此后，浏览器访问该网站时，会在请求头附上这个 Cookie，服务器根据 Cookie 即可区分出用户。** 安全性： 如果引入的第三方库存在恶意代码，则被第三方直接获取到用户登录信息。为了解决这个问题，服务器在设置 Cookie 的时候使用 httpOnly，设置的 Cookie 不能被 Javascript 读取。 1document.cookie; // 'v=123; remember=true; prefer=zh' ▉ history history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 2、操作 DOM▉ 更新 DOM1）innerHtml属性 修改文本。用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。 1234567// 获取&lt;p id="p-id"&gt;...&lt;/p&gt;var p = document.getElementById('p-id');// 设置文本为abc:p.innerHTML = 'ABC'; // &lt;p id="p-id"&gt;ABC&lt;/p&gt;// 设置HTML:p.innerHTML = 'ABC &lt;span style="color:red"&gt;RED&lt;/span&gt; XYZ';// &lt;p&gt;...&lt;/p&gt;的内部结构已修改 2) 修改 innerText 或 textContent 属性 可以自动对字符串进行HTML编码，保证无法设置任何HTML标签： 12p.innerText = '&lt;script&gt;alert("Hi")&lt;/script&gt;';// HTML被自动编码，无法设置一个&lt;script&gt;节点: 3) 两者区别 读取属性，innerText不返回隐藏元素的文本，而textContent返回所有文本。另外注意 IE&lt;9 支持textContent。 4）设置 CSS 样式 DOM节点的style属性对应所有的 CSS 。CSS允许font-size这样的名称使用驼峰命名法（fontSize）。 1p.style.fontSize = &apos;20px&apos;; ▉ 插入 DOM1）使用 appendChild 把一个子节点添加到父节点的最后一个子节点。 123456var list = document.getElementById('list'), haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.appendChild(haskell); 2) insertBefore 插入指定位置 12// 将子节点插入到 referenceElement 之前parentElement.insertBefore(newElement, referenceElement); ▉ 删除 DOM parentElement () 得到删除节点的父节点，然后 removeChild() 删除节点。 1234567// 拿到待删除节点:var self = document.getElementById('to-be-removed');// 拿到父节点:var parent = self.parentElement;// 删除:var removed = parent.removeChild(self);removed === self; // true 注意： 1、删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 2、parent.children[0] 删除节点的时候注意下标。 3、操作表单HTML表单的输入控件主要有以下几种： 文本框，对应的&lt;input type=&quot;text&quot;&gt;，用于输入文本； 口令框，对应的&lt;input type=&quot;password&quot;&gt;，用于输入口令； 单选框，对应的&lt;input type=&quot;radio&quot;&gt;，用于选择一项； 复选框，对应的&lt;input type=&quot;checkbox&quot;&gt;，用于选择多项； 下拉框，对应的&lt;select&gt;，用于选择一项； 隐藏文本，对应的&lt;input type=&quot;hidden&quot;&gt;，用户不可见，但表单提交时会把隐藏文本发送到服务器。 ▉ 获取值1234567// &lt;input type="text" id="email"&gt;var input = document.getElementById('email');input.value; // '用户输入的值'// &lt;label&gt;&lt;input type="radio" name="weekday" id="monday" value="1"&gt; Monday&lt;/label&gt;mon.value; // '1'mon.checked; // true或者false ▉ 提交表单方法一： 响应一个 button 方法。 1234567891011121314&lt;!-- HTML --&gt;&lt;form id="test-form"&gt; &lt;input type="text" name="test"&gt; &lt;button type="button" onclick="doSubmitForm()"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function doSubmitForm() &#123; var form = document.getElementById('test-form'); // 可以在此修改form的input... // 提交form: form.submit();&#125;&lt;/script&gt; 方法二： onsubmit 事件。 12345678910111213141516&lt;form id="login-form" method="post" onsubmit="return checkForm()"&gt; &lt;input type="text" id="username" name="username"&gt; &lt;input type="password" id="input-password"&gt; &lt;input type="hidden" id="md5-password" name="password"&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt;function checkForm() &#123; var input_pwd = document.getElementById('input-password'); var md5_pwd = document.getElementById('md5-password'); // 把用户输入的明文变为MD5: md5_pwd.value = toMD5(input_pwd.value); // 继续下一步: return true;&#125; 4、操作文件 在表单提交文件时，from 表单的 enctype 属性应该使用 multipart/form-data 不对文件数据进行编码才能上传，其他数据默认 application/x-www-form-urlencoded 编码再提交。 1234567//input 的 IDvar f = document.getElementById(&apos;test-file-upload&apos;);var filename = f.value; // &apos;C:\fakepath\test.png&apos;if (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) &#123; alert(&apos;Can only upload image file.&apos;); return false;&#125; ▉ File API 操作文件 HTML5的File API提供了 File 和 FileReader 两个主要对象，可以获得文件信息并读取文件。 12345678910111213141516171819202122232425262728293031323334var fileInput = document.getElementById('test-image-file'), info = document.getElementById('test-file-info'), preview = document.getElementById('test-image-preview'); // 监听change事件: fileInput.addEventListener('change', function () &#123; // 清除背景图片: preview.style.backgroundImage = ''; // 检查文件是否选择: if (!fileInput.value) &#123; info.innerHTML = '没有选择文件'; return; &#125; // 获取File引用: var file = fileInput.files[0]; // 获取File信息: info.innerHTML = '文件: ' + file.name + '&lt;br&gt;' + '大小: ' + file.size + '&lt;br&gt;' + '修改: ' + file.lastModifiedDate; if (file.type !== 'image/jpeg' &amp;&amp; file.type !== 'image/png' &amp;&amp; file.type !== 'image/gif') &#123; alert('不是有效的图片文件!'); return; &#125; // 读取文件: var reader = new FileReader(); //异步操作的回调函数 reader.onload = function(e) &#123; var data = e.target.result; // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...' preview.style.backgroundImage = 'url(' + data + ')'; &#125;; // 以DataURL的形式读取文件:(异步操作) reader.readAsDataURL(file); &#125;); 5、AJAX 需要注意的几点： 1、通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest 2、先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成 3、XMLHttpRequest对象的open()方法有3个参数，分别为请求方式、URL地址、是否使用异步。 4、send 发送，Get 不需要参数，Post 需要把 body 部分以字符串或者 FormData 对象传进去。 关于 FromData 请查看：FormData 123456789101112131415161718192021222324252627282930313233343536373839function success(text) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = text;&#125;function fail(code) &#123; var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code;&#125;var request;if (window.XMLHttpRequest) &#123; //现代浏览器 request = new XMLHttpRequest();&#125; else &#123; //低版本 IE 浏览器 request = new ActiveXObject('Microsoft.XMLHTTP');&#125;request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调 if (request.readyState === 4) &#123; // 成功完成 // 判断响应结果 if (request.status === 200) &#123; // 成功，通过responseText拿到响应的文本: return success(request.responseText); &#125; else &#123; // 失败，根据响应码判断失败原因: return fail(request.status); &#125; &#125; else &#123; // HTTP请求还在继续... &#125;&#125;// 发送请求:request.open('GET', '/api/categories');request.send();alert('请求已发送，请等待响应...'); 6、Cookie▉ 定义 1）概念：Cookie 小段文本信息，存储于计算机硬盘中，大小只有 4 k。 2）特点：每个 Cookie 文件都对应一个域名，同一域名下的所以页面可以共享 Cookie，不能跨域名访问。 3）使用：通常从 document 中提取 cookie 属性提供给 javascript，然后进行创建或发送 cookie 到服务器。 ▉ 作用 cookie 是存在用户硬盘中，用户每次访问站点时，Web应用程序都可以读取 Cookie 包含的信息。当用户再次访问这个站点时，浏览器就会在本地硬盘上查找与该 URL 相关联的 Cookie。如果该 Cookie 存在，浏览器就将它添加到 request header 的 Cookie 字段中，与 http请求 一起发送到该站点。 ▉ 缺点 安全性：由于cookie在HTTP中是明文传递的，其中包含的数据都可以被他人访问，可能会被篡改、盗用。 大小限制：cookie的大小限制在4KB左右，若要做大量存储显然不是理想的选择。 增加流量：cookie每次请求都会被自动添加到Request Header中，无形中增加了流量。cookie信息越大，对服务器请求的时间也越长。 ▉ 用途 Cookie 一般用于保存网页访问者的信息。 1）保存用户登录信息。在一些登录网站选择下次自动登录，登录成功后，后台对用户名和密码进行加密返回数据，客户端就会将数据存储到 Cookie 中。当用户下一次进行登录时，判断 Cookie 中否存在值，存在则将Cookie 信息加到 HTTP 头部发送到服务器，实现自动登录。 2）创建购物车。通常将选择的物品放入 Cookie 中，同一域名下页面实现 Cookie 共享，提交订单将 Cookie 传到后台。 3）跟踪用户。用 Cookie 记录用户的偏好信息，然后推广小广告，在侧边栏经常是我们之前搜索过的内容。 ▉ 其他存储机制 1）web存储机制 sessionStorage：用于一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除 localStorage ：用于跨会话持久化地存储数据。 2）indexedDB 是 indexed Database API 的简称，是在浏览器中保存结构化数据的一种「数据库」，它类似SQL数据库的结构化数据存储机制 ， 它能够在客户端存储大量的结构化数据，并且使用索引高效检索的API。 7、 同源跨域问题请查看另一篇：]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 CSS3 之基础篇【转换】]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E8%BD%AC%E6%8D%A2%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进 CSS3 转换，好玩又是重点。 一、Treansform CSS3 变形属性。 让元素在一个坐标系中变形。这个属性包含一系列的变形函数，可以移动、旋转和缩放元素。 ▉ 语法1transform:none | &lt;tranform-function&gt; ▉ 兼容性1IE12+、ForeFox16+、Chrome36+、Safari16+、Opera23+ 二、2D 转换 rotate() 旋转 translate() 平移 scale() 缩放 skew() 扭曲和斜切 matrix() 矩阵或混合 1、旋转 rotate 通过指定的角度参数对原元素指定一个 2D rotation （2D 旋转）。 ▉ 语法1transform: rotate(&lt;angle&gt;); ▉ 参数说明angle 指旋转角度，正数表示顺时针旋转，负数表示逆时针旋转。 2、移动 translate 根据左（X轴）和顶部（Y轴）位置给定的参数，从当前元素位置移动。 ▉ 语法1transform: translate (); ▉ 三种情况 translateX(x) 仅仅水平方向移动（X 轴移动）； translateY(Y) 仅垂直方向移动（Y 轴移动）; translate(x,y) 水平方向和垂直方向同时移动（也就是 X 轴和 Y 轴同时移动）。 3、scale 缩放 2D 缩放。 ▉ 三种缩放 scaleX() 水平方向缩放 scaleY() 垂直方向缩放 scale() x y 同时缩放 4、扭曲 skew 斜切扭曲。 ▉ 三种扭曲 skewX（）水平扭曲（正值，逆时针） skewY（）垂直扭曲（正值，顺时针） skew（）水平垂直同时扭曲 5、矩阵 matrix（难点） 矩阵分为 matrix 和 matrix3d 矩阵，分别为 3 3 和 4 4 的矩阵。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 CSS3 之基础篇【图片切换】]]></title>
    <url>%2F2019%2F03%2F31%2F%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2%E3%80%91%2F</url>
    <content type="text"><![CDATA[CSS3 实现图片多样式切换！ 一、不同格式的字体对浏览器的兼容性不同 Browser @font-face TrueType WOFF EOT SVG SVGZ IE 4+ 9+ 9+ 4+ 火狐 3.5+ 3.5+ 3.6+ 谷歌 4+ 4+ 6+ 4+ 6+ 苹果 3.1+ 3.1+ 6+ 3.1+ 3.1+ opera 10+ 10+ 11.1+ 10+ 10+ 二、内联元素的自动转换 当给一个内联元素加以下属性就会转换为块元素。 1、float; 2、position; 3、absolute;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析之 Python 【Pandas】]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%20Python%20%E4%B9%8B%E3%80%90Pandas%E3%80%91%2F</url>
    <content type="text"><![CDATA[如果日常数据清理工作不是非常复杂，几句 Pandas 代码就给你搞定！ 一、Series 和 DataFrame 分别代表着一维的序列和二维的表结构。基于这两种数据结构，Pandas 可以对数据进行导入、清洗、处理、统计和输出。 1、Series Series 是个定长的字典序列。 1、Series 有两个属性：values 和 index（默认的index为1,2…），指定 index 比如 index=[‘a’,’b’,’c’,’d’]。 12345678910111213141516171819import pandas as pdfrom pandas import Series,DataFramex1 = Series([1,2,3,4])x2 = Series(data=[1,2,3,4], index=['a','b','c','d'])print(x1)print(x2)# 输出结果0 11 22 33 4dtype: int64a 1b 2c 3d 4dtype: int64 ▉ 数据字典创建 用数据字典的方式创建 Series。 12345678910# 数据字典创建 Seriesd = &#123;'a':1,'b':2,'c':3,'d':4&#125;x3 = Series(d)print(x3)# 结果a 1b 2c 3d 4dtype: int64 2、DataFrame 类似数据库的表。包括行索引和列索引。 12345678910111213141516171819202122232425262728import pandas as pdfrom pandas import Series,DataFrame# 数据data = &#123; 'Chinese':[66, 95, 93, 90, 80], 'English':[65, 85, 92, 88, 90], 'Math':[30, 98, 96, 77, 90] &#125;# 索引默认 1,2,3...df1 = DataFrame(data)# 设置索引df2 = DataFrame( data, # 行索引 index=['ZhangFei', 'GuanYu', 'ZhaoYun', 'HuangZhong', 'DianWei'], # 列索引 columns=['English', 'Math', 'Chinese'] )print(df1)print(df2)# 结果4 80 90 90 Chinese English MathZhangFei 66 65 30GuanYu 95 85 98ZhaoYun 93 92 96HuangZhong 90 88 77DianWei 80 90 90 二、数据的导入和输出 Pandas 允许直接从 xlsx,csv 等文件导入数据，也可以输出到这些文件。 1# python3.0 安装 openpyxl 包 三、数据清洗1、删除 DataFrame 中不必要的行或列123456789101112131415161718192021import pandas as pdfrom pandas import Series,DataFramedata = &#123; 'Chinese': [66, 95, 93, 90,80], 'English': [65, 85, 92, 88, 90], 'Math': [30, 98, 96, 77, 90]&#125;df2 = DataFrame(data, index=['ZhangFei', 'GuanYu', 'ZhaoYun', 'HuangZhong', 'DianWei'], columns=['English', 'Math', 'Chinese'] )print(df2)# drop 删除 DataFrame 中不必要的列或行# columns 删除行df2 = df2.drop(columns=['Chinese'])print(df2)# index 删除列df2 = df2.drop(index=['ZhangFei'])print(df2) 2、重命命列名 columns，让列表名更容易识别 对列名重新命名，直接使用 rename(columns = new_name,inplace=True)函数。 123# 重命名列名df2.rename(columns=&#123;'Chinese':'YuWen','English':'YingYu'&#125;,inplace = True)print(df2) 3、去重复的值 数据采集有重复的行，使用 drop_duplicates() 就会自动把重复的行去掉。 12# 去除重复行df = df.drop_duplicates() 4、格式问题▉ 更改数据格式 使用 astype 函数来规范数据格式，比如 Chinese 字段的值改为 str 类型，或者 int64 可以这么写。 123# 更改数据格式df2['YuWen'].astype('str')df2['YuWen'].astype(np.int64) ▉ 数据间的空格 用 strip 函数删除数据之间的空格。 123456# 删除左右两边空格df2['Chinese']=df2['Chinese'].map(str.strip)# 删除左边空格df2['Chinese']=df2['Chinese'].map(str.lstrip)# 删除右边空格df2['Chinese']=df2['Chinese'].map(str.rstrip) 删除某一个字段里的特殊符号。 12# 删除某一字段中的特殊符号df2['YuWen']=df2['YuWen'].str.strip('$') ▉ 大小写转换 对人名、城市名为了统一都可能用到大小写转换，直接用 upper()、lower()、title() 函数，方法如下。 123456# 全部大写df2.columns = df2.columns.str.upper()# 全部小写df2.columns = df2.columns.str.lower()# 首字母大写df2.columns = df2.columns.str.title() ▉ 查找空值 数据量大的情况下，有很多字段存在 NaN 的可能，使用 isnull 函数进行查找。 12345678910111213141516# 查找空值print(df2.isnull());# 只显示空值df2.isnull().any()# 结果1 Yingyu Math YuwenGuanYu False False FalseZhaoYun False False TrueHuangZhong False False TrueDianWei False False True# 结果2Yingyu FalseMath FalseYuwen Truedtype: bool]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 CSS3 之基础篇【过渡】]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E8%BF%87%E6%B8%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[CSS 过渡会用到什么地方呢？ 一、CSS3 过渡 1、允许 css 的属性值在一定的时间区间内平滑地过渡。 2、在鼠标点击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变 css 的属性值。 ▉ 兼容性 IE 10+、FireFox16+、Chrome26+、Safari6.1+ Opera 12.1 + 二、CSS3 transition 属性(4个)1、transition-property 属性 检索或设置对象中的参与过渡的属性。 ▉ 语法1transition-property:none|all|property 参数说明： none : 没有属性改变 all : 所有属性改变，默认值 property: 元素的属性名称 2、transition-property 属性 检索或设置对象过渡的持续时间。 ▉ 语法1transition - duration: time; 参数说明： 规定完成过渡效果需要花费的时间（以秒或毫秒计） 默认为 0 3、transition-timing-function 属性 检索或设置独享中的过渡的当动画类型。 ▉ 语法1transition-timing-function：ease|linear|ease-in|ease-out|ease-in-out|step-start|step-end 参数说明： linear：匀速过渡 ease：平滑过渡（慢—快—慢） ease - in：由慢到快 ease - out: 由快到慢 ease - in - out：由慢到快再到慢（最人性化） step-start：等同于 steps(1,start) step-start：等同于 steps(1,end) 3、transition-delay 属性 检索或设置对象延迟过渡的时间。 ▉ 语法1transition-delay：time; 4、transition 复合属性 复合属性 ▉ 语法12//属性 过渡时间 类型 延迟transition:property duration timing-fnction delay;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 CSS3 之基础篇【选择器】]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E8%BE%B9%E6%A1%86%E4%B8%8E%E9%98%B4%E5%BD%B1%E3%80%91%2F</url>
    <content type="text"><![CDATA[带你走进 CSS3 的边框与阴影！ 一、CSS3 圆角1、border - radius 属性 最多可以指定四个 border -*- radius 属性的符合属性，这个属性允许为你元素添加圆角边框！ ▉ 语法1border-radius:1-4 length|% ▉ 兼容性 IE9+、FireFox4+、Chrome、Safari5+、Opera 123456//不同浏览器使用不同内核来渲染-webkit-border-radius：50%;//谷歌浏览器 -moz-border-radius:50%;//火狐浏览器 -ms-border-radius:50%;//IE 浏览器 -o-border-radius:50%;//Opera浏览器 border-radius:50%; 12345678910&lt;style&gt; div&#123; width: 800px; height: 300px; border: 5px solid red; margin: 0 auto; /* 左上角、右上角、右下角、左下角 */ border-radius: 10px 20px 30px 40px; &#125;&lt;/style&gt; ▉ 指定每个圆角 border-top-left-radius 定义左上角的弧度 border-top-right-radius 定义右上角的弧度 border-bottom-left-radius 定义左下角的弧度 border-bottom-right-radius 定义右下角的弧度 二、CSS 盒阴影属性 可以设置一个或多个下拉阴影的框。 1、box-shadow 属性▉ 语法12//水平偏移量，垂直偏移量，模糊，扩展(向周边长度进行扩展)，颜色，内阴影box-shadow:h-shadow v-shadow blur spread color insert; ▉ 兼容性 IE9+、FireFox4+、Chrome、Safari5+、Opera 三、CSS 边界图片1、border-image 属性 使用 border-image- * 属性来构建魅力的可扩展按钮。 ▉ 语法12// border-image:source slice width outset repeat; ▉ 兼容性 IE 不兼容、FireFox、Chrome、Safair6+、Opera 不兼容。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[必会的网络原理之【UDP-TCP】]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%BF%85%E4%BC%9A%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E3%80%90UDP-TCP%E3%80%91%2F</url>
    <content type="text"><![CDATA[网络协议是每个工程师必须要掌握的知识。 一、网络层中协议1、五层模型 越最下层越靠近硬件，越最上方的层，越靠近用户。 应用层 传输层 网络层 连接层 实体层 2、层与协议 互联网分为若干层，每一层都有特定的功能和规则。大家都要遵守的规则叫做 “协议”。 3、实体层 电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。 它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。 4、链路层▉ 定义 问题：单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？ 解决：这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。 ▉以太网协议（数据包的定义） 一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。 标头：包含数据包的一些说明项，比如发送者、接受者、数据类型等等 数据： 数据包的具体内容 ▉MAC地址 问题：发送者和接受者是如何标识呢？ 解决：以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。 ▉广播 问题：一块网卡怎么会知道另一块网卡的MAC地址？以太网数据包必须知道接收方的MAC地址，然后才能发送。 （ARP协议） 问题：知道MAC地址了，系统怎样才能把数据包准确送到接收方 ？ 解决： 发送方并不是准确的发送到接受方，而是向本网络内所有计算机发送，每台计算机判断是否接收？它们读取这个包的”标头”，找到接收方的 MAC 地址，然后与自身的 MAC 地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。 5、网络层▉ 由来 上述虽然可以实现通信，存在一下弊端： 1）局限在发送者所在的子网络 。 2）以广播发送效率低下。 3）两台机器不在子网络。广播是传不过去的。 ▉ 网络层的定义 问题：怎么做到如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。？ 解决: 这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。 ▉ 网络地址和MAC地址的区别？ 1、两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。 2、网络在确定所在子网络的时候，先处理网络地址，然后在处理MAC地址。 ▉ IP 协议 作用： 一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 定义：规定网络地址的协议，叫做IP协议。它所定义的地址，就被称 为IP地址。 组成： 地址分成两个部分，前一部分代表网络，后一部分代表主机 。可以判断两台计算机是否处于同一网络中。 ▉ 子网掩码 问题： 对于 IP 地址无法判断网络部分，到底是前16位还是前24位代表网络地址？ 解决：子网掩码 组成: 它的网络部分全部为1，主机部分全部为0。 比如，比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 ▉ 判断是否处于同一网络 将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。 ▉ IP 数据包 之前的以太网数据包只包含 MAC 地址，没有 IP 地址的栏位。并不需要添加 IP 栏位，我们直接将 IP 数据包添加到以太网数据包的数据部分。这就是互联网分层的好处，上层的变动完全不涉及下层的结构。 IP 数据包： 标头：包括版本、长度、IP地址等信息。 数据：IP 数据包的具体内容。 包装后的以太网数据包： ▉ ARP 协议 问题：IP 数据包是放在以太网数据包里发送的，所以同时知道 IP 地址和 MAC 地址，IP 地址是已知的，但是不知道 MAC 地址。我们需要从 IP 地址中的到 MAC 地址。 解决： 两种情况：是否在同一子网络。 第一种情况，不在同一子网络，将数据包扔给两个子网络连接处网关处理。 第二种情况，同一子网络中，通过 ARP协议。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包 二、UDP 与 TCP 的区别是什么？1、面向无连接 UDP 发送数据不需要提前进行连接，想发直接发送就可以了，并且知识数据报文的搬运工，不会对报文有任何拆分和拼接操作。 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作 2、3、]]></content>
      <categories>
        <category>网络原理</category>
        <category>TCP</category>
        <category>UDP</category>
      </categories>
      <tags>
        <tag>网络原理</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析之 Python 【NumPy库】]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%20Python%20%E3%80%90NumPy%E5%BA%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[NumPy 是一个重要的 Python 库，有哪些操作呢？ 一、Numpy是什么？ Python 中使用最多的第三方库，NumPy 所提供的数据结构是 Python 数据分析的基础。 ▍两个对象 1、ndarray解决了多维数组问题。 2、ufunc 则是解决对数组进行处理的函数。 二、Numpy 和 list 的区别？ 1、 Python中的 list 保存的是对象的指针，因此数据量大时很占内存，所以会慢。 2、NumPy 数组存储在一个均匀连续的内存块中，这样数组计算遍历所有的元素，不像列表 list 还需要对内存地址进行查找，从而节省了计算资源，比较快。 三、Numpy 的使用1、安装 Numpy 使用 pip 命令进行安装，如果 pip 不是内外部命令，则在 path 环境变量中进行配置。 1pip install numpy 2、创建数组 在 NumPy 数组中，维数称为秩（rank），一维数组的秩为 1，二维数组的秩为 2，以此类推。在 NumPy 中，每一个线性的数组称为一个轴（axes），其实秩就是描述轴的数量。 123456789101112import numpy as npa = np.array([1,2,3])b = np.array([[1,2,3],[4,5,6],[7,8,9]])//添加数据b[1,1] = 10// 获取数组大小print(a.shape)print(b.shape)//获取元素类型print(a.dtype)print(b) 3、结构数组 总体数量中的某一类数据，求平均数等操作。 123456789101112131415161718import numpy as nppersontype = np.dtype(&#123; 'names':['name','age','chinese','math','english'], 'formats':['S32','i', 'i', 'i', 'f']&#125;)# 添加数据,参数二：设置数组的类型persons = np.array([("ZhangFei",32,75,100, 90), ("GuanYu",24,85,96,88.5), ("ZhaoYun",28,85,92,96.5), ("HuangZhong",29,65,85,100)],dtype = persontype)# 统计每个人的年龄ages = persons[:]['age']print(ages)# 计算年龄的平均数print(np.mean(ages)) S32 : 32个字节的字符串类型，由于结构中的每个元素的大小必须固定，因此需要指定字符串的长度 i : 32bit的整数类型，相当于np.int32 f : 32bit的单精度浮点数类型，相当于np.float32 4、ufunc 运算 对数组中的每个元素进行操作。ufunc 计算速度快，底层是 c 语言实现的。 5、连续数组的创建 使用 arange 或 linspace 创建连续函数。 ▉ arange 通过指定（初始值、终值、步长）来创建等差数列的一维数组，默认不包括终值。 1x1 = np.arange(1,11,2)//[1 3 5 7 9] ▉ linspace 通过指定（初始值、终值、元素个数）来创建等差数列的一维数组，默认包括终值。 6、算数运算 通过 NumPy 可以自由地创建等差数组，同时也可以进行加、减、乘、除、求 n 次方和取余数。 12345678910111213141516171819202122import numpy as npx1 = np.arange(1,11,2)x2 = np.linspace(1,9,5)# 相加print(np.add(x1,x2))# 相减print(np.subtract(x1,x2))# 相乘print(np.multiply(x1,x2))# 相除print(np.divide(x1,x2))# 求 n 次方print(np.power(x1,x2))# 取余print(np.remainder(x1,x2))print(np.mod(x1,x2)) 7、统计函数 对大量数据进行描述性的统计分析。最大值、最小值、平均值，是否符合正态分布、方差、标准差多少等等。 ▉ 计算数组/矩阵的最大值函数(amax()),最小值函数 (amin())123456789101112import numpy as npa = np.array([[1,2,3],[4,5,6],[7,8,9]])# 数组中的最大值print(np.amax(a))# 延 axis=0 轴(纵轴)的最小值print(np.amin(a,0))# 延 axis=1 轴(横轴)的最小值print(np.amin(a,1)) ▉ 统计最大值与最小值之差12345678# 数组中最大值和最小值之差print(np.ptp(a))# 延 axis=0 轴(纵轴)最大值和最小值之差print(np.ptp(a,0))# 延 axis=1 轴(横轴)最大值和最小值之差print(np.ptp(a,1)) ▉ 统计数组的百分位数 percentile() percentile() 代表着第 p 个百分位数，这里 p的取值范围是 0-100，如果 p=0，那么就是求最小值，如果 p=50 就是求平均值，如果 p=100 就是求最大值。同样你也可以求得在 axis=0 和 axis=1 两个轴上的 p% 的百分位数。 1234567a = np.array([[1,2,3],[4,5,6],[7,8,9]])# 统计数组的百分位数print(np.percentile(a,100))//9.0print np.percentile(a, 50, axis=0)print np.percentile(a, 50, axis=1) ▉ 统计数组中的中位数 median、平均数 mean()12345# 求中位数print(np.median(a))# 求中位数print(np.mean(a)) ▉ 统计数组中的加权平均值 average() average() 函数可以求加权平均，加权平均的意思就是每个元素可以设置个权重，默认情况下每个元素的权重是相同的，所以np.average(a)=(1+2+3+4)/4=2.5，你也可以指定权重数组 wts=[1,2,3,4]，这样加权平平均 np.average(a,weights=wts)=(11+22+33+44)/(1+2+3+4)=3.0。 12345# 统计数组的加权平均值a = np.array([1,2,3,4])wts = np.array([1,2,3,4])print(np.average(a))print(np.average(a,weights=wts)) ▉ 统计数组中的标准差 std()、方差 var() 方差的计算是指每个数值与平均值之差的平方求和的平均值,标准差是方差的算术平方根(代表的是一组数据离平均值的分散程度)。 1234# 求标准差和方差a = np.array([1,2,3,4])print(np.std(a))print(np.var(a)) 8、NumPy 排序1sort(a, axis=-1, kind=‘quicksort’, order=None) 1、使用 sort 函数，kind 的值可以指定为 quicksort 、mergesort、heapsort分别表示快速排序、归并排序、堆排序，一般使用快速排序。 2、同样 axis 默认是 -1，即沿着数组的最后一个轴进行排序，也可以取不同的 axis 轴，或者 axis=None 代表采用扁平化的方式作为一个向量进行排序。 3、order 字段，对于结构化的数组可以指定按照某个字段进行排序。 12345678910111213141516171819# NumPy 排序# 4 3 2# 2 4 1a = np.array([[4,3,2],[2,4,1]])# 横轴排序print(np.sort(a,axis=-1))# 纵轴排序print(np.sort(a,axis=0))print(np.sort(a,axis=1))# 结果[[2 3 4] [1 2 4]]---------[[2 3 1] [4 4 2]]---------[[2 3 4] [1 2 4]]]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 CSS3 之基础篇【选择器】]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%89%8D%E7%AB%AF%20CSS3%20%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%90%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[CSS3 所有基本选择器（必会）！ 基本选择器一、回顾选择器（5个） 1、通配符选择器 *{} 2、元素选择器 h1{} 3、类选择器 .container{} 4、ID选择器 #id{} 5、后代选择器 ul em{ } 二、新增基本选择器（4个） 子元素选择器，相邻兄弟元素选择器，通用兄弟选择器，群组选择器。 1、直接后代选择器（子元素选择器） 只能选择某元素的子元素。 ▉ 语法格式 父元素 &gt; 子元素 （Father &gt; Children） ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 123456789101112&lt;style&gt; section&gt;div&#123; color: #0f0f; &#125;&lt;/style&gt;&lt;section&gt; //这个div变色 &lt;div&gt;外边的DIV&lt;/div&gt; &lt;article&gt; &lt;div&gt;里边的DIV&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 2、相邻兄弟选择器 相邻兄弟选择器可以选择紧接在另一元素后的元素，而且他们具有一个相同的父元素。 ▉ 语法格式 元素 + 兄弟相邻元素。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 123456789101112131415&lt;style&gt; section&gt;div + article&#123; color: #0f0f; &#125;&lt;/style&gt;&lt;section&gt; &lt;div&gt;外边的DIV&lt;/div&gt; &lt;!-- 控制这一个 --&gt; &lt;article&gt; &lt;div&gt;里边的DIV&lt;/div&gt; &lt;/article&gt; &lt;article&gt; &lt;div&gt;里边的DIV&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 3、通用兄弟选择器 选择某元素后边的多有兄弟元素，而且他们具有一个相同的父元素。 ▉ 语法格式 元素 ~ 后面所有兄弟相邻元素 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 1234567891011121314151617 &lt;style&gt; section&gt;div ~ article&#123; color: #0f0f; &#125; &lt;/style&gt; &lt;section&gt; &lt;!-- div 前边的 article 不会被选择 --&gt; &lt;div&gt;外边的DIV&lt;/div&gt; &lt;!-- 控制这一个 --&gt; &lt;article&gt; &lt;div&gt;里边的DIV&lt;/div&gt; &lt;/article&gt; &lt;!-- 也控制这一个 --&gt; &lt;article&gt; &lt;div&gt;里边的DIV&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 4、群组选择器 相同元素的样式分组在一起，每个选择器之前使用逗号 “，” 隔开。 ▉ 语法格式 元素，元素，…，元素n ▉ 兼容性 IE6+、FireFox、Chrome、Safari、Opera。 12345section &gt; div,section &gt; article,section &gt; aside&#123; color:#000;&#125; 三、伪类选择器（5个）1、动态伪类选择器 并不存在 HTML 中，只有当用户和网站交互的时候才能体现出来。 ▉ 锚点伪类 : link，: visited。 ▉ 用户行为伪类 : hover（必须写在 link 和 visited 才会生效）, : active（必须写在 hover 后才会生效）,: focus(用于input输入) 2、UI元素状态伪类 把“：enabled”，“：disabled”，“：checked” 伪类称为UI元素状态伪类。 ▉ 兼容性 IE9+、FireFox、Chrome、Safari、Opera。 123456789101112&lt;style&gt; input:enable&#123; width:100px; height:100px; background: #0000ff; &#125; //没有宽和高 input:disabled&#123; background: #0000ff; &#125;&lt;/style&gt;&lt;input type="text" disabled="disabled"&gt; 3、否定选择器 :not （Element/selector）选择器匹配非指定元素/选择器的每个元素。 ▉ 语法格式 父元素：not(子元素/子选择器) ▉ 兼容性 IE9+、FireFox、Chrome、Safari、Opera。 123nav &gt; a:not(:last-of-type)&#123; border-right:1px solid red;&#125; 四、伪元素选择器 伪元素用于向某些选择区设置特殊效果。 :first-line: 应用于多行文本的首行元素。应用于块元素。 :first-letter: 选取首字母。应用于块元素。 :first-child:选择父元素的第一个子元素。注意：在 IE 中声明&lt;!DOCTYPE&gt; 才生效！ :before:元素之前添加内容 :after : 元素之后添加内容 五、属性选择器 Element[attribute]、Element[attribute= “value” ]、Element[attribute~= “value” ]、Element[attribute^= “value” ]、Element[attribute$= “value” ]、Element[attribute*= “value” ]、Element[attribute|= “value” ]。 1、Element[attribute] 为带有 attribute 属性的 Element 元素设置样式。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 123456&lt;style&gt; a[href]&#123; text-decoration: none; &#125;&lt;/style&gt;&lt;a href="attribute.html"&gt;atribute&lt;/a&gt; 2、Element[attribute= “value” ] 为 attribute= “value” 属性的 Element 元素设置样式。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 1234a[href = "attribute.html"]&#123; text-decoration: none; color: #f0f; &#125; 3、Element[attribute~= “value” ] 选择 attribute 属性包含单词 “value” 的元素，并设置其样式。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 123456789&lt;style&gt; a[class ~= "two"]&#123; text-decoration: none; color: #f0f; &#125;&lt;/style&gt;&lt;a class="one two" href="attribute.html1"&gt;atribute&lt;/a&gt;&lt;a class="two three" href="attribute.html2"&gt;atribute&lt;/a&gt; 4、Element[attribute^= “value” ] 选择以 value 开头的元素。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 123456789101112&lt;style&gt; a[href ^= "attribute.html"]&#123; text-decoration: none; color: #f0f; &#125;&lt;/style&gt; &lt;a href="attribute.html"&gt;atribute&lt;/a&gt;//变 &lt;a class="one two" href="attribute.html1"&gt;atribute&lt;/a&gt; &lt;a class="two three" href="attribute.html2"&gt;atribute&lt;/a&gt; &lt;a href="attribute.html3"&gt;atribute&lt;/a&gt;//变 &lt;a href="attribute.html4"&gt;atribute&lt;/a&gt;//变 &lt;a href="attribute.html5"&gt;atribute&lt;/a&gt;//变 5、Element[attribute$= “value” ] 选择以 value 结尾的元素。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 6、Element[attribute*= “value” ] 选择包含 value 的元素。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 7、Element[attribute|= “value” ] 选择为 “value” 或者以 “value-” 开头的元素，并设置其样式。 ▉ 兼容性 IE8+、FireFox、Chrome、Safari、Opera。 六、CSS 权重1、什么是权重？ 很多规则被应用于某一个元素上，权重就是那中规则生效。或者说是优先级。 2、权重等级与权值 行内样式（1000）&gt; ID 选择器（100）&gt;类、属性选择器和伪类选择器（10）&gt;元素和伪类（1）&gt; * (0)。]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析之 Python 【基础篇】]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%20Python%20%E3%80%90%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%91%2F</url>
    <content type="text"><![CDATA[快速入门 Python 基础! 1、输入输出 input 用于 py3.0 的输入，print 用于输出。 1234name = input("请输入输出的数据")sum = 100 + 100print('hello,%s'%name)print('sum = %d'%sum) 2、判断语句（if…else）12345678910# 判断语句number = input('请输入成绩:')score = int(number)if score &gt;= 90: print('优秀')else: if score &lt; 60: print('不及格') else: print('及格') 3、循环语句 range(11) 代表从 0 到 10，不包括 11，也相当于 range(0,11)，range 里面还可以增加步长，比如 range(1,11,2) 代表的是 [1,3,5,7,9]。 12345# 循环语句sum = 0for item in range(11): sum = sum + itemprint(sum) 4、while 循环 while 循环适合循环次数不确定的循环，而 for 循环循环的条件相对确定，适合固定次数的循环。 123456sum = 0number = 1while number &lt; 11: sum = sum + number number = number + 1print(sum) 5、数据类型：列表、元组、字典、集合▉ 列表: [] —— 数组 列表是 Python 中常用的数据结构，相当于数组，具有增删删改查的功能，我们可以使用 len() 函数获得 lists中元素的个数；使用 append() 在尾部添加元素，使用 insert() 在列表中插入元素，使用 pop() 删除尾部的元素。 12345678# 列表lists = ['1','2','3']lists.append('4')print (lists)print (len(lists))lists.insert(0,'xiaolu')lists.pop()print (lists) ▉ 元组 () —— 只能访问，不能赋值 元组 tuple 和 list 非常类似，但是 tuple 一旦初始化就不能修改。因为不能修改所以没有append(), insert() 这样的方法，可以像访问数组一样进行访问，比如 tuples[0]，但不能赋值。 123# 元组tuples = ('xiaolu','小鹿')print(tuples[0]) ▉ 字典 {} —— map 字典其实就是{key, value},多次对同一个 key 放入 value，后面的值会把前面的值替换，同样有增删改查 123456789101112131415# 字典# 字典定义score = &#123;'age':22,'name':'xiaolu'&#125;# 添加数据score['school'] = '三本'print(score)# 删除元素score.pop('name')print(score)# 查看 key 是否存在print('age' in score)# 查看 key 对应的值print(score.get('age'))# 给一个默认值print(score.get('school','三本')) ▉ 集合: set —— 存储字典的 key 值 集合 set 和字典 dictory 类似，不过它只是 key 的集合，不存储 value。同样可以增删查，增加使用 add，删除使用 remove，查询看某个元素是否在这个集合里，使用 in。 12345678# 集合s = set(['a','b','c'])# 添加s.add('d')# 移除s.remove('b')print(s)print('c' in s) 6、引用模块 / 包：import 1、import 的本质是路径搜索。import 引用可以是模块 module，或者包 package。 2、针对 module，实际上是引用一个.py 文件。 3、而针对 package，可以采用 from … import… 的 方式。 4、这里实际上是从一个目录中引用模块，这时目录结构中必须带有一个init.py 文件。 12345678# 导入一个模块import model_name# 导入多个模块import module_name1,module_name2# 导入包中指定模块 from package_name import moudule_name# 导入包中所有模块 from package_name import * 7、函数：def 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号，在圆括号里是传进来的参数，然后通过 return 进行函数结果得反馈。 1234# 函数def addone(score): return score + 1print(addone(1))]]></content>
      <categories>
        <category>python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【模块化】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%91%2F</url>
    <content type="text"><![CDATA[随着前后端分离，前端的业务日渐复杂，ES6为我们增加了模块话操作。 1、模块化 export :负责进行模块化，也是模块的输出。 import : 负责把模块引，也是模块的引入操作。 2、export的用法 export可以让我们把变量，函数，对象进行模块话，提供外部调用接口，让外部进行引用 123456//暴露接口export var a = 'xiaolu';//index.js中以import的形式引入import &#123;a&#125; from './temp.js';console.log(a); 3、多变量的输出12345678910//多变量的模块化var a ='xiaolu';var b ='小鹿';var c = '三本';export &#123;a,b,c&#125;//函数的模块化export function add(a,b)&#123; return a+b;&#125; 4、as 用法 as的用法 有些时候我们并不想暴露模块里边的变量名称，而给模块起一个更语义话的名称，这时候我们就可以使用as来操作。 12345678var a ='xiaolu';var b ='小鹿';var c = '三本';export &#123; x as a, y as b, z as c&#125; 5、默认值 default12345678910111213//无默认值//exportexport var a ='xiaolu';//对应的导入方式export function add(a,b)&#123; return a+b;&#125;//export defalut 方式//export defalutexport default var a='xiaolu';//引入方式import str from './temp'; ES6的模块化不能直接在浏览器中预览，必须要使用Babel进行编译之后正常看到结果。这节课讲完我们ES6的课程就算结束了，你可能觉的没有书上的内容多，那是因为很多东西都归到了ES7中。]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【promise对象】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90class%E7%B1%BB%E3%80%91%2F</url>
    <content type="text"><![CDATA[ES6为我们提供了类的使用。需要注意的是在写类的时候和 ES5 中的对象和构造函数要区分开来，不要学混了。 1、类的声明 最简单的类只有一个方法。 12345class coder&#123; name(val)&#123; console.log(val); &#125;&#125; 2、类的使用123456789//类的使用class Coder&#123; name(val)&#123; console.log(val) &#125;&#125;let xiaolu = new Coder;xiaolu.name('小鹿') 3、类的多方法声明 这里需要注意的是两个方法中间不要写逗号了，还有这里的this指类本身，还有要注意return 的用法。 1234567891011121314//类的使用class Coder&#123; name(val)&#123; console.log(val) return val &#125; skill(val)&#123; console.log(this.name('xiaolu')+':'+'Skill:'+val) &#125;&#125;let xiaolu = new Coder;xiaolu.name('小鹿')xiaolu.skill('三本') 4、类的传参 在类的参数传递中用 constructor() 进行传参。传递参数后可以直接使用 this.xxx 进行调用。 123456789101112131415161718192021//类的使用class Coder&#123; name(val)&#123; console.log(val) return val &#125; skill(val)&#123; console.log(this.name('xiaolu')+':'+'Skill:'+val) &#125; constructor(a,b)&#123; this.a = a; this.b = b; &#125; add()&#123; return this.a+this.b; &#125;&#125;let xiaolu = new Coder(1,2);console.log(xiaolu.add()) 5、class的继承123456class Html extends Coder&#123;&#125;let l = new Htmll.name('哈哈哈')]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【promise对象】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90promise%E5%AF%B9%E8%B1%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[ES6中的 promise 的出现给我们很好的解决了回调地狱的问题 。 1、概念 Promise 针对于异步操作中的回调地狱问题，它可以使异步操作写起来更像是写同步的流程，不必一层层的嵌套回调。使得处理逻辑和执行结果更好的分离。 2、基本用法▉ promise 执行逻辑 创建一个 promise 对象，将执行异步操作的函数传入，之关心异步操作的逻辑实现。 1var p1 = new Promise(test); ▉ promise 执行结果处理 p1 是一个 Promise 对象，只负责执行 test 函数，由于 test 是异步的操作，当异步执行完成，就会告诉 p1 对象，如果执行成功就执行下方函数。 123p2 = p1.then(function(result)&#123; console.log('成功'+result)&#125;) 如果执行失败，就告诉 promise 对象执行下列函数。 123p2.catch（function(reason)&#123; console.log('失败：' + reason);&#125;） 连起来书写方式。 12345new Promise(test).then(function(result)&#123; console.log('成功'+result)&#125;).catch(function (reason) &#123; console.log('失败：' + reason);&#125;) 3、AJAX 的 Promise 用法 将 ajax 请求封装为 Promise 对象。 1234567891011121314151617// ajax函数将返回 Promise 对象:function ajax(method, url, data) &#123; var request = new XMLHttpRequest(); return new Promise(function (resolve, reject) &#123; request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; resolve(request.responseText); &#125; else &#123; reject(request.status); &#125; &#125; &#125;; request.open(method, url); request.send(data); &#125;);&#125; 调用返回执行结果。 1234567var log = document.getElementById('test-promise-ajax-result');var p = ajax('GET', '/api/categories');p.then(function (text) &#123; // 如果AJAX成功，获得响应内容 log.innerText = text;&#125;).catch(function (status) &#123; // 如果AJAX失败，获得响应代码 log.innerText = 'ERROR: ' + status;&#125;); 4、并行执行异步任务 使用 Promise 方法可以并行执行多个异步任务。 12345678910var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2');&#125;);// 同时执行p1和p2，并在它们都完成后执行then:Promise.all([p1, p2]).then(function (results) &#123; console.log(results); // 获得一个Array: ['P1', 'P2']&#125;); 5、Promise 多异步容错 为了多个异步可以容错，多个异步任务，只需要获得先返回的结果即可 ，其他返回结果丢弃。使用 Promise.race() 方法。 123456789var p1 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1');&#125;);var p2 = new Promise(function (resolve, reject) &#123; setTimeout(resolve, 600, 'P2');&#125;);Promise.race([p1, p2]).then(function (result) &#123; console.log(result); // 'P1'&#125;);]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【Proxy预处理】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90Proxy%E9%A2%84%E5%A4%84%E7%90%86%E3%80%91%2F</url>
    <content type="text"><![CDATA[Proxy 预处理的强大之处！ 1、钩子函数 当我们在操作一个对象或者方法时会有几种动作，比如：在运行函数前初始化一些数据，在改变对象值后做一些善后处理。这些都算钩子函数，Proxy的存在就可以让我们给函数加上这样的钩子函数，你也可以理解为在执行方法前预处理一些代码。 2、声明Proxy 基本格式。 1new Proxy（&#123;&#125;,&#123;&#125;）; 第一个花括号就相当于方法的主体 。 第二个花括号是代理处理区域，写钩子函数的地方。 ▉ 实例123456789101112相当于在方法调用前的钩子函数var pro = new Proxy(&#123; add: function (val) &#123; return val + 10; &#125;, name: 'I am xiaolu'&#125;, &#123; get:function(target,key,property)&#123; console.log('小鹿'); return target[key]; &#125; &#125;);console.log(pro.name);//先打印小鹿，后打印 I am xiaolu ，相当于在方法调用前的钩子函数 ▉ get 属性 get属性是在你得到某对象属性值时预处理的方法，他接受三个参数 target：得到的目标值 key：目标的 key 值，相当于对象的属性 property：这个不太常用，用法还在研究中。 ▉ set属性 set 属性是值你要改变 Proxy 属性值时，进行的预先处理。它接收四个参数。 target:目标值。 key：目标的Key值。 value：要改变的值。 receiver：改变前的原始值。 1234567891011121314151617181920//set属性var pro = new Proxy(&#123; add:function(val)&#123; return 2+val; &#125;, name:'小鹿'&#125;,&#123; get:function(target,key)&#123; console.log("你好") return target[key]; &#125;, set:function(target,key,val,receiver)&#123; console.log('seting &amp;&#123;k&#125; = $&#123;value&#125;'); return target[key] = val; &#125;&#125;)console.log(pro.name);pro.name = "xiaolu"console.log(pro.name) ▉ apply的使用 apply 的作用是调用内部的方法，它使用在方法体是一个匿名函数时。 12345678910111213get = function () &#123; return 'I am xiaolu';&#125;;var handler = &#123; apply(target, ctx, args) &#123; console.log('do apply'); return Reflect.apply(...arguments); &#125;&#125;var pro = new Proxy(get, handler);console.log(pro());]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【map】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E3%80%90map%E3%80%91%2F</url>
    <content type="text"><![CDATA[map是一种灵活，简单的适合一对一查找的数据结构。 1、Json和map格式的对比 map的效率和灵活性更好 ,可以把它看成一种特殊的键值对，但你的key可以设置成数组，值也可以设置成字符串。 123456789let json = &#123; name:'xiaolu', skill:'小鹿'&#125;console.log(json.name);let map = new Map();map.set(json,'123')console.log(map) 2、Map 的增删改▉ get 取值1console.log(map.get(json)) ▉ delete 删除12map.delete(json)console.log(map) ▉ has 查找1console.log(map.has(json)) ▉ 清楚所有元素clear1console.log(map.clear) ▉ size 属性1console.log(map.size)]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【set和WeakSet数据结构】]]></title>
    <url>%2F2019%2F03%2F21%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90set%E5%92%8CWeakSet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%2F</url>
    <content type="text"><![CDATA[ES6中的数据结构，很有用处的新知识！ 1、set的声明 Set和Array 的区别是 Set 不允许内部有重复的值，如果有只显示一个，相当于去重。 123//Setlet setArr = new Set(['小鹿','xiaolu','三本'])console.log(setArr) 2、Set值的增删查▉ add 增加1234let setArr = new Set(['小鹿','xiaolu','三本'])console.log(setArr)setArr.add('哈哈')console.log(setArr) ▉ delete 删除12345678let setArr = new Set(['小鹿','xiaolu','三本'])console.log(setArr)setArr.add('哈哈')console.log(setArr)setArr.delete('小鹿')console.log(setArr) ▉ has 查找12let setArr = new Set(['小鹿','xiaolu','三本'])console.log(setArr.has('xiaolu')) ▉ clear 清空12setArr.clear();console.log(setArr) ▉ set的循环 for…of…循环：1234let setArr = new Set(['小鹿','xiaolu','三本'])for(let item of setArr)&#123; console.log(item)&#125; ▉ size属性 返回 set 中的数量。 1console.log(setArr.size) ▉ forEach循环12345setArr.forEach( (value)=&gt;&#123; console.log(value) &#125;) 3、WeakSet的声明 注意：这里需要注意的是，如果你直接在new 的时候就放入值，将报错， 而且不能传入重复的值。 12345let weakObj = new WeakSet();let obj = &#123;a:'xiaolu',b:'小鹿'&#125;weakObj.add(obj);console.log(weakObj)]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【Symbol在对象中的作用】]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90Symbol%E5%9C%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[Symbol，它的意思是全局标记。 1、声明Symbol1234567var a = new String;var b = new Number;var c = new Boolean;var d = new Array;var e = new Object; var f= Symbol();console.log(typeof(d)); 2、Symbol的打印123var g = Symbol('xiaolu');console.log(g);console.log(g.toString()); 3、Symbol在对象中的应用1234567var xiaolu = Symbol();var obj=&#123; [jspang]:'小鹿'&#125;console.log(obj[jspang]);obj[jspang]='三本';console.log(obj[jspang]); 4、Symbol对象元素的保护作用 循环的是时候不输出。 1234567let obj=&#123;name:'xiaolu',skill:'三本'&#125;;let age=Symbol();obj[age]=18;for (let item in obj)&#123; console.log(obj[item]);&#125; console.log(obj);]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【ES6对象】]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90ES6%E5%AF%B9%E8%B1%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[对象对于Javascript是非常重要的。在ES6中对象有了很多新特性。 1、对象赋值 ES6允许把声明的变量直接赋值给对象。 12345//ES6对象let name="xiaolu";let skill= '小鹿';var obj= &#123;name,skill&#125;;console.log(obj); 2、对象 Key 值的构建 获取对象键值对 key 值，我们自己定义键值对 key 值。 123456//对象构建key值let key='skill';var obj=&#123; [key]:'小鹿'&#125;console.log(obj.skill); 3、自定义对象方法123456var obj=&#123; add:function(a,b)&#123; return a+b; &#125;&#125;console.log(obj.add(1,2)); //3 4、Object.is( ) 对象比较 ES6为我们提供了is方法进行对比。 1234var obj1 = &#123;name:'xiaolu'&#125;;var obj2 = &#123;name:'xiaolu'&#125;;console.log(obj1 === obj2);//falseconsole.log(Object.is(obj1.name,obj2.name)); //true 区分 === 和 is方法的区别是什么 12345//===为同值相等，is()为严格相等。console.log(+0 === -0); //trueconsole.log(NaN === NaN ); //falseconsole.log(Object.is(+0,-0)); //falseconsole.log(Object.is(NaN,NaN)); //true 5、Object.assign( )合并对象12345var a=&#123;a:'xiaolu'&#125;;var b=&#123;b:'小鹿'&#125;;var c=&#123;c:'三本'&#125;;let d=Object.assign(a,b,c)console.log(d);]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【函数和数组补漏】]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E5%87%BD%E6%95%B0%E6%95%B0%E7%BB%84%E8%A1%A5%E6%BC%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[数组和函数的其他使用！ 1、对象的函数解构 后台传来的JSON格式数据当作参数，传递到函数内部进行处理。ES6就为供了这样的解构赋值，不用一个个传递参数了。 12345678910// 数组 JSON 解构let json = &#123; a:'xiaolu', b:'小鹿'&#125;//b设置默认值function fun(&#123;a,b='xiaolu'&#125;)&#123; console.log(a,b);&#125;fun(json); 2、数组的函数解构123456//解构数组let arr = [&apos;xiaolu&apos;,&apos;小鹿&apos;,&apos;三本&apos;];function fun(a,b,c)&#123; console.log(a,b,c);&#125;fun(...arr); 3、in的用法■ 对象判断 判断某一个属性值是否在对象中。 12 ■ 数组判断1234567891011//ES5存在的弊端let arr=[,,,,,];console.log(arr.length); //5// ES6中的 in 来解决let arr=[,,,,,];//这里的0指的是数组下标位置是否为空。console.log(0 in arr); //falselet arr1=['xiaolu','小鹿'];console.log(0 in arr1); // true 4、数组的遍历方法■ forEach forEach循环的特点是会自动省略为空的数组元素，相当于直接给筛空了。 12345//遍历数组let arr = ['xiaolu','小鹿','三本'];arr.forEach((element,index) =&gt; &#123; console.log(element+index)&#125;); ■ filter12345//filter遍历let arr = ['xiaolu','小鹿','三本'];arr.filter( element =&gt;console.log(element)) ■ some123//some 遍历let arr = ['xiaolu','小鹿','三本'];arr.some(element =&gt;console.log(element)) ■ map 遍历123//map循环起到代替作用let arr = [&apos;xiaolu&apos;,&apos;小鹿&apos;,&apos;三本&apos;];console.log(arr.map(element=&gt;&apos;xiaolu&apos;)) 5、数组转换为字符串■ join() 方法123//‘|’隔开let arr = ['xiaolu','小鹿','三本'];console.log(arr.join('|')) ■ toString() 方法123//逗号隔开let arr = [&apos;xiaolu&apos;,&apos;小鹿&apos;,&apos;三本&apos;];console.log(arr.toString())]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【箭头函数和扩展】]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[箭头函数的使用！ 一、箭头函数 注意箭头函数不能当做 构造函数来使用。 1、箭头函数1234567//普通函数function add(a,b=1)&#123; return a+b;&#125;//箭头函数var add = (a,b=1)=&gt;a+b;console.log(add(1)) 2、{ } 使用 如果函数体内多余两条语句，就使用 {}。 12345var add =(a,b=1) =&gt; &#123; console.log('jspang') return a+b;&#125;;console.log(add(1));]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【新增数组】]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E6%96%B0%E5%A2%9E%E6%95%B0%E7%BB%84%E3%80%91%2F</url>
    <content type="text"><![CDATA[ES6 中新增的数组知识！ 一、ES6中新增的数组知识 在ES6中绝大部分的Array操作都存在于Array对象里。 1、JSON数组格式转换123456789// JSON 转换数组let json = &#123; '0':'xiaolu', '1':'小鹿', '2':'小鹿哈哈', length:3&#125;let arr = Array.from(json)console.log(arr) 2、Array.of()方法 负责把一堆文本或者变量转换成数组。 1234let arr = Array.of(1,2,3,4);let arrText = Array.of('小鹿','小明','小强')console.log(arr)console.log(arrText) 3、find()实例方法 所谓的实例方法就是并不是以Array对象开始的，而是必须有一个已经存在的数组，然后使用的方法，这就是实例方法。 value：表示当前查找的值。 index：表示当前查找的数组索引。 arr：表示当前数组。 123456//find() 实例方法let arr=[1,2,3,4,5,6,7,8,9];console.log(arr.find(function(value,index,arr)&#123; return value &gt; 10;&#125;))//控制台输出了6，说明找到了符合条件的值，并进行返回了，如果找不到会显示undefined。 4、fill() 实例方法 用于把数组进行填充 。 参数一：填充的变量 参数二：开始填充的位置 参数三：填充到的位置 12345//fill()填充方法let arr=[0,1,2,3,4,5,6,7,8,9];arr.fill('小鹿',2,5);//把数组从第二位到第五位用xiaolu进行填充console.log(arr);//[0, 1, "小鹿", "小鹿", "小鹿", 5, 6, 7, 8, 9] 5、数组的遍历 for…of循环。 12345//for-of循环let arr = ['小鹿','xiaolu','啦啦']for(let item of arr)&#123; console.log(item)&#125; 输出数组索引。 123for(let index of arr.keys())&#123; console.log(index)&#125; 同时输出索引和元素。 123for(let [index,val] of arr.entries())&#123; console.log(index+':'+val);&#125; 6、entries( )实例方法 entries()实例方式生成的是Iterator形式的数组，需要时用next()手动跳转到下一个值。 12345678let arr = ['小鹿','xiaolu','啦啦']let list = arr.entries();console.log(list.next().value);console.log(list.next().value);console.log(list.next().value);//[0, "小鹿"]//[1, "xiaolu"]//[2, "啦啦"]]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 HTML5 基础篇之【属性变化】]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%89%8D%E7%AB%AF%20HTML5%20%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E3%80%90%E5%B1%9E%E6%80%A7%E5%8F%98%E5%8C%96%E3%80%91%2F</url>
    <content type="text"><![CDATA[第二节：HTML5 的属性添加了哪些？ HTML5 属性变化目录 Input 标签 表单属性 链接属性 其它属性 一、Input 属性 针对于 iphone 手机端(5个)：email /url /tel /数字/Date Pickers 针对于客户端（3个）：Range / Search /Color 1、email 类型 针对于手机端，出现特殊的键盘，电子邮件 Input 类型。 12//用于手机输入邮件&lt;input type="email" name="email" &gt; 2、url 类型 之应用于苹果手机端，特殊键盘。 1&lt;input type="url" name="url"&gt; 3、tel 类型 出现特殊的电话号码键盘。 1&lt;input type="tel" name="tel"&gt; 4、数字类型 出现数字运算键盘。 1&lt;input type="number" name="number"&gt; 5、Date Pickers类型 日期类型。手机端只应用于 iphone。 Date —— 选取日、月、年 Month —— 选取月年 Week —— 选取周和年 Time —— 选取时间（小时和分钟） Datetime —— 选取时间、日、月、年（UTC时间） Datetime-local —— 选取时间、日、月、年（本地时间） 1234567// 手机出现滚动日期date:&lt;input type="date" name="date"&gt;&lt;br&gt;//年、月、日month:&lt;input type="month" name="month"&gt;&lt;br&gt;//年、月week:&lt;input type="week" name="week"&gt;&lt;br&gt;//年、周time:&lt;input type="time" name="time"&gt;&lt;br&gt;//时、分datetime:&lt;input type="datetime" name="datetime"&gt;&lt;br&gt;//年、月、日、时区datetime-local:&lt;input type="datetime-local" name="datetime-local"&gt;&lt;br&gt;//年、月、日 Datetime 和 Datetime-local 的区别？ 1)兼容性。Datetime 类型只有 Safire 和 Opera 浏览器兼容；而 Datetime-local 兼容 Chrome 、 Safire 和 Opera。 2) 返回类型不同。local 返回本地时间，而 Date 返回时区。 6、Range 类型 范围，默认范围0—100。 1&lt;input type="range" name="range" min="1" max="10"&gt; 7、search 类型 搜索框。 1&lt;input type="search" name="search"&gt; 8、Color 类型 出现颜色色板。 1&lt;input type="color" name="color"&gt; 二、表单属性（5个）1、autocomplete 属性 当重新加载页面时，输入框重置，是否提示。autocomplete=”on/off” 12345&lt;form action="" autocomplete="on"&gt; &lt;input type="text" name="text"&gt; &lt;input type="email" name="email" autocomplete="off"&gt; &lt;input type="submit"&gt;&lt;/form&gt; 2、aotufocus 属性 页面加载时，自动获取属性。 1&lt;input type="text" name="text" autofocus="autofocus"&gt; 3、multiple 属性 规定输入域可选择多个值。一般应用于上传文件（file）和邮件 （email ）输入框。 4、placeholder 属性 提供一种提示（hint）。 1&lt;input type="text" name="text" placeholder="请输入您的用户名"&gt; PS：适用于以下几个 input 标签：（6个） text，search，url，tel，email，password。 5、require 属性 主要用来进行输入域验证（不能为空），必填字段。 12//填写完整才能进行提交&lt;input type="email" name="email" required="required"&gt; PS：适用于以下几个 input 标签： text，search，url，telephone，email，password，date，pickers，number，checkbox，radio，file。 三、链接属性（3个）1、sizes 根据屏幕不同的分辨率来调整不同的sizes。 1&lt;link rel=&quot;icon&quot; href=&quot;icon.gif&quot; type=&quot;image/gif&quot; size=&quot;16X16&quot;&gt; 2、target base标签写在之间。 12//控制所有的页面的超链接默认选择新窗口。&lt;base href="http://localhost/" target="_blank"&gt; 3、超链接123a：media=&quot;&quot;//表示对设备进行优化，handhelp对手持设备进行支持，tv 对“电视”设备进行支持。a:hreflang=&quot;zh&quot;//设置语言，这里设置的中文a:rel=&quot;external&quot; //这里的超链接为外部链接 三、其他属性（4个）1、script 标签 defer 属性：（只兼容 IE 浏览器）加载完浏览器之后，再加载 js 外部文件夹。 async 属性：（兼容一切浏览器）加载页面的同时也加载外部文件。 2、ol Start —— 起始值：有序列表的起始值。 Reversed —— 有序列表倒序输出。 3、html 定义页面的离线文件。 1&lt;html mainifest=&quot;index.mainifest&quot; 4、*style scoped：内嵌CSS。 12&lt;stylr scoped&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 HTML5 基础篇之【新增标签】]]></title>
    <url>%2F2019%2F03%2F20%2F%E9%87%8D%E5%AD%A6%20HTML5%20%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E3%80%90%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E3%80%91%2F</url>
    <content type="text"><![CDATA[第一节：HTML 5 有哪些新增标签，各有什么作用呢？ HTML5新增标签1、结构标签 块状元素——有意义的div。（10个可根据网页记忆） ■ ：标记一篇文章。 ■ ：标记一个页面的头部或一个区域的头部。 ■ ：标记定义导航链接。 ■ ：标记定义一个区域。 ■ ：标记定义页面内容部分的侧边栏。 ■ ：标记定义文件中的一个区块的相关信息。 ■ ：标记定义一组媒体内容以及它们的标题。 ■ ：标记定义 figure元素的标题。 ■ ：标记定义一个页面或一个区域的底部。 ■ ：标记定义一个对话框类似微信。 2、多媒体标签■ ：标记定义一个视频。 12345//对于不是 mp4 格式的视频，使用 source 来解决&lt;video src=&quot; &quot; autoplay=&quot;autoplay&quot; width=&quot; &quot; height=&quot; &quot;&gt; //需要进行转码 &lt;source src=&quot; &quot; type=&quot;video/mp4&quot; /&gt;&lt;/video &gt; ■ ：标记定义音频内容。 ■ ：标记定义媒体资源。 1&lt;video src=&quot; &quot; autoplay=&quot; &quot; loop=&quot; &quot; controls=&quot; &quot;&gt;您的浏览器不支持！&lt;/video&gt; 12345//对于不是 mp3 格式的音频，使用 source 来解决&lt;audio autoplay=&quot; &quot;&gt; //需要进行转码 &lt;source src=&quot; &quot; type=&quot;audio/mpeg&quot; /&gt;&lt;/audio&gt; ■ ： 画布 ■ ：标记定义外部的可交互的内容或插件，比如 flash。 3、Web 应用标签▉ 状态标签■ ：状态标签（实时状态显示：气压、气温） 浏览器兼容：Chrome、Opera 12&lt;meter value="380" min="20" max="380" low="200" high="240" optimum="220"&gt;&lt;/meter&gt;&lt;meter value="0.75"&gt;75%&lt;/meter&gt; ■ ：状态标签（任务过程：安装、加载） 浏览器兼容：Chrome、Firefox、Opera 12&lt;progress value="30" max="100"&gt; &lt;/progress&gt;&lt;progress max="100"&gt; ▉ 列表标签■ ：为 input 添加下拉列表。 浏览器的兼容性：Firefox、Opera 12345678&lt;input placeholder="请选择您喜欢的手机品牌" list="phoneList"/&gt;&lt;datalist id="phoneList"&gt; &lt;option value="iphone"&gt;&lt;/option&gt; &lt;option value="sumsung"&gt;&lt;/option&gt; &lt;option value="HUawei"&gt;&lt;/option&gt; &lt;option value="HTC"&gt;&lt;/option&gt; &lt;option value="Meizu"&gt;&lt;/option&gt;&lt;/datalist&gt; ■ ：隐藏、显示详细内容。 浏览器兼容 ：Chrome。 1234567891011&lt;details&gt; &lt;summary&gt;问候&lt;/summary&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;&lt;/details&gt; ▉ Menu 标签■ ：工具栏菜单 大部分浏览器不支持。 4、其他标签■ ：标记定义有标记的文本（黄色选中状态） ■ ：标记定义一些输出类型，计算表单结果配合 oninput 事件。 ■ ：标记定义表单里一个生成的键值（加密信息传送） ■ ：标记定义一个日期/时间，目前所有的主流浏览器都不支持 删除的标签一、纯表现的元素 html：结构层；CSS：表现层； Basefont、Big、Center、font、s、strike、tt、u 二、对可用性产生负面影响的元素 框架级元素。 1、frameset 会去掉 body ，破坏 html 的结构。 frame、frameset、noframes 三、产生混淆的元素 acronym、applet、isindex、dir 重定义标签■ :代表内联文本，通常是粗体，没有传递表示重要的意思 ■ ：代表内联文本，通常是斜体，没有传递表示重要的意思 ■ ：描述，可以同 details 与 figure 一同使用，定义包含文本，dialog 也可用 ■ ：标题，可以同 details 与 figure 一同使用，汇总细节，dialog 也可用 ■ ：表示主题结束，而不是水平线，虽然显示相同 ■ ：表示小字体，例如打印注释或者法律条款 ■ ：表示重要性而不是强调符号]]></content>
      <categories>
        <category>前端</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 HTML5 基础篇之【新增标签】]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%89%8D%E7%AB%AF%20HTML5%20%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E3%80%90%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE%E3%80%91%2F</url>
    <content type="text"><![CDATA[第一节：HTML 5 有哪些新增标签，各有什么作用呢？ HTML5一、新增标签1、结构标签(10个) 块状元素——有意义的div。（10个可根据网页记忆） ■ article：标记一篇文章。 ■ header ：标记一个页面的头部或一个区域的头部。 ■ nav：标记定义导航链接。 ■ section：标记定义一个区域。 ■ aside：标记定义页面内容部分的侧边栏。 ■ hgroup：标记定义文件中的一个区块的相关信息。 ■ figure：标记定义一组媒体内容以及它们的标题。 ■ figcaption：标记定义 figure元素的标题。 ■ footer：标记定义一个页面或一个区域的底部。 ■ dialog：标记定义一个对话框类似微信。 2、多媒体标签（5个）■ &lt;video src=&quot; &quot; autoplay=&quot; &quot; loop=&quot; &quot; controls=&quot; &quot;&gt; ：标记定义一个视频。 12345//对于不是 mp4 格式的视频，使用 source 来解决&lt;video src=" " autoplay="autoplay" width=" " height=" "&gt; //需要进行转码 &lt;source src=" " type="video/mp4" /&gt;&lt;/video &gt; ■ &lt;audio&gt;：标记定义音频内容。 ■ &lt;source&gt;：标记定义媒体资源。 1&lt;video src=&quot; &quot; autoplay=&quot; &quot; loop=&quot; &quot; controls=&quot; &quot;&gt;您的浏览器不支持！&lt;/video&gt; 12345//对于不是 mp3 格式的音频，使用 source 来解决&lt;audio autoplay=&quot; &quot;&gt; //需要进行转码 &lt;source src=&quot; &quot; type=&quot;audio/mpeg&quot; /&gt;&lt;/audio&gt; ■ &lt;canvas&gt;： 画布。 ■ &lt;embed&gt;：标记定义外部的可交互的内容或插件，比如 flash。 3、Web 应用标签（5个)▉ 状态标签■ &lt;meter&gt;：状态标签（实时状态显示：气压、气温） 浏览器兼容：Chrome、Opera。 12&lt;meter value="380" min="20" max="380" low="200" high="240" optimum="220"&gt;&lt;/meter&gt;&lt;meter value="0.75"&gt;75%&lt;/meter&gt; ■ &lt;progress&gt;：状态标签（任务过程：安装、加载) 浏览器兼容：Chrome、Firefox、Opera 12&lt;progress value="30" max="100"&gt; &lt;/progress&gt;&lt;progress max="100"&gt; ▉ 列表标签■ &lt;datalist&gt;：为 input 添加下拉列表。 浏览器的兼容性：Firefox、Opera。 12345678&lt;input placeholder="请选择您喜欢的手机品牌" list="phoneList"/&gt;&lt;datalist id="phoneList"&gt; &lt;option value="iphone"&gt;&lt;/option&gt; &lt;option value="sumsung"&gt;&lt;/option&gt; &lt;option value="HUawei"&gt;&lt;/option&gt; &lt;option value="HTC"&gt;&lt;/option&gt; &lt;option value="Meizu"&gt;&lt;/option&gt;&lt;/datalist&gt; ■ &lt;details&gt;：隐藏、显示详细内容。 浏览器兼容 ：Chrome。 1234567891011&lt;details&gt; &lt;summary&gt;问候&lt;/summary&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt; &lt;p&gt;你好你好，你好，你好，你好&lt;/p&gt;&lt;/details&gt; ▉ Menu 标签■ &lt;menu&gt;：工具栏菜单 大部分浏览器不支持。 4、其他标签■ &lt;mark&gt;：标记定义有标记的文本（黄色选中状态）。 ■ &lt;output&gt;：标记定义一些输出类型，计算表单结果配合 oninput 事件。 ■ &lt;keygen&gt;：标记定义表单里一个生成的键值（加密信息传送）。 ■ &lt;time&gt;：标记定义一个日期/时间，目前所有的主流浏览器都不支持。 二、删除的标签1、纯表现的元素 html：结构层；CSS：表现层； Basefont、Big、Center、font、s、strike、tt、u。 2、对可用性产生负面影响的元素 框架级元素。 1、frameset 会去掉 body ，破坏 html 的结构。 frame、frameset、noframes 3、产生混淆的元素 acronym、applet、isindex、dir。 三、重定义标签■ &lt;b&gt; :代表内联文本，通常是粗体，没有传递表示重要的意思。 ■ &lt;i&gt;：代表内联文本，通常是斜体，没有传递表示重要的意思。 ■ &lt;dd&gt;：描述，可以同 details 与 figure 一同使用，定义包含文本，dialog 也可用。 ■ &lt;dt&gt;：标题，可以同 details 与 figure 一同使用，汇总细节，dialog 也可用。 ■ &lt;hr&gt;：表示主题结束，而不是水平线，虽然显示相同。 ■ &lt;small&gt;：表示小字体，例如打印注释或者法律条款。 ■ &lt;strong&gt;：表示重要性而不是强调符号。]]></content>
      <categories>
        <category>前端</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【数字操作】]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%20%E3%80%90%E6%95%B0%E5%AD%97%E6%93%8D%E4%BD%9C%E3%80%91%2F</url>
    <content type="text"><![CDATA[如果你对数字操作的不好，就很难写出令人惊奇的程序 。 一、进制声明1、二进制声明 二进制的英文单词是Binary，二进制的开始是0（零），然后第二个位置是b ，然后跟上二进制的值就可以了 1let binary = 0b010101;//21 2、八进制声明 八进制的英文单词是Octal，也是以0（零）开始的，然后第二个位置是O（欧），然后跟上八进制的值就可以了。 1let b=0o666;//438 二、数字判断和转换1、数字验证 Number.isFinite( xx ) 只要是数字，不论是浮点型还是整形都会返回true，其他时候会返回false。 123let a= 11/4;console.log(Number.isFinite(a));//trueconsole.log(Number.isFinite('xiaolu'));//false 2、NaN验证 NaN是特殊的非数字，可以使用Number.isNaN()来进行验证。下边的代码控制台返回了true。 1console.log(Number.isNaN(NaN)); 3、判断是否为整数Number.isInteger(xx)12let a=123.1;console.log(Number.isInteger(a)); //false 4、整数转换Number.parseInt(xxx)和浮点型转换Number.parseFloat(xxx)123let s = 12.34console.log(Number.parseInt(s))console.log(Number.parseFloat(s)) 5、整数取值范围操作 整数的操作是有一个取值范围的，它的取值范围就是2的53次方。 12let a = Math.pow(2,53)-1;console.log(a); //9007199254740991 6、最大安全整数 计算时会经常超出这个值，所以我们要进行判断，ES6提供了一个常数，叫做最大安全整数 1consolec .log(Number.MAX_SAFE_INTEGER); 7、最小安全整数1console.log(Number.MIN_SAFE_INTEGER); 8、安全整数判断isSafeInteger( )12let a= Math.pow(2,53)-1;console.log(Number.isSafeInteger(a));//false 9、]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【字符串模板】]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF%E3%80%91%2F</url>
    <content type="text"><![CDATA[前后端分离经常用到拼接。 字符串拼接1、简单拼接 使用 ${} 进行拼接。 1234// 注意使用的 ` 符号let lu = 'xiaolu';let blog = `$&#123;lu&#125; 你好&lt;br&gt;呀`; //在里边可以加标签document.write(blog) 2、对运算符的支持1234let a = 1;let b = 2;let c = `$&#123;a+b&#125;`document.write(c) 3、字符串查找▉ 查找是否存在123let xiaolu='小鹿';let blog = '大家好，我是小鹿。';document.write(blog.includes(xiaolu))//返回true ▉ 判断开头是否存在1blog.startsWith(xiaolu); ▉ 判断开头是否存在1blog.endsWith(xiaolu); ▉ 复制字符串1document.write(&apos;xiaolu|&apos;.repeat(3));]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【扩展运算符和rest运算符】]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8Crest%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[两者都是（…）三个点，更好的为我们解决参数和对象数组未知情况下的编程，代码更健壮 。 一、扩展运算符 可以传入多个值，并且就算方法中引用多了也不会报错。 123456789//扩展运算符const xiaolu = (...arg) =&gt;&#123; console.log(arg[0]); console.log(arg[1]); console.log(arg[2]); console.log(arg[3]);&#125;//调用xiaolu(1,2,3)//1,2,3,undefined ▉ 扩展运算符的应用 数组的赋值只改变了对内存堆栈的引用，而不是真正的赋值。 1234567891011//扩展运算符的应用let arr = ['xiaolu','haha','nihao']let arr2 = arr;arr.push('lala');console.log(arr2)//改进let arr = ['xiaolu','haha','nihao']let arr2 = [...arr]//真正的进行赋值arr.push('lala')console.log(arr)console.log(arr2) 二、rest 运算符 最基本用法。 123456//rest 运算符const xiaolu = (fist,...arg) =&gt;&#123; console.log(arg.length)&#125;//first 代表 1 参数xiaolu(1,2,3,4,5,6,7)//打印 7 ，说明 age 里边有 7 个参数 ▉ for…of 打印 arg 的值123456const xiaolu = (fist,...arg) =&gt;&#123; for(let a of arg)&#123; console.log(a) &#125;&#125;xiaolu(1,2,3,4,5,6,7)//打印 2,3,4,5,6,7]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【解构赋值】]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E3%80%91%2F</url>
    <content type="text"><![CDATA[解构赋值在实际开发中可以大量减少我们的代码量，并且让我们的程序结构更清晰，主要应用于解析 JSON 。 变量的解构赋值 应用：一般应用于解构 JSON 数据，非常方面快捷。 1、数组的结构▉ 简单数组结构1234567//一般形式let a=0;let b=1;let c=2;//解构形式letl [a,b,c]=[1,2,3]; ▉ 数组和赋值模式统一 等号左右要统一，否则可能获得 undefined。 1let [a,[b,c],d] = [1,[2,3],4]; ▉ 解构的默认值 需要注意 undefined 和 null 的区别。undefined 代表什么都没有，null代表有值。 12let [foo = true] = [];console.log(foo); //控制台打印出true 2、对象的解构 与数组解构的不同点：数组的元素是按次序排列的 ，而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 1let &#123;foo,bar&#125; = &#123;foo:'xiaolu',bar:'小鹿'&#125;; ▉ 圆括号的使用1234567//如果之前已经解构，现在就会报错let foo;&#123;foo&#125; =&#123;foo:'xiaolu'&#125;;//需要加圆括号let foo;(&#123;foo&#125;=&#123;foo:'xiaolu'&#125;); 3、字符串解构 字符串被转换成了一个类似数组的对象 。 1const [a,b,c,d,e,f]="JSPang";]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零学习 React 之【环境搭建】]]></title>
    <url>%2F2019%2F03%2F18%2F%E4%BB%8E%E9%9B%B6%E5%AD%A6%E4%B9%A0%20React%20%E4%B9%8B%E3%80%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[第一小节：从零学习 react 环境搭建！ React 环境搭建1、初始化项目 初始化项目，生成 package.json 文件 1npm init -y 2、安装 webpack 和 webpack-cli 安装 webpack。 12npm install --save-dev webpacknpm install --save-dev webpack-cli 3、配置 webpack.config.js 根目录新建 webpack.config.js 配置文件，配置出入口文件： 12345678910var path =require(&apos;path&apos;);module.exports = &#123; //入口文件 entry:&apos;./app/index.js&apos;, //出口文件 output:&#123; filename:&apos;index.js&apos;, path:path.resolve(__dirname,&apos;dist&apos;) &#125;&#125; 在package.json的script中加入&quot;build&quot;: &quot;webpack&quot;命令配置。 1234567891011121314151617&#123; &quot;name&quot;: &quot;react-demo-webpack&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.29.6&quot;, &quot;webpack-dev-server&quot;: &quot;^3.2.1&quot; &#125;&#125; 4、测试 webpack 配置 在终端输入命令进行打包测试 dist 文件夹中出现打包文件。 1npm run build 5、开发服务器配置 实现开发环境下的代码与浏览器热更新。 1npm install --save-dev webpack-dev-server 配置在 webpack.config.js文件中配置服务器 123456devServer:&#123; contentBase:&apos;./&apos;, host:&apos;localhost&apos;, compress:true, port:1717&#125; 在 package.json 中加入启动服务器命令。 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;server&quot;: &quot;webpack-dev-server --open&quot; &#125;, 6、自动刷新浏览器 上方配置并不能自动刷新浏览器，我们稍微进行配置。 在 package.json 文件中加入 publicPath:&#39;temp/&#39; 12345output:&#123; filename:&apos;index.js&apos;, path:path.resolve(__dirname,&apos;dist&apos;), publicPath:&apos;temp/&apos;&#125;, index.html文件引入JS 1&lt;script src=&quot;./temp/index.js&quot;&gt;&lt;/script&gt; 7、Babel安装配置 在webpack中配置Babel需要先加入babel-loader ,需要支持es2015和React ,共安装四个包。 1npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react 在 package.js 文件中查看包的版本信息。 12345678&quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.26.0&quot;, &quot;babel-loader&quot;: &quot;^7.1.2&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;, &quot;webpack&quot;: &quot;^3.8.1&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.3&quot;&#125; 8、配置module 在 webpack.config.js 配置 loader 。 12345678910loaders:[ &#123; test:/\.js$/, exclude:/node_modules/, loaders:&quot;babel-loader&quot;, query:&#123; presets:[&apos;es2015&apos;,&apos;react&apos;] &#125; &#125; ] 9、安装 React 和 React-dom1npm install --save react react-dom]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器如何工作的之【基础篇】]]></title>
    <url>%2F2019%2F03%2F18%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B9%8B%E3%80%90%E5%9F%BA%E7%A1%80%E7%AF%87%E3%80%91%2F</url>
    <content type="text"><![CDATA[浏览器是如何工作的(一)目录[TOC] 浏览器工作总流程 1、浏览器使用 HTTP 协议或者 HTTPS 协议，向服务器发送请求。 2、把请求回来的 HTML 代码经过解析，构成 DOM 树； 3、最后根据 CSS 属性对元素进行逐个渲染，得到内存中的位图。 4、一个可选的步骤是对位图进行合成，极大地增加后续绘制的速度； 5、合成之后，再绘制到界面上。 第一阶段：浏览器请求 浏览器使用 HTTP 协议或者 HTTPS 协议，向服务器发送请求。 第二阶段：文档解析 第一阶段请求服务器后，服务器通过字符流的方式返回数据，浏览器进行一系列的解析。会被浏览器流式的处理从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上。CSS属性也会同步计算。这一过程拿到元素会一次匹配规则，根据规则的优先级进行覆盖和调整， 一、DOM 解析 DOM 解析三种文件，分别是 HTML/SVG/XHTML，通过解析然后构建 DOM 树。 1、第一步：状态机将字符解析成词 字符流通过状态机(大部分语言的词法通过状态机实现的)对各类标签和属性进行解析成词（token）。 2、第二步：用栈来构建 DOM 树 利用数据结构中的栈来实现 DOM 树的构建。栈顶的最后为根元素，DOM 树的第一项就是 stack[0]； 123456789101112&lt;html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Web page parsing&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h1&gt;Web page parsing&lt;/h1&gt; &lt;p&gt;This is an example Web page.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 二、CSS 解析（以 Firefox 为主，webkit 直接用一棵树完成） 首先根据 CSS 文档建立 CSS 规则树（CSS Rule Tree），CSS 规则树是比照 DOM 树来进行构建的,然后通过这两棵树合成渲染树（Render Tree），就是把 CSS Rule 结点 Attach 到DOM Tree上 。 1、第三步：根据 CSS 文档建立 CSS 规则树。1234/* rule 1 */ doc &#123; display: block; text-indent: 1em; &#125;/* rule 2 */ title &#123; display: block; font-size: 3em; &#125;/* rule 3 */ para &#123; display: block; &#125;/* rule 4 */ [class="emph"] &#123; font-style: italic; &#125; 2、第四步：挂载 css 规则树。 把 CSS Rule 结点 Attach 到 DOM Tree上合成渲染树（Render Tree） 。 第三阶段：渲染 渲染之前先进行排版（确定每个元素的位置），然后根据 css 属性对元素进行渲染，得到内存中的位图。 1、第一步：排版。 浏览器最基本的排版是正常流排版，包括顺次排版和折行排版，用于确定每个元素的位置。 2、第二步：渲染 把模型变成位图(内存中的一张二维表格，把一张图片每个像素的颜色值保存进去 )的过程。渲染主要涉及到两种操作，分别为 Repaint 和 Reflow 。 Repaint（部分重绘）：屏幕的一部分要重画，比如某个 CSS 的背景色变了。但是元素的几何尺寸没有变。 Reflow（全部重绘）：意味着元件的几何尺寸变了，需要重新验证并计算 Render Tree。是 Render Tree 的一部分或全部发生了变化。这就是 Reflow，或是 Layout。 第四阶段：合成 渲染过程不会把子元素渲染到位图上面，合成的过程，就是为元素创建一个 “合成后的位图”，也称为合成层。 第五阶段：绘制 绘制就是把位图按照 z-index 绘制到屏幕上，变成页面上的图像的过程。 重绘的频率过快，性能会下降，应该部分区域 重绘。 脏矩形算法：就是把屏幕均匀的分为若干个矩形区域。 重绘部分的矩形区域就可以。]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小学生都能学会的 Git 之【本地仓库】]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%B0%8F%E5%AD%A6%E7%94%9F%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%20Git%20%E4%B9%8B%E3%80%90%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[git 怎么搭建本地仓库？ 一、Git 简介二、安装 Git三、配置用户信息1. 命令来配置用户名和邮箱 有 –global 「所有项目」默认使用此信息。 无 –global 「特定项目」下的配置信息。 1234//配置用户名git config --global user.name &quot;xiaolu&quot; //配置邮件git config --global user.email xiaolu@example.com 图示： 2、检查是否配置成功123456//单独检查用户名git config user.name//单独检查邮件地址git config user.email//查看 git 的全部配置信息git config --list 图示： 四、创建 git 项目 在本地创建一个文件夹（xiaolu），进入该文件夹，然后初始化该文件夹（仓库）,创建之后就会出现一个隐藏文件 .git ，该文件会记录所有有关 git 操作提交记录和你所进行的 git 全部操作。 图示： 注意： 如果没有发现 .git 隐藏文件，因为我们文件夹设置不显示隐藏文件了，通过在查看的隐藏文件夹中勾选选择显示隐藏文件。 图示： 五、工作区、版本库和暂存区 工作区：工作区就是一个文件夹，比如刚刚创建的有 .git 文件夹的命名为 xiaolu 文件夹。 版本库：工作区有一个 .git 隐藏文件，我们叫做 Git 的版本库，工作区有一个称为 stage 的暂存区。 暂存区：暂存区就是临时的仓库，存放即将提交的临时文件。 六、提交代码 我们在文件夹中创建一个命名为 xiaolu.txt 的文件（手动创建或命令创建），我们将本地文件夹（仓库）的 xiaolu.txt文件提交到 Github 远程仓库中去，将经历以下过程。 1、创建文件夹1234//命令创建 xiaolu.txt 文件touch xiaolu.txt//命令查看在 xiaolu 文件中是否存 xiaolu.txt 文件ls 命令图示： 可视图示： 2、提交过程 将本地代码先提交至版本库，等待提交至远程仓库。 12345678//1、先将工作区的文件添加到暂存区等待被提交git add xiaolu.txt//2、查看缓存区是否存在 xiaolu.txt 文件git status//3、将暂存区文件提交至版本库 master 分支（-m 后是提交备注信息）git commit -m &apos;第一次提交，提交内容为 xiaolu.txt 文件&apos;//4、显示最近一次提交记录git show 提交图示： 提交过程图示： 3、删除文件 删除已经提交至版本库中的文件。新建命名为 file.txt 的文件，提交至版本库，然后进行在版本库中的删除。 创建 file.txt 提交至版本库： 删除工作区file文件同时删除版本库file文件： 123456//1、删除工作区文件git rm file.txt//2、查看要删除文件状态git status//3、提交删除版本库中的 file 文件git commit -m &apos;删除file文件&apos; 查看本地所有提交记录： 12//4、查看本地所有 git 提交记录git log 3、拉取版本库代码]]></content>
      <categories>
        <category>Git版本控制</category>
      </categories>
      <tags>
        <tag>Git版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack成神之路之插件配置【HTML发布】]]></title>
    <url>%2F2019%2F03%2F11%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90HTML%E5%8F%91%E5%B8%83%E3%80%91%2F</url>
    <content type="text"><![CDATA[打包发布 HTML 文件！ 一、开发环境和生产环境 注意：两者设置冲突会报错！在实际开发中，webpack配置文件是分开的，开发环境一个文件，生产环境一个文件 开发环境：开发环境中是基本不会对js进行压缩的，在开发预览时需要明确的报错行数和错误信息，所以完全没有必要压缩JavasScript代码。热更新的插件 devServer用于开发环境 。 生产环境：生产环境中才会压缩JS代码，用于加快程序的工作效率。 二、打包 HTML 文件1、安装打包插件1npm install --save-dev html-webpack-plugin 2、webpack.config.js文件引入html-webpack-plugin插件。1const htmlPlugin= require(&apos;html-webpack-plugin&apos;); 3、webpack.config.js里的plugins里进行插件配置1234567new htmlPlugin(&#123; minify:&#123; removeAttributeQuotes:true &#125;, hash:true, template:&apos;./src/index.html&apos; &#125;) minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。 hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。 template： 是要打包的html模版路径和文件名称。 4、webpack 进行打包 HTML 文件里引用的 js 路径可以去掉，打包之后它会自动加上。]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack成神之路之插件配置【js压缩】]]></title>
    <url>%2F2019%2F03%2F11%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E3%80%90js%E5%8E%8B%E7%BC%A9%E3%80%91%2F</url>
    <content type="text"><![CDATA[使用插件对 JS 进行压缩！ 一、webpack 插件压缩 js 在 webpack 已经集成，但是有的还是需要手动安装。 1、安装 uglifyjs-webpack-glugin1npm install uglifyjs-webpack-plugin --save-dev 2、导入插件 在webpack.config.js中引入uglifyjs-webpack-glugin插件 1const uglify = require(&apos;uglifyjs-webpack-plugin&apos;); 3、配置插件 plugins配置里new一个 uglify对象 。 123plugins:[ new uglify() ], 4、进行压缩 webpack 进行压缩，你会发现文件的大小前后的变化，文件变小了。]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack成神之路之模块【css文件打包】]]></title>
    <url>%2F2019%2F03%2F11%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E6%A8%A1%E5%9D%97%E3%80%90css%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E3%80%91%2F</url>
    <content type="text"><![CDATA[将 CSS 文件进行打包！ 一、Loaders Loaders是Webpack最重要的功能之一， Loader 对不同的文件进行处理。 可以把SASS文件的写法转换成CSS，而不在使用其他转换工具。 可以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码。 可以把React中的JSX转换成JavaScript代码。 1、安装 Loader Loader 有两个解析的 Loader 分别为 style-loader 和 css-loader。 12345//安装style-loadernpm install style-loader --save-dev//安装css-loadernpm install --save-dev css-loader 2、配置 Loader 在 webpack.config.js 进行配置。 1234567891011//直接用usemodule:&#123; rules: [ &#123; //用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的； test: /\.css$/, //loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错； use: [ 'style-loader', 'css-loader' ] &#125; ]&#125;, 123456789//把use换成loader。module:&#123; rules:[ &#123; test:/\.css$/, loader:[&apos;style-loader&apos;,&apos;css-loader&apos;] &#125; ] &#125;, 123456789101112131415//用use+loader的写法：module:&#123; rules:[ &#123; test:/\.css$/, use: [ &#123; loader: &quot;style-loader&quot; &#125;, &#123; loader: &quot;css-loader&quot; &#125; ] &#125; ] &#125;, test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的； use： loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错； include/exclude: 手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选）。 3、打包 CSS 在 js 文件中引入 css 文件。 1import css from &apos;./src/index.css&apos;; 12//命令进行打包webpack]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【Trie 树】]]></title>
    <url>%2F2019%2F03%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90Trie%E6%A0%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[如何实现搜索引擎的搜索关键词的提示功能？ 一、什么是 Trie 树？ Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。 1、Trie 树的本质 Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。 2、Trie 树的构造 根节点不存储数据，通过树中根节点进行匹配，可以做到完全匹配和前缀匹配。 二、如何实现一颗 Trie 树？1、如何存储 Trie 树 借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针。通过数组来存储指向子节点的指针，如果存储的结点不存在我们就存储下标为 null。 1234class TrieNode &#123; char data; TrieNode children[26];&#125; 2、查找字符串过程 当在 Trie 树中查找字符串的时候，就可以通过字符的 ASCII 码减去“a”的 ASCII 码，迅速找到匹配的子节点的指针。比如，d 的 ASCII 码减去 a 的 ASCII 码就是 3，那子节点 d 的指针就存储在数组中下标为 3 的位置中。 3、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.xiaolu.Trie;/** * 功能:字典树(Trie 树) * @author 小鹿 * */public class Trie &#123; //Trie 树的结点 public class TrieNode &#123; //数据域: 存放的字符数据 public char data; // 结点中存放的数组 public TrieNode[] children = new TrieNode[26]; //记录字符是否已经存放完毕 public boolean isEndingChar = false; //构造函数(初始化) public TrieNode(char data) &#123; this.data = data; &#125; &#125; // 存储无意义字符(根节点为'/') private TrieNode root = new TrieNode('/'); /** * 往 Trie 树中插入一个字符串 * @param text 要插入的字符串 */ public void insert(char[] text) &#123; // p 结点存储为空 TrieNode p = root; //循环遍历字符串中的每个字符 for (int i = 0; i &lt; text.length; ++i) &#123; //计算每个字符所在数组的下标 int index = text[i] - 'a'; //判断该下标的数据是否已存字符 if (p.children[index] == null) &#123; //如果没有存放，我们就将该字符存入结点 TrieNode newNode = new TrieNode(text[i]); //存放该结点 p.children[index] = newNode; &#125; //将指针移动到该数组中的 TrieNode 结点 p = p.children[index]; &#125; //所有字符存放完毕之后，将值置为 true p.isEndingChar = true; &#125; /** * 在 Trie 树中查找一个字符串 * @param pattern 要查找的字符串 * @return */ public boolean find(char[] pattern) &#123; //定义根节点'/' TrieNode p = root; //遍历要查找的字符 for (int i = 0; i &lt; pattern.length; ++i) &#123; //计算字符串中的第一个字符在数组中的下标 int index = pattern[i] - 'a'; //判断是否存在该字符 if (p.children[index] == null) &#123; // 不存在 pattern return false; &#125;else &#123; //如果存在，将指针移动到该字符存储的数值中 p = p.children[index]; &#125; &#125; //判断匹配的该字符是否已经完全匹配 if (p.isEndingChar == false) &#123; return false; // 不能完全匹配，只是前缀 &#125; else &#123; return true; // 找到 pattern &#125; &#125; &#125; 4、时间复杂度 1）构建 Trie 树需要扫描所有的字符，时间复杂度为 O(n)。 2）查询的时候，如果查询的字符串的长度是 K ，那我们要对比 K 个节点，查找字符串的时间复杂度为 O(k)。 三、Trie 数的性能分析 Trie 不但是一种高效的字符串匹配方法，也是非常消耗内存的一种方法，用的是时间换空间的思路。 1、为什么消耗内存 即便是少量的字符串，我们还要维护很长的数组。 2、怎么做优化呢？ 为了解决上边的内存问题，要消耗点查询效率，将数组换成其他的数据结构，有序数组、散列表、红黑树、跳表。 3、有序数组做优化 假设我们用有序数组，数组中的指针按照所指向的子节点中的字符的大小顺序排列。查询的时候，可以通过二分查找的方法，快速查找到某个字符应该匹配的子节点的指针。但是，在往 Trie 树中插入一个字符串的时候，为了维护数组中数据的有序性，就会稍微慢了点。 4、缩点优化 将连续重复的字符进行放到一个节点中。 五、Trie为什么不适合做字符串查找？ 1）字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。 2）要求字符串的前缀重合比较多。不然空间消耗会变大很多 3）如果要用 Trie 树解决问题，那就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。 4）通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。 5) 更倾向于用散列表或者红黑树。因为这两种数据结构，我们都不需要自己去实现，直接利用编程语言中提供的现成类库就行了。 六、Trie 树适用条件 Trie 比较适合的是查找前缀匹配的字符串。 七、Trie 的应用 自动输入补全。比如：输入法自动补全功能、IDE 代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等。 八、本节思考：如何利用 Trie 树实现搜索关键词的提示功能？1、问题 对于更加复杂的中文来说，词库中的数据又该如何构建成 Trie 树呢？ 如果词库中有很多关键词，在搜索提示的时候，用户输入关键词，作为前缀在 Trie 树中可以匹配的关键词也有很多，如何选择展示哪些内容呢？ 像 Google 这样的搜索引擎，用户单词拼写错误的情况下，Google 还是可以使用正确的拼写来做关键词提示，这个又是怎么做到的呢？ 九、扩展思考1、问题 现在给你一个很大的字符串集合，比如包含 1 万条记录，如何通过编程量化分析这组字符串集合是否比较适合用 Trie 树解决呢？也就是如何统计字符串的字符集大小，以及前缀重合的程度呢？]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F10%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%90%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%83%AD%E6%9B%B4%E6%96%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Webpack 成神之路【配置文件】]]></title>
    <url>%2F2019%2F03%2F10%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%90%E5%A4%9A%E5%85%A5%E5%8F%A3%E5%A4%9A%E5%87%BA%E5%8F%A3%E3%80%91%2F</url>
    <content type="text"><![CDATA[webpack 配置文件实现多入口多出口！ 一、新建webpack.config.js文件 在根目录新建 webpack.config.js 配置文件,属性如下： 123456789101112module.exports=&#123; //入口文件的配置项 entry:&#123;&#125;, //出口文件的配置项 output:&#123;&#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125; 二、配置属性信息 添加入口文件和出口文件进行打包。 123456//双入口配置文件entry:&#123; entry:'./src/entry.js', //另一个入口文件 entry2:'./src/entry2.js'&#125;, 出口文件。 123456789//全局const path = require(&apos;path&apos;);//局部 output:&#123; //打包的路径文职，绝对路径 path:path.resolve(__dirname,&apos;dist&apos;), //打包文件名 filename:&apos;[name].js&apos; &#125;, 其中 path.resolve(__dirname,&#39;dist&#39;)获取根目录，然后定位到 dist 目录路径。 三、命令打包 控制台输入 Webpack命令进行打包。 四、全部代码123456789101112131415161718192021222324//node 知识const path = require('path');// 配置文件module.exports=&#123; //入口文件的配置项 entry:&#123; entry:'./src/entry.js', //另一个入口文件 entry2:'./src/entry2.js' &#125;, //出口文件的配置项 output:&#123; //打包的路径文职，绝对路径 path:path.resolve(__dirname,'dist'), //打包文件名(name)表示对应的入口文件名 filename:'[name].js' &#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125;]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 2016 入门【函数的扩展】]]></title>
    <url>%2F2019%2F03%2F10%2FECMAScript%202016%20%E5%85%A5%E9%97%A8%E3%80%90%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[ES 6中对函数的扩展。 一、箭头函数1、基本用法▉格式一：最基本的格式123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; ▉格式二：多个参数，圆括号表示123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; ▉格式三：代码块多余一条，大括号括起来，用 return 返回1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; ▉格式四：返回对象加圆括号1let getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;); ▉格式五：只有一行语句 ，不需要返回值1let fn = () =&gt; void doesNotReturn(); ▉格式六：与变量结构结合使用123456const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之JavaScript执行(三)]]></title>
    <url>%2F2019%2F03%2F09%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BJavaScript%E6%89%A7%E8%A1%8C(%E4%B8%89)10%2F</url>
    <content type="text"><![CDATA[你知道现在有多少种函数吗？ 一、函数1、普通函数 用 function 关键字定义的函数。 123function foo()&#123; // code&#125; 2、箭头函数 用 =&gt;运算符定义的函数。 12345class C &#123; foo()&#123; //code &#125;&#125; 3、方法 在 Class 中定义的函数。 12345class C &#123; foo()&#123; //code &#125;&#125; 4、生成器函数 用 function * 定义的函数。 123function foo*()&#123; // code&#125; 5、类 用 Class 定义的类，实际上也是函数。 12345class Foo &#123; constructor()&#123; //code &#125;&#125; 6、异步函数 普通函数、箭头函数和生成器函数加上 async 关键字。 123456789async function foo()&#123; // code&#125;const foo = async () =&gt; &#123; // code&#125;async function foo*()&#123; // code&#125; 二、this 关键字的行为 this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同。]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack 成神之路【搭建 Demo】]]></title>
    <url>%2F2019%2F03%2F08%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E3%80%90%E6%90%AD%E5%BB%BADemo%E3%80%91%2F</url>
    <content type="text"><![CDATA[Webpack 实现项目打包！ 一、项目基本目录 在根目录下建立两个文件夹，分别是 src 文件夹和 dist 文件夹。 src：用来存放我们编写的javascript代码，可以简单的理解为用JavaScript编写的模块。 dist ：用来存放供浏览器读取的文件，这个是webpack打包成的文件。 二、添加文件 1、在 dist 中我们建立 index.html 的文件并引入 bubdle.js 文件（bubdle.js 是打包后的文件，在这先进行引入）。 2、在 src 下建立源文件 js，也就是我们所说的入口文件 entery.js ，用来编写 js 代码。 三、打包 webpack 4.0+ 在终端使用命令进行打包，命令格式如下： 1webpack [entry file] --output [destination for bundled file] --mode development [entry file] : 入口文件的路径，也就是 js 源文件的路径。 [destination for bundled file] ： 打包后存放的路径。 四、打包完成 运行完上方命令之后，在 dist 打包后的文件夹中出现 bundle.js 打包文件，我们就可以在浏览器中进行预览了。]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack成神之路【环境搭建】]]></title>
    <url>%2F2019%2F03%2F08%2FWebpack%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E3%80%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[一文教你搭建 Webpack 在 VS code 中的环境搭建！ 一、为什么需要webpack? JS 的复杂性和需要很多依赖包，CSS,Less…新增样式的扩展写法的编译工作，所以我们不得不借助Webpack工具来做辅助。 二、什么是Webpack? WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。3.0 版本出现了优化的作用。 打包： 可以把多个Javascript文件打包成一个文件，减少服务器压力和下载带宽。(模块 —&gt; 静态优化) 转换： 把拓展语言转换成为普通的JavaScript，让浏览器顺利运行。 优化：前端变的越来越复杂后，性能也会遇到问题，而WebPack也开始肩负起了优化和提升性能的责任。 三、安装 Webpack1、前提 安装 Node.js ，用 npm 来进行安装，进入项目的根目录。 2、初始化项目12//初始化项目npm init 3、安装 webpack,并一路回车 主要目的就是生成 package.json文件(当前项目的依赖模块，自定义的脚本任务等 ) ,自行扩展到 Node相关知识。 1）初始化目录12//初始化目录$ npm init npm终端会问你关于项目的名称，描述等，如果你不考虑发布到npm上，这些内容都不重要， 直接回车初始化，根目录会生成 package.json 文件。 2）安装webpack --save-dev为本地安装。 1$ npm install webpack --save-dev 3）检测版本 如果报错，请检查版本是否错误，或者全局已经安装，本地安装就会报错（需要删除全局安装，然后进行本地安装）。 1webpack -v]]></content>
      <categories>
        <category>前端工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之JavaScript执行(二)]]></title>
    <url>%2F2019%2F03%2F06%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BJavaScript%E6%89%A7%E8%A1%8C(%E4%BA%8C)9%2F</url>
    <content type="text"><![CDATA[闭包和执行上下文到底怎么回事？ 本节目录 闭包； 作用域链； 执行上下文； this 值； 一、闭包1、什么是闭包？ 闭包是一个绑定了执行环境的函数，与普通函数的区别就是它携带了执行的环境。 2、闭包的组成？ 环境部分 环境：函数的词法环境（执行上下文的一部分） 标识符列表：函数中用到的未声明的变量 表达式部分：函数体 二、执行上下文：执行的基础设施 执行上下文：JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。 1、var 声明与赋值 var 声明作用域是函数执行的作用域，也就是说 var 会穿透 for、if等语句。 ■ 将函数变为函数表达式12345678910//注意：加上分号，否则自动执行;(function()&#123; var a; //code&#125;());(function()&#123; var a; //code&#125;)(); 推荐写法： 12345//加 void 关键字void function()&#123; var a; //code&#125;(); 2、let ES6 引入的新特性，为了实现 let ，js 引入了会计作用域。 以下语句会产生 let 使用作用域： for if switch try/catch/finally 3、Realm 在标准（9.0）中引入新概念 Realm “范围”。]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩转 ES6 之【环境搭建】]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%8E%A9%E8%BD%AC%20ES6%20%E4%B9%8B%E3%80%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[VSCode ES6 Babel 环境搭建。 一、ES6 环境搭建 目前 Chrome 浏览器已经支持 ES6 了，但是很多低版本的浏览器不支持 ES6 语法，所以需要将 ES6 转换成 ES5 来进行打包执行，除了 Webpack 支持自动编译转换的能力，Babel 也可以完成，下边用 Babel 来搭建 ES6 环境。 1、初始化项目 安装 Babel 之前，需要初始化项目，打开终端或者 cmd 进入项目目录下，输入以下命令，项目根目录会出现 package.json 配置文件，可进行修改。 12// -y 默认全部同意npm init -y 2、全局安装 Babel-cli 在终端输入安装命令，npm 或者 cnpm 进行安装。 12// -g 全局npm install -g babel-cli 注意：这时输入命令babel [用ES6写的js目录/index.js] -o [转换成ES5的目录/index.js]虽然可以在新转换成ES5的目录中出现新转换的文件夹，但是里边的内容还是ES6语法。 3、安装 babel-preset-es2015 和 babel-cli 转换包1npm install --save-dev babel-preset-es2015 babel-cli 安装完成之后，package.json 文件多了 devDependencies 选项。 1234&quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot; &#125; ▉ 新建 .babelrc在根目录下新建 .babelrc 文件，MAC 可能此后缀文件不支持，可上网自行搜索方法，让其支持此后缀。打开文件输入一下内容： 123456&#123; &quot;presets&quot;:[ &quot;es2015&quot; ], &quot;plugins&quot;:[]&#125; ▉ 转化命令 完成上边的安装之后，我们开始进行转换。下边这种命令转换非常繁琐，我们可以进一步进行简化。 1babel src/index.js -o dist/index.js 简化： 1234567891011121314151617&#123; &quot;name&quot;: &quot;ReactDome&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; //修改这一行，冒号前边是命令，后边是转化路径 &quot;bulid&quot;: &quot;babel [用ES6写的js目录/index.js] -o [转换成ES5的目录/index.js]&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;babel-cli&quot;: &quot;^6.26.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot; &#125;&#125; 输入一下命令将ES6 转化 ES5： 1npm run build]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【哈希算法】]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[如何防止数据库中的用户信息被脱库？ 一、哈希基本常识1、什么是哈希算法？ 将任意长度的二进制串映射为固定长度的二进制串，这个映射规则就是哈希算法。从原始数据映射之后的二进制串就是哈希值。 2、哈希算法满足的条件？ 1）从哈希值不能反向推导出原始数据（单向哈希算法）； 2）对原始数据敏感，哪怕只改了一个bit，得到的哈希值大不形同； 3）散列冲突的概率要小，对于不同原始的数据，哈希值相同的概率非常小； 4）哈希算法执行效率要高效，对于较长的文本，也能快速的计算出哈希值。 3、实际用途（MD5 算法） MD5 的哈希值是 128 位的 Bit 长度，为了方便表示转化成了 16 进制编码。 12MD5(&quot; 我今天讲哈希算法！&quot;) = 425f0d5a917188d2c3c3dc85b5e4f2cbMD5(&quot; 我今天讲哈希算法 &quot;) = a1fb91ac128e6aa37fe42c663971ac3d 二、哈希算法最常见的七大应用 安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。 应用一：安全加密 最常用的两种加密算法 MD5（Message-Digest Algorithm，消息摘要算法） 加密算法和 SHA（Secure Hash Algorithm，安全散列算法）。 1、加密的哈希特性有哪些？■ 对于加密，不能通过哈希值反向推导。 加密为了防止原始数据泄漏，所以很难通过哈希值反向推倒原始数据。 ■ 散列冲突要小 无论什么哈希算法，我们只能尽量减少冲突的概率，理论上没有办法做到完全不冲突 —— 鸽巢原理（也叫抽屉原理）。 2、为什么哈希无法做到零冲突？ 哈希算法产生的哈希值长度是固定值有限的。 比如： MD5 算法，哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据。而我们的原始数据是无限的，就必然会存在哈希值冲突现象。 应用二：唯一标识1、问题 在海量的图库中，搜索到一张图片是否存在，最常用的解决办法就是对比图像的名称，有可能出现名称相同，图像内容不符的情况，所以应该怎么来解决？ 2、解决方法 图片在计算机中的存储是以二进制码串的形式，就是用查找图片的码串和图库中的所有码串进行对比。但是由于每张图片几十 kb 转化成二进制码串非常长，怎么进行优化？ 3、方法优化 给每个字符串取唯一标识，取二进制码头100字节，中间100字节，尾100字节，将这 100 字节放到一块，通过哈希算法得到一个哈希字符串当做图片的唯一标识。 4、进一步优化 通过图片的唯一标识和图片相应的路径信息都对应的存在散列表中。直接通过对比哈希字符串定位到图片的唯一标识，然后通过散列表得到该图片再进行比较，如果完全相同，说明存在该图片，如果不相同，就说明存在图片名称相同，内容不同的两张图片。 应用三：数据校验1、问题 基于 p2p 协议的 BT 下载软件，在多个机器并行下载，电影被分割成多块进行同步下载，然后下载完成进行整合。由于不能确定每块文件的完整性，可能被恶意篡改、下载错误等，导致最后整合无法观看，那么如何校验文件块的正确性呢？ 2、校验的哈希特性 哈希算法对数据很敏感，一旦文件快内容一丁点的改变，最后的哈希值就完全不同。 3、解决方法 用哈希算法检验下载文件块是否完整，可以对下好的文件块的哈希值与完整的文件块进行一一对比，如果不相同，就说明该文件快损坏，需要重新下载。 应用四：散列函数 散列函数也是哈希算法的一种应用。 1、散列函数的哈希要求 1）散列函数对散列冲突要求比较低，只要不过于严重，通过开发寻址法或者链表法解决。 2）散列函数计算出的值能否反向解密不关心，反而更加关注是否能平均分布，也就是一组数据能否均匀的在各个槽中。 3）散列函数的快慢影响散列表的性能，所以说散列函数要求比较简单，比较追求性能。 哈希算法在分布式系统中有哪些应用？ 应用五：负载均衡 负载均衡算法有很多，比如轮询、随机、加权轮询等。 1、问题 那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢。也就是说，需要在同一个客户端上，在一次会话中的所有请求都路由到一个同一个服务器上。 2、常规解决 维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。 3、存在弊端 1、如果客户端很多，映射表可能会很大，比较浪费内存空间； 2、客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大； 4、哈希解决 对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算。最终得到的值就是应该被路由到的服务器编号。就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。 应用六：数据分片▉ 示例一：如何统计“搜索关键词”出现的次数？1、问题 假如有 1T 的日志文件，这里面记录了用户的搜索关键词，想要快速统计出每个关键词被搜索的次数，该怎么做呢？ 2、思路分析 1） 搜索日志很大，没办法放到一台机器的内存中。 2）如果只用一台机器来处理这么巨大的数据，处理时间会很长。 3、解决办法 MapReduce 的基本设计思想，先进行数据分片，然后采用多台机器的方法处理，来提高处理效率。 1）从搜索记录的日志文件中，依次读出每个搜索关键词。 2）并且通过哈希函数计算哈希值，然后再跟 n 取模。 3） 最终得到的值，就是应该被分配到的机器编号。 4、条件限制 有另一种方法可以解决，用到散列表，详细章节情跳转：《堆》的求前 k 大搜索关键词求所有关键字的次数。 ▉ 示例二：如何快速判断图片是否在图库中？1、问题 假设现在我们的图库中有 1 亿张图片，如何快速判断图片是否在图库中？ 2、思路分析 1）在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。 2）用多台机器进行计算。 3、解决 当判断一个图片是否在图库中的时候，用同样的哈希算法，计算唯一标识，然后与机器个数n求余取模。假设得到的值是k，那就去标号k的机器构建的散列表中查。 应用七：分布式存储1、问题 当拥有海量的用户和数据的时候，为了提高数据的读写、写入能力，一般采用分布式来存储数据。 2、思想 利用数据分片思想，通过计算哈希算法，对数据去哈希值，然后对机器的个数进行取余，最终的就是存储缓存机器的标号。 3、数据太大如何扩容？ 变化最大就是机器的数量增加了，导致取模使得哈希值变化很大。 4、导致问题 1）进行大规模数据迁移，所有的数据都要进行重新计算哈希值，重新搬移到正确的机器上。 2）当量的数据在缓存中就失效了，所有的数据请求都会穿透缓存，直接去请求数据库。会发生雪崩效应，压垮数据库。 5、解决方法 假设有k个机器，数据的哈希值范围是【0，MAX】。我们将整个范围划分为m个小区间（m远大于k）， 每个机器负责m/k个小区间。当有新机器加入的时候，我们在几个小区间里搬移数据到新机器中，即不用重 搬移数据，又保持了各个机器上数据的均衡。 三、本节思考：如何防止数据库的用户信息被脱库？ 安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，只是增加了攻击的成本而已。 ■ 问题 用户的密码通过哈希算法都能转化成哈希值，所有的用户信息形成一个数据字典，一旦数据字典被攻击，黑客就会拿到加密后的密文之后和数据字典中的数据进行比对，一般对比相同的就是数据字典中的明文。 ■ 优化 引入一个盐（salt）概念，跟用户的密码进行组合到一起，增加密码的复杂度，拿到组合后的字符串进行哈希加密，将它存储到数据库，进一步增加破解的难度。 四、扩展思考▉ 问题： 区块链是怎么用哈希算法进行解决问题的？ ▉ 区块链的组成 区块链分为区块头和区块体。区块头保存着自己区块体和上一区块头的哈希值。 ▉ 区块链的哈希特性 唯一性：链式关系用到了哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。 ▉ 区块链的算法 区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 2016 入门【基本语法】]]></title>
    <url>%2F2019%2F03%2F03%2FECMAScript%202016%20%E5%85%A5%E9%97%A8%E3%80%90%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[ECMAScript 6 基本入门。 Promise 对象1、定义 Promise 是一种异步编程的解决方案。 2、基本用法123456789101112131415const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); Promise 接受一个函数，该函数两个参数分别为 resolve和reject。 resolve函数的作用: pending 变为 resolved； reject函数的作用：pending 变为 rejected； then方法：指定 resolved 状态和rejected的回调函数。 then两个方法：第一个当状态变为resolve时调用；第二个当状态变为rejected时调用；第二个通常不提供； 3、应用场景■ 异步加载图片123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; ■ Promise 实现 AJAX1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); async 函数1、含义 ES2017 标准引入了 async 函数，使得异步操作变得更加方便。 2、基本用法 async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 ■ 代码示例 指定 50 毫秒以后，输出hello world。 123456789101112function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncPrint(value, ms) &#123; await timeout(ms); console.log(value);&#125;asyncPrint('hello world', 50);]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之JavaScript执行(一)]]></title>
    <url>%2F2019%2F03%2F03%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BJavaScript%E6%89%A7%E8%A1%8C(%E4%B8%80)8%2F</url>
    <content type="text"><![CDATA[Promise 里的代码为什么比 setTimeout 先执行？ 一、JavaScript 引擎 一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。 1、ES3 更早的版本 js 没有处理异步的能力。ES5 之后 js 引入 Promise 异步编程，js 引擎本身也可以发起任务。 1、宏观任务 由宿主环境发起的任务叫做宏观任务。 ■ 事件循环 JavaScript 引擎等待宿主环境分配宏观任务，等待就是一个事件循环。 ■ 宏观任务 每次执行的过程就是一个宏观任务。宏观任务的队列就相当于事件循环。 2、微观任务 由 js 引擎发起的任务称为微观任务，x许多微观任务组成了宏观任务。 3、Promise Promise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。 ■ 代码实例一12345678 //输出的顺序是 a、b、cvar r = new Promise(function(resolve, reject)&#123; console.log("a"); resolve() &#125;);//异步回调 r.then(() =&gt; console.log("c")); console.log("b") ■ 代码实例二1234567891011// js 引擎发起的微观任务var r = new Promise(function(resolve, reject)&#123; console.log("a"); resolve()&#125;);//浏览器(宿主)发起的宏观任务setTimeout(()=&gt;console.log("d"), 0)//微观任务先于宏观任务r.then(() =&gt; console.log("c"));console.log("b")//打印顺序 a、b、c、d 4、如何分析异步执行的顺序 首先我们分析有多少个宏任务； 在每个宏任务中，分析有多少个微任务； 根据调用次序，确定宏任务中的微任务执行次序； 根据宏任务的触发规则和调用次序，确定宏任务的执行次序； 确定整个顺序。 5、ES6新特性：async/await参考 ES6 语法：http://es6.ruanyifeng.com/#docs/async]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 高级程序设计第七章【函数表达式】]]></title>
    <url>%2F2019%2F02%2F27%2FJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%90%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[递归与闭包以及私有变量 第七章 函数表达式 定义函数有两种形式：1、函数声明 2、函数表达式 1、函数声明 函数提升：在执行代码之前，先读取函数声明，所以函数声明代码可以放在函数调用的后边。 2、函数表达式 匿名函数：function 后边没有函数名， 3、函数提升 理解函数声明与函数表达式之间的区别。 注意：同一个函数声明不要出现在同一 if - else 判断中语句中使用，但是函数表达式可以使用。 7.1 递归1、示例 下方示例会出现错误，因为在 otherfun 里调用 fun ，fun 已经变为 null 了。 1234567891011var otherfun = fun;fun = null;alert(otherfun(4));fun(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; return fun(num-1); &#125;&#125; 2、改进 arguments.callee 是一个指向正在执行的函数的指针，用它来实现递归的调用。 12345678fun(num)&#123; if(num &lt;= 1)&#123; return 1; &#125;else&#123; // arguments.callee 永远指向正在执行的函数 return arguments.callee(num-1); &#125;&#125; 3、严格模式下 严格模式下，不能通过脚本来调用 arguments.callee ，否则报错。 123456789// 通过匿名函数可以来访问var fun2 = ( if(num &lt;= 1)&#123; return 1; &#125;else&#123; return f(num-1); &#125;); 7.2 闭包 区分闭包和匿名函数。 闭包：有权访问另一个函数作用域中的变量的函数。 1、理解闭包的 即使函数内部的函数返回了，在另一地方照样可以访问外部函数的参数，因为匿名函数的作用域链包含 createFunction函数的作用域。 1234567function createFunction（name）&#123; //返回匿名函数 return function(object1)&#123; //匿名函数内部访问外部函数变量 var value = object1[name]; &#125;&#125; 过程分析： 1、匿名函数返回时会将外部函数的活动对象和全局的活动对象添加到自己的作用域链中，当匿名函数在外部访问时，外部的变量就会访问到。 2、包含闭包函数的外部函数销毁时，只会销毁执行环境中的作用域链，而不会销毁活动对象，活动对象仍然留在内存中；直到闭包函数被销毁后，活动对象才会被销毁。 闭包使用注意： 闭包会携带其他函数的作用域链，在内存中会占用很大的空间，过度使用闭包可能导致内存占用过多，有必要时在考虑闭包问题。 7.2.1 闭包与变量]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【队列】]]></title>
    <url>%2F2019%2F02%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E9%98%9F%E5%88%97%E3%80%91%2F</url>
    <content type="text"><![CDATA[队列在线程池等有限资源池中的应用！ 一、队列的基本常识1、什么是队列 先进先出的数据结构。 2、特点 先进先出，吃多了就拉！ 二、怎么实现队列 用数组来实现的叫做顺序队列，用链表来实现叫做链式队列。 1、顺序队列■ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940// 用数组实现的队列public class ArrayQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public ArrayQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队 public boolean enqueue(String item) &#123; // 如果 tail == n 表示队列已经满了 if (tail == n) return false; //将数据插入到尾部 items[tail] = item; //指向尾部的下标加、+1 ++tail; //返回ture return true; &#125; // 出队 public String dequeue() &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; //取出队头的第一个数据 （问题：队列头部的值还仍然存在数组中） String ret = items[head]; //队头下边向后移动+1 ++head; //将出队的元素返回 return ret; &#125;&#125; ■ 问题探讨 用两个指针来控制队列，频繁的出队和入队会产生head 和 tail 都会持续往后移动，当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。怎么解决呢？ ■ 解决一：数据迁移 每出队一个元素就进行数据搬移，导致的时间复杂度从 O(1) 上升到了 O(n)，可以继续进行优化。 ■ 优化：解决一 当数据出队的时候，不做任何数据搬移，当无法往数组中添加数据的时候，然后集中进行数据搬移，优化后出队的时间复杂度为 O(1)，入队的时间复杂度分析： 1、当队尾有空余空间，进行直接插入，时间复杂度为 O(1)。 2、当队尾没有空闲时间时，先进行搬移然后进行插入，时间复杂度为O(n)。用均摊分析方法求出平均时间复杂度为 O(1)。 ■ 优化后的代码1234567891011121314151617181920// 入队操作，将 item 放入队尾 public boolean enqueue(String item) &#123; // tail == n 表示队列末尾没有空间了 if (tail == n) &#123; // tail ==n &amp;&amp; head==0，表示整个队列都占满了 if (head == 0) return false; // 数据搬移 for (int i = head; i &lt; tail; ++i) &#123; items[i-head] = items[i]; &#125; // 搬移完之后重新更新 head 和 tail tail = tail - head; head = 0; &#125; //将入队列的元素插入到队尾 items[tail] = item; //队尾指针+1 ++tail; return true; &#125; 2、链式队列■ 代码实现1234567891011121314151617181920212223242526272829303132public class CircularQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public CircularQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队 public boolean enqueue(String item) &#123; // 队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true; &#125; // 出队 public String dequeue() &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; head = (head + 1) % n; return ret; &#125;&#125; ■ 三种常见的队列1、循环队列▍由来 数组实现队列，在 tail == n 的时候，需要进行数据搬移，入队就会受到影响，为了避免这次操作，出现了循环队列。 ▍定义 循环队列，顾名思义，队列首尾相接形成一个环。 ▍ 示意图 ▍工作方式 上图中，当 tail 指向 7 时，插入一个新数据并不更新 tail ,而是将 tail 指向下标为 0 的位置，当再次插入数据的时候，然后将 tail + 1更新为 1。 ▍判定条件 最重要的是队空和队满两种判空条件。 ① 队列的判空条件：head == tail 。 ② 队满的判断条件：(tail+1)%n=head。 补充： 当a=bq+r，q是整数，并使其达到最大，此时我们说a模除b等于r。以数学式子表示：a模除b。例如要计算100模除16，由于100/16是一个大于6且不大于7的整数，取q=6。100-16*6=4，而4就是答案。 注意： 当队列满时，tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。 ▍ 代码实现 1234567891011121314151617181920212223242526272829303132public class CircularQueue &#123; // 数组：items，数组大小：n private String[] items; private int n = 0; // head 表示队头下标，tail 表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为 capacity 的数组 public CircularQueue(int capacity) &#123; items = new String[capacity]; n = capacity; &#125; // 入队 public boolean enqueue(String item) &#123; // 队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true; &#125; // 出队 public String dequeue() &#123; // 如果 head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; head = (head + 1) % n; return ret; &#125;&#125; 2、阻塞队列▍由来 通过队列实现安全高效的数据处理的功能。 ▍定义 阻塞队列，是在普通队列基础上实现了阻塞线程的功能（生产者—消费者模式）。 详细分析：在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回 ▍问题一：阻塞产生的问题 当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。 ▍问题解决： 通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。 ▍问题二：多线程引起的问题 配置多个 “消费者” 需要开启多线程。而多个线程同时操作队列，就会存在线性安全问题，使用到下方的并发队列来解决线性安全问题。 3、并发队列 线性安全队列叫做并发队列。 ▍实现方式 最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。 补充：实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。 三、队列的应用场景 队列可以应用在任何有限池中，用于排队请求，比如数据库的连接池等。对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”来实现请求排队。 三、本节思考■ 问题 当向固定大小的线程池请求一个线程的时候，如果线程没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种策略是怎么实现的呢？ ■ 解决1）非堵塞处理方式 直接拒绝任务请求； 2）阻塞处理方式 将请求排队，等到有空闲线程时，取出排队的请求继续处理。 ■ 链表和数组排队请求的区别 ① 基于链表的实现。实现一个无限排队的无界队列，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。 ② 基于数组实现。实现一个有界队列，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，对于响应时间比较敏感的系统更加合适。设置一个合理的队列大小是非常有讲究的，队列太大导致等待的请求太多，队列太小会导致无法充分资源，发挥最大性能。 四、扩展思考1、类似于线程池用到队列排队请求，还有哪些类似的池结构或者场景会用到队列请求呢？ 答：Android 中的 Handle 消息处理机制中的消息队列用到了队列请求（需扩展） 2、如何实现无锁并发队列呢？ 答：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【栈】]]></title>
    <url>%2F2019%2F02%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E6%A0%88%E3%80%91%2F</url>
    <content type="text"><![CDATA[如何实现浏览器的前进后退功能？ 一、栈的基本常识1、什么是栈？ 先进后出的结构。 2、特点 先进后出。 二、怎么实现栈？ 用数组实现的栈，叫作顺序栈，用链表实现的栈，叫作链式栈。 1、顺序栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package easy_test;/** * 功能:基于数组的顺序栈 * @author:小鹿 * */public class ArrayStack &#123; private String[] items; // 数组 private int count; // 栈中元素个数 private int n; // 栈的大小 // 初始化数组，申请一个大小为 n 的数组空间 public ArrayStack(int n) &#123; this.items = new String[n]; this.n = n; this.count = 0; &#125; /** * 功能:入栈 * 说明:数组入栈的入口为数组尾部 * @param item :入栈数据元素 * @return:是否入栈成功 */ public boolean push(String item) &#123; // 数组空间不够了，直接返回 false，入栈失败。 if (count == n) return false; // 将 item 放到下标为 count 的位置 items[count] = item; //数组长度+1 ++count; //入栈成功 return true; &#125; /** * 功能:出栈 * @return:返回出栈元素 */ public String pop() &#123; // 栈为空，则直接返回 null if (count == 0) return null; // 返回下标为 count-1 的数组元素 String tmp = items[count-1]; //数组长度-1 --count; //返回出栈数据元素 return tmp; &#125;&#125; 2、链式栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package easy_test;/** * 功能:基本链表实现栈，入栈、出栈、输出栈 * @author : 小鹿 * */public class StackBasedLinkedList &#123; //定义栈顶指针 private Node top = null; //定义栈结点 private static class Node &#123; //栈结点数据域 private int data; //栈结点指针域 private Node next; //构造函数 public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125; //get 获取数据域方法 public int getData() &#123; return data; &#125; &#125; /** * 功能:入栈 * @param value:要入栈的数据元素 */ public void push(int value) &#123; //创建一个栈结点 Node newNode = new Node(value, null); // 判断栈是否为空 if (top == null) &#123; //如果栈为空，就将入栈的值作为栈的第一个元素 top = newNode; &#125; else &#123; //否则插入到top栈结点前（所谓的就是单链表的头插法） newNode.next = top; top = newNode; &#125; &#125; /** * 功能 : 出栈 * @return: -1 为栈中没有数据 */ public int pop() &#123; // 如果栈的最顶层栈结点为null,栈为空 if (top == null) return -1; //否则执行出栈操作，现将栈顶结点的数据元素赋值给 Value int value = top.data; //将 top 指针向下移动 top = top.next; //返回出栈的值 return value; &#125; /** * 功能:输出栈中所有元素 */ public void printAll() &#123; //将栈顶指针赋值给p Node p = top; //循环遍历栈(遍历单链表) while (p != null) &#123; System.out.print(p.data + " "); //指向下一个结点 p = p.next; &#125; System.out.println(); &#125;&#125; 三、栈操作的性能1、时间复杂度 顺序栈和链式栈入栈和出栈只操作栈顶元素，所以时间复杂度为 O(1)。 2、空间复杂度 顺序栈和链式栈只需要大小为 n 的空间就可以，入栈和出栈需要一个临时空间来存储变量，空间复杂度为 O(1)。 四、栈的动态扩容 当栈满的时候，需要进行动态扩容，可以仿照数组的动态扩容。 1、时间复杂度分析 出栈涉及不到扩容，时间复杂度为 O(1)；入栈当栈满的时候，需要进行扩容，数据进行搬移，时间复杂度为 O(n)。平均时间复杂度为 O(1)，进行摊还分析。 五、栈的实际应用1、应用一：函数调用栈 操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。 ■ 代码实现123456789101112131415int main() &#123; int a = 1; int ret = 0; int res = 0; ret = add(3, 5); res = a + ret; printf("%d", res); reuturn 0;&#125;int add(int x, int y) &#123; int sum = 0; sum = x + y; return sum;&#125; ■ 示意图 2、应用二：栈在表达式求值中的应用 编译器就是通过两个栈来实现的。其中一个保存操作数的栈 ，另一个是保存运算符的栈。从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。 ■ 实例 将 3+5*8-6 这个表达式的计算过程画成了一张图，进行计算。 ■ 示意图 ■ 过程分析 如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。 3、应用三：栈在括号匹配中的应用 用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(” 跟 “)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。 六、本节思考：怎样实现浏览器的前进后退？ 答：使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。 七、扩展思考1、为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？ 答： 因为函数调用的执行顺序符合后进者先出，先进者后出的特点。比如函数中的局部变量的生命周期的长短是先定义的生命周期长，后定义的生命周期短；还有函数中调用函数也是这样，先开始执行的函数只有等到内部调用的其他函数执行完毕，该函数才能执行结束。正是由于函数调用的这些特点，根据数据结构是特定应用场景的抽象的原则，我们优先考虑栈结构。 2、那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？ 答： JVM里面的栈和我们这里说的是一回事，被称为方法栈。和前面函数调用的作用是一致的，用来存储方法中的局部变量]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之HTML标签7【元信息】]]></title>
    <url>%2F2019%2F02%2F24%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BHTML%E6%A0%87%E7%AD%BE7%E3%80%90%E5%85%83%E4%BF%A1%E6%81%AF%E3%80%91%2F</url>
    <content type="text"><![CDATA[head 里一共能写哪几种标签？ 元信息类标签 所谓元信息，描述自身的信息，元信息类标签，就是 HTML 用于描述文档自身的一类标签。 ■ head 标签 html 标签的第一个标签，必须包含一个 title，并且最多只能包含一个 base ，如果文档作为 iframe，或者有其他方式指定了文档的标题，可以允许不包含 title 标签。 ■ title 标签 title 表示文档的标题。 1、title 和 h1 的区别 title 作为元信息，可能会被用在浏览器收藏夹、微信推送卡片、微博等各种场景，这时侯往往是上下文缺失的，所以 title 应该是完整地概括整个网页内容的。 h1 仅仅表示页面展示，默认具有上下文，并具有链接辅助，所以可以简写。 ■ base 标签 给页面上所有的 URL 相对地址提供一个基础。实际开发中建议使用 javascript 来代替 base 标签，因为容易跟 javascript 造成配合问题。 ■ meta 标签 是一组键值对，是一种通用的元信息表示标签。一般的 meta 标签由 name 和 content 两个属性来定义。name 表示元信息的名，content 则用于表示元信息的值。 1&lt;meta name=application-name content="lsForums"&gt; 1、具有 charset 属性的 meta HTML 5 开始简写法，添加的 meta 没有了 name 和 content 属性，放到 head 的第一个。 1234&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;…… 1、浏览器在读到此标签之前，所有处理的字符是 ASCll 字符(ASCll 字符是 UTF-8 字符编码的子集)。 2、http 服务端会通过 http 头来指定正确的编码方式，但是有些特殊的情况如使用 file 协议打开一个 HTML 文件，则没有 http 头，这种时候，charset meta 就非常重要了。 2、具有 http-equiv 属性的 meta 表示执行一个命令。 12&lt;!-- 相当于添加了 content-type 这个 http 头，并且指定了 http 编码方式 --&gt;&lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; content - type 几种命令： content-language 指定内容的语言； default-style 指定默认样式表； refresh 刷新； set-cookie 模拟 http 头 set-cookie，设置 cookie； x-ua-compatible 模拟 http 头 x-ua-compatible，声明 ua 兼容性； content-security-policy 模拟 http 头 content-security-policy，声明内容安全策略。 3、name 为 viewport 的 meta 是移动端开发的事实标准。 1&lt;meta name="viewport" content="width=500, initial-scale=1"&gt; width：页面宽度，可以取值具体的数字，也可以是 device-width，表示跟设备宽度相等。 height：页面高度，可以取值具体的数字，也可以是 device-height，表示跟设备高度相等。 initial-scale：初始缩放比例。 minimum-scale：最小缩放比例。 maximum-scale：最大缩放比例。 user-scalable：是否允许用户缩放。 12&lt;!--如果已经做好移动端适配的网页，应该把用户的缩放功能禁止掉，宽度为设备宽度--&gt;&lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【二分查找】]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E3%80%91%2F</url>
    <content type="text"><![CDATA[如何用最省内存的方式实现快速查找 ! 二分查找（上） 一般二分查找的都可以用散列表或者二叉查找树来解决。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。 一、适用条件1、二分查找依赖的是顺序结构（数组） 二分查找算法需要按照下标随机访问元素 ,因为时间复杂度为 O(1)，如果使用链表，下标随机访问时间复杂度变成为 O(n)。 2、二分查找针对的是有序数据 二分查找只能应用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用，使用二叉树。 3、二分查找不适合数据量太小 如果要处理的数据量太小，直接遍历就足够了。一个特殊情况，那就是数据之间比较操作非常耗时，无论数据量大小，推荐使用二分查找。 4、二分查找不适合数据量太大 由于二分查找底层依赖的是数组这种结构，内存空间要求是连续的。如果数据量太大，内存连续的空间不足，用数据存储起来比较吃力。 二、最简单的二分查找 最简单的情况就是有序数组中不存在重复的元素 1、最简单代码实现1234567891011121314151617181920public int simpleFind(int[] a,int n, int value) &#123; int low = 0; int high = n - 1; // 当两个指针同时指向一个数据时，必须用 &lt;= while(low &lt;= high) &#123; //注意:两者之和可能会溢出 //改进: low + (high - low)/2 或 low + ((high - low)&gt;&gt;2) int mid = (low + high)/2; if(a[mid] == value) &#123; return mid; &#125;else if(a[mid] &lt; value) &#123; // 如果不 + 或 - 会发生死循环 low = mid + 1; &#125;else &#123; high = mid - 1; &#125; &#125; return -1;&#125; 2、递归代码实现方式12345678910111213141516public int recursionTwoFind(int[] a,int low,int high,int value) &#123; //终止条件 if(low &gt; high) return -1; //计算中间结点 int mid = low + (high-low)/2; //进行递归 if(a[mid] == value) &#123; return mid; &#125;else if(a[mid] &lt; value)&#123; return recursionTwoFind(a, mid + 1, high, value); &#125;else &#123; return recursionTwoFind(a, low, mid - 1, value); &#125;&#125; 三、三个重点1、循环退出条件 注意是 low &lt;= height,而不是 low &lt; heigh。 原因：指向同一个数据，并不能查找到。 2、mid 的取值 mid=(low+high)/2 写法有问题。 原因：因为如果 low 比和 height 大的话，两者之和可能会溢出。 优化：应写成 low+(high-low)/2 ，如果优化到极致的话，改进为位运算符 low+((high-low)&gt;&gt;1)。 3、low 和 high 的更新 low=mid+1，high=mid-1。 原因：如果不进行 +1 和 -1 ，就有可能会发生死循环 二分查找（下）一、四个变体问题1、查找第一个值等于给定值的元素 有序数据集合中包含重复数据，之前的二分查找只适合于无重复数据，在这里就不适用了，查找第一个值等于给定值的元素。 ■ 代码实现 1234567891011121314151617181920212223242526272829303132/** * 变体一:查找第一个值等于给定值的元素 * @param a 数组 * @param n 数组的长度 * @param value 超找的值 * @return 该元素的数组下标 */ public int find1(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; // 当两个指针同时指向一个数据时，必须用 &lt;= while(low &lt;= high) &#123; //注意:两者之和可能会溢出 //改进: low + (high - low)/2 或 low + ((high - low)&gt;&gt;2) int mid = low + (high - low)/2; if(a[mid] == value) &#123; // 找出重复元素中第一个元素 if(mid == 0 || a[mid - 1] != value) &#123; return mid; &#125;else &#123; high = mid - 1; &#125; &#125;else if(a[mid] &lt; value) &#123; // 如果不 + 或 - 会发生死循环 low = mid + 1; &#125;else &#123; high = mid - 1; &#125; &#125; return -1; &#125; 2、查找对后一个值等于给定值的元素 查找对后一个值等于给定值的元素。 ■ 代码实现 123456789101112131415161718192021222324252627282930313233/** * 变体一:查找最后一个值等于给定值的元素 * @param a 数组 * @param n 数组的长度 * @param value 超找的值 * @return 该元素的数组下标 */public int find2(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; // 当两个指针同时指向一个数据时，必须用 &lt;= while(low &lt;= high) &#123; //注意:两者之和可能会溢出 //改进: low + (high - low)/2 或 low + ((high - low)&gt;&gt;2) int mid = low + (high - low)/2; if(a[mid] == value) &#123; // 找出重复元素中第一个元素 if(mid == n - 1 || a[mid + 1] != value) &#123; return mid; &#125;else &#123; low = mid + 1; &#125; &#125;else if(a[mid] &lt; value) &#123; // 如果不 + 或 - 会发生死循环 low = mid + 1; &#125;else &#123; high = mid - 1; &#125; &#125; return -1;&#125; 3、查找第一个大于等于给定值的元素 查找第一个大于等于给定值的元素。 ■ 代码实现 12345678910111213141516171819202122232425262728/** * 变体三:查找第一个大于等于给定值的元素 * @param a 数组 * @param n 数组的长度 * @param value 数组的值 * @return */ public int find3(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; // 当两个指针同时指向一个数据时，必须用 &lt;= while(low &lt;= high) &#123; // 注意:两者之和可能会溢出 // 改进: low + (high - low)/2 或 low + ((high - low)&gt;&gt;2) int mid = low + (high - low)/2; if(a[mid] &gt;= value) &#123; if((mid == 0) || (a[mid - 1] &lt; value )) &#123; return mid; &#125;else &#123; high = mid - 1; &#125; &#125;else &#123; low = mid + 1; &#125; &#125; return -1; &#125; 4、查找第一个小于等于给定值的元素 查找第一个小于等于给定值的元素。 ■ 代码实现 12345678910111213141516171819202122232425262728/** * 变体四:查找第一个小于等于给定值的元素 * @param a 数组 * @param n 数组的长度 * @param value 数组的值 * @return */ public int find4(int[] a, int n, int value) &#123; int low = 0; int high = n - 1; // 当两个指针同时指向一个数据时，必须用 &lt;= while(low &lt;= high) &#123; // 注意:两者之和可能会溢出 // 改进: low + (high - low)/2 或 low + ((high - low)&gt;&gt;2) int mid = low + (high - low)/2; if(a[mid] &lt;= value) &#123; if((mid == n-1) || (a[mid + 1] &gt; value )) &#123; return mid; &#125;else &#123; low = mid + 1; &#125; &#125;else &#123; high = mid - 1; &#125; &#125; return -1; &#125; 二、扩展思考：如何快速定位一个 IP 地址的归属地？■ 问题： 如何在 12 万条数据中，快速定位一个 IP 地址的归属地？ ■ 解决： 1、首先预先处理这 12 万条数据，让其按照起始 IP 从小打到排序，将 IP 转化为 32 位的整型数，然后按照对应到的整型值的大小关系，从小到大进行排序。 2、将问题转化为变体四的问题，“查找最后一个小于等于某个给定值的元素”。 3、找到一个 IP 区间起始位置的IP 小于等于该查找 IP 的区间，然后检查该 IP 是否在区间内。 ■ 代码实践 12]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之浏览器如何工作的【浏览器】]]></title>
    <url>%2F2019%2F02%2F09%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%846%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[浏览器是如何工作的？ 浏览器是如何工作的？第一阶段：（通讯部分）HTTP 的请求过程一、浏览器的请求过程 DOM 树构建、CSS 计算、渲染、合成、绘制。 浏览器使用 HTTP 协议或者 HTTPS 协议，向服务器发送请求。 把请求回来的 HTML 代码经过解析，构成 DOM 树； 最后根据 CSS 属性对元素进行逐个渲染，得到内存中的位图。 一个可选的步骤是对位图进行合成，极大地增加后续绘制的速度； 合成之后，再绘制到界面上。 二、HTTP 协议 1、HTTP 是纯粹的文本协议，基于 TCP 协议出现的。TCP 是双向通信通道，HTTP 规定了 Request-Response 的模式，必须是由客户端首先发起。 2、浏览器是只需要 tcp 库或者现成的 http 库就能搞定网络通讯部分。 1、HTTP 请求 请求的方法 请求的路径 请求的协议 请求的版本 2、HTTP 响应 响应的协议 响应的版本 响应的状态 响应的文本 三、HTTP 协议格式 1、Method（方法） GET 通过浏览器访问的都是 GET 方法。 POST 表单提交使用 POST 方法。 HEAD HEAD 则是跟 GET 类似，只返回请求头，多数由 Js 发起。 PUT DELETE PUT 和 DELETE 分别表示添加资源和删除资源。 CONNECT 现在多用于 HTTPS 和 WebSocket。 OPTIONS TRACE OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。 2、Status code(状态码) 和 Status text(状态文本) 1XX ：临时回应，表示客户端请继续。 1xx 的状态被浏览器 http 库直接处理掉了，不会让上层应用知晓。 2XX ：请求成功。 200 ：请求成功 3XX ：表示请求的目标有变化，希望客户端进一步处理。 301 &amp;&amp; 302：永久性与临时性跳转。 实际上 301 更接近于一种报错，提示客户端下次别来了。 304 ：跟客户端缓存没有更新。 客户端本地已缓存资源，发送条件请求判断是否为最新版本，如果为最新版本，返回 304 状态码，读取本地缓存。 4XX ：客户端请求错误。 403 : 无权限。 404：表示请求的页面不存在。 418：超文本咖啡壶控制协议。 5XX :服务端请求错误。 500：服务端错误。 503：服务器暂时性错误，可以一会再试。 3、HTTP Head(HTTP 头) Request Header。 Response Header。 4、HTTP Request Body HTTP 请求的 body 主要用于提交表单场景。 application/json application/x-www-form-urlencoded (form 标签提交默认格式) multipart/form-data （文件上传） text/xml 第二阶段：DOM树是如何构建的？ 第一阶段用 HTTP/HTTPS 请求服务器，服务器返回数据进行第二阶段构建 DOM 树。 一、词（token）的拆分 这部分内容正是 HTTP 的 Response 的 body 部分内容，词（token）是最小的有意义的单元。就是将各类标签和属性拆分。 我们就收到字符串之后并不知道那个词，每读入一个字符都要进行决策，要想把字符流解析成词，我们就是用状态机。 二、状态机1、状态机的定义 大部分语言的词法部分都是使用状态机实现的。 HTML 共规定 80 个状态：https://html.spec.whatwg.org/multipage/parsing.html#tokenization 2、状态机的原理 状态机把每个词的特征字符逐个拆分开，然后再把所有词的特征字符链合并起来，形成联通图结构。 如果获得的是一个非 &lt; 字符，那么可以认为进入了一个文本节点； 如果获得的是一个 &lt; 字符，那么进入一个标签状态。 比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。 如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。 如果下一个字符是字母，那么可以确定进入了一个开始标签。 如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。 3、状态机的实现 每个函数就是一种状态，参数是接受的字符，返回值是下一个状态函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243var data = function(c)&#123; if(c=="&amp;") &#123; return characterReferenceInData; &#125; if(c=="&lt;") &#123; return tagOpen; &#125; else if(c=="\0") &#123; error(); emitToken(c); return data; &#125; else if(c==EOF) &#123; emitToken(EOF); return data; &#125; else &#123; emitToken(c); return data; &#125;&#125;;var tagOpenState = function tagOpenState(c)&#123; if(c=="/") &#123; return endTagOpenState; &#125; if(c.match(/[A-Z]/)) &#123; token = new StartTagToken(); token.name = c.toLowerCase(); return tagNameState; &#125; if(c.match(/[a-z]/)) &#123; token = new StartTagToken(); token.name = c; return tagNameState; &#125; if(c=="?") &#123; return bogusCommentState; &#125; else &#123; error(); return dataState; &#125;&#125;; 4、字符流转换成词 每一个状态是一个函数，通过 “if else” 来区分下一个字符做状态迁移。状态迁移，将当前状态函数返回下一个状态函数。 12345678910111213141516function HTMLLexicalParser()&#123; // 状态函数们…… function data() &#123; // …… &#125; function tagOpen() &#123; // …… &#125; // …… var state = data; this.receiveInput = function(char) &#123; state = state(char); &#125;&#125; 三、构建 DOM 树 DOM 树的构建，利用数据结构中的栈来实现。 接受字符串，转换成词，开始构建 DOM 树； 栈顶的最后为根元素，DOM 树的第一项就是 stack[0]； 不同的 HTML 节点对应不同的 Node 子类。 1、利用栈来构建 DOM 树 源代码完全遵守 xhtml，html 具有很强的容错能力，当栈顶和栈尾不匹配的时候，又有一套复杂的规则。 链接：http://w3c.github.io/html/syntax.html#tree-construction 栈顶元素就是当前节点； 遇到属性，就添加到当前节点； 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点； 遇到注释节点，作为当前节点的子节点； 遇到 tag start 就入栈一个节点，当前节点就是这个节… 遇到 tag end 就出栈一个节点（还可以检查是否匹配）。 第三阶段：CSS 的计算 当我们构建 DOM 树的时候，这个过程会被浏览器流式的处理，从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上，CSS属性也会同步计算。这一过程拿到元素会一次匹配规则，根据规则的优先级进行覆盖和调整， 一、选择器的各种符号 那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。 空格 &lt; + ~ || 二、匹配规则1、后代选择器“空格” 匹配规则：后代选择器的作用范围是父节点的所有子节点，因此规则是在匹配到本标签的结束标签时回退。 123a#b .cls &#123; width: 100px;&#125; 12345&lt;a id=b&gt; &lt;span&gt;1&lt;span&gt; &lt;span class=cls&gt;2&lt;span&gt;&lt;/a&gt;&lt;span class=cls&gt;3&lt;span&gt; 2、后继选择器“~” 匹配规则：后继选择器只作用于一层，上述的激活或者关闭规则不适用了。所以给选择器的激活，带上一个条件：父元素。这里的父元素是 。 123456789101112.cls~* &#123; border:solid 1px green;&#125;&lt;div&gt; &lt;span&gt;1&lt;span&gt; &lt;span class=cls&gt;2&lt;span&gt; &lt;span&gt; 3 &lt;span&gt;4&lt;/span&gt; &lt;span&gt; &lt;span&gt;5&lt;/span&gt;&lt;/div&gt; “后继”：cls 的后继有 2, 3, 5。 3、子代选择器“&gt;” 拿当前节点作为父元素，然后激活后边的 .cls 选择条件，并且指定了父元素必须是当前div，后续的构建 DOM 中就选中了相应的标签。 4、直接后继选择器“+” 直接对唯一元素生效，不用反复的激活和关闭规则。匹配到之后让其失效。 5、逗号分隔 逗号分隔看做是两条规则来处理。为了提高效率，可以把选择器构造成一课树： 12345678910#a .cls &#123;&#125;#a span &#123;&#125;#a&gt;span &#123;&#125; #a &lt;空格&gt;.cls &lt;空格&gt;span span 第四阶段：排版（确定元素位置） 所谓的排版，就是确定每一个文字的位置。 一、浏览器的排版 浏览器最基本的排版就是正常流排版（跟平时书写文字一样，所以叫正常溜），包括顺次排版和折行排版。 1、正常流排版 文字排版遵循公认的文字排版模型，包括行模型（行顶、行底、文字区域、基线）和文字在行模型中的排布。 ■ 浏览器所支持的元素 双向文字系统（不同语言文字书写顺序不同） 盒模型（元素和文字混排）—— 元素被定义为长方形区域（边框、留白、边距） 绝对定位元素 —— 不参加排版计算，直接由 top 和 left 等属性确定自身的位置，position 属性控制 浮动元素元素 —— 在正常流的位置向左或向右移动到边界，并占据一块排版空间，float 元素控制 ■ 正常流 —— 文字和盒混排 ① 文字 浏览器支持文字书写的方向为主轴，跟主轴垂直的叫做交叉轴。 advance 代表每一个文字排布后在主轴上的前进距离，文字之间的间距，文字中的重要属性。 多数元素被当做长方形盒来排版的，而 dispaly 为 inline 的元素，是被拆分成文本来排版的。 ■ 正常流中的盒 ■ 绝对定位元素 ■ 浮动元素排版 二、思考：打造自己的排版方式 课后练习。 第五阶段：在内存中进行渲染、合成、绘制一、渲染 渲染（render）:特指把模型变成位图的过程。 ■ 位图 内存中的一张二维表格，把一张图片每个像素的颜色值保存进去（位图是 DOM 树中占据浏览器内存中最多的信息，做内存优化应优先考虑）。 ■ 渲染过程 把每个元素对应的盒变成位图，元素包括 HTML元素 和伪元素，每一个盒对应一张位图。 图形 盒的背景、边框、SVG 元素、阴影等特性，都是需要绘制的图形类，需要一个底层库来支持。 文字 盒中的文字也需要底层库来支持，叫做字体库，最常用的字体库（Freetype）。 二、 合成 渲染过程不会把子元素渲染到位图上面，合成的过程，就是为元素创建一个 “合成后的位图”，也称为合成层。 三、 绘制 绘制就是把位图按照 z-index 绘制到屏幕上，变成页面上的图像的过程。 过程 ① 重绘的频率过快，性能会下降，应该部分区域 重绘。 ② 脏矩形算法：就是把屏幕均匀的分为若干个矩形区域。 ③ 重绘部分的矩形区域就可以。 四、思考：js 实现一个浏览器]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之CSS结构5【css语法】]]></title>
    <url>%2F2019%2F02%2F07%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BCSS%E7%BB%93%E6%9E%845%E3%80%90css%E8%AF%AD%E6%B3%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[CSS语法：除了属性和选择器，你还需要知道这些带@的规则 目录 at 规则 13 个例子 普通规则 选择器 声明区块 属性 值（函数） 选择器语法结构 CSS语法一、at 规则 @ charset : https://www.w3.org/TR/css-syntax-3/ charset 用于提示 CSS 文件使用的字符编码方式。 1@charset "utf-8"; @ import : https://www.w3.org/TR/css-cascade-4/ @ import 用于引入css文件，引入另一个 javascript 文件的全部内容。 12@import "mystyle.css";@import url("mystyle.css"); @ media : https://www.w3.org/TR/css3-conditional/ 它能够对设备的类型进行一些判断。 123@media print &#123; body &#123; font-size: 10pt &#125;&#125; @ page : https://www.w3.org/TR/css-page-3/ page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。 1234567891011@page &#123; size: 8.5in 11in; margin: 10%; @top-left &#123; content: "Hamlet"; &#125; @top-right &#123; content: "Page " counter(page); &#125;&#125; @ counter-style : https://www.w3.org/TR/css-counter-styles-3/ counter-style 产生一种数据，用于定义列表项的表现。 12345@counter-style triangle &#123; system: cyclic; symbols: ‣; suffix: " ";&#125; @ key-frames : https://www.w3.org/TR/css-animations-1/ keyframes 产生一种数据，用于定义动画关键帧。 12345678910111213@keyframes diagonal-slide &#123; from &#123; left: 0; top: 0; &#125; to &#123; left: 100px; top: 100px; &#125;&#125; @ fontface : https://www.w3.org/TR/css-fonts-3/ fontface 用于定义一种字体，icon font 技术就是利用这个特性来实现的。 123456@font-face &#123; font-family: Gentium; src: url(http://example.com/fonts/Gentium.woff);&#125;p &#123; font-family: Gentium, serif; &#125; @ supports : https://www.w3.org/TR/css3-conditional/ support 检查环境的特性，它与 media 比较类似。 @ namespace : https://www.w3.org/TR/css-namespaces-3/ 用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。 二、普通规则1、选择器：语法角度（https://www.w3.org/TR/selectors-4/）语法结构： complex-selector（单个元素选择器） 符号选择器 空格（后代选择器） 整个网页中父节点下的子节点全部选中。 > （子代选择器） 只选择父节点下的第一的子节点。 + (直接后继选择器) h1 + p {margin-top:50px;} //h1后面的第一个p元素会有 50px 的间距。代表选择紧接在 h1 元素后出现的段落 ~ （后继选择器） p~ul{} :只选择 p 标签下的 ul 。 || （列选择器） 专门针对表格的选择器。 属性选择器 compound-selector（复合选择器） type-selector subclass-selector id (#) class attribute pseudo-class pseudo-element 2、声明：属性和值 属性是由中划线、下划线、字母等组成的标识符，CSS 还支持使.用反斜杠转义。属性不允许使用连续的两个中划线开头，这样的属性会被认为是 CSS 变量。 12345678:root &#123; --main-color: #06c; --accent-color: #006;&#125;/* The rest of the CSS file */#foo h1 &#123; color: var(--main-color);&#125; CSS 属性值类型： CSS 范围的关键字：initial，unset，inherit。 字符串：比如 content 属性。 URL：使用 url() 函数的 URL 值。 整数 / 实数：比如 flex 属性。 维度：单位的整数 / 实数，比如 width 属性。 百分比：大部分维度都支持。 颜色：比如 background-color 属性。 图片：比如 background-image 属性。 2D 位置：比如 background-position 属性。 函数：来自函数的值，比如 transform 属性。 CSS 支持的计算型函数： calc () calc()函数是基本的表达式计算，它支持加减乘除四则运算。 12345section &#123; float: left; margin: 1em; border: solid 1px; width: calc(100%/3 - 2*1em - 2*1px);&#125; max () min () clamp () max()、min() 和 clamp()则是一些比较大小的函数。clamp() 则是给一个值限定一个范围，超出范围外则使用范围的最大或者最小值。 toggle () toggle() 函数在规则选中多于一个元素时生效,它会在几个值之间来回切换。 1ul &#123; list-style-type: toggle(circle, square); &#125; attr () 函数允许 CSS 接受属性值的控制。]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之JavaScript对象【对象分类】]]></title>
    <url>%2F2019%2F02%2F07%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8Bjavascript%E5%AF%B9%E8%B1%A14%E3%80%90%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB%E3%80%91%2F</url>
    <content type="text"><![CDATA[JavaScript对象：你知道全部的对象分类吗？]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 高级程序设计第五章【引用类型】]]></title>
    <url>%2F2019%2F02%2F02%2FJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%90%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[Object 类型、Array 类型、Date 类型、RegExp 类型、Function 类型、基本包装类型、单体内置对象。 第五章 引用类型5.15.2 Array 类型 js 中的数组与其他语言的数组不同。1、一项数组可以保存不同类型的数据。2、数组的大小是可以动态调整的。 1、创建数组的两种方式123456//Array 构造法var array = new Array();var array = new Array("1","2","3");var array = new Array(20);//数组字面量表示法var array = [1,2,3];//不会调用构造方法 2、length 的应用应用一： 移除末尾的项。 123var colors = ["1","2","3"];colors.length = 2;alert(colors[3]);//undefined 应用二： 设置为大于数组项数的值，新增每一项取得 undefined 值。 应用三： 在末尾添加新值。 12var colors = ["1","2","3"];colors[colors.length] = "4"; 5.2.1 检测数组 确定某个对象是不是数组。 1234//确定某个值是不是数组if(Array.isArray(value))&#123; &#125; 5.2.2 转换方法 数组转换字符串。如果数组中有 undefined 或者 null 都会返回空字符串。 1、toString() 数组转换为以逗号隔开的字符串。 2、valueOf() 数组转换为以逗号隔开的字符串。 3、toLocaleString() 与上边两者不同的是，调用数组每一项的 toLocaleString() 方法，而不是 toString 方法。 4、join(“符号”) 以自定义符号进行分隔开。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 高级程序设计第六章【面向对象】]]></title>
    <url>%2F2019%2F02%2F02%2FJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[面向对象的程序设计。 第六章、面向对象的程序设计6.1 理解对象1234567891011121314//方式一var o = new Object();o.name = "zhangsan";o.sayName = function()&#123; alert(this.name);&#125;//方式二var o = &#123; name: "zhangsan", syName: function()&#123; alert(this.name);&#125; 6.1.1 属性类型 描述了属性的各个特征。ECMAScript 有两种属性：数据属性和访问器属性。 1、数据属性■ [[Configurable]] : 表示能否通过 delete 删除属性（删除权限），从而重新定义属性，默认值为 true。 ■ [[Enumerable]] : 表示能否通过 for - in 循环返回属性。默认值为 true。 ■ [[Writable]] : 表示能否修改属性的值（读写权限）。默认值为 true。 ■ [[Value]] : 包含这个属性的数据值。默认值为 undefined。 12345var person = &#123;&#125;;object.definePropert(person,"name",&#123; Enumerable: false, Value: "zhangsan"&#125;) 补充：对于一个属性多次使用 definePropert 修改属性导致错误，Writable 属性除外。 2、访问器属性■ [[Configurable]] : 表示能否通过 delete 删除属性（删除权限），从而重新定义属性，默认值为 true。 ■ [[Enumerable]] : 表示能否通过 for - in 循环返回属性。默认值为 true。 ■ [[Get]]: 在读取属性的时候调用函数，默认值为 undefined。 ■ [[Set]]: 在写入属性的时候调用函数，默认值为 undefined。 12345678910111213141516171819var book = &#123; _year:2004, edition: 1&#125;;Object.defineProperty(book,"year",&#123; get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue&gt;2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); //2 设置一个属性值导致其他属性值发生改变，访问器最常使用方式。 6.1.2 定义多个属性 通过 Object.defineProperties 定义多个属性。 1234567891011121314151617181920212223var book = &#123; &#125;;Object.defineProperties(book,&#123; _year:&#123; writable:true, value: 2004 &#125;, edition:&#123; writable:true, value: 1 &#125;, get: function()&#123; return this._year; &#125;, set: function(newValue)&#123; if(newValue&gt;2004)&#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;) 6.1.3 读取属性的特性 通过 Object.getOwnPropertyDescriptor（）方法取得对象属性的描述值。 123var descriptor = Object.getOwnPropertyDescriptor(book,"year");alert(descriptor.value);//2004alert(descriptot.configurable);//false 6.2 创建对象 通过 Object 构造器或者自变量都可以创建一个对象，但是存在一个缺点，同一接口（属性）创建很多对象，会产生大量的重复代码。 6.2.1 工厂模式 用函数来封装特定的接口创建对象的细节。 1234567891011fuction createPerson(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.sayName = function()&#123; alert(this.name); &#125;; return o;&#125;var person = createPerson("Nicholas",29,"SoftWare Engineer") ■ 优点： 大大减少了代码量。 ■ 缺点： 没有解决对象识别（即对象的类型）。 6.2.2 构造器模式 构造器可以创建特定类型的对象。 12345678910fuction Person(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.sayName = function()&#123; alert(this.name); &#125;;&#125;var person = new Person("Nicholas",29,"SoftWare Engineer"); ■ 与工厂模式不同点 没有显示的创建对象。 直接将属性和方法赋值给了 this 对象。 没有 return 语句。 ■ new 创建对象的四个阶段 创建新对象 将构造函数的作用域赋值给新对象（this指向这个新对象）。 执行构造函数中的代码（为这个新对象添加属性）。 返回新对象。 Person 的有一个 construction (构造函数) 属性，该属性指向 Person。 1、将构造函数当做函数 通过 new 来操作都可以成为构造函数，不使用 new 来操作，和普通的函数没有什么区别。 1234567891011//当构造函数来使用(new 构造函数创建对象)var person = new Person("Nicholas",29,"SoftWare Engineer");//作为普通函数来调用(在全局作用域内创建，将属性添加到了全局对象)Person("Grey",27,"Doctor"); //添加到了浏览器 window 对象window.sayName();// Greg//在另一个作用域中调用（通过 apply/call 在特殊对象的作用域调用函数）var o = new Object();Person.call(o,"Kristen",25,"Nurse");o.sayName();//Kristen 2、构造函数问题 每个方法需要每个实例上重新创建一遍，那两个方法不是同一个 Function 的实例。会导致不同作用域链和标识符的解析。 注意：ECMAScript 中的都是对象。 123456789101112//创建两个相同任务的 Function 实例确实没有必要。fuction Person(name,age,job)&#123;个个 var o = new Object(); o.name = name; o.age = age;&#125;function()&#123; alert(this.name);&#125;;var person = new Person("Nicholas",29,"SoftWare Engineer"); ■ 缺点： 1、全局作用域中定义的函数实际上只能被某个对象调用，让全局变量名副其实。 2、定义多个方法，定义多个全局变量函数，自定义引用类型丝毫没有封装可言。 6.2.3 原型模式 解决多个对象共享同一属性。 1、理解原型对象 每个函数都有一个 prototype 属性，这个属性是一个指针，指向函数的原型对象，原型对象有个 construct 属性，指向函数对象。 【图】 isPrototypeof () ： 判断对象是否存在与(函数.prototype)原型对象存在某种关系。 123alter(Person.prototype.isPrototypeof（person1）);//true//ES5 新增加属性Object.getPrototypeof(person1)；//获取原型对象 hasOwnProtype () ：判断属性来自原型还是实例。 1alert(person1.hasOwnProtype(&quot;name&quot;))// false :原型 true:实例 属性搜索过程 访问对象属性 —&gt; 对象实例 —&gt; 原型对象。 ① 为实例添加与原型相同属性 会覆盖掉原型对象属性。 ② delete 删除属性 会删除实例的属性，而不是原型的属性。 2、原型与 in 操作符 两种使用方式：单独使用、for-in循环中使用。 ① 单独使用 in 操作符只要是对象能够访问到的都返回 true。hasOwnProtype 只存在实例中才返回 true。 1alert("name" in person1) ② object.keys(对象)方法 数组返回所有对象的属性。 1var keys = Object.keys(Person.prototype); ③ Object.getOwnPropertNames (对象名) 获取对象的所有属性。 1var keys = Object.getOwnPropertNames (Person.prototype); 3、更简单的原型语法 字面量重写原型对象。 1234567Person.prototype = &#123; name: "zhangsan", age: 29, sayName: function()&#123; alert(this.name); &#125;&#125; 注意： construct 属性不在指向 Person 了，因为字面量创建的 prototype 对象被重写，constructor 指向 Object 构造函数。每一个函数的创建都会自动创建 construct 属性并指向本对象。 4、原型的动态性 如果重写了整个原型对象，就切断了构造函数与原来远行对象的联系，导致 error 。 【图】 5、原生对象的原型 基本封装类型 Array 、String 等这种原生的引用类型都有原型对象，并且封装了方法，比如 String.prototype 中的 toString 方法。 6、原型模式的缺点 原型模式最大的问题就是有其共享的本性所导致的。在原型中添加数组为例。 原型属性值被修改，所有的实例共享原型属性都会被修改。 6.2.4 组合使用构造模式和原型模式（创建自定义类型最常用的方法）■ 优点 1、既能有一份实例属性的副本，同时又共享着对方的引用，最大节省了内存。 2、支持向构造函数传参。 123456789101112131415function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friend = ['zhang','li'];&#125;Person.prototype = &#123; constructor : Person, sayName :function()&#123; alert(this.name) &#125;&#125;//改变 person1 的 friend属性值 不会改变 person2 的属性值。 ■ 缺点 缺少封装性。 6.2.5 动态原型模式 将独立的构造函数和原型封装到构造函数中，为了在构造函数中初始化原型（必要情况下）。 12345678910111213//只有在 sayName 方法不存在的情况下，才在原型中初始化 sayName 方法。function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; //不支持字面量初始化原型 if(typeof this.sayName != "function")&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125;&#125; 6.2.6 寄生构造函数模式（类似工厂模式） 返回的对象和构造函数或者原型之间没有关系。 6.2.7 稳妥构造函数模式（安全性） 稳妥对象：没有公共属性，其方法不引用 this 的对象。不使用 new 来创建对象。 6.3 继承的 ECMAScript 只支持实现继承，是通过原型链实现的。 6.3.1 原型链 作用链的本质：就是指向一个指向变量对象（存放函数中的局部变量）的指针列表。 联系构造函数、原型以及实例的关系，如果把一个原型对象当做另一个原型对象的实例，这个原型对象有一个指向另一个原型的指针，另一个原型对象又是其他原型对象的实例，就构成了原型与实例的链条，也就是原型链。 ■ 代码实现 1234// SuperType 和 SubType 分别是两个构造函数// SubType 继承了 SuperType // SubType 没有用自己的原型对象，而是用了SuperType的新原型 SubType.prototype = new SuperType(); // SubType 的全部属性和方法来自于 SuperType ■ 图示 注意： 1) [[prototype]] 是实例所拥有的属性， 在原型链中，每个继承者都有该属性，因为是其他原型对象的实例。 2) 继承者的实例对象 constructor 属性指向的是父类的原型对象的构造函数。 ■ 原型搜索机制 搜索过程按照原型链向上搜索。 1）搜索实例 2）搜索 SubType.prototype 3）搜索 SuperType.prototype 4) 搜索 Object.prototype 1、默认的 Object 原型 所有的引用类型都继承于 Object ，所有的原型都包含一个内部指针，指向于 Object.protopyte 。这正是所有的引用类型都有 toString() 方法和 valueOf() 等默认方法存在的原因。 图示 2、判断原型和实例的关系 方式一：instanceof 1alert(实例 instanceof Object);//true 方式二：isPrototypeof() 1alert(Object.prototype.isPrototypeof(实例));//true 3、谨慎地定义子类方法 子类有时候覆盖超类中的某个方法或者添加超类中不存在的方法，一定放在替换原型语句之后。 代码实例 123456789101112SubType.prototype = new SuperType();//给 Subtype 添加新方法Subtype.prototype.getSubValue = function()&#123; return this.name;&#125;//重写 Supertype 方法Supertype.prototype.getSupertypeValue = function()&#123; return this.name; &#125; 注意： 1、Subtype 的实例调用重写的方法会调用重写方法； 2、Supertype 的实例调用重写方法会调用原来没有重写的方法； 3、Subtype 的实例调用新添加的方法； 字面量创建原型方法 不能用字面量创建原型方法，它会导致重写原型链。 4、原型链的问题 ① 原型链中所有属性共享。（修改某一对象的属性，会在另一对象反应出来） ② 子类不能向超类传递参数。 注意：原型链一般不单独使用！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【B+树】]]></title>
    <url>%2F2019%2F01%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90B%2B%E6%A0%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[Mysql 数据库的索引是如何实现的？]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【链表】]]></title>
    <url>%2F2019%2F01%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[LRU 缓存淘汰算法是用链表怎么实现的？ 目录[TOC] 链表一、什么链表？ 链表是由零散的内存块串联起来不连续的内存空间组成。 二、链表有什么特点？▍优点 1、插入、删除数据操作快。 2、支持动态扩容后。 ▍缺点 1、随机访问效率低下。 2、需要额外的存储指针的内存空间。 三、三种常见的链表结构1、单链表▉ 定义 链表通过指针将一组零散的内存块串联在一起。内存块称为链表的结点，每个节点都有存储下一结点的地址。 ▉涉及算法 查找操作 插入操作 删除操作 顺序表的合并 ▉代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248public class SinglyLinkedList &#123; /** * 功能：定义 Node 结点，Node 包含数据域和引用（作用：存储所指向对象的内存地址） * @author Boy Baby * */ public static class Node &#123; //数据域 private int data; //引用（存储所指向对象的内存地址） private Node next; //构造函数（初始化数据） public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125; //获取结点数据元素 public int getData() &#123; return data; &#125; &#125; private Node head = null; /** * 功能：单链表按值查找 * @param value * @return */ public Node findByValue(int value) &#123; //将链表的头部复制给结点 p（？） Node p = head; //判断结点 p 是否为空相当于判断链表是否为空链表且结点中的值是否和要查找的值是否相同 while (p != null &amp;&amp; p.data != value) &#123; //如果不相同，则将下一结点的地址赋值给 p p = p.next; &#125; //返回结点 p //思考：如果单链表中没有要查找的数据怎么办？这个函数还合适吗？ return p; &#125; /** * 功能:单链表按照索引查找 * @param index:索引 0 是第一个元素 * @return */ public Node findByIndex(int index) &#123; //将链表的头部复制给结点 p（？） Node p = head; //定义计数变量 pos int pos = 0; //如果单链表不是空链表且索引不为用户指定索引 while (p != null &amp;&amp; pos != index) &#123; //则将下一结点的地址赋值给 p p = p.next; //计数索引+1 ++pos; &#125; //返回结点 p //思考：如果单链表中没有要查找的数据怎么办？这个函数还合适吗？ return p; &#125; /** * 功能:将元素插入结点并且利用「头插法」插入链表 * @param value:结点插入元素值 */ public void insertToHead(int value) &#123; //生成新结点 Node newNode = new Node(value, null); //调用头插法函数 insertToHead(newNode); &#125; /** * 功能：头插法 * ① 如果链表是空链表（head == null）,需要将新结点作为头部 * ② 如果链表不是空链表,现将新节点的next指向头结点地址，然后将新结点替换成头部 * @param newNode:要插入的新节点 */ public void insertToHead(Node newNode) &#123; //如果链表是空链表 if (head == null) &#123; //将新结点作为头部 head = newNode; &#125; else &#123; //现将新节点的next指向头结点地址 newNode.next = head; //将新结点替换成头部 head = newNode; &#125; &#125; /** * 功能:将元素插入结点并且插入到指定结点的后面 * @param p:指定结点 * @param value:被插入结点的值域中的元素 */ public void insertAfter(Node p, int value) &#123; //生成新结点 Node newNode = new Node(value, null); //插入到指定结点后边 insertAfter(p, newNode); &#125; /** * 功能:插入到指定结点的后面 * 思考:如果该指定结点是最后一个结点，该方法是否适用？答:可行 * @param p:指定结点 * @param newNode:被插入的新结点 */ public void insertAfter(Node p, Node newNode) &#123; //判断要插入的链表是否是一个空链表 if (p == null) return; //将原本 p 结点存储下一结点的地址赋值给新结点的地址域 newNode.next = p.next; //然后p结点的地址域指向新结点 p.next = newNode; &#125; /** * 功能:将元素插入结点并且插入到指定结点的前边 * @param p:指定结点 * @param value:被插入结点的值域中的元素 */ public void insertBefore(Node p, int value) &#123; //生成新结点 Node newNode = new Node(value, null); //插入到指定结点前边 insertBefore(p, newNode); &#125; /** * 功能:插入到指定结点的前边 * @param p:指定结点 * @param newNode:被插入结点的值域中的元素 */ public void insertBefore(Node p, Node newNode) &#123; //判断要插入的链表是否是一个空链表 if (p == null) return; //判断指定的结点是否为头结点 if (head == p) &#123; //头插法 insertToHead(newNode); return; &#125; // 将单链表表头赋值给结点 q Node q = head; //如果此单链表为空链表，停止操作 if (q == null) &#123; return; &#125; // 通过结点 q 进行遍历查找到 p 结点 while (q != null &amp;&amp; q.next != p) &#123; q = q.next; &#125; //将p结点的地址存进新结点的地址域 newNode.next = p; //将新结点的地址存进q结点的地址域 q.next = newNode; &#125; /** * 功能：指点结点删除 * @param p:指定的结点 */ public void deleteByNode(Node p) &#123; //如果是空链表，直接return if (p == null || head == null) return; //如果指定的结点为头结点 if (p == head) &#123; //设置下一节点为头结点(所说的头结点为第二段) head = head.next; //问题:是否可以return？ &#125; //将存储头结点的地址赋值 q Node q = head; //如果链表不为空链表且地址域存储的值不为指定删除结点的地址就继续执行 while 循环 while (q != null &amp;&amp; q.next != p) &#123; //下一个结点赋值给 q 结点 q = q.next; &#125; //如果遍历到链表尾部还没有找到指定删除的结点，就 return。 if (q == null) &#123; return; &#125; //如果找到了，就删除p结点，也就是将该删除的结点下一结点的地址赋值给删除结点前的地址域存储 //q.next = p.next 与下边等式等价 q.next = q.next.next; &#125; /** * 功能:指定元素值删除链表结点 * @param value:指定的元素值 */ public void deleteByValue(int value) &#123; //如果链表为空链表，则就return if (head == null) return; //将存储头结点的地址赋值 q Node p = head; Node q = null; //如果不是空链表且当前结点的元素值不等于指定元素的值，继续执行while循环 while (p != null &amp;&amp; p.data != value) &#123; //将 p 结点赋值给 q 结点 q = p; //然后将下一个结点赋值给 p 结点 p = p.next; &#125; //如果遍历完单链表没有找到存储该元素的结点，就return。 if (p == null) return; //如果单链表为空链表（？） if (q == null) &#123; head = head.next; &#125; else &#123; //如果找到了，就删除p结点，也就是将该删除的结点下一结点的地址赋值给删除结点前的地址域存储 //q.next = p.next 与下边等式等价 q.next = q.next.next; &#125; &#125; //打印链表结点中所有数据结点 public void printAll() &#123; Node p = head; //由于链表最后一个存储的结点为null,所以不到 while (p != null) &#123; System.out.print(p.data + " "); p = p.next; &#125; System.out.println(); &#125;&#125; 2、循环链表 ▉ 定义 循环链表的尾结点指针是指向链表的头结点。 要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。 3、双向链表 ▉ 定义 双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。 ▉ 链表删除数据的情况 情况一：删除结点中“值等于某个给定值”的结点； 单链表：单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间复杂度为 O(n)。 情况二：删除给定指针指向的结点。 双向链表：双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历，所以时间复杂度为 O(1)。 ▉ 实际用途 在 java 语言中 LinkedHashMap 的底部实现原理就是用 LinkedHashMap 实现的。 四、数组和链表的区别 1、 数组的优缺点。 2、链表的优缺点。 五、数组和链表的「性能比较」▉ 比较一:1、数组简单易用，在内存的空间是连续的，可以有效的借助 CPU 的缓存机制预读数组中的数据，从而大大的增加了访问效率；而链表的内存空间不是连续的，对 CPU 缓存不友好，没有办法进行预读处理。 2、CPU 缓存实现了比内存访问速度更快的机制，也就是 CPU 缓存存在的意义:为了弥补内存访问速度过慢与 CPU 执行速度快之间的差异而引入。 3、对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到 CPU 缓存这样执行速度会快于存储空间不连续的链表存储。 4、补充：什么是 CPU 缓存机制？ CPU 在读取内存数据的时候，会先将读取到的数据加载到 CPU 缓存中，每次 CPU 在内存中读取数据时并不是访问特定地址的数据，而是在内存中读取一个数据块，并保存在 CPU 缓存中。当 CPU 再次访问此数据时，先在 CPU 缓存查找，如果查找到了就不用去内存中查找了，实现了比内存访问快的 CPU 缓存机制，也就是 CPU 缓存存在的意义：为了弥补内存访问速度慢的与 CPU 访问速度快之间差异而引用的。 ▉ 比较二：1、数组缺点就是大小固定，一旦生命就需要占内存中连续的空间，如果声明数组过大，系统可能没有足够连续的内存空间进行分配。如果声明数组过小，就会出现不够用的情况，然后我们需要再申请一个比较大的数组，将之前数组的数据拷贝进去，费时费力。链表就不同了，支持动态扩容。 2、数组和容器的缺点 在 JAVA 中我们使用到的 ArrayList 容器也支持动态扩容，和数组一样，当容器中没有空间的时候，就会扩展到空间的1.5倍，之前的数据就会拷贝到新建空间容器上去，这个过程很耗时。 3、链表的缺点 1）如果对内存的要求很苛刻，建议使用数组。因为链表中的每个结点都需要消耗额外的内存空间去存储指向下一个结点的指针，所以内存消耗会翻倍。 2）再加上对链表频繁的插入和删除，导致频繁的申请释放内存空间，容易遭成内存碎片，在 java 中就会导致频繁的 GC（垃圾回收）。 六、设计思想（空间换时间）1、当内存充足时。 如果我们更要追加代码的执行速度，我们可以选择空间复杂度较高、但是时间复杂度较低的算法或者数据结构。 2、实际用途 1） 缓存就用到了空间换时间设计思想 。如果我们把数据存到硬盘上，就会比较节省内存，但是每查找一次数据都要访问一次硬盘，比较慢。但是通过缓存技术，事先将数据加载到内存中，虽然比较耗费内存空间，但是每次查找数据的效率大大增加了。 2）当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。 六、实例：基于链表如何实现 LRU 缓存淘汰算法？1、算法思路 假设有一个有序的单链表，在内存中，越靠近单链表的尾部越早访问，那么，当一个新数据来插入到内存链表中，就从头开始遍历整个链表，然后该数据是否已在缓存中。 2、情况分析▉情况一：数据已在缓存中 对存在的数据进行删除，然后将新数据插入到头部。 (链表是有序链表，按照访问时间排序，访问时间值最晚的放到链表尾部，最早的放到链表头。当要淘汰一个数据时，直接删除链表尾部的结点，当要加入一个数据时，直接插入链表头部） 。 ▉情况二：数据不在缓存中 缓存未满状态 直接将该数据插入到链表的头部。 缓存已满状态 先删除链表尾部的数据，然后将数据插入到链表的头部。 3、时间复杂度 无论缓存有没有满，都要遍历一遍整个链表，所以缓存的访问时间复杂度为O(n)。 4、算法优化 使用散列表进行优化，插入数据的时候，存到散了表中，再次查询数据的时候，直接从散列表中查询，查询的时间复杂度为 O（1）。 七、思考题1、用数组怎么实现 LRU 缓存淘汰算法？■ 算法思路 在内存中，越靠近数组的尾部越早访问，那么，当一个新数据来插入到数组中，我们就从头开始遍历整个数组，然后该数据是否已在缓存中。 ■ 情况分析情况一：已存在数组中，我们直接将其标记，而不是真正的删除，当数组满元素的时候，我们再进行对标记的元素进行删除，然后将数据插入数组的头部。插入数据时，将头部元素直接放到数据的尾部，然后插入到数组的头部。 情况二：数据不在缓存中。 缓存未满：将头部元素直接放到数据的尾部，然后插入到数组的头部。 缓存已满：删除所有标记的数据，如果没有标记的数据，就删除尾部元素。 ■ 算法优化 同样使用散列表进行优化。 2、用单链表存储的字符串如何判断回文字符串？解题思路是什么？时间空间杂度多少？ 答： 1）循环这个回文链表 L1，在遍历到一半之前把逆文存在一个L2中； 例如L1 为A-&gt;B-&gt;C-&gt;B-&gt;A，那么遍历到一半时，L2 为：B-&gt;A； 偶数和奇数的区别在与中间的节点要不要放在L2中。 2） 继续遍历比较L1,L2两个链表各个元素是否相等，如果不相等则立即返回；如果比较到最后遍历结束，则说明是回文；因此通过一次遍历就知道这个链表是否为回文。时间复杂度为O(n)。 3、总结 对于执行效率较慢的程序来说，我们可以通过消耗更多的内存空间（空间换时间）来进行优化；而消耗过多的内存程序，我们可以通过消耗更多的时间（时间换空间）来降低内存的消耗。 八、写出链表代码的五个技巧1、理解指针和引用的含义 指针或引用：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。 2、警惕指针丢失和内存泄漏 1）C 语言中，删除链表结点时，要释放内存空间。如果没有手动释放结点对应的内存空间，就会产生内存泄漏。对于像 java 这中虚拟机自动管理内存空间的编程语言来说，就无需考虑这么多。 2）指针指向自己，就会导致指针丢失，从而导致内存泄漏。 123456//错误p-&gt;next = x; // 将 p 的 next 指针指向 x 结点；x-&gt;next = p-&gt;next; // 将 x 的结点的 next 指针指向 b 结点；//正确x-&gt;next = p-&gt;next; // 将 x 的结点的 next 指针指向 b 结点；p-&gt;next = x; // 将 p 的 next 指针指向 x 结点； 3、利用哨兵简化实现难度■ 链表代码不足 123456789// 插入链表中的第一个结点if (head == null) &#123; head = new_node;&#125;//删除链表最后一个结点if (head-&gt;next == null) &#123; head = null;&#125; 针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样实现的代码不简洁，很繁琐，考虑不全面会出错。 ■ 添加哨兵改进 添加一个带头的链表，该头结点不存储任何数据。 使用哨兵简化编程的例子： 插入排序 归并排序 动态规划 ■ 示例 代码一：普通解决123456789101112131415161718// 在数组 a 中，查找 key，返回 key 所在的位置// 其中，n 表示数组 a 的长度int find(char* a, int n, char key) &#123; // 边界条件处理，如果 a 为空，或者 n&lt;=0，说明数组中没有数据，就不用 while 循环比较了 if(a == null || n &lt;= 0) &#123; return -1; &#125; int i = 0; // 这里有两个比较操作：i&lt;n 和 a[i]==key. while (i &lt; n) &#123; if (a[i] == key) &#123; return i; &#125; ++i; &#125; return -1;&#125; 代码二：哨兵思想12345678910111213141516171819202122232425262728293031323334353637// 在数组 a 中，查找 key，返回 key 所在的位置// 其中，n 表示数组 a 的长度// a = &#123;4, 2, 3, 5, 9, 6&#125; n=6 key = 7// a = &#123;4, 2, 3, 5, 9, 6&#125; n=6 key = 6int find(char* a, int n, char key) &#123; if(a == null || n &lt;= 0) &#123; return -1; &#125; // 这里因为要将 a[n-1] 的值替换成 key，所以要特殊处理这个值 if (a[n-1] == key) &#123; return n-1; &#125; // 把 a[n-1] 的值临时保存在变量 tmp 中，以便之后恢复。tmp=6。 // 之所以这样做的目的是：希望 find() 代码不要改变 a 数组中的内容 char tmp = a[n-1]; // 把 key 的值放到 a[n-1] 中，此时 a = &#123;4, 2, 3, 5, 9, 7&#125; a[n-1] = key; int i = 0; // while 循环比起代码一，少了 i&lt;n 这个比较操作 while (a[i] != key) &#123; ++i; &#125; // 恢复 a[n-1] 原来的值, 此时 a= &#123;4, 2, 3, 5, 9, 6&#125; a[n-1] = tmp; if (i == n-1) &#123; // 如果 i == n-1 说明，在 0...n-2 之间都没有 key，所以返回 -1 return -1; &#125; else &#123; // 否则，返回 i，就是等于 key 值的元素的下标 return i; &#125;&#125; 4、重点留意边界条件处理 如果链表为空，是否可以正常工作？ 如果链表只包含一个结点时，代码是否能够正常工作？ 如果链表只包含两个结点时，代码是否能够正常的工作？ 代码逻辑在处理头结点和尾结点的时候，是否可以正常的工作？ 5、举例画图，辅助思考6、多写多练，没有捷径■ 链表的五种常见操作： 单链表反转 链表中环的检测 两个有序链表合并 删除链表倒数第 n 个结点 求链表的中间结点 ■ 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220package easy_test;/** * 1) 单链表反转 * 2) 链表中环的检测 * 3) 两个有序的链表合并 * 4) 删除链表倒数第n个结点 * 5) 求链表的中间结点 * * Author: 小鹿 */public class LinkedListAlgo &#123; public static class Node &#123; private int data; private Node next; public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125; public int getData() &#123; return data; &#125; &#125; public static Node createNode(int value) &#123; return new Node(value, null); &#125; /** * 功能:单链表反转 * 思路:创建一个头指针和尾指针,现将第一个结点拿出，放到做后一个节点，并将最后一个指针的值赋值给在链表中拿出的结点并向前移动指向刚拿出的结点地址。 * 如果还存在没有遍历完的结点，头指针就向后移动，继续遍历。 * @param list:传入要反转的链表 * @return */ public static Node reverse(Node list) &#123; //定义头结点 Node headNode = null; //定义尾指针 Node previousNode = null; //定义头指针并指向链表 Node currentNode = list; //如果指针指向的链表不为空,就执行以下循环 while (currentNode != null) &#123; //先将指针指向的结点中存储的下一结点地址存储到 nextNode 中 Node nextNode = currentNode.next; //判断指针指向该结点后是否还有结点，如果是 null 的话，就相当于指针处于链表的最后一个结点，而该结点的next是null(相当于为没有下一结点) if (nextNode == null) &#123; //如果是最后一个结点，拿出来当做反转链表的头结点 headNode = currentNode; &#125; //将已经反转好的链表地址存储到在单链表中拆解下来的结点的地址域中 currentNode.next = previousNode; //尾指针向前移动一个结点 previousNode = currentNode; //头指针向后移动 currentNode = nextNode; &#125; return headNode; &#125; /** * 功能:检测单链表是否为环 * 思路:定义两个指针(快指针、慢指针),两个指针的初始化位置是fast指针在前，slow指针在后,每判断一个两个指针是否在同一个位置来检测环，如果不在同一位置 * 就使fast指针向后走三步，慢指针向前走一步，每走一步就判断一下。如果指针遇到 null 的情况下，就说明单链表不为null。否则这样一直循环下去， * 直到两个指针重合。 * @param list:传入要检测的单链表 * @return */ public static boolean checkCircle(Node list) &#123; // 如果单链表为空,直接返回false if (list == null) return false; //定义一个快指针 fast Node fast = list.next; //定义一个慢指针 slow Node slow = list; //判断两个指针指向的结点是否为空 while (fast != null &amp;&amp; fast.next != null) &#123; //如果不为空就 fast 指针向后移动两个结点 fast = fast.next.next; // solw 向后移动一个结点 slow = slow.next; //如果两个指针重合,则返回 true if (slow == fast) return true; &#125; //如果两个指针初始化就为 null,直接返回 false return false; &#125; /** * 功能:单链表的合并 * @param la:链表 la * @param lb:链表 lb * @return */ public static Node mergeSortedLists(Node la, Node lb) &#123; //判断两个单链表是否为null if (la == null) return lb; if (lb == null) return la; //分别将两个链表赋值给 p、q Node p = la; Node q = lb; //定义一个头结点 Node head; //比较两个结点数据域中元素的大小 if (p.data &lt; q.data) &#123; //如果 p 数据小于 q 数据，将 p 结点赋值给head head = p; //数据小的那条链表的指针向后移动一位 p = p.next; &#125; else &#123; //否则，移动另一个指针 head = q; q = q.next; &#125; //将 head 结点赋值给 r Node r = head; //判断两个链表指针指到最后一个结点,要想跳出循环，肯定p、q其中有一个先遍历完 while (p != null &amp;&amp; q != null) &#123; //如果没有指到最后的结点,继续进行比较大小 if (p.data &lt; q.data) &#123; //r 继承着 head 继续向下添加结点 r.next = p; p = p.next; &#125; else &#123; r.next = q; q = q.next; &#125; //r 指针向下移动，指向新添加的结点 r = r.next; &#125; //判断 p、q 两个链表哪一个先遍历晚，最后将剩余的链表拼接到合成链表的最后 if (p != null) &#123; r.next = p; &#125; else &#123; r.next = q; &#125; //返回头结点 return head; &#125; /** * 功能:删除倒数第K个结点 * 思路:我们想需要定义一个头指针，从链表的头部向后移动 k个单位，然后用头指针(fast)标记，在单链表的头部再定义一个指针(slow) * 之后，fast每向后移动一个结点，solw就紧跟移动一个结点，直到 fast 指针移动到了最后一个结点，slow 指针所指向的结点就是倒数 * 第k个结点,进行单链表的删除即可。 * @param list:要删除的单链表 * @param k:倒数第 k 个 * @return */ public static Node deleteLastKth(Node list, int k) &#123; //将fast指针指向list单链表的开始的第一个结点 Node fast = list; //i 用来进行计数 int i = 1; //通过 while 循环,正想找到第 K 个结点(这里有两个判断条件,fast != null 条件的作用是要删除倒数第k个结点 //的单链表不能小于k的长度) while (fast != null &amp;&amp; i &lt; k) &#123; fast = fast.next; ++i; &#125; //如果单链表的长度小于 k ,就返回 list 单链表 if (fast == null) return list; //前边找到第 k 个结点之后,让 slow 指向第一个结点 Node slow = list; Node prev = null; //判断fast指针也就是最前边的指针下一个节点是否为 null(如果为null相当于到尾部了) while (fast.next != null) &#123; //如果不为 null , fast 指针向后移动一个指针，slow 指针也要移动一个 fast = fast.next; //prev 指向移动前的结点，为了区别下方单链表的长度和 k 相等 prev = slow; //slow 向后移动一个 slow = slow.next; &#125; //这个判断是，如果单链表的长度正好等于 k ,删除倒数第K个结点也就是删除头结点。 if (prev == null) &#123; list = list.next; &#125; else &#123; //不为上述情况就可以用单链表的删除思想了 prev.next = prev.next.next; &#125; //返回已经删除结点的链表 return list; &#125; /** * 功能:求中间结点 * 思路:定义一个指针 fast 用来移动做逻辑判断(画一下图就很清晰) * @param list:传入要求中间结点的链表 * @return */ public static Node findMiddleNode(Node list) &#123; //如果单链表为 null,就返回 null if (list == null) return null; //slow 指向的就是 fast.next 与 fast.next.next 中间的那个结点 Node fast = list; Node slow = list; //循环遍历满足fast指针条件单链表 while (fast.next != null &amp;&amp; fast.next.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; //返回的slow就是中间结点 return slow; &#125; //输入链表的所有值 public static void printAll(Node list) &#123; Node p = list; while (p != null) &#123; System.out.print(p.data + " "); p = p.next; &#125; System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 高级程序设计第四章【内存问题】]]></title>
    <url>%2F2019%2F01%2F28%2FJavaScript%20%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%90%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[变量、作用域和内存问题 第四章 变量、作用域和内存问题4.1 基本类型和引用类型的值基本类型的值 七种基本类型：Undefined、null、Number、String、Boolean、Symbol、Object。访问基本类型是按照值访问的。 引用类型的值 由多个值构成的对象。访问引用类型是按照引用（地址）访问的。 4.1.1 动态的属性基本类型： 不可以动态的添加属性，添加属性之后为 undefined 。 引用类型： 可以动态的进行添加属性，以便将来使用。 4.1.2 复制变量值12var num1 = 5;var num2 = num1; 基本类型： num1 会在 num2 变量上创建一个新值，将值复制给 num2 ，num1 和 num2 的值是相互独立的。 【此处加图】 1234var obj1 = new Object();var obj2 = obj1;obj1.name = “zhang”；alert(obj2.name); //zhang 引用类型： 复制后的对象(obj2)和原对象(obj1)指向堆内存中的同一个对象，一个变化，另一个对象的属性随之变化。 【此处加图】 4.1.3 传递参数① 什么是值传递？什么是引用传递？ 值传递：当我们往函数的形参传递实参的时候，修改形参的值并不会影响实参的值。 引用传递：函数的形参接受实参是隐示引用，改变形参的值就会改变实参的值。 ② js 传递参数 ECMAScript 中「所有」的函数参数都是按「值传递」的。也就是说，从外部的值复制给函数内部的参数就像一个变量的值复制给另一个变量的值一样。 4.1.4 检测类型基本类型 typeof : 一般用 typeof 检测undefined、String、Number、Boolean类型的数据。如果检测一个对象或者Null，都会返回一个 Object，从而无法判断是什么类型。 对象 instanceof： 用 instance 检测对象都会返回 true。 4.2 执行环境及作用域 执行环境：执行环境定义了变量或函数有权访问的其他数据，决定了各自的行为权限。 变量对象：每个执行环境都有一个变量对象，该执行环境中所有的变量和函数都存储到该变量对象中。 作用域链：保证对执行函数有权访问的所有变量和函数的有序访问。 ■ 浏览器和函数的执行环境 1、在 web 浏览器中，全局的执行环境被公认为 window 对象。 2、web 浏览器有自己的执行环境，函数也有当一个函数将被执行的时候，该函数的环境将被推进环境栈中，等函数执行完成，该函数的环境出栈，将执行权交给之前的函数。 ■ 作用域链 全局 —&gt; 局部，环境内部可以访问到环境外部作用域。 示例代码： 123456789var color = &apos;red&apos;;function changColor()&#123; var color1 = &apos;blue&apos;; function swapColor()&#123; var color2 = &apos;green&apos;; &#125;&#125; 作用域链图示：【图】 4.2.1 延长作用域链 (?) 当执行进入到一下两种语句时，作用链将会加长。 try - catch 语句和 catch 块 with 语句 4.2.2 没有块级作用域 在 if 语句或 for语句的 { } 语句块中，js 声明的变量将会添加到当前执行函数中去。与 java 等其他语言不同，在 { } 执行完会销毁。 例子： 1234for(var i = 1;i&lt;=10;i++)&#123; doSomething(i);&#125;alert(i); //10 1、声明变量用 var 声明的变量会被自动添加到最近的执行函数中去，而没有被 var 声明的变量，将会添加到全局变量环境中去。 注意：我们建议初始化变量之前一定要声明。 2、查询标识符 当我们读取一个标识符的时候，首先在作用域链的最前端进行搜索，如果有函数，就在函数局部搜索查看当前是否有该标识符，如果没有就继续沿作用域链向上搜，如果没有发现，则宣告未声明该标识符。当我们在局部查到了，就停止搜索，返回该执行环境变量的值。 4.3 垃圾回收 在浏览器中，javascript 有自己管理的垃圾回收机制。对内存进行自动管理，而无需操作员手动管理。垃圾回收器跟踪哪些变量有用，哪些变量没有用，对没有用的变量进行标记，以备在将来收回内存空间。 4.3.1 标记清除 标记所有内存变量标记 ——&gt; 删除标记进行使用 ——&gt; 使用完成添加删除标记 ——&gt; 对标记删除的进行内存清理。垃圾回收机制的运行间隔很重要，关系到性能问题。 4.3.2 内存问题■ 性能问题 因为为了安全起见，防止运行 js 网页耗尽系统的所有内存导致系统崩溃，所以 javascript 给浏览器分配的内存数量远小于桌面应用程序，也影响到了 js 在网页中的执行语句的条数。 ■ 性能优化 解除引用：为了占用最少的空间使网页得到最大的优化，所以我们将不用的变量设置为 null。适合全局变量和局部变量，局部变量通常会在函数执行完成之后自己解除引用。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【动态规划】]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美中的动态规划。 动态规划基础篇一、认识动态规划 问题：“双十一” 购物问题，选择购物车中商品尽最大的能够参与满减活动。 0 - 1 背包问题问题： 背包问题我们进行改进，对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？ 回溯算法可以解决这个问题，但是需要穷举所有的情况，时间复杂度非常高，接下来我们用动态规划来解决此问题。 回溯算法代码实现： 123456789101112131415// 回溯算法实现。注意：我把输入的变量都定义成了成员变量。private int maxW = Integer.MIN_VALUE; // 结果放到 maxW 中private int[] weight = &#123;2，2，4，6，3&#125;; // 物品重量private int n = 5; // 物品个数private int w = 9; // 背包承受的最大重量public void f(int i, int cw) &#123; // 调用 f(0, 0) if (cw == w || i == n) &#123; // cw==w 表示装满了，i==n 表示物品都考察完了 if (cw &gt; maxW) maxW = cw; return; &#125; f(i+1, cw); // 选择不装第 i 个物品 if (cw + weight[i] &lt;= w) &#123; f(i+1,cw + weight[i]); // 选择装第 i 个物品 &#125;&#125; 递归树实现： 递归中存在的问题在这个地方我们可以进行优化，就是重复计算问题。递归树的表现形式（i，w）,i 表示将要决策的第几个物品，w 是背包中已存在物品的总重量。 我们可以对地归树中存在的问题进行改进，通过散列表来存储已经计算过的值，当我们再次计算到该值的时候，我们就直接使用，而不是重复计算，降低效率。 1234567891011121314151617private int maxW = Integer.MIN_VALUE; // 结果放到 maxW 中private int[] weight = &#123;2，2，4，6，3&#125;; // 物品重量private int n = 5; // 物品个数private int w = 9; // 背包承受的最大重量private boolean[][] mem = new boolean[5][10]; // 备忘录，默认值 falsepublic void f(int i, int cw) &#123; // 调用 f(0, 0) if (cw == w || i == n) &#123; // cw==w 表示装满了，i==n 表示物品都考察完了 if (cw &gt; maxW) maxW = cw; return; &#125; if (mem[i][cw]) return; // 重复状态 mem[i][cw] = true; // 记录 (i, cw) 这个状态 f(i+1, cw); // 选择不装第 i 个物品 if (cw + weight[i] &lt;= w) &#123; f(i+1,cw + weight[i]); // 选择装第 i 个物品 &#125;&#125; 动态规划解决： 1、首先，我们将整个过程分解成 n 个阶段，每个阶段决策是否放入背包，每个决策完成之后会有多种情况，也就是对应递归树中不同的结点（不同状态）。 2、我们将每个阶段相同的情况进行合并，只记录一次，可以避免每个阶段情况数量的指数增长。 3、用二维数组来记录每个阶段不同的状态。 4、第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states[0][2]=true 来表示这两种状态。 5、以此类推，我们将做成二维数组图。 6、代码实现： 123456789101112131415161718weight: 物品重量，n: 物品个数，w: 背包可承载重量public int knapsack(int[] weight, int n, int w) &#123; boolean[][] states = new boolean[n][w+1]; // 默认值 false states[0][0] = true; // 第一行的数据要特殊处理，可以利用哨兵优化 states[0][weight[0]] = true; for (int i = 1; i &lt; n; ++i) &#123; // 动态规划状态转移 for (int j = 0; j &lt;= w; ++j) &#123;// 不把第 i 个物品放入背包 if (states[i-1][j] == true) states[i][j] = states[i-1][j]; &#125; for (int j = 0; j &lt;= w-weight[i]; ++j) &#123;// 把第 i 个物品放入背包 if (states[i-1][j]==true) states[i][j+weight[i]] = true; &#125; &#125; for (int i = w; i &gt;= 0; --i) &#123; // 输出结果 if (states[n-1][i] == true) return i; &#125; return 0;&#125; 动态规划的时间复杂度 回溯算法的时间复杂度为 O(2^n)，可知上述代码，动态时间复杂度为 O(n*w)。 n 表示物品个数，w 表示背包可以承载的总重量。 动态规划的空间复杂度 尽管执行效率很高，导师我们需要一个空间为 n*w+1 的二维数组，这是一种空间换时间的解决思路。 动态规划空间消耗改进 1234567891011121314public static int knapsack2(int[] items, int n, int w) &#123; boolean[] states = new boolean[w+1]; // 默认值 false states[0] = true; // 第一行的数据要特殊处理，可以利用哨兵优化 states[items[0]] = true; for (int i = 1; i &lt; n; ++i) &#123; // 动态规划 for (int j = w-items[i]; j &gt;= 0; --j) &#123;// 把第 i 个物品放入背包 if (states[j]==true) states[j+items[i]] = true; &#125; &#125; for (int i = w; i &gt;= 0; --i) &#123; // 输出结果 if (states[i] == true) return i; &#125; return 0;&#125; 补充：j 是按照从大到小来计算的，如果从小到大计算存在重复，我们可以进行改进。 0—1背包升级问题 增加的条件是，在满足以上条件的同时，要使的装入的物品价值最大，应该怎么做？ 实现思路 我们继续画递归树，然后用（i,w+1）来表示，w+1 不能用 boolean 类型了，而是代表最大价值。 代码实现 1234567891011121314151617181920212223242526272829public static int knapsack3(int[] weight, int[] value, int n, int w) &#123; int[][] states = new int[n][w+1]; for (int i = 0; i &lt; n; ++i) &#123; // 初始化 states for (int j = 0; j &lt; w+1; ++j) &#123; states[i][j] = -1; &#125; &#125; states[0][0] = 0; states[0][weight[0]] = value[0]; for (int i = 1; i &lt; n; ++i) &#123; // 动态规划，状态转移 for (int j = 0; j &lt;= w; ++j) &#123; // 不选择第 i 个物品 if (states[i-1][j] &gt;= 0) states[i][j] = states[i-1][j]; &#125; for (int j = 0; j &lt;= w-weight[i]; ++j) &#123; // 选择第 i 个物品 if (states[i-1][j] &gt;= 0) &#123; int v = states[i-1][j] + value[i]; if (v &gt; states[i][j+weight[i]]) &#123; states[i][j+weight[i]] = v; &#125; &#125; &#125; &#125; // 找出最大值 int maxvalue = -1; for (int j = 0; j &lt;= w; ++j) &#123; if (states[n-1][j] &gt; maxvalue) maxvalue = states[n-1][j]; &#125; return maxvalue;&#125; 二、思考：双十一凑单购物问题1、问题 淘宝双十一购物，满 200 减 100 ，为了尽最大条件满足减满，怎么选择购物车里的物品呢？ 2、问题分析 1、如果用回溯算法解决，穷举所有的可能，选择解决200的那套方案，但是效率很低下，时间服阿杜非常高，指数级别。 2、如果我们采用动态规划去解决，但是并不像 0-1 背包问题，满足最大限度，而是接近最大限度的最小值（超过200最小值）。 3、求出接近200的最小值之后，然后倒推出我们可以选择哪些购买的商品。 3、解决思路 1、购物车中有 n 个商品，针对每个商品进行决策是否购买，每次决策都对应不同的状态集合，我们用一个数组来表示。 2、我们设定一份最大上限值，比如 1001，我们要找的是大于等于 200（满减条件）的值中最小的。 4、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243// items 商品价格，n 商品个数, w 表示满减条件，比如 200public static void double11advance(int[] items, int n, int w) &#123; // 设置上限为 3 倍 boolean[][] states = new boolean[n][3*w+1]; // 第一行的数据要特殊处理（也就是第 0 个物品两种选择） states[0][0] = true; states[0][items[0]] = true; // 动态规划 for (int i = 1; i &lt; n; ++i) &#123; // 不购买第 i 个商品（结合二维图表来分析） for (int j = 0; j &lt;= 3*w; ++j) &#123; //对上一层状态集合改变下一层状态集合 if (states[i-1][j] == true) &#123; //进行标记true states[i][j] = states[i-1][j]; &#125; &#125; // 购买第 i 个商品 for (int j = 0; j &lt;= 3*w-items[i]; ++j) &#123; // 商品价格相加 if (states[i-1][j]==true) states[i][j+items[i]] = true; &#125; &#125; int j; for (j = w; j &lt; 3*w+1; ++j) &#123; // 输出结果大于等于 w 的最小值 if (states[n-1][j] == true) break; &#125; // 没有可行解 if (j == -1) return; // 倒推遍历可购买商品（i 表示二维数组中的行，j 表示列） for (int i = n-1; i &gt;= 1; --i) &#123; if(j-items[i] &gt;= 0 &amp;&amp; states[i-1][j-items[i]] == true) &#123; // 购买这个商品的价格 System.out.print(items[i] + " "); //总价格减去已购买商品的价格 j = j - items[i]; &#125; // else 没有购买这个商品，j 不变。 &#125; //如果遍历完成所有的商品价格，不等于大于200的最小值，就输出第一个商品价格 if (j != 0) System.out.print(items[0]);&#125; 所有的商品可购买状态是由上一层决策推导而来的。 1、如果 states[i-1][j] 可达，就说明我们没有买这个商品； 2、如果 states[i-1][j-value[i]] 可达，就说明，我们已购买该商品。 3、如果两者都可达到，我们就随意选择一种，继续迭代其他商品。 动态规划理论篇一、什么样的问题适合用动态规划？ 一个模型三个特征。 1、一个模型 多阶段策略最优解模型： ① 一般是用动态规划来解决最优问题。 ② 需要经历多个决策阶段。每个决策阶段都对应着一组状态。 ③ 寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。 2、三个特征① 最优子结构 问题的最优解包含子问题的最优解。后面阶段的状态可以通过前面阶段的状态推导出来。 ② 无后效性 1、在推导后边的状态时，只关心前边的状态，不关心前边的状态是怎么推到出来的。 2、某一决策状态一旦确认，就不受后边阶段的影响。 ③ 重复子问题 不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。 3、实例剖析■ 问题 有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？ ■ 一个模型分析 1、从 (0, 0) 走到 (n-1, n-1)，总共要走 2 (n-1) 步，也就对应着 2(n-1) 个阶段。每个阶段都对应着向右或者向左走两种决策，每个阶段对应一个状态集合，符合一个模型。 2、我们把状态定义为 min_dist(i,j) ,其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。 ■ 三个特征分析 重复子问题：通过回溯算法画出递归树，所有的情况就会列出，有多种路线，符合重复子问题。 无后效性：(i, j) 只能通过 (i-1, j)，(i, j-1) 这两个状态推导而来，之关心这两种状态，并不关心怎么这两种状态怎么达到的。仅仅允许往右往左移动，不能后退，前边的状态不会受到后边状态的改变，符合无后效性。 最优子结构：以上两种状态其中一种肯定是最优解，所以每个决策的子问题都对应最优解，符合最优子结构。 ■ 代码实现 12345678910111213141516171819public int minDistDP(int[][] matrix, int n) &#123; int[][] states = new int[n][n]; int sum = 0; for (int j = 0; j &lt; n; ++j) &#123; // 初始化 states 的第一行数据 sum += matrix[0][j]; states[0][j] = sum; &#125; sum = 0; for (int i = 0; i &lt; n; ++i) &#123; // 初始化 states 的第一列数据 sum += matrix[i][0]; states[i][0] = sum; &#125; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt; n; ++j) &#123; states[i][j] = matrix[i][j] + Math.min(states[i][j-1], states[i-1][j]); &#125; &#125; return states[n-1][n-1];&#125; 二、动态规划解题思路 两种思路，状态转移表法和状态转移方程法。 1、状态转移法■ 解决思路 ① 动态规划问题一般可以使用回溯算法和暴力搜索解决，定义状态。 ② 画出每个状态的递归树，看是否有子节点问题。 ③ 直接用回溯加 ”忘备录“ 解决重复子问题；状态转移法； ■ 状态转移 画出状态表，根据决策先后过程，找出递归关系，分阶段填写表，然后将填写表这个过程翻译成代码，这就是动态规划代码了。 2、状态转移方程法 某个问题通过子问题来递归求解，所谓的最优子结构，写递推公式，也就是状态转移方程。两种实现方式：递归加 “忘备录” 、迭代递归。 ■ 状态转移方程 状态转移方程是解决动态规划的关键。 12//状态转移方程min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j)) ■ 代码实现 (?) 12345678910111213141516171819202122232425private int[][] matrix = &#123;&#123;1，3，5，9&#125;, &#123;2，1，3，4&#125;，&#123;5，2，6，7&#125;，&#123;6，8，4，3&#125;&#125;;private int n = 4;private int[][] mem = new int[4][4];// 调用 minDist(n-1, n-1);public int minDist(int i, int j) &#123; if (i == 0 &amp;&amp; j == 0) return matrix[0][0]; if (mem[i][j] &gt; 0) &#123; return mem[i][j]; &#125; int minLeft = Integer.MAX_VALUE; if (j-1 &gt;= 0) &#123; minLeft = minDist(i, j-1); &#125; int minUp = Integer.MAX_VALUE; if (i-1 &gt;= 0) &#123; minUp = minDist(i-1, j); &#125; int currMinDist = matrix[i][j] + Math.min(minLeft, minUp); mem[i][j] = currMinDist; return currMinDist;&#125; 三、四种算法思想 贪心算法、分治算法、回溯算法、动态规划。 1、回溯算法 ① 能用贪心、动态规划解决的问题都能用回溯算法解决。 ② 回溯穷举所有情况，指数级别的时间复杂度，只能解决小规模数据。 2、动态规划 ① 不是所有问题都能用动态规划，需要满足三个特征。 ② 在重复子问题上，动态规划和分治算法 有区分。 3、贪心算法 ① 动态规划里边的一种特殊情况。 ② 三个特征，最优子结构、无后效性、贪心选择性。 ③ 每个局部的最优选择，构成全局的最优选择。 4、分治算法 ① 分割成子问题，不能有重复子问题。 ② 动态规划高效的原因有很多重复子问题。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之JavaScript类型2【基本类型】]]></title>
    <url>%2F2019%2F01%2F27%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BJavaScript%E7%B1%BB%E5%9E%8B3%E3%80%90%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进重学前端中的基本类型！ javascript 基本类型 运行时类型是代码实际执行过程中我们用到的类型。所有的类型数据都会属于 7 个类型之一。从变量、参数、返回值到表达式中间结果，任何 JavaScript 代码运行过程中产生的数据，都有运行时类型。 一、七大基本类型 Undefined; null; Boolean; String; Number; Symbol; Object; ■ Undefined、Null① Undefined MDN 官网解释： A primitive value automatically assigned to variables that have just been declared or to formal arguments for which there are no actual arguments。 Undefined 表示未定义，只有一个值为 undefined。 问题：为什么编程规范用 void（0）来代替 undefind ？ 答：因为 undefined 是一个变量，并非是一个关键字，这是 js 语言公认的设计失误之一，所以为了避免被篡改，所以建议用 void(0) 代替它。 ② Null Null 值为一个空对象的指针，用 type 检测类型为 object 类型。Null 为值定义了，但是为空，是 js 中的关键字。 ③ undefined/null 的区别 1、undefined 值是派生自 null 的值，所以 alter(undefined == null) // true。 2、声明的变量没有必要显示的赋值 undefined ,而 null 可以将即将保存的对象的变量赋值为 null。 ■ String 字符串类型：String 最大长度为 2^53 -1 。所谓的字符串长度并不是字符数，而是字符串的 uft16 编码的影响的。 ■ Number① 区分 +0 和 -0 。 加法运算没有区别，但是除法计算注意，除以 -0 会得到 -Infinity 从而导致错误。用 1/x 来检测 Infinity 或 -Infinity。 ② 为什么 0.1+0.2 不等于 0.3。 非整数类型不能用 == 或者 === 来比较。之所以上方不相等原因就是浮点型的预算精度问题，导致不是严格相等，只是相差了微小的值。 ③ 检测浮点型的方法（最小精度） J检查等式左右两边的差的绝对值是否小于最小精度来比较浮点数。 1console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON); //true ■ symbol Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合。 ① 创建 Symbol 变量。 1var mySymbol = Symbol("my symbol"); //使用全局的 symbol 函数来创建 ■ Object① 让对象的方法用在基本类型上。 运算符提供了装箱操作，它会根据基础类型构造一个临时对象。 1cosole.log(&quot;abc&quot;.charAt(0)); //a ② 在原型方法上添加方法和属性。 12345Symbol.prototype.hello = () =&gt; console.log(&quot;hello&quot;);var a = Symbol(&quot;a&quot;);console.log(typeof a); //symbol，a 并非对象a.hello(); //hello，有效 二、类型转换 “==” 运算是 js 设计的失误，“==” 运算试图跨类型比较，规则非常的复杂，很多实际中禁止使用 “==” 运算。我们通常进行显示的转换之后，用 “===” 来进行比较。 ■ StringToNumber 字符串到数字类型的转换。，类型转换支持十进制、二进制、八进制和十六进制。 注意： parseInt 和 parseFloat 转换语法与这里的转换不尽相同。 1、parseInt 不传入第二个参数，只支持 16 进制的转换，会忽略非数字和科学计数法。 2、parseFloat 直接将原字符串作为十进制来解析。 ■ NumberToString 1、在较小的范围内，数字到字符串的转换是完全符合你直觉的十进制表示。2 2、在Number 绝对值较大时，字符串是用科学计数法来表示的。（实际用途不大） ■ 装箱转换 装箱转换就是把基本类型转换成对应的对象类型。 1、Symbol 不能用 new 来调用，我们借助 call 方法强制装箱。 12345var symbolObject = (function()&#123; return this; &#125;).call(Symbol("a"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //true 注意：装箱机制会产生临时对象，在一些性能要求较高的场景下，尽量避免对基本类型做装箱操作。 2、使用 object 进行显示调用装箱操作 12345var symbolObject = Object((Symbol("a"));console.log(typeof symbolObject); //objectconsole.log(symbolObject instanceof Symbol); //trueconsole.log(symbolObject.constructor == Symbol); //true ■ 拆箱操作 将对象类型到基本类型的转换。 对象 string 和 Number 的转换遵循 “先拆箱再转换” 的规则，通过拆箱装换，把对象变成基本基本类型，再从基本类型转换为 Number 或者 String。 1、拆箱操作会尝试着调用 valueof 方法和 toString 方法，如果都不存在，则没有基本类型，就会产生类型错误 TypeError。 12345678910var o = &#123; valueOf : () =&gt; &#123;console.log("valueOf"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log("toString"); return &#123;&#125;&#125;&#125;o * 2//执行顺序// valueOf// toString// TypeError 12345678910var o = &#123; valueOf : () =&gt; &#123;console.log("valueOf"); return &#123;&#125;&#125;, toString : () =&gt; &#123;console.log("toString"); return &#123;&#125;&#125;&#125;o + ""//执行顺序// toString// valueOf// TypeError]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之HTML语义2【呈现 wiki 网页】]]></title>
    <url>%2F2019%2F01%2F24%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BHTML%E8%AF%AD%E4%B9%892%E3%80%90%E6%90%AD%E5%BB%BAwiki%E7%BD%91%E9%A1%B5%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进重学前端之 HTML 语义2 【呈现 wiki 网页】。关注公众号「一个不甘平凡的码农」回复 “博客秘钥”，即可获取文章密码。 如何用 HTML 语义呈现 WIKI 页面？ 一、网页标签组成■ aside 侧边栏标签 左边「侧边栏」根据上一篇的语义定义，属于 aside 内容，是 导航性质的内容。 ■ article 文章标签 右侧部分是「文章主题内容」，因为主题部分需要明确的独立性，所以用 article 来包裹。 ■ hgroup, h1 , h2 主题标签 文章主题上边的「主标题和副标题」应用 hgroup 标签内分别用 h1 和 h2 语义来呈现。 1234&lt;hgroup&gt;&lt;h1&gt;World Wide Web &lt;/h1&gt;&lt;h2&gt;From Wikipedia, the free encyclopedia&lt;/h2&gt;&lt;/hgroup&gt; ■ abbr 缩写标签 abbr 标签表示缩写。正文中的 “www” 表示 World Wide Web 的缩写，所以我们用 abbr 标签。 1&lt;abbr title="World Wide Web"&gt;WWW&lt;/abbr&gt;. ■ hr 横线标签 hr 标签并不仅仅所有的横线就用 hr 标签，hr 的语义是故事的走向或者话题的转变，此处两个标题并非这种关系，所以使用 css 中的 border 表示。 ■ p 段落标签 下方的文章段落使用的是 p 标签，段落标签。 ■ strong 黑体标签 文中出现很多黑体字，我们用 strong 标签进行标记。 1234&lt;p&gt; A global map of the web index for countries in 2014&lt;strong&gt;The World Wide Web (WWW)&lt;/strong&gt;, also called &lt;strong&gt;the Web&lt;/strong&gt;,...... ■ blockquote ,q ,cite 引述标签 blockquote ：表示段落引述内容。 q : 表示行内的引述内容。 cite : 表示引述的作品名。 这里的是作品名称，所以用 cite 来引述。 1&lt;cite&gt;"What is the difference between the Web and the Internet?"&lt;/cite&gt;. W3C Help and FAQ. W3C. 2009. Archived from the original on 9 July 2015. Retrieved 16 July 2015. ■ time 日期标签 为了让机器阅读更加方便，我们加上 time 标签。 1&lt;cite&gt;"What is the difference between the Web and the Internet?"&lt;/cite&gt;. W3C Help and FAQ. W3C. 2009. Archived from the original on &lt;time datetime="2015-07-09"&gt;9 July 2015&lt;/time&gt;. Retrieved &lt;time datetime="2015-07-06"&gt;16 July 2015&lt;/time&gt;. ■ figure , figcaption 标签 右侧的文字加图片组成 figure 的语法现象。 1234&lt;figure&gt; &lt;img src="https://.....440px-NeXTcube_first_webserver.JPG"/&gt; &lt;figcaption&gt;The NeXT Computer used by Tim Berners-Lee at CERN.&lt;/figcaption&gt;&lt;/figure&gt; ■ dfn 被定义标签 dfn 标签是用来包裹被定义的名词。 1234//Internet是一个由相互连接的计算机网络组成的全球系统。The &lt;dfn&gt;Internet&lt;/dfn&gt; is a global system of interconnected computer networks.// 与此相反，万维网是全球的文件和资源管理的集合。In contrast, the &lt;dfn&gt;World Wide Web&lt;/dfn&gt; is a global collection of documents and ■ nav , ol ,ul 列表导航标签 下方文章的目录我们可以用 nav 来加 ol 有序列表来实现。 1234567891011121314&lt;nav&gt; &lt;h2&gt;Contents&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;&lt;a href="..."&gt;History&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="..."&gt;Function&lt;/a&gt; &lt;ol&gt; &lt;li&gt;&lt;a href="..."&gt;Linking&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="..."&gt;Dynamic updates of web pages&lt;/a&gt;&lt;/li&gt; ... &lt;/ol&gt; &lt;/li&gt; ... &lt;/ol&gt;&lt;/nav&gt; ■ pre, samp, code 代码或预先编译标签 pre ：有时候我们并不需要 html 的自动换行，所以我们使用 pre 标签能表示这部分内容是预先排版过的，不需要浏览器重新排版。 samp : 一段计算机的示例输出，所以我们可以使用 samp 标签。 code :用来显示 HTML 标签代码。 示例： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Example.org – The World Wide Web&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;The World Wide Web, abbreviated as WWW and commonly known ...&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 代码实现： 12345678910&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Example.org – The World Wide Web&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;The World Wide Web, abbreviated as WWW and commonly known ...&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt; 还有一些行内代码，我们也应该用 code 标签。 总结：]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【数组】]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E6%95%B0%E7%BB%84%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美的数组。 目录[TOC] 一、数组的基本知识1、什么是数组？ 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 2、数组有什么特点？■ 优点 快速实现「随机访问」 ◆ 问题：数组如何实现下标随机访问的？ 计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。 ◆ 答：寻址公式 当我们进行下标随机访问某个元素的时候，通过寻址公式来计算该元素的位置。 12// base_address 首地址，data_type_size 每个元素的大小，int 类型为 4 个字节。a[i]_address = base_address + i * data_type_size ■ 缺点 1、低效的插入和删除操作。 2、不支持动态扩容。数组的缺点是大小固定，如果数组的声明过大，内存没有连续的内存空间；如果数组声明过小，内存空间不够用，必须进行数据搬移，耗费时间。 数组插入、删除数据低效的原因◆ 问题一：数组插入、删除数据为什么会低效？ 数组为了「保持内存空间的连续性」，会导致插入、删除这两个操作比较低效。 ◆ 问题二：数组插入数据低效的具体原因？ 1、如果在数组的末尾插入元素，那就不需要移动数据了，最好时间复杂度为 O(1)。 2、如果在数组开头插入元素，那就将所有的数据往后移动一个，最坏时间复杂度为 O(n)。 3、因为在每个地方插入数据的概率是相同的，所以平均时间复杂度为 O(n)。 ◆ 问题三：数组删除数据低效的具体原因？ 1、如果删除末尾的数据，最好时间复杂度为 O(1)； 2、如果删除的头部的数据，最坏时间复杂度为 O(n)； 3、平均时间复杂度为 O(n)； 数组插入、删除数据的改进方法■ 插入数据改进 数组插入新数据，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。 ■ 删除数据改进 为了避免数据的移动，我们可以先标记要删除的数据，而不是真正的删除。等内存空间不足的时候，我们一次性删除数据，大大较少了数据的搬移。 补充： JVM 标记清除垃圾回收机制算法的核心。 二、数组的使用的注意事项1、警惕数组的访问越界实例分析：123456789int main(int argc, char* argv[])&#123; int i = 0; int arr[3] = &#123;0&#125;; for(; i&lt;=3; i++)&#123; arr[i] = 0; printf("hello world\n"); &#125; return 0;&#125; 运行结果： 这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？ 原因分析：① 代码分析 因为，数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i&lt;=3 而非 i&lt;3，所以当 i=3 时，数组 a[3] 访问越界。 ② 底层内存分析 在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3] 也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。 补充：在 java 中数组越界问题，java 本身会做越界检查，会抛出java.lang.ArrayIndexOutOfBoundsException。 三、ArrayList 与 数组1、ArrayList 的特点① ArrayList 最大的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。 ② 支持动态扩容。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。 2、数组适用条件① Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。 ② 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。 ③ 当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList array。 3、数组使用总结 1、对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。 2、做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。 四、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * 1) 数组的插入、删除、按照下标随机访问操作； * 2）数组中的数据是int类型的； * * Author:zheng * 注释人：小鹿 */public class Array05 &#123; //声明变量 private int data[]; private int n; private int count; /** * @param capacity:用户传参，数组的大小 * 功能：构造函数（初始化数据） */ public Array05(int capacity) &#123; //定义一个大小为 capacity 的数组 data = new int[capacity]; n = capacity; count = 0; &#125; /** * 功能：下标随机访问 * @param index:用户传参下标 * @return */ public int find(int index) &#123; //索引判断，课程中所讲的边界问题（不在数组的范围内函数返回-1） if (index &lt; 0 || index &gt;= count ) return -1; //否则返回该索引对应的数据 return data[index]; &#125; /** * 功能:小鹿改进数组下标随机访问 * 改进内容:index 与上述函数不同，该 index 一般表示用户访问的位于数组的第几个元素 * 对应的索引数据下标应该 -1 ，比如，访问第1个元素，在数组中对应的数据下标就是 * data[0],1 就是相当于用户输入的index。上述用户输入访问第一个元素直接输入0， * index就是0，个人认为改进的更为符合实际操作罢了，原理还是一样的，改进如下代码。 * @param index * @return */ public int improvmentFind(int index) &#123; //索引判断，课程中所讲的边界问题（不在数组的范围内函数返回-1） if (index-1 &lt; 0 || index-1 &gt;= count ) return -1; //否则返回该索引对应的数据 return data[index-1]; &#125; /** * 功能：根据用户输入索引删除数组中数据。 * 补充：这个索引也是可以改进的，自己可以仿照上边改进一下 * @param index * @return */ public boolean delete(int index) &#123; //首先判断删除的索引值是否在数组索引范围内（边界问题） if (index &lt; 0 || index &gt;= count) return false; //将删除元素的后边元素都向前依次移动 for(int i = index + 1; i &lt; count; ++i) &#123; data[i-1] = data[i]; &#125; //删除一个元素后，数组长度 -1 --count; return true; &#125; /** * 功能：数组插入元素 * @param index:数组下标索引 * @param value:要插入的元素值 * @return */ public boolean insert(int index, int value) &#123; //首先判断删除的索引值是否在数组索引范围内（边界问题） if (index &lt; 0 || index &gt;= count) return false; //还要考虑到一种情况就是，如果你一直删除元素知道把元素全部删除完，数组长度为0，无法进行插入元素，对于这种情况就需要进行判断 if (count == n) return false; //数组中数据从最后一依次向后移动，直到将用户指定索引元素空出空间 for (int i = count - 1; i &gt;= index; --i) &#123; data[i+1] = data[i]; &#125; //将元素插入到数组中 data[index] = value; //数组长度+1 ++count; return true; &#125; /** * 功能：插入的另一种情况，当我们向一个数组的尾部插入元素时，上述的插入方法就不适合了，所以我们单独写一个将元素插入到数组尾部的方法。 * @param value:要插入的元素值 * @return */ public boolean insertToTail(int value) &#123; if (count == n) return false; //在数组尾部追加空间，将新元素插入到数组尾部 data[count++] = value; return true; &#125; /** * 通过for循环输出数组所有元素 */ public void printAll() &#123; for (int i = 0; i &lt; count; ++i) &#123; System.out.print(data[i] + " "); &#125; System.out.println(); &#125;&#125; 五、思考题1、为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1开始？■ 从 0 开始编号 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式： 1a[k]_address = base_address + k * type_size ■ 从 1 开始编号 如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为： 1a[k]_address = base_address + (k-1)*type_size ■ 具体原因 1、对比两个公式，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。 2、数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。 补充：以上证明并不是压倒性证明，更有可能是历史原因，其他语言都效仿 C 语言，编号从 0 开始。 2、 JVM 的标记清除垃圾回收算法的核心理念，说一说 JAVA 的标记清除垃圾回收算法。目前最基本的垃圾收集算法有四种。 标记-清除算法(mark-sweep) 标记-压缩算法(mark-compact) 复制算法(copying) 引用计数算法(reference counting) 标记-清除算法(mark-sweep)：先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 3、二维数组的内存寻址公式是怎样的呢？① C语言中，对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为： 1address = base_address + ( i * n + j) * type_size ② java 二维数组是分块连续的 。 六、面试问题1、数组和链表的区别 1、错误表述：“ 链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1) ”。实际上，数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。 2、正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。 七、练习题1、实现一个动态扩容的数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import javax.xml.crypto.Data;/** * 功能：实现一个支持动态扩容的数组 * 方法一:System.arraycopy() * 最好时间复杂度为O(1),最坏时间复杂度为 O(n),平均时间复杂度为 O(1). * * 方法二:ArrayList 实现自动扩容 * @author 小鹿 * */public class Array01 &#123; private int count; private int[] array; private int num; private int n; //初始化 public Array01(int number) &#123; count = 0; array = new int[number]; num = number; n = 1; &#125; public static void main(String[] args) &#123; Array01 data = new Array01(5); data.insert(1); data.insert(2); data.insert(3); data.insert(4); data.insert(5); data.insert(6); data.insert(7); data.insert(8); data.insert(9); data.insert(10); data.insert(11); data.insert(12); data.print(); &#125; //插入数据 public void insert(int value) &#123; if(count&gt;=num*n) &#123; //动态扩容 int[] newArray = new int[array.length*2]; //数组数据搬移 for(int j =0;j&lt;array.length;j++) &#123; newArray[j] = array[j]; &#125;// System.arraycopy(array, 0, newArray, 0, array.length); array = newArray; //然后再插入数组 array[count] = value; //下标移动 count++; //扩容计数 n++; &#125;else &#123; //插入数据 array[count] = value; //下标移动 count++; &#125; &#125; //打印数组内容 public void print() &#123; for(int i=0;i&lt;array.length;i++) &#123; System.out.print(array[i]+" "); &#125; &#125;&#125; 2、实现一个大小固定的有序数组，支持动态增删改操作。12 3、实现两个有序数组合并为一个有序数组12]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【回溯算法】]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美中的10大算法之一回溯算法。 一、如何理解“回溯算法”？1、回溯思想 深度优先搜索用到的就是回溯算法思想，当我们某一条路行不通时，我们就退回上一个岔口选择其他路径。 2、举例① 八皇后问题 有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。第一幅图是满足条件的一种方法，第二幅图是不满足条件的的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。 ② 问题解答 将此问题分为八个阶段，我们拿着八个棋子从第一行开始开始放，每放一次，我们就不停的检查是否满足条件，如果满足，我们就放置下一个棋子；如果不满足，我们就尝试另一种方法。 ③ 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 全局或成员变量, 下标表示行, 值表示 queen 存储在哪一列int[] result = new int[8];// 调用方式：cal8queens(0);public void cal8queens(int row) &#123; if (row == 8) &#123; // 8 个棋子都放置好了，打印结果 printQueens(result); return; // 8 行棋子都放好了，已经没法再往下递归了，所以就 return &#125; for (int column = 0; column &lt; 8; ++column) &#123; // 每一行都有 8 中放法 if (isOk(row, column)) &#123; // 有些放法不满足要求 result[row] = column; // 第 row 行的棋子放到了 column 列 cal8queens(row+1); // 考察下一行 &#125; &#125;&#125;// 判断 row 行 column 列放置是否合适private boolean isOk(int row, int column) &#123; int leftup = column - 1, rightup = column + 1; for (int i = row-1; i &gt;= 0; --i) &#123; // 逐行往上考察每一行 if (result[i] == column) return false; // 第 i 行的 column 列有棋子吗？ if (leftup &gt;= 0) &#123; // 考察左上对角线：第 i 行 leftup 列有棋子吗？ if (result[i] == leftup) return false; &#125; if (rightup &lt; 8) &#123; // 考察右上对角线：第 i 行 rightup 列有棋子吗？ if (result[i] == rightup) return false; &#125; --leftup; ++rightup; &#125; return true;&#125;// 打印出一个二维矩阵private void printQueens(int[] result) &#123; for (int row = 0; row &lt; 8; ++row) &#123; for (int column = 0; column &lt; 8; ++column) &#123; if (result[row] == column) System.out.print("Q "); else System.out.print("* "); &#125; System.out.println(); &#125; System.out.println();&#125; 二、回溯算法的应用1、0 - 1 背包① 问题 有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？ ② 分析 1、我们第一想到的就是贪心算法，但是贪心算法前提条件是物品可以分割的，可以装某一物品的一部分放进背包，但是这个问题不能分割的，要么装下，要么不装，我们用回溯算法来解决。 2、每个物品我们有两种状态，总的装法就有 2^n 种，怎么才能不重复的穷举这些可能呢？ ③ 解决 我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。 ④ 代码实现 1234567891011121314151617181920// 存储背包中物品总重量的最大值public int maxW = Integer.MIN_VALUE; // cw 表示当前已经装进去的物品的重量和；i 表示考察到哪个物品了；// w 背包重量；items 表示每个物品的重量；n 表示物品个数// 假设背包可承受重量 100，物品个数 10，物品重量存储在数组 a 中，那可以这样调用函数：// f(0, 0, a, 10, 100)public void f(int i, int cw, int[] items, int n, int w) &#123; // cw==w 表示装满了 ;i==n 表示已经考察完所有的物品 if (cw == w || i == n) &#123; if (cw &gt; maxW) maxW = cw; return; &#125; // 已经超过可以背包承受的重量的时候，就不要再装了(已改) if (cw + items[i] &lt;= w) &#123; f(i+1,cw + items[i], items, n, w); &#125;else&#123; f(i+1, cw, items, n, w); &#125;&#125; 2、正则表达式① 问题 假设正表达式中只包含“ ”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“”匹配任意多个（大于等于0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？ ② 分析 我们依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。 ③ 解决 如果遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。 ③ 代码实现 12345678910111213141516171819202122232425262728293031323334public class Pattern &#123; private boolean matched = false; private char[] pattern; // 正则表达式 private int plen; // 正则表达式长度 public Pattern(char[] pattern, int plen) &#123; this.pattern = pattern; this.plen = plen; &#125; public boolean match(char[] text, int tlen) &#123; // 文本串及长度 matched = false; rmatch(0, 0, text, tlen); return matched; &#125; private void rmatch(int ti, int pj, char[] text, int tlen) &#123; if (matched) return; // 如果已经匹配了，就不要继续递归了 if (pj == plen) &#123; // 正则表达式到结尾了 if (ti == tlen) matched = true; // 文本串也到结尾了 return; &#125; if (pattern[pj] == '*') &#123; // * 匹配任意个字符 for (int k = 0; k &lt;= tlen-ti; ++k) &#123; rmatch(ti+k, pj+1, text, tlen); &#125; &#125; else if (pattern[pj] == '?') &#123; // ? 匹配 0 个或者 1 个字符 rmatch(ti, pj+1, text, tlen); rmatch(ti+1, pj+1, text, tlen); &#125; else if (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; // 纯字符匹配才行 rmatch(ti+1, pj+1, text, tlen); &#125; &#125;&#125; 补充 剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。 三、思考问题 现在我们对今天讲到的 0-1 背包问题稍加改造，如果每个物品不仅重量不同，价值也不同。如何在不超过背包重量的情况下，让背包中的总价值最大？ 解答]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【分治算法】]]></title>
    <url>%2F2019%2F01%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美中的10大算法之一分治算法。 一、分治算法 分治算法是一种处理问题的思想，递归是一种编程技巧。 1、什么分治算法？ 分治算法（divide and conquer），分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。 2、每层递归实现的三个操作 分解：将原问题分解成一系列的子问题。 解决：递归地求解各个子问题，若子问题足够小，则直接求解； 合并：将子问题的结果合并成原问题。 3、分治算法满足的条件 可分解：原问题与分解成的小问题具有相同的模式； 无关联：原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别【链接：动态规划与分治算法的区别】。 终止条件：具有分解终止条件； 合并不能太复杂：可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。 二、应用一：降低处理数据时间的复杂度1、问题 求 n 个数据的逆序度或有序度的个数。 2、一般解决方法 每个数据一一比较，时间复杂度为 O(n²)。 3、利用分治算法改进 将数组中的数据分为前后两半 A1、A2，分别计算 A1 、A2 的逆序个数 K1、K2，然后在计算 A1、A2 合起来的逆序个数 K3，那数组逆序个数等于 K1+K2+K3。 4、分治算法合并函数 我们会用到归并排序中的一个非常关键的操作，就是将两个有序的数组合并成一个有序数组。在合并的同时计算逆序对个数，把这些计算出来的逆序对个数求和。 5、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445// 全局变量或者成员变量private int num = 0;// a 为要求逆序的数组，n 为数组的长度public int count(int[] a, int n) &#123; num = 0; //分治求逆序 mergeSortCounting(a, 0, n-1); return num;&#125;//分治思想private void mergeSortCounting(int[] a, int p, int r) &#123; if (p &gt;= r) return; int q = (p+r)/2; //递归 mergeSortCounting(a, p, q); mergeSortCounting(a, q+1, r); //合并求逆序数 merge(a, p, q, r);&#125;//合并两个有序的数组private void merge(int[] a, int p, int q, int r) &#123; int i = p, j = q+1, k = 0; int[] tmp = new int[r-p+1]; while (i&lt;=q &amp;&amp; j&lt;=r) &#123; if (a[i] &lt;= a[j]) &#123; tmp[k++] = a[i++]; &#125; else &#123; num += (q-i+1); // 统计 p-q 之间，比 a[j] 大的元素个数 tmp[k++] = a[j++]; &#125; &#125; while (i &lt;= q) &#123; // 处理剩下的 tmp[k++] = a[i++]; &#125; while (j &lt;= r) &#123; // 处理剩下的 tmp[k++] = a[j++]; &#125; for (i = 0; i &lt;= r-p; ++i) &#123; // 从 tmp 拷贝回 a a[p+i] = tmp[i]; &#125;&#125; 6、练习题 二维平面上有 n 个点，如何快速计算出两个距离最近的点。 有两个 n n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=AB？ 三、应用二：在海量数据的中的应用 分治算法思想的应用是非常广泛的，并不仅限于指导编程和算法设计。它还经常用在海量数据处理的场景中。 1、问题 给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2、3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。 2、解决思路 可以利用分治的思想。可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。 3、解决方案 给 10GB 的订单排序，我们就可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。 四、思考：为什么说 MapReduce 的本质就是分治思想？ 1、实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS（Google File System 是谷歌面向大量数据处理的文件分布式系统）来存储数据，依赖 Borg（是 Google 面向大规模集群的管理器） 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。 2、尽管 MapReduce 的模型非常简单，但是在 Google 内部应用非常广泛 。它除了可以用来处理这种数据与数据之间存在关系的任务。比如 MapReduce 的经典例子，统计文件中单词出现的频率。 3、除此之外，它还可以用来处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理，效率低下，我们就可以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的网页。 收获： 创新并非离我们很远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这本身就是算法的的一个魅力所在。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之HTML语义1【基本入门】]]></title>
    <url>%2F2019%2F01%2F22%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BHTML%E8%AF%AD%E4%B9%891%E3%80%90%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进重学前端中的 HTML 语义之基本入门。关注公众号「一个不甘平凡的码农」回复 “博客秘钥”，即可获取文章密码。 一、语义标签1、语义标签是什么？ 像 section 、nav、p 这样的语义类标签，每个标签都有自己表达的意思。 2、为什么要用语义标签？ 增强可读性，没有 css 也能清晰地看出网页的结构，便于团队维护和开发。 适合于机器阅读，文字表现力丰富，更适合于搜索引擎检索（SEO），有效提升网页的搜索量。 语义类标签支持读屏软件，根据文章可以自动生成目录等等。 3、怎么用语义标签？ 1、“用对”比“不用”好，“不用” 比 “用错” 好，我们要不断的追求“用对”。 2、错误的语义标签会造成阅读的混淆、增加嵌套，给 CSS 编写加重负担。 4、自然语言语义便签 表示强调某个关键词。 Example 12今天我吃了一个 &lt;em&gt; 苹果 &lt;/em&gt;。今天我吃了 &lt;em&gt; 一个 &lt;/em&gt; 苹果。 5、标题摘要语义标签■ hgroup 标签 ① 代码实例 123456789例如：&lt;h1&gt;HTML 语义 &lt;/h1&gt;&lt;p&gt;balah balah balah balah&lt;/p&gt;&lt;h2&gt; 弱语义 &lt;/h2&gt;&lt;p&gt;balah balah&lt;/p&gt;&lt;h2&gt; 结构性元素 &lt;/h2&gt;&lt;p&gt;balah balah&lt;/p&gt;...... ② 树形结构 HTML 语义 弱语义 结构性元素 …… ③ 缺点 h1 - h6 代表文章不同层次的标题，如果我们有副标题，也会用到 h1 - h6 那我们怎么办呢？ ④ 改进 123456&lt;hgroup&gt; &lt;h1&gt;JavaScript 对象 &lt;/h1&gt; &lt;h2&gt; 我们需要模拟类吗？&lt;/h2&gt;&lt;/hgroup&gt;&lt;p&gt;balah balah&lt;/p&gt;...... ⑤ 树形目录 JavaScript 对象——我们需要模拟类吗？ … ■ section 标签 section 不仅仅是一个 “ 有语义的 div ”，还会改变 h1 - h6 的语义。，他会使得其中的 h1 - h6 下降一级，所以只需要 section 和 h1 就能形成文档树形结构。 例子 12345678910111213&lt;section&gt; &lt;h1&gt;HTML 语义 &lt;/h1&gt; &lt;p&gt;balah balah balah balah&lt;/p&gt; &lt;section&gt; &lt;h1&gt; 弱语义 &lt;/h1&gt; &lt;p&gt;balah balah&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h1&gt; 结构性元素 &lt;/h1&gt; &lt;p&gt;balah balah&lt;/p&gt; &lt;/section&gt;......&lt;/section&gt; HTML 语义 弱语义 结构性元素 …… 6、作为整体结构的语义标签 很多浏览器推出「阅读模式」，以及非浏览器终端的出现，语义化的 HTML 适合机器阅读特性变的越来越重要。 实例 123456789101112131415161718&lt;body&gt; &lt;header&gt; &lt;nav&gt; …… &lt;/nav&gt; &lt;/header&gt; &lt;aside&gt; &lt;nav&gt; …… &lt;/nav&gt; &lt;/aside&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;footer&gt; &lt;address&gt;……&lt;/address&gt; &lt;/footer&gt;&lt;/body&gt; article 标签 一个典型的场景是多篇新闻展示在同一个新闻专题页面中，这种类似报纸的多文章结构适合用 article 来组织。 例子： 123456789101112131415161718192021222324&lt;body&gt; &lt;header&gt;……&lt;/header&gt; //文章一 &lt;article&gt; //头 &lt;header&gt;……&lt;/header&gt; //主体 &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; &lt;section&gt;……&lt;/section&gt; //尾 &lt;footer&gt;……&lt;/footer&gt; &lt;/article&gt; //文章二 &lt;article&gt; …… &lt;/article&gt; &lt;article&gt; …… &lt;/article&gt; &lt;footer&gt; &lt;address&gt;&lt;/address&gt; &lt;/footer&gt;&lt;/body&gt; header 标签 通常出现在前部，表示导航或者介绍性的内容。 footer 标签 通常出现在尾部，包含一些作者信息、相关链接、版权信息等。 aside 标签 跟文章主体不那么相关的部分，它可能包含导航、广告等工具性质的内容。「侧边栏是 aside，aside 不一定是侧边栏。」 aside 和 header 中的导航（nav）区别？ 1、header 中的导航多数是到文章自己的目录。 2、aside 中的导航多数是到关联页面或者是整站地图。 footer 中 address 标签 表示文章（作者）的联系方式。]]></content>
      <categories>
        <category>前端</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【贪心算法】]]></title>
    <url>%2F2019%2F01%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美中的10大算法之一贪心算法。 一、如何理解“贪心算法”？1、联想到贪心算法。 针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的条件下，期望值得到最大。 2、是否用贪心算法解决。 每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。 3、贪心算法产生的结果是否最优。 举例进行验证，严格地验证贪心算法的正确性，使用复杂的数学推理。 4、贪心算法不是最优解 很多时候贪心算法并不是最优解，比如有权图，求最短路径问题。 1、我们使用贪心算法求得最短路径为 S-&gt;A-&gt;E-&gt;T，路径长度是 1+4+4=9。 2、然而我们的最短路径为 S-&gt;B-&gt;D-&gt;T，路径的长度是 2+2+2=6。 为什么？ 贪心算法不能正常工作的主要原因就是，前面的选择会影响后边的选择。 二、贪心算法实战分析1、分糖果问题： 我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n），所以糖果只能分配给一部分孩子。 每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。 我的问题是，如何分配糖果，能尽可能满足最多数量的孩子？ 分析： 我们起初用最小的糖去满足对糖最小的需求，然后不断用其中最小的糖满足需求最小的孩子。 2、钱币找零问题： 假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？ 分析： 先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推。 3、区间覆盖问题： 假设我们有 n 个区间，区间的起始端点和结束端点分别是 [l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？ 分析： 1、首先我们找到取件中最左边的点和最右边的点。 2、要想满足最多区间，左端点和前边已经覆盖的区域不重合，右端点尽可能的小，这样才能让剩下的未覆盖区间尽可能的大，可以放置更多的区域。 三、思考：如何用贪心算法解决霍夫曼编码？问题： 假设我有一个包含 1000 个字符的文件，每个字符占 1 个byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？假设1000个字符中只含 6 中不同的字符，a、b、c、e、f。 解决：① 改变存储方式。 3 位二进制表示 8 个不同的字符，6 个字符我们就用 3 个二进制位（bit）来表示，那存储 1000 个字符只需 3000 bits 就可以了，比原来的存储方式节省了很多空间。 1a(000)、b(001)、c(010)、d(011)、e(100)、f(101) ② 利用霍夫曼编码。 定义： 霍夫曼编码是一种非常有效的编码方式，广泛应用于数据压缩中，其压缩率通常在 20%~90% 之间。 原理: 霍夫曼编码采用不同的字符出现的频率采用不同的编码长度来存储。 贪心算法： 把出现频率最多的字符，用稍微短一些的编码进行解释；出现频率最多的字符用稍微长一些的编码。 思路： 我们将 6 个字符从上到下出现的频率以此排序，a、b、c、e、f，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会有歧义。在每次解压的时候尽可能的解压二进制串，霍夫曼编码压缩之后，1000 个字符只需要 2100 bits 就可以了。 如何对不同的字符进行不同长度的编码？ 1、构建优先队列。 2、画权值。 ，我们给每一条边加上画一个权值，指向左子节点的边标记 0，右子树的边标记为 1，从根结点到叶子结点的路径就是对应字符的霍夫曼编码。 课后思考1、在一个非负整数 a 中，我们希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？ 2、假设有 n 个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这这 n 个人总的等待时间最短？ 被服务时间短的用户先服务。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【复杂度分析】]]></title>
    <url>%2F2019%2F01%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美的复杂度分析。关注公众号「一个不甘平凡的码农」回复 “博客秘钥”，即可获取文章秘钥。 复杂度分析 目录[TOC] 一、复杂度分析概念📚 1、什么是复杂度分析？ 1、数据结构是用来干嘛的？ 数据结构与算法的诞生是让计算机「执行的更快」、「更省空间」的。 2、用什么来评判数据结构与算法的好坏？ 从「执行时间」和「占用空间」两个方面来评判数据结构与算法的好坏。 3、什么是复杂度？ 用「时间复杂度」和「空间复杂度」来描述性能问题，两者统称为复杂度。 4、复杂度描述了什么？ 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。 📚 2、为什么要进行复杂度分析？ 1、和性能分析相比有什么优点？ 复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。 2、为什么要复杂度分析？ 将能编写出性能「更优的代码」，有利于降低系统「开发和维护成本」 📚 3、如何进行复杂度分析？ 1、什么方法可以进行复杂度分析？ 方法：「大 O 表示法」 2、什么是大 O 表示法？ 算法的「执行时间」与每行代码的「执行次数」成正比【T(n) = O(f(n)) 】=》其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。 3、大 O 表示法的特点？ 由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。 4、复杂度分析法则 [单段代码看频率]：看代码片段中「循环代码」的时间复杂度。 [多段代码看最大]：如果多个 for 循环，看「嵌套循环最多」的那段代码的时间复杂度。 [嵌套代码求乘积]：循环、递归代码，将内外嵌套代码求乘积去时间复杂度。 [多个规模求加法] : 法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。 二、复杂度分析方法1、定义 1、什么是复杂度？ 所有代码的「执行时间 T(n)」 与每行代码的「执行次数n」 成正比【T(n) = O(f(n)) 】。 2、时间复杂度（分析方法） 2、分析的三个方法 最多法则 加法法则 乘法法则 ①最多法则 忽略掉公式中的常量、低阶、系数，取最大循环次数就可以了，也就是循环次数最多的那行代码。 例子： 12345678// 求n个数字之和int xiaolu(int n) &#123; int sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; sum = sum + i; &#125; return sum; &#125; 分析： 第二行是一行代码，也就是常量级别，与 n 没有关系，可以忽略，四、五行代码是我们重点分析对象，与 n 有关，时间复杂度就是反映执行时间和 n 数据规模的关系。求 n 个数据之和需要执行 n 次。所以时间复杂度为 O(n)。 ② 加法法则 总复杂度等于循环次数最多的那段复杂度。 例子： 1234567891011int xiaolu(int n) &#123; int sum = 0; //循环一 for (int i = 1; i &lt;= 100; j++) &#123; sum = sum + i; &#125; //循环二 for (int j = 1; j &lt;= n; j++) &#123; sum = sum + i; &#125; &#125; 分析： 上边有两个循环，一个循环 100 次，另一个循环 n 次，我们选择循环次数最多的那一个且和「数据规模 n 」相关的循环。由上可知，我们很容易选出循环二，即和数据规模 n 有关，循环次数最多，循环次数最多的那段代码时间复杂度就代表总体的时间复杂度，为 O(n) ; ③ 乘法法则 当我们遇到嵌套的 for 循环的时候，怎么计算时间复杂度呢？那就是内外循环的乘积。 例子： 1234for (int j = 1; j &lt;= n; j++) &#123; for(int i = 1; i &lt;= n; i++) sum = sum + i; &#125; 分析： 外循环一次，内就循环 n 次，那么外循环 n 次，内就循环 n*n 次。所以时间复杂为 O(n²)。 3、空间复杂度 表示算法的「存储空间」与「数据规模」之间的增长关系 例子： 12345int i = 0;int[] a = new int[n];for (i; i &lt;n; ++i) &#123; a[i] = i * i;&#125; 分析： 在所有代码中，我们很容易寻找到存储空间相关的代码，就是第二行，申请了一个 n 大小的存储空间，所以空间复杂度为 O(n)。 最常见的空间复杂度 O(1)、O(n)、O(n²)。 4、常见的时间复杂度 O(1) O(logn)、O(nlogn) O(m+n)、O(m*n) 1、O(1)常量级的时间复杂度表示方法，无论是一行代码，还是多行，只要是常量级的就用 O(1) 表示。 例子： 123int i = 1;int j = 2;int sum = i + j; 分析： 因为这三行代码，也就是常量级别的代码不随 n 数据规模的改变而改变。（循环、递归除外） 2、O(logn)、O(nlogn)「对数阶时间复杂度」，最难分析的一种时间复杂度。 例子： 1234i=1;while (i &lt;= n) &#123; i = i * 3;&#125; 分析： 要求这段代码的时间复杂度就求这段代码执行了多少次，看下图具体分析。 补充： 不管是以 2 为底、以 3 为底，还是以 10 为底，可以把所有对数阶的时间复杂度都记为 O(logn)，因为对数之间可以转换的，参照高中课本。 3、O(m+n)、O(m*n) 参照上边讲到的加法和乘法法则。 三、最好、最坏、平均、均摊时间复杂度 最好情况时间复杂度 最坏情况时间复杂度 平均情况时间复杂度 均摊时间复杂度 1、最好、最坏时间复杂度 所谓的最好、最坏时间复杂度分别对应代码最好的情况和最坏的情况下的执行。 例子： 123456//在一个 array 数组中查找一个数据 a 是否存在for (int i = 1; i &lt; n; i++) &#123; if (array[i] == a) &#123; return i; &#125; &#125; 分析： 1、最好情况就是数组的第一个就是我们要查找的数据，上边代码之执行一遍就可以，这种情况下的时间复杂度为最好时间复杂度，为 O(1)。 2、最坏的情况就是数组的最后一个才是我们要查找的数据，需要循环遍历 n 遍数组，也就对应最坏的时间复杂度为 O(n) 。 2、平均时间复杂度 平均时间复杂度需要借助概率论的知识去分析，也就是我们概率论中所说的加权平均值，也叫做期望值。 分析： 比如上方的例子，假设我们查找的数据在数组中的概率为 1/2；出现在数组中的概率为 n/1,根据下边的公式就可以算出出现的概率为 1/2n 。 然后我们再把每种情况考虑进去，就可以计算出平均时间复杂度。 3、均摊时间复杂度 顾名思义，均摊的意思就是把最多的那份平均到各个均等的份上，通常重点掌握使用均摊分析来求均摊时间复杂度。 摊还分析 比如我们每 n 次插入数据的时间复杂度为 O(1)，就会有一次插入数据的时间复杂度为 O(n)，我们将这一次的时间复杂度平均到 n 次插入数据上，时间复杂度还是 O(1)。 适用场景 一般应用于某一数据结构，连续操作时间复杂度比较低，但是个别情况时间复杂度特别高，我们将特别高的这一次进行均摊到较低的操作上。 四、总结1、各个时间复杂度]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【AC 自动机】]]></title>
    <url>%2F2019%2F01%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90AC%20%E8%87%AA%E5%8A%A8%E6%9C%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美的AC 自动机。 一、基于单模式串和 Trie 树实现敏感词过滤1、多模式串匹配 多模式串匹配是在多个模式串中和一个主串之间进行匹配，也就是在一个主串中查找多个模式串。 2、用单模式匹配敏感词缺点 用 BF 算法、RK 算法、BM 算法、KMP 算法，还有 Trie 树实现多模式串匹配算法可以实现，但是每个匹过程都要扫描用户输入的内容，整个过程需要扫描很多遍内容，如果用户输入很长，敏感词过多，匹配过程很低效。 3、Trie 树实现敏感词匹配 1、我们将敏感词进行预处理，形成 Trie 树结构，如果铭感次更新或者删除了，只需更新一下 Trie 树就可以了。 2、当用户输入一个文本内容后，我们把用户输入的内容作为主串，从第一个字符从 Trie 树开始匹配。当遇到叶子节点或者不匹配时，然后从下一个字符开始，重新匹配 Trie 树。 二、经典的多模式匹配算法：AC自动机定义 AC 自动机算法，全称 Aho-Corasick 算法。AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处构建在树上。 代码12345678910public class AcNode &#123; public char data; public AcNode[] children = new AcNode[26]; // 字符集只包含 a~z 这 26 个字符 public boolean isEndingChar = false; // 结尾字符为 true public int length = -1; // 当 isEndingChar=true 时，记录模式串长度 public AcNode fail; // 失败指针 public AcNode(char data) &#123; this.data = data; &#125;&#125; AC 自动机的构建 将多模式串构建成树。 在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【字符串匹配】]]></title>
    <url>%2F2019%2F01%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法中的字符串匹配。 数据结构与算法之美【字符串匹配】01|字符串匹配基础（上）：借助哈希算法实现高效字符串匹配 一串匹配一串： 1、简单的两种字符串匹配算法，BF算法、RK算法。 2、难理解、但是更加高效的算法，BM算法、KMP算法。 一串匹配多串： 1、一串匹配多串的时候使用 Trie 树和 AC 自动机。 BF 算法（Brute Force）定义 BF（Brute Force） 算法也叫暴力匹配算法，也叫做朴素匹配算法。 优点 简单、好懂。 缺点 性能差。 主串和模式串(n&gt;m) 主串（n）：被查找的字符串。 模式串（m）：要查找的字符串。 BF 算法思路 我们在主串中，从起始位置到 0、1、2、 … m-n 开始检查能否和长度为 m 的字符串匹配。最多需要比较 n-m+1 次。 时间复杂度 最坏时间复杂度O(m*n): 当主串为 aaa…aaa 时，模式串为 aaaaab 时，每次对比 m 个字符串，要比对 n-m+1 次。时间复杂度为 m*n+m²+1 。 适用情况 虽然 BF 的时间复杂度非常高了，但是在我们实际开发中经常用到。在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。 1、大部分情况下，模式串和主串的长度不会太长。 每次进行字符串匹配的时候，当中途不能匹配的时候就会停止，不需要把所有的 m 个字符串都进行对比。所以理论上最坏时间复杂度为 O(n*m),但是，统计意义上，大部分的情况下的效率还是比较高的。 2、代码简单易实现 朴素字符串匹配算法思想简单，代码实现简单，简单意味着不容易出错，如果有 bug 也容易暴露和修复。在实际项目中，在满足性能的要求前提下，简单是首选，这也是我们常说的。符合 kiss 原则 。 KISS原则是英语 Keep It Simple, Stupid 的首字母缩略字，是一种归纳过的经验原则。KISS 原则是指在设计当中应当注重简约的原则。总结工程専业人员在设计过程中的经验，大多数系统的设计应保持简洁和单纯，而不掺入非必要的复杂性，这样的系统运作成效会取得最优；因此简单性应该是设计中的关键目标，尽量回避免不必要的复杂性。 RK 算法(Rabin-Karp) 由来 它是由 Rabin 和 Karp 两位发明者来命名的。 BF 算法的不足 上边也讲到了，在匹配字符串的时候，需要一个字符一个字符的比较，最坏情况下的时间复杂度为 O（m*n），我们引入哈希算法。 RK 算法思路 利用哈希算法，对剩余的 n-m+1 个子串进行求哈希值，然后逐个与模式串进行对比，我们世道哈希值是一个数字，比较起来很多，我们先不考虑哈希冲突，这样效率提高了很多。 RK 计算哈希值不足 你可能会说，字符串计算哈希值的时候，我们需要遍历字符串，总体的时间复杂度并没有降低。 计算哈希值改进 将包含 K 的字符串用 K 进制来表示，比如 a~z , 26 个字母，计算哈希值的时候我们改为 26 进制就可以了。然后将 26 进制改为 10 进制。 这种哈希算法有个特点就是相邻的两个子串的哈希值的计算公式有一定的关系。 两者之间的关系满足的公式： 关于26^(m-1) 这部分的计算，我们通过数组的方式来计算更加快速。 RK 算法的时间复杂度 RK 算法包括两部分，一部分是计算子串的哈希值，另一部分是与子串的哈希值进行比较。 1、计算子串的哈希值是遍历一遍字符串就可以，时间复杂度是 O(n)。 2、比较哈希值需要比较 n-m+1 次，所以时间复杂度为 O(n)。、、 3、所以 RK 算法的总体的时间复杂度为 O(n)。 存在的问题 1、如果模式串很长，计算哈希值的长度超过计算机的存储的整数范围的话，我们应该怎么办？ 2、计算哈希值存在哈希冲突怎么办？ 问题解决 解决一：对于问题一，我们可以优化一下计算哈希值的算法就可以，如:字符串对应素数一次类推等。 解决二：对于问题二，就让他存在哈希冲突，当我们遇到哈希冲突的时候，我们再对应模式串和子串的本身。 补充： 我们还是要尽量将冲突的概率控制的较低，否则RK 算法的时间复杂度就会推化为 O(n*m)。总的来说，RK 算法的时间复杂度相对于 BF 算法效率还是很高的。 02|字符串匹配基础（中）：实现文本编辑器的查找功能BM 算法的核心思想BM 算法（Boyer-Moore） 字符串匹配中，BF 算法和 RK 算法的做法就是每比较一个模式串，就向后滑动一个，那么为了提高效率，我们什么情况下直接跳过不可能匹配的模式串，向后滑动多个字符呢？这就是 BM 算法解决的问题。 BM 算法原理分析 BM 算法包括两个部分，分别是坏字符串（bad character rule）规则和好后缀（good suffix shift）规则。 1、坏字符串规则定义 我们在子串中匹配模式串的时候通常是顺序匹配的，但是 BM 不同的是从后向前匹配，倒着匹配。 过程 ① 当我们在匹配字符串的时候，当遇到没法匹配的字符的时候，我们将此字符叫做坏字符。 ② 当我们发现字符串不匹配的时候，我们将字符串对应的模式串中的下标记做为 si。如果模式串中存在坏字符串，我们就将在模式串中标记为 xi。如果不存在，我们就将 xi 标记为 -1。那模式串往后移动的位数就等于 si-xi 这样做的目的就是防止防止一次性移动过多，导致本来匹配的情况被略过。 时间复杂度 BM 最好时间复杂度为 O（n/m） 坏字符串规则不足 如果坏字符串在模式串中存在，假如我们在主串 aaaaaaaa 中匹配 baaa 。不但不会向后滑动，还有可能会出现向前滑动的现象。 2、好后缀规则 坏字符串中的不足点，下方的情况我们会怎么滑动模式串？我么能使用好后缀匹配规则。 ① A、我们将从后往前已经匹配好的字符串记做 {u} ，我们就拿它在模式串中查找，如果找到了跟 {u} 相同的匹配的字符串，那我们就将模式串滑动到子串 {u*} 与模式串中对其的位置。 B、如果我们没有在模式串中找到该字符串，我们就将向后移动整个模式串（会出现问题）。我们在移动的同时需要判断子串后缀的字符串是否和模式串的头字符串是否匹配,如果匹配我们就移动到重合位置，否则直接移动模式串长度的位置。 3、两如何个规则 我们分别计算好后缀和坏字符串往后滑动的位数，然后取两个数中最大的作为字符串向后滑动的位数。（避免了向后滑动位数问题，又解决了滑动负数的问题） BM 算法的实现略 … BM 算法的性能分析及优化思考：BM 算法通常用在文本编辑器中。小结 1、主要目的我们学习算法的思想，需要的时候加以应用就好。 2、要有优化意识。前边的 BF 算法和 RK 算法在实际中已经够用了。 3、算法的优化就是为了减少时间复杂度，但是带来的弊端就是优化代码带来复杂，维护成本变的很高。 字符串匹配基础（下）：理解KMP 算法 虽然我们学到的 BM 算法是日常中最高效、最常用的字符串匹配方法。那 KMP 算法是最知名的一句话，放我们提到字符串匹配最先想到 KMP 算法。 一、KMP 算法的基本原理1、定义 KMP（D.E.Knuth，J.H.Morris 和 V.R.Pratt）,算法的全称为 Knuth Morris Pratt 算法，简称为 KMP 算法。 2、KMP 核心思想 KMP 主要解决的就是模式串在主串进行匹配的时候，我们希望找到一定的规律，直接跳过那些不会匹配的情况。 3、KMP 实现原理 我们类比 BM 算法，KMP 分为好前缀和坏字符两部分。 ① 当我们遇到坏字符时，我们就将模式串向后移动，在滑动过程中，我们将模式串中的前缀子串和好前缀中的字符判断上下是否存在重合。 ② 我们只需在好前缀的后缀子串中，查找模式串中前缀子串中最长匹配的字符串。设定模式串中的前缀子串是 {v}，长度为 K，我们一次性往后滑动 j-k 位，相当于遇到坏字符时，我们就把 j 更新为 k，i 不变，然后继续比较。 ③ 那我们的最长匹配字符串是怎么查找的那呢？ 把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作最长可匹配后缀子串；对应的前缀子串，叫作最长可匹配前缀子串，叫作最长可匹配前缀子串。 ④ 如何来求好前缀的最长可匹配前缀和后缀子串呢？ 我们将有可能为最前缀的字符串最后字符的下标存储到数组中，我们将这个数组叫做 next 数组。也叫做 失效函数。 ⑤ KMP 的框架代码 12345678910111213141516171819// a, b 分别是主串和模式串；n, m 分别是主串和模式串的长度。public static int kmp(char[] a, int n, char[] b, int m) &#123; // 模式串中的 next 数组 int[] next = getNexts(b, m); int j = 0; // for (int i = 0; i &lt; n; ++i) &#123; while (j &gt; 0 &amp;&amp; a[i] != b[j]) &#123; // 一直找到 a[i] 和 b[j] j = next[j - 1] + 1; &#125; if (a[i] == b[j]) &#123; ++j; &#125; if (j == m) &#123; // 找到匹配模式串的了 return i - m + 1; &#125; &#125; return -1;&#125; 二、失效函数计算方法三、KMP 算法复杂度分析]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【深度和广度优先搜索】]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E6%B7%B1%E5%BA%A6%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你走进数据结构与算法之美深度优先和广度优先算法。 社交网络中的六度分割理论 就是说你与世界上的另一个人关系不会超过六度，平均只需要六步就可以联系到任何两个互不相识的人。 什么是“搜索”算法？ 深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。所谓的深度和广度优先算法就是在图中找到从一个顶点到另一个顶点的路径。 图的实现代码 1234567891011121314151617181920// 无向图public class Graph &#123; // 顶点的个数 private int v; // 邻接表 private LinkedList&lt;Integer&gt; adj[]; public Graph(int v) &#123; this.v = v; adj = new LinkedList[v]; for (int i=0; i&lt;v; ++i) &#123; adj[i] = new LinkedList&lt;&gt;(); &#125; &#125; // 无向图一条边存两次 public void addEdge(int s, int t) &#123; adj[s].add(t); adj[t].add(s); &#125;&#125; 广度优先搜索（BFS）定义 广度优先搜索（Breadth-First-Search），我们平常都把简称为 BFS。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445//广度优先搜索public void bfs(int s, int t) &#123; //如果两顶点为同一个顶点，则返回 if (s == t) return; //用来存储已访问的顶点（v为图的顶点个数） boolean[] visited = new boolean[v]; //将第一个顶点置为true visited[s]=true; //定义一个队列，用来存储已经被访问但相连的顶点还没有被访问的顶点 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); //现将第一个节点存储 queue.add(s); //用来存储搜索路径（v为图的顶点个数） //将数组prev全部置为 -1 int[] prev = new int[v]; for (int i = 0; i &lt; v; ++i) &#123; prev[i] = -1; &#125; //当队列中已有存储的结点的时候 while (queue.size() != 0) &#123; // 队列中第一个元素出队 int w = queue.poll(); // for (int i = 0; i &lt; adj[w].size(); ++i) &#123; int q = adj[w].get(i); if (!visited[q]) &#123; prev[q] = w; if (q == t) &#123; print(prev, s, t); return; &#125; visited[q] = true; queue.add(q); &#125; &#125; &#125;&#125;// 递归打印 s-&gt;t 的路径private void print(int[] prev, int s, int t) &#123; if (prev[t] != -1 &amp;&amp; t != s) &#123; print(prev, s, prev[t]); &#125; System.out.print(t + " ");&#125; visited :用来记录已经被访问的顶点，如果顶点q被访问，那相应的 visited[q] 会被设置为 ture 用来避免顶点被重复访问。 queue :是一个队列，用来存储已经被访问但相连的顶点还没有被访问的顶点。确保每一层访问完 k 层再访问 k+1 层的顶点。 prev :用来记录搜索路径（路径是反向存储的）。 图示图解 广度优先搜索的时间复杂度1、最糟糕的情况下 ① 终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。每个顶点都需要进出一遍队列，每个边也会被访问一次，所以时间复杂度为O(V+E)。V 表示顶点个数，E 表示边的个数。 ② 对于一个连通图来说的是，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，广度优先搜索的时间复杂度也可以简写为O(E)。 广度优先搜索的空间复杂度 广度优先搜索空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小个数不会超过顶点的个数，所以空间复杂度为 O(V)。 深度优先搜索（DFS） 深度优先搜索（Depth-First-Search），简称DFS。最直观的例子就是“走迷宫”。就像是走迷宫，如果遇到走不通了，然后退回来，重新找另一条路，直到到达终点为止。 代码实现123456789101112131415161718192021222324252627282930//深度优先搜索boolean found = false; // 全局变量或者类成员变量public void dfs(int s, int t) &#123; found = false; boolean[] visited = new boolean[v]; int[] prev = new int[v]; for (int i = 0; i &lt; v; ++i) &#123; prev[i] = -1; &#125; recurDfs(s, t, visited, prev); print(prev, s, t);&#125;private void recurDfs(int w, int t, boolean[] visited, int[] prev) &#123; if (found == true) return; visited[w] = true; if (w == t) &#123; found = true; return; &#125; for (int i = 0; i &lt; adj[w].size(); ++i) &#123; int q = adj[w].get(i); if (!visited[q]) &#123; prev[q] = w; recurDfs(q, t, visited, prev); &#125; &#125;&#125; 上述代码和广度优先搜索差不多相同的，但是有个地方不同的是，变量found,它的作用是，已经找到终止t之后，我们就不再递归地继续查找了。 深度优先搜索的时间复杂度 每条边最多访问两次，一次是遍历，另一次是回退，所以图上的深度优先搜索算法的时间复杂度为O(E)。 深度优先搜索的空间复杂度 深度优先搜索的消耗内存主要是 visited、prev 数组和递归调用栈。数组的大小不会超过顶点 V，所以空间复杂度为O(V)。 思考：如何找出社交网络中的三度好友关系？ 借助广度优先搜索，每一层是一度关系好友，用一个数组来记录每个顶点与起始顶点的距离，就可以找出三都好友。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【图的表示】]]></title>
    <url>%2F2019%2F01%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%9B%BE%E3%80%91%2F</url>
    <content type="text"><![CDATA[如何存储微博、微信等社交网站中的好友关系？ 一、图的基本知识1、什么是图？ 树的元素称为节点，图中的元素叫做顶点。图中的顶点可以与任意其他顶点建立连接关系，叫做边（edge）。跟顶点连接的边的条数，就叫做顶点的度。 2、图的分类 根据图有无方向，我们分为有向图和无向图。 1）有向图：把度分为入度（有多少条边指向这个顶点）和出度（有多少条边指向其他顶点）。 2）无向图：没有方向的图称为无向图。 3）带权图：每条边都有一个权重的图为带权图。 3、图的实际例子 1）微信：互相加为好友，就添加一条边，微信好友之间的关系可以用一张无向图来表示。 2）微博：单向关注或互相关注，微博好友之间的关系可以用有向图来表示。 3）QQ：不仅是好友关系，还有记录好友之家的亲密关系以及用户的亲密度。 二、如何存储图？1、邻接矩阵存储法 基于数组实现的空间换时间思想。 ▉ 图示 ▉ 实现 1）对于无向图来说，如果顶点 i 与顶点 j 之间有边，就将A[i][j] 和 A[j][i] 标记为 1； 2）对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，就将 A[i]/[j] 标记为 1。如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j]/[i] 标记为 1 3）对于带权的图，数组中就存储相应的权重。 ▉ 优点 1）邻接矩阵存储方式简单、直接，因为基于数组，所以获取两边的顶点关系的时，就非常高效。 2）计算高效，可以将图转化为矩阵进行计算。如：求最短路径问题：Floyd-Warshall 算法。 ▉ 缺点 比较浪费空间。 分析： 1） 对于无向图来说，A[j][i] 和 A[i][j] 存储的都是 1，实际上存储一个就可以了，对角线只不过是白白浪费了内存空间。 2）如果存储稀疏图（顶点多，边不多），所以邻接矩阵更浪费空间。 2、邻接表存储方法 基于链表实现的时间换空间思想。 ▉ 图示 ▉ 实现 邻接表有点像（链接：散列表），每个顶点对应一条链表，链表中存储的是这个顶点相连接的其他顶点。 ▉ 优点 基于链表的邻接表，可以有效节约内存空间。 ▉ 缺点 链表存储对缓存不友好，所有在查询两个节点之间的关系就不是那么高效了。链表过长导致查询耗时过长，可以将链表换换成其他的数据结构。 ▉ 优化 如果上述的链表过长，导致查询数据太过于耗时，为了提高效率，可以将链表转换成更高效的数据结构，比如平衡二叉树(红黑树)、跳表、散列表、二叉查找树。还可以转化成有序的动态数组，通过二分查找的方法来快速定位两个顶点是否存在边。 三、本节思考：怎么存储微博、微信中的好友关系？1、问题： 要实现微博用户功能。 判断用户 A 是否关注了用户 B； 判断用户 A 是否是用户 B 的粉丝； 用户 A 关注了用户 B； 用户 A 取消关注了用户 B； 根据用户首字母进行排序，分页获取用户的粉丝列表； 根据用户名称的首字母排序，分页获取用户的关注列表； 2、问题分析■ 判断用户 A 是否关注了用户 B。 挂钩数据结构：微博是一个大的社交网络，是一张稀疏图，存储方式选择邻接表。 ■ 判断用户 A 是否是用户 B 的粉丝。 灵活运用：一个邻接表只能知道用户关注了哪些，而不知道自己有哪些粉丝，应该怎么做？加一个逆邻接表用来存储一个用户有哪些粉丝。 ■ 微博人数太多，邻接表导致两个用户关系的查询慢 数据结构的缺点：将邻接表中的链表改为支持快速增删改查的数据结构平衡二叉树、跳表、散列表、二叉查找树、基于数组动态数据的二分查找。 ■ 根据用户首字母进行排序 问题特点精选：用户名称的首字母来排序的，使用跳表来实现。 3、性能分析■ 选用的数据结构 跳表性能分析：跳表支持快速增删改查，非常高效，时间复杂度是O(logn)，空间复杂度较高，是 O（n）。但是跳表存储本来就是有序的，所以分页获取粉丝列表或关注列表就非常高效。 ■ 内存消耗（数据规模） 1、小规模：数据（几万，几十万），直接加载到内存中去。 2、大规模： 数据（上亿级）。 ▍方法一：内存 利用哈希数据分片的方式进行存储，存储到不同的机器。 方法二：外存 外部存储宽裕，因为数据库是我们经常用来持久化存储关系数据的，所以考虑数据库的一种方式。表可以存储两个用户之间对应的关系，为了高效的支持前边的操作，就用数据库索引，对字段都建立索引。 四、扩展思考1、微信这种无向图怎么存储? 2、关于图的实例还有哪些？ 多对多：地图、网络、电话。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【堆】]]></title>
    <url>%2F2019%2F01%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%A0%86%E3%80%91%2F</url>
    <content type="text"><![CDATA[为什么说堆排序没有快速排序快？ 一、什么是堆？ 堆是一个完全二叉树；堆中的每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 1、堆的分类 大顶堆：每个节点的值大于等于子树每个节点值的堆。 小顶堆：每个节点的值小于等于子树中每个节点值的堆。 2、堆的特点 堆是一个完全二叉树； 堆中的每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 二、如何实现一个堆？1、堆的存储 数组中下标为 i 的节点的左子节点就是下标为 i*2 的节点，右子节点就是下标为 i * 2+1 的节点，父节点就是下标为 i/2 的节点。 2、堆中插入一个数据 从下往上进行堆化。 ■ 代码实现12345678910111213141516171819202122232425262728/** * 时间:2019/2/28 * 功能:插入数据 * 分析: * 1)插入到数组尾部(堆最后的节点) * 2)自下而上堆化(比较和交换) * 边界条件: * 1)判断是否已经堆满 * @param data 插入的数据 */public void insert(int data) &#123; //判断堆是否已满 if(count &gt;= n) return; //计数+1(下标 0 不存储数据) count++; //将数据插入最后节点 a[count] = data; //自下往上堆化 int i = count; //判断插入数据的根节点是否大于 0 且插入的数据是否大于根节点数据 while(i/2 &gt; 0 &amp;&amp; a[i] &gt; a[i/2]) &#123; //交换下标为 i 和 i/2 的元素 swap(a,i,i/2); //继续堆化比较交换 i = i/2; &#125;&#125; 2、堆中删除一个数据 把堆顶的元素删除之后，将最后一个节点放到堆顶，然后按照上边的方法进行交换，直到父子节点满足大小关系为止，从上往下堆化方法。 ■ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445 /** * 时间:2019/2/28 * 功能:删除堆顶数据 * 分析: * 1)判断堆是否为空 * 2)数组长度 -1 * 3)从下标为 1 的数据从上到下进行堆化 * 4)在左右节点中选出最大元素进行交换 * 边界分析: * 1)判断堆是否为空 * 2)堆中是否只有一个元素 * @param data 要删除的数据 */public void removeMax() &#123; //如果堆中无数据,则返回 if(count == 0) return; //删除堆顶的第一个元素,与最后一个元素进行交换 a[1] = a[count]; //数组长度-1 count--; //从上到下进行堆化 heapify(a,count,1);&#125;/** * 功能:从上自下堆化 * @param a 堆化的数组 * @param count 当前堆中的数据 * @param i */private void heapify(int[] a,int n,int i) &#123; while(true) &#123; int maxPos = i; //选择子节点中最大的数据作交换 if(i*2 &lt; n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2; if(i*2+1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos = i*2+1; //如果堆顶只剩一个元素,break if(maxPos == i) break; //进行交换 swap(a, i, maxPos); //继续往下堆化 i = maxPos; &#125;&#125; 三、堆插入、删除的时间复杂度分析 n 个节点的完全二叉树，树的高度不会超过 log2n，堆化的过程就是顺着路径进行交换的过程，时间复杂度与树的高度成正比，也就是 O(logn)。 四、堆排序 借助于堆这种数据结构实现的排序算法，就叫作堆排序。这种排序方法的时间复杂度非常稳定，是 O(nlogn)，并且是原地排序算法。 1、 建堆■ 方法一： 借助前边讲的堆插入一个数据元素，就好比从1到n ，插入n个数据。数组操作就是从前到后处理数据，堆排序需要从下向上堆化。 ■ 方法二：（最常用的方法） 与第一种截然相反，数组从后向前处理（数组的中间位置），堆排序是从上到下堆化。 ■ 代码实现12345678910111213141516171819202122232425262728293031323334/** * 时间:2019/2/28 * 功能:建堆 * 1)取数组中间从后往前 * @param a 数组 * @param n 数组的大小 */public static void buildHeap(int[] a,int n) &#123; for (int i = n/2; i &gt;= 1; i++) &#123; heapify(a,n,i); &#125;&#125;/** * 功能:从上自下堆化 * @param a 堆化的数组 * @param count 当前堆中的数据 * @param i */private static void heapify(int[] a,int n,int i) &#123; while(true) &#123; int maxPos = i; //选择子节点中最大的数据作交换 if(i*2 &lt; n &amp;&amp; a[i] &lt; a[i*2]) maxPos = i*2; if(i*2+1 &lt;= n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos = i*2+1; //如果堆顶只剩一个元素,break if(maxPos == i) break; //进行交换 swap(a, i, maxPos); //继续往下堆化 i = maxPos; &#125;&#125; 注意： 从 n/2 开始堆化，下标是 n/2 +1 到 n 的结点都是叶子节点，不需要堆化。对于完全二叉树来说，下标从 n/2+1到n的节点都是叶子节点。 ■ 建堆的时间复杂度分析 1、堆化的时间复杂度为 O(logn)，需要堆化 n/2 + 1个结点，时间复杂度为 O(nlogn)，不够精确，叶子节点并没有参与堆化。 2、需要在倒数第二层进行堆化，所以将每层堆化的结点数和每层的高度相乘总体相加得出时间复杂度。 3、建堆的时间复杂度为 O(n)。 2、排序 借助删除堆顶元素的方法来对堆元素进行排序。 ■ 代码实现12345678910111213141516171819/** * 功能:排序 * @param a 数组 * @param n 数据的个数 */public static void sort(int[] a, int n) &#123; //建堆 buildHeap(a, n); //堆排序 int k = n-1; while (k &gt; 1) &#123; //交换堆顶元素和最后一个元素 swap(a, 1, k); //堆元素减一 --k; //从上向下进行堆化 heapify(a, k, 1); &#125;&#125; ■ 堆排序的时间复杂度分析 建堆的时间复杂度为 O(logn) ，n 个结点排序的时间复杂度为 O(nlogn)。 3、堆排序的性能▍堆排序是否为原地排序算法？ 答：是 分析：数据交换只需要变量级别的临时空间，所以空间复杂度为 O(1)。 ▍堆排序是否为稳定排序算法？ 答：不是 分析：在整个堆排序的过程中，存在将堆的最后一个节点和堆顶节点的互换的操作，所以有可能改变相同数据的原始相对顺序。所以堆排序不是稳定排序。 ▍堆排序的时间复杂度？ 答：O(nlogn) 分析：建堆的时间复杂度为 O(n)，堆排序的时间复杂度为 O(nlogn)，所以总的时间复杂度为 O(nlogn); 五、为什么快速排序比堆排序性能好？1、堆排序数据访问的方式没有快速排序友好 对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。比如，堆排序中，最重要的一个操作就是数据的堆化。堆排序访问元素会跳这访问，不像快速排序一样局部顺序访问，这样对 CPU 缓存不友好。 2、对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。 堆排序经过建堆，会将数据的逆序度降低，本来一组数据是有序的，经过建堆之后就会变得无序。而快速排序整个排序过程中，数据交换的次数不会比逆序度多。 六、扩展思考1、对于完全二叉树来说，下标从 n/2 + 1 到 n的都是叶子节点，怎么推导出出来的？ 七、堆的应用1、应用一：优先级队列■ 定义 顾名思义，队列是先进先出，而这里的优先级队列的出队顺序不是先进先出，而是按照优先级来的，优先级越高就先出队。 ■ 思路 用堆实现优先级队列是最直接、最高效的一种方式，因为堆和优先级队列最为相似。一个堆可以看成一个优先级队列，往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列删除一个元素，就相当于取出一个堆顶元素。 ■ 优先级队列一：合并有序小文件▍问题： 假设有 100 个小文件，每个文件的大小是 100 MB，每个文件存储的都是有序的字符串。希望将这些 100 小文件合并成一个有序的大文件。 ▍解决： 归并排序中的合并函数，先分别从 100 个文件中各提取一个字符串，放入数组中，然后比较大小，选择最小的字符串合并到大文件中，然后在数组中删除改元素，从该文件中重新选择一个字符串放到数组中重新比较。 ▍不足; 用数组其实不是最高效的方法，我们需要在数组中遍历所有元素进行比较，比较耗时。 ▍优化： 利用小顶堆来实现。 ▍时间复杂度分析： 1、数组的实现方式：对数组删除、插入以及比较取出最小值操作时间复杂度为 O(n)。 2、小顶堆实现方式：每个堆总数据为 100 ，删除堆顶、往堆中插入数据的时间复杂度为 O(logn)。 ■ 优先级队列二：高性能定时器▍问题： 假设有一个定时器，定时器维护了很多任务，每个任务都设定了出发的时间点，定时器每过一秒都要扫描一下任务，判断当前的任务有没有达到执行时间的，如果达到了，就拿出来执行。 ▍解决： 小顶堆来解决，小顶堆存放的数据就是任务时间和当前时间差。 1、堆顶元素就是最先执行的任务。 2、堆顶的任务执行完毕之后，然后重新计算差值，得出首任务。 2、应用二：利用堆求 Top K▍问题： 如何在包含 n 个数据的数组中，查找前 K 大数据呢？1、静态数据；2、动态数据。 ▍ 静态数据： 1、首先维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。 2、如果取出的数据比堆顶大，我们呢就将堆顶元素删除，然后将数据进行插入。 3、如果比堆顶的元素小，我们就不做处理。 4、将数组全部遍历完成之后，堆中的数据就是前K大数据**。 ▍静态数据复杂度 遍历数组时间复杂度为 O(n)，一次堆化时间复杂度为 O(logK) 。 1、最坏的情况下：数据从小到大排列，时间复杂度为 O(nlogK) 。 2、最好的情况下：数据从大到小排列，时间复杂度为 O(n)。 ▍动态数据复杂度 实时的求前 k 大数据。 1、一直维护一个 K 大小的小顶堆，当有数据被添加进来的时候，就拿着它与堆顶的元素对比。如果比堆顶元素大，我们就删除堆顶元素，将此元素进行插入，如果比堆顶小，我们就不做任何处理。 3、堆的应用三：利用堆求中位数▍问题： 如果数据的个数是奇数的时候，中位数为 n/2 + 1。如果是偶数的话，中位数有两个，分别为 n/2 和 n/2 + 1。如何求动态数据集合的中位数? ▍静态数据求中位数： 关于静态数据，中位数是固定的，我们先可以进行排序，第 n/2 个数据就是中位数。 缺点：排序的代价有点大。 优点：边际成本会很小。 ▍动态数据求中位数： 1、需要维护两个堆，一个大顶堆，一个是小顶堆。大顶堆存储前半部分数据，小顶堆存储后半部分数据。且小顶堆的数据都大于大顶堆的数据。 2、如果有 n 个数据，n 是偶数，从小到大排序，那前 n/2 个数据存储在大顶堆中,也就是堆顶就是中位数。如果 n 是奇数，大顶堆就存储 n/2 + 1个数据，小顶堆就存储 n/2 个数据。 3、如果新加入的数据小于等于大顶堆的堆顶元素，就将这个新数据插入到大顶堆；如果新加入的数据大于等于小顶堆的堆顶元素，就将这个新数据插入到小顶堆。 4、插入新数据会导致两个堆的数据不符合前边约定的情况，导致 n 是偶数的时候，两个堆的数据都是 n/2 个数据。奇数大顶堆有 n/2 + 1 个数据，小顶堆有 n/2 个数据。 5、可以不停的移动一个堆顶的元素向另一个堆顶移动，这样就可以调整了。 ▍时间复杂度分析 1、插入数据需要涉及到堆化，时间复杂度为O(logn) 。 2、求中位数直接返回堆顶元素就行了，所以时间复杂度为 O(1)。 八、本节思考：如何快速获取到Top 10最热门的搜索关键词？▍问题： 有 10 亿个搜索关键字的日志文件，如何快速获取 Top 10 的搜索关键词呢？ ▍方法选择 1、一般用 MapReduce 去解决，解决思想：请跳转《哈希算法》中的数据分片的应用解决方法。 2、如果是单机操作，上述方法就不能使用了。 ▍分析： 1、关键词是用户重复输入搜索的，首先要统计关键词出现的次数，选用一些支持快速实现增、删、改、查的数据结构（散列表、平衡二叉树等）。 2、散列表来实现，顺序遍历 10 亿关键词。散列表中不存在插入数据计数1，存在关键字就+1. 3、建立一个大小为 10 的小顶堆，遍历散列表，关键词出现的次数和顶堆进行比较，如大于顶堆元素，删除顶堆元素，插入这条数据。 ▍附加条件： 10 亿的关键词很多，假如我们不重复的关键词为 1 个亿，每个搜索关键词的长度为 50 个字节，需要 5 G 的内存空间，散列表需要避免冲突，不会选择太大的装载因子，所以消耗内存空间更多。假设机器只有 1 G 的存储空间，无法一次性将数据加载到内存中。 ▍改进： 1、使用哈希算法的相同数据经过哈希算法得到相同的哈希值一样的特性，通过这一个特性，将 10 亿个关键词通过哈希算法分片到 10 个文件中。 2、创建 10 个空文件，00,01,02…09，遍历 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后同 10 取模， 3、每个文件只有 1 亿个关键词，去掉重复的也就是 1000 万个，每个关键词平均 50 字节，所以总的大小为 500 MB，1 G的内存空间完全可以容下。 4、每个文件利用散列表和堆进行求 Top 10,然后将十个文件中的 Top10 放在一起，然后取 100 个关键词中的前十个。 九、扩展思考▍问题： 有一个访问量非常大的新闻网站，我们希望将点击量排名 Top 10 的新闻摘要，滚动显示在网站首页 banner 上，并且每1 小时更新一次。如果你是负责开发这个功能的工程师，你会如何来实现呢？ ▍解答： 1、首先，用户每点击一个新闻摘要的关键字，就通散列函数进行计数。 2、每过一个小时就遍历计算出散列表中的点击次数。 3、维护一个大小为 10 的小顶堆，遍历散列表中所有关键词出现的次数，与小顶堆的堆顶进行比较，如果大于堆顶元素就删除，将数据插入堆顶，否则就忽略，直到所有数据遍历完成。 ▍时间复杂度分析： 1、遍历所有新闻关键词，时间复杂度为 O(n)。 2、插入堆数据最坏时间复杂度为 O(klog2(10))——这里的 k 应该小于 n 的。 3、总体的时间复杂度为 O(n)。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【红黑树】]]></title>
    <url>%2F2019%2F01%2F03%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[为什么工程中都用红黑树这种二叉树！ 红黑树(上)一、什么是平衡二叉树 二叉树中任意一个节点的左右子树的高度相差不能大于 1。最早出现的平衡二叉树是 AVL 树。（完全二叉树、满二叉树，AVL树） 二、红黑树 1、红黑树的由来 为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。 2、红黑树（Red-Black Tree） 顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。红黑树，简称 R-B Tree。它是一种不严格的平衡二叉树。 根节点是黑色的； 每个叶子的结点都是黑色的空节点（NIL），叶子节点不存储数据； 任何相邻（上下）的结点都不能同时为红色，红色结点是被黑色结点隔开的； 每个节点，从该节点到其可达叶子节点的所有路径，都包含相同数目的黑色节点； 三、红黑树的性能分析 『平衡』可以等价为性能不退化。『近似平衡』就等价为性能不会退化的太严重。 1、怎么判断红黑树平衡？ 二叉查找树的性能（时间复杂度）跟树的高度成正比，大约是 log2n ，只要分析「红黑树的高度是否趋近于 log2n 」。 2、红黑树的复杂度分析 红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。 ■ 分析1、先将红色结点去掉，单纯的看黑色节点的高度. 2、由上图可知，红黑树变成了四叉树。 3、仅包含黑色节点的四叉树高度比包含相同节点的二叉树高度要小，完全二叉树的高度近似log2n，去掉红色结点的红黑树也就是小于 log2n。 4、因为红黑树红黑结点相隔，加入红色节点之后，红黑树的高度近似 2log2n。 补充：红黑树的高度只比高度平衡的 AVL 树的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。 四、为什么喜欢在工程中用红黑树平衡二叉查找树？ 1、其他平衡而二叉树 Treap、Splay Tree 绝大情况下操作效率非常高，但是在极端情况下时间复杂度会退化，这种极端情况虽然出现的概率不大，对于单次操作时间非常敏感。 2、AVL树是一种高度平衡二叉树，查找的效率非常高，但是AVL树为了维持这种高度平衡，每次插入、删除都要做调整，就比较复杂、耗时。所以对于比较频繁的插入、删除操作的数据集合，使用AVL树代价比较高。 3、红黑树虽然只做到了近似平衡，并不是严格的平衡，所以在维护成本上比AVL树低。 4、红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，更倾向于这种性能稳定的平衡二叉查找树。 五、扩展思考1、还有哪些支持动态地数据插入、删除、查找操作的数据结构，各自的优缺点和应用场景怎么样的？ 答： 六、联系扩展1、跳表 红黑树实现比较复杂，更倾向用跳表来代替。]]></content>
      <categories>
        <category>数据结构</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github 开源项目工作流程【git】]]></title>
    <url>%2F2018%2F12%2F25%2F%E5%B0%8F%E5%AD%A6%E7%94%9F%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%20Git%20%E4%B9%8B%E3%80%90%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿详细分享 Github 开源项目工作流程。 Github 工作流程1、fork 开源项目 克隆别人好的开源项目在自己的远程仓库。 2、Clone 开源项目 将 fork 的项目 clone 到本地仓库，拥有本地的开发环境。 3、进行修改项目内容 注意：不建议直接在 master 分支上直接修改。 ① 我们需要另外创建一个分支（并且换分支）进行修改。 1$ git checkout -b 分支名字 查看当前分支命令： 1234//查看当前本地分支$ git branch//查看远程仓库当前分支$ git branch -a 切换分支命令： 1$ git checkout 分支名 ② 更改项目某些信息 1$ git add a.text 1$ git commit -m &apos;add a.text&apos; ③ 将分支合并到主分支 1$ git checkout master //切换到主分支 合并分支到主分支 1$ git merge 分支名 ④ 将本地从仓库修改的项目同步到远程仓库中 1$ git push 4、 Pull request(提交一个请求) 向原作者提交你的项目。 ① New pull request（新建一个请求） github 这时候自动对源仓库和自己的远程仓库进行代码对比，是否存在冲突，如果有冲突就会显示 Able to merge(可以合并) 。 ② Create pull request 我们就创建一个新的请求。（在请求里边备注向原作者提交的原因或改动内容） 5、原作者就会收到一个请求 Pull request 1. ① 原作者点进去可以看到别人对自己项目提交的请求。 ② merg pull request 如果觉得他人对自己的修改有帮助，就将请求内容合并到自己当前的分支。 6、fetch 原作者的项目变动，我们仓库的项目怎么进行同步呢？ 1$ git fetch 源项目地址 master:latest (源项目的分支：自己本地项目的分支) 注意：本地项目分支也可以是主分支。（不建议直接在主分支修改） 7、merge 我们将代码 fetch 到 latest 了，接下来怎么做？ ① 切换到主分支进行 fetch 的代码合并 12$ git checkout master //切换到主分支 $ git merge 分支名 8、Push 本地仓库的代码与原作者的仓库的代码同步了，但是我们的远程仓库还没有同步,我们进行代码同步。 1$ git push]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端项目总结]]></title>
    <url>%2F2018%2F12%2F24%2F%E5%89%8D%E7%AB%AF%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B9%8B%E3%80%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[前端项目总结 JavaScript 功能总结一、页面接受数据传参页面1admin?username=xiaolu&amp;password=123 接受页面123456789101112131415var url=location.search; //获取得到 ? 之后的部分var object = new Object(); //新建一个Request对象url = decodeURI(url); //中文转码if(url.indexOf(&quot;?&quot;)!=-1)&#123; //判断url中是否存在 ? 字符 var str = url.substr(1);//截取?之后的字符串 strs= str.split(&quot;&amp;&quot;); //将字符串以符号&quot;&amp;&quot;分隔成两段 for(var i = 0; i &lt; strs.length; i++)&#123; //将每一段字符串又以&quot;=&quot;分为两段,键存储到对象 object 中去 object[strs[i].split(&quot;=&quot;)[0]] = strs[i].split(&quot;=&quot;)[1]; &#125;&#125;//通过访问对象的属性获取值username = object[username]password = object[password] 二、JS 事件监听传「字符串」参数1onclick=&apos;member_edit(\&quot; &quot;+&apos;操作员编辑&apos;+&quot; \&quot;)&apos; 传参使用转义将引号转义。 三、背景图要 (no-repeat)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小学生都能学会的 Git 之【基础设置】]]></title>
    <url>%2F2018%2F12%2F23%2F%E5%B0%8F%E5%AD%A6%E7%94%9F%E9%83%BD%E8%83%BD%E5%AD%A6%E4%BC%9A%E7%9A%84%20Git%20%E4%B9%8B%E3%80%90%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你入门 Git 版本控制工具。 Git 入门配置1、配置 user 信息123$ git config --global user.name 'your_name'$ git config --global user.email 'your_email@domain.com' config 的三个作用域： 123$ git config --local //只对某个仓库有效$ git config --global //对当前用户所有仓库有效$ git config --system //对系统所有的登录用户有效 显示 config 的配置（加 –list） 123$ git config --list --local$ git config --list --global $ git config --list --system 2、建立 Git 仓库 注意：首先切换到你想建立仓库的本地文件夹。 初始化一个git仓库1git init 仓库名 //我这里的仓库名为 git_xaiolu 1cd git_xiaolu //切换到仓库文件夹中 里边会有一个叫做 .git 的隐藏文件。 后边会讲到文件夹中每个文件有什么作用。 设置新建仓库配置① 先查看仓库的当前配置 1git config --global --list 上边信息是我们之前设置过全局仓库的配置，所以本地所有的仓库配置都是统一 username 和 email 。 问题：我们想要单独配置该仓库的信息怎么办？ 那我们使用 --local 专门配置当前仓库的配置信息。 12$ git config --local user.name &apos;xiaolu&apos; //修改 name 为 xiaolu$ git config --local user.email &apos;2645299496@qq.com&apos; //修改email为另一个邮箱地 2645299496@qq.com ② 我们再使用命令查看一下配置信息是否更改。 1git config --local --list 已更改！ ③ 添加一个名叫做 xiaolu 的文件夹 1mkdir xiaolu ④ 我们在文件夹中添加一个叫做 test.txt 文件。 1234cd xiaolu //切换到新建文件夹中vi test.txt //新建一个文件输入 : wq 保存并退出。 查看当前目录下有有没有我们刚刚创建的 test.txt 文件。 1ls ⑤ 然后提交到 git 仓库中。 1git add test.txt 这个命令的作用就是我们将 test.txt 文件提交到缓存中，还有没有真正的提交到我们创建的仓库中去。 1git status 我们可以通过上边的命令查看当前提交缓存的文件是否已经在一个叫做「暂存区」的地方。 上图说明我们的文件已经在缓存中等待用户下一步的提交了。 下面我们进行真正的提交到仓库。 1$ git commit -m &apos;add new file&apos; 这句命令具体什么意思呢？ commit提交的意思，-m 后边要加上在这次提交的备注。 如果你不写备注，你的团队是知道你提交了什么东西。一个好的备注是至关重要的。 提交成功！ ⑥ 查看我们提交的记录 1$ git log //通过此命令可以查看提交的历史记录（也就是提交日志） 我们可以在日志汇总看到提交者、提交日期、提交备注等信息。]]></content>
      <categories>
        <category>Git版本控制</category>
      </categories>
      <tags>
        <tag>Git版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【二叉树】]]></title>
    <url>%2F2018%2F12%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[什么样的二叉树适合用数组来存储！ 二叉树（上） 什么样的二叉树适合用数组来存储！ 一、树（tree）1、树的定义 树中的每个元素叫做“节点”；用来连线的关系叫做“父子关系”；没有父节点的节点叫做根节点；我们没有子节点的节点叫做叶子节点。 2、树的三个概 高度(Height)、深度(Depth)、层(Level)。 节点的高度 = 节点到叶子节点的最长路径（边数）。 节点的深度 = 根节点到这个节点所经历的边的个数。 节点的层数 = 节点深度 + 1。 树的高度 = 根节点的高度。 二、二叉树（Binary Tree）1、特点 二叉树，最多只有两个节点。 2、两种二叉树 ■ 满二叉树 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。（上图二号树） ■ 完全二叉树① 叶子节点都在最底下两层 ，最后一层的叶子节点都靠左排列。 ② 并且除了最后一层，其他层的节点个数都要达到最大。 ③ 数组存储中最省内存的一种方式。 三、如何存储一棵二叉树 理解完全二叉树，先理解如何存储一棵树。 1、两种存储方法 基于指针或者引用的二叉链式存储法。 基于数组的顺序存储法。 ■ 链式存储法 ■ 顺序存储法 ① 根节点存储在下标 i = 1 的位置。 ② 左子节点存储在下标 i * 2 = 2 的位置。 ③ 右子节点存储在 i * 2 + 1 = 3 的位置。 ■ 链式和顺序的区别 1、完全二叉树可以节省存储空间，而下边这种情况浪费了大量的存储空间。 2、数组的存储方式不像链表一样需要额外的存储指针的空间。 四、二叉树的遍历1、三种方式（递归） 二叉树的前、中、后遍历就是一个递归的过程。 前序遍历： 根节点 ——&gt; 左子树 ——&gt; 右节点 中序遍历: 左子树 ——&gt; 根节点 ——&gt; 右子树 后序遍历: 左子树 ——&gt; 右节点 ——&gt; 根节点 2、递归公式※ 递归章节链接：如何写递归代码？ 写递归代码看是否能写出递归公式，递归公式的关键就是，解决 A 问题就要假设子问题 B、C已经解决，然后看利用 B、C来解决 A。 12345678前序遍历的递推公式：preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)中序遍历的递推公式：inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)后序遍历的递推公式：postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r 3、递归代码123456789101112131415161718192021//前序遍历void preOrder(Node* root) &#123; if (root == null) return; print root // 此处为伪代码，表示打印 root 节点 preOrder(root-&gt;left); preOrder(root-&gt;right);&#125;//中序遍历void inOrder(Node* root) &#123; if (root == null) return; inOrder(root-&gt;left); print root // 此处为伪代码，表示打印 root 节点 inOrder(root-&gt;right);&#125;//后序遍历void postOrder(Node* root) &#123; if (root == null) return; postOrder(root-&gt;left); postOrder(root-&gt;right); print root // 此处为伪代码，表示打印 root 节点&#125; 4、二叉树遍历的时间复杂度 每个树的结点需要遍历一遍，所以二叉树遍历时间复杂度为 O(n)。 五、扩展思考1、给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？ 放到数组中存储有多少种存储方式，n! 种方式。 2、二叉树按照层的遍历方式是怎么实现的？ 图的广度优先遍历（※ 章节链接：图的广度优先遍历）的问题。 二叉树（下） 有高效的散列表（※ 章节链接：散列表）为何还需要二叉树？ 一、二叉查找树■ 定义 二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。 ■ 特点 在树的任意节点，其左子树的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。 ■ 优点 实现快速的增删改查。 二、二叉查找树的操作1、查找操作■ 查找思想 要查找数据与根节点对比，如果等于要查找的数据，返回该数据。如果数据小于根节点，左子树进行递归。否则右子树进行递归查询。 ■ 代码实现12345678910111213141516171819202122232425262728293031323334353637 public class BinarySearchTree &#123; //声明一课树 private Node tree; //定义树结点 public static class Node &#123; //树的数据节点 private int data; //树的左子树 private Node left; //树的右子树 private Node right; //构造传值 public Node(int data) &#123; this.data = data; &#125; &#125; //查找树操作 //参数为要查找的数据 public Node find(int data) &#123; //给树赋值 Node p = tree; //如果这棵树不为空 while (p != null) &#123; //树的根节点与要查找数据进行比较 //如果小于根节点，就在左子树查找 if (data &lt; p.data) p = p.left; //如果大于节点，就在右子树查找 else if (data &gt; p.data) p = p.right; //否则等于根节点 else return p; &#125; //如果次树为空，则返回null return null; &#125;&#125; 2、插入操作■ 插入思想 如果插入的数据比结点大，并且节点的右子树为空，就将新数据插到右节点的位置，否则就递归遍历右子树，查找插入位置。如果数据小于根节点，那么就插入到左子树。 ■ 代码实现1234567891011121314151617181920212223242526272829public void insert(int data) &#123; if (tree == null) &#123; tree = new Node(data); return; &#125; Node p = tree; //如果树不为空 while (p != null) &#123; //如果插入的数据大于根节点的数据 if (data &gt; p.data) &#123; //且根节点的右子树为空 if (p.right == null) &#123; //将数据插入到右子树 p.right = new Node(data); return; &#125; //遍历下一个节点 p = p.right; // data &lt; p.data &#125; else &#123; if (p.left == null) &#123; p.left = new Node(data); return; &#125; p = p.left; &#125; &#125;&#125; 3、删除操作■ 情况一：如果删除的结点没有子节点 在父节点将指向删除结点的指针为 null。 ■ 情况二：如果删除的结点只有一个节点（左子节点或右子节点） 将父节点直接指向删除节点的子节点。 ■ 情况三：要删除的节点有两个子节点 1、首先找到该节点的右子树中最小的结点。将最小节点与删除节点进行替换。 2、删除这个最小节点，因为最小节点没有左子树。 ■ 删除节点改进 单纯的将将要删除的结点标记为已删除，但不是真正的删除，单数删除的结点还是存储到内存空间中，比较浪费内存，但是删除操作就变得很简单了。 ■ 代码实现123456789101112131415161718192021222324252627282930313233public void delete(int data) &#123; Node p = tree; // p 指向要删除的节点，初始化指向根节点 Node pp = null; // pp 记录的是 p 的父节点 while (p != null &amp;&amp; p.data != data) &#123; pp = p; if (data &gt; p.data) p = p.right; else p = p.left; &#125; if (p == null) return; // 没有找到 // 要删除的节点有两个子节点 if (p.left != null &amp;&amp; p.right != null) &#123; // 查找右子树中最小节点 Node minP = p.right; Node minPP = p; // minPP 表示 minP 的父节点 while (minP.left != null) &#123; minPP = minP; minP = minP.left; &#125; p.data = minP.data; // 将 minP 的数据替换到 p 中 p = minP; // 下面就变成了删除 minP 了 pp = minPP; &#125; // 删除节点是叶子节点或者仅有一个子节点 Node child; // p 的子节点 if (p.left != null) child = p.left; else if (p.right != null) child = p.right; else child = null; if (pp == null) tree = child; // 删除的是根节点 else if (pp.left == p) pp.left = child; else pp.right = child;&#125; 4、查找最大节点和最小节点■ 查找最大节点1234567891011121314/*** 时间:2019/2/24* 功能:寻找最大节点*/public Node findMax() &#123; //如果树为空树,直接返回 if(tree == null) return null; //否则遍历右子树寻找最大点 Node p = tree; while(p.right != null) &#123; p = p.right; &#125; return p;&#125; ■ 查找最小节点12345678910111213/*** 时间:2019/2/24* 功能:寻找最小节点*/public Node findMin() &#123; if(tree == null) return null; //否则遍历左子树寻找最大点 Node p = tree; while(p.left != null) &#123; p = p.left; &#125;return p;&#125; 5、查找前驱结点和后继节点■ 代码实现12 6、输出有序数据序列 二叉查找树(二叉排序树)，中序遍历二叉树。时间复杂度为 O(n)。 三、二叉查找树存储对象 在实际开发，用二叉查找树存储多个字段的对象，以对象的某个值来构建二叉查找树，其他字段叫做卫星数据。 1、存储相同的值■ 方法一： 二叉查找树中每一个节点不仅会存储一个数据，因此通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储到同一个节点上。 ■ 方法二： ① 插入数据时，将相同的值作为大于根节点的值，放在该结点的右子树，继续遍历，直到结束为止。 ② 查找数据时，遇到相同值的结点，我们并不停止查找操作，我们继续在右子树进行查找，直到遇到叶子节点，停止。这样才能把键值等于要查找值的所有节点都找出来。 ③ 删除数据时，需要先查找到每个要删除的节点，然后再按前面讲的删除操作方法，依次进行删除。 四、二叉查找树的时间复杂度1、时间复杂度分析■ 最糟糕的情况 二叉查找树插入数据失去平衡，退化成单链表，查找的时间复杂度为 O(n)。 ■ 最理想的情况 完全二叉树：求查找、插入、删除操作的时间复杂度，时间复杂度其实都跟树的高度成正比，也就是O(height)，如何求n个节点的完全二叉树的高度？ ■ 具体分析 ① 高度 = 层数 - 1，转化成层来计算，第一层一个结点，第二层两个节点，第三层四个结点…… 第 K 层结点数为 2^(K-1)。 ② 完全二叉树最后一层的节点个数在 1 个到 2^(L-1) 个之间（假设最大层数是 L），把每层的节点加起来就等于 n。 123//完全二叉树n &gt;= 1+2+4+8+...+2^(L-2)+1n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1) ③ 等比数列求和，可以计算出范围 [log2(n+1), log2n +1] ，所以完全二叉树的高度小于等于 log2n 。 ■ 改进 平衡二叉树:搭建一种平衡的二叉树，树的高度接近于 logn ,插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。 五、相对于散列表，为什么还用二叉查找树呢？ 1、散列表中的数据无序存储的，输出数据需要先排序。而二叉查找树直接中序遍历，在 O(n）时间复杂度内，输出有序的数据序列。 2、散列表扩容耗时，遇到散列冲突时。性能不稳定。二叉查找树尽管不稳定，工程中最常用的是平衡二叉查找树性能非常稳定，时间复杂度稳定在 O(logn)。 3、笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。 4、 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。 5、浪费大量内存空间。为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。 六、扩展思考：如何通过编程，求出一棵给定二叉树的确切高度呢？]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【跳表1】]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E8%B7%B3%E8%A1%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[为什么 Redis 一定要用跳表来实现有序集合？而不是红黑树？ 跳表的实现 一、什么是跳表？ 用单链表来实现二分查找进行稍加修改，支持类似于“二分”的查找算法。我们把改造之后的数据结构叫做跳表。 二、优点是什么？ 支持快速的增、删、改、查，写起来也不复杂，可以完全代替红黑树。 三、怎么实现跳表？ 对单链表进行添加索引层，能够快速的实现查找某一个结点。 1、快速查找的原因 加上一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查询效率提高了不少。 2、改进 为了再改进查询效率，我们会再添加二级索引、三级索引… 3、举例 原本 65 个结点需要遍历 65 次进行查找，现在建立了五层索引，查找次数只用了 11 次。数据越多，效果越来越明显。 三、跳表的时间复杂度 跳表的时间复杂度。 1、 索引个数的计算 假设每两个结点设置一个索引，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2^k)。 2、时间复杂度分析 1、假设索引有 h 级，最高级的索引有 2 个结点，可得 n/(2^h)=2，h=log2n - 1如果包含原来的这一层，跳表的高度就是 log2n 。 2、查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn）。 3、按照前边的错音，只需要遍历 3 个就可以了，也就是 m=3 3、m = 3 是怎么来的？我们规定每层索引的节点与节点之间的只有三个结点。 4、时间复杂度 跳表的时间复杂度为 O(logn) ,和二分查找的时间复杂度是相同的。 四、跳表的空间复杂度 跳表的实现，需要存储多级索引，会消耗掉更多的存储空间。 1、结点空间分析 每个索引层需要额外的存储空间，以三个结点为例，一级索引需要 n/3 ,二级索引需要 n/9 ,以此类推。 跳表的时间复杂度为：O(n) 。 2、怎么降低跳表的空间复杂度？ 增加结点之间的间距，尽管时间复杂度没有改变，但是索引的存储空间减少了一半。不用过多的在乎这些，当单链表中的存储有很大对象的时候，索引额外的空间就可以忽略了。 五、跳表高效的动态插入和删除1、插入数据 会以时间复杂度为 O(logn) 进行查找，然后以 O(1) 进行插入数据。 2、删除数据 删除也是使用同样的方法来解决，删除的同时一定要获取前驱结点，但是记住，删除数据的同时要删除索引。 六、跳表索引动态更新 我们不断的往跳表中添加数据，导致某一个结点数据很多。极端情况下，会退化成单链表。 1、动态更新 通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第K 级这 K 级索引中。 2、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * 跳表的一种实现方法。 * 跳表中存储的是正整数，并且存储的是不重复的。 * * Author：ZHENG */public class SkipList &#123; private static final int MAX_LEVEL = 16; private int levelCount = 1; private Node head = new Node(); // 带头链表 private Random r = new Random(); public Node find(int value) &#123; Node p = head; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; &#125; if (p.forwards[0] != null &amp;&amp; p.forwards[0].data == value) &#123; return p.forwards[0]; &#125; else &#123; return null; &#125; &#125; public void insert(int value) &#123; int level = randomLevel(); Node newNode = new Node(); newNode.data = value; newNode.maxLevel = level; Node update[] = new Node[level]; for (int i = 0; i &lt; level; ++i) &#123; update[i] = head; &#125; // record every level largest value which smaller than insert value in update[] Node p = head; for (int i = level - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; update[i] = p;// use update save node in search path &#125; // in search path node next node become new node forwords(next) for (int i = 0; i &lt; level; ++i) &#123; newNode.forwards[i] = update[i].forwards[i]; update[i].forwards[i] = newNode; &#125; // update node hight if (levelCount &lt; level) levelCount = level; &#125; public void delete(int value) &#123; Node[] update = new Node[levelCount]; Node p = head; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; p.forwards[i].data &lt; value) &#123; p = p.forwards[i]; &#125; update[i] = p; &#125; if (p.forwards[0] != null &amp;&amp; p.forwards[0].data == value) &#123; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; if (update[i].forwards[i] != null &amp;&amp; update[i].forwards[i].data == value) &#123; update[i].forwards[i] = update[i].forwards[i].forwards[i]; &#125; &#125; &#125; &#125; // 随机 level 次，如果是奇数层数 +1，防止伪随机 private int randomLevel() &#123; int level = 1; for (int i = 1; i &lt; MAX_LEVEL; ++i) &#123; if (r.nextInt() % 2 == 1) &#123; level++; &#125; &#125; return level; &#125; public void printAll() &#123; Node p = head; while (p.forwards[0] != null) &#123; System.out.print(p.forwards[0] + " "); p = p.forwards[0]; &#125; System.out.println(); &#125; public class Node &#123; private int data = -1; private Node forwards[] = new Node[MAX_LEVEL]; private int maxLevel = 0; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); builder.append("&#123; data: "); builder.append(data); builder.append("; levels: "); builder.append(maxLevel); builder.append(" &#125;"); return builder.toString(); &#125; &#125;&#125; 七、为什么 Redis 要用跳表来实现有序集合，而不是红黑树？1、Redis 中的有序集合支持的核心操作主要有下面这几个 插入一个数据； 删除一个数据； 查找一个数据； 按照区间查找数据（比如查找值在 [100, 356] 之间的数据）； 迭代输出有序序列。 2、跳表比红黑树的优势 1、查找操作比红黑树要快。 2、插入、删除和红黑树差不多，但是按照区间查找O(logn)就能完成。 2、跳表更容易代码实现，意味着可读性好，不容易出错。 3、跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。 3、红黑树的优势 红黑树直接拿来用就可以了，跳表必须自己实现。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【散列表】]]></title>
    <url>%2F2018%2F11%2F28%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E6%95%A3%E5%88%97%E8%A1%A8%E3%80%91%2F</url>
    <content type="text"><![CDATA[Word文档中的单词拼写检查功能是如何实现的？ 散列表（一）一、什么是散列表 散列表的英文也叫做 “Hash Table”,平时我们叫他 “哈希表” 或者 “Hash表”。散列表用的是「数组支持下标随机访问的特性」，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说没有数组就没有散列表。 二、散列表的特点 散列思想：把数组下标叫做键（key）或者关键字，把数组中的值转化为数组的下标的映射方法叫做散列函数（”Hash”函数或者“哈希函数”），通过散列函数计算得到的值叫做散列值（“Hash值” “哈希值”）。 三、散列表的优点（随机访问） 1、散列表就是利用数组支持下标随机访问，时间复杂的O（1）的特性，通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应的下标位置。 2、通过键值查询数据元素的时用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取数据。 四、散列表的缺点（散列冲突）1、散列冲突 即使再完美的散列表也会出现散列冲突的情况。 2、开放寻址法 当我们遇到散列冲突的时候，就重新探测一个空闲位置，将其插入。 ■ 优点 ① 散列表都存储在数组中，可以有效的利用 CPU 缓存加快查询速度。 ② 序列化起来简单，链表包含指针，序列化起来没那么容易。（？） ■ 缺点 ① 删除数据的时候比较麻烦，需要特殊的标记已经删除的数据。 ② 开放寻址所有的数据存储到一个数组中，比起链表法来说，冲突的代价更高。 ③ 使用开放寻址的散列表，转载因子不能太大，这种方法比链表法更浪费内存空间。 ■ 两种探测方法 1、线性探测 插入操作 ​ 插入数据，若位置被占用，则从当前位置开始往后依次寻找空闲位置，直到插入。 查找操作 查找元素，如果求得的元素不相等，我们就依次向后查找。 删除操作 前提：通过线性探测，找到一个空闲位置，我们就认定散列表不存在该值。 方法：将删除的元素标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下测。 2、二次探测和双重散列 ① 所谓的二次探测，跟线性探测很像，线性探测每次探测步长为1，而二次探测是原来的二次方。它探测的下标序列就是 hash(key)+0，hash(key)+1²hash(key)+2²… ② 所谓的双重散列，不仅要使用一个散列函数，我们要使用一组散列函数，先用一组散列函数计算得到存储位置，如果已经被占用，就再用第二个散列函数，以此类推，直到找到空闲存储位置。 3、装载因子 表示散列表空位的多少。装载因子越大，空闲位置越少，冲突越多，散列表的性能就会下降。 1散列表的装载因子 = 填入表中的元素个数 / 散列表的长度 3、链表法 当插入数据的时候，计算出散列表的槽位，将其插入到槽位后对应的链表中。 1、插入的时间复杂度为 O(1)。 2、查找、删除的时间复杂度为O(k) 。 ■ 优点 ① 链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创键，并不需要提前申请好。 ② 链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适合装载因子小于1 的情况。接近1时就会有可能大量的散列冲突，导致大量的探测、再散列等。链表法只不过是链表变长了，查找效率有所下降，比起顺序查找还是快很多。 ■ 缺点 ① 链表的因为需要存储指针，所以对于比较小的对象存储，是比较消耗内的。可能让内存进行翻倍。 ② 因为链表的结点是散列的分布到内存的，不是连续的，对 CPU 不友好。 五、散列函数1、定义 散列函数，把它定义成 hash（key）,其中 key 表示元素的键值，hash（key）的值表示经过散列函数计算得到的散列值。 2、散列函数的设计要求① 散列函数计算得到的散列值是一个非负整数； 解释：数组下标是从 0 开始的。 ② 如果 key1 = key2,那 hash（key） == hash（key2）; 解释：相同的 key 的到的散列值也相同。 ③ 如果 key1 ≠ key2,那 hash（key） ≠ hash（key2）; 解释：有可能不能达到此要求，因为会有散列冲突现象。 六、应用思考：Word文档中的单词拼写检查功能是如何实现的？ 答：常见的英文单词有 20 万个左右，假设单词的平均长度是 10 个单词，平均一个单词占用 10 个字节的内存空间，20 万大约占用 2 MB，这个大小完全可以存储的开，我们用散列表来实现。当用户输入单词的时候，我们拿着单词去散列表中查找，如果查找到了，则说明拼写正确，如果没有，则拼写错误，基于提示。 七、扩展思考1、假设我们有 10 万条 URL 访问日志，如何按照访问次数给URL 排序？ 答：首先，我们遍历这 10 万条数据，URL 为 key，访问次数是value，将他们存入散列表。然后借助排序算法中的快排。 2、有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？ 答：先以第一个数组为例建立一个散列表，key 字符串，value 全部设置为 0，另一个数组中的字符串作为 key 在散列表中进行查找，如果可以找到，则为两个数组共同的字符串。 散列表（二）一、何为工业级的散列表 支持快速的查询、插入、删除操作； 内存占用合理。不能浪费过多的内存空间； 性能稳定，在极端情况下，散列表的性能也不会退化到无法接受的情况。 二、如何实现这样一个散列表？ 设计一个合适的散列函数 定义装载因子阈值，并且设计动态扩容策略 选择合适的散列冲突解决方法 1、如何设计散列函数？ 散列表设计不能太复杂；散列函数生成的值尽可能的随机并且均匀分布。 数据分析（重点） 直接寻址法 平方取中法 折叠法 随机数法 2、如何根据装载因子动态扩容 散列表的装载因子越大，散列表中的元素越多，空闲位置越少，散列冲突的概率越大。多次寻址导致消耗很长时间，链表法导致拉很长的链，查找过程非常慢。 ■ 静态数据 很容易根据特点设计出合适的散列表。 ■ 动态数据 随着数据不断的插入，装载因子不断的慢慢变大，到达一定程度的时候，散列冲突不得不发生。 动态扩容 我设置一定的阈值来进行散列空间的扩容，在装载因子小于某个值的时候进行缩容，超过某个阈值进行扩容。 两个问题 扩容过大，导致内存浪费。 散列空间过小，导致三列散列冲突。 两个方法 如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值； 如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。 二、如何避免低效地扩容？1、什么是低效的扩容？ 当装载因子到达阈值时，需要先进行扩容，再插入数据，在这个种极端的情况下插入数据会非常慢。 2、怎么解决低效的扩容？ 当达到装载因子阈值之后，申请新空间，但是不进行数据搬移，当有新数据插入的时候，从老散列表拿出数据往新的散列表进行插入。重复此过程，在极端的情况下复杂度也是O（1）。 三、如何选择冲突解决方法？ 最常用解决冲突的方法为链表法和开放寻址法。 java中的 LinkedHashMap 就采用了链表法解决冲突。 而 ThreadLocalMap 就采用了线性探测的开放寻址法来解决冲突。 1、开放寻址法■ 优势： ① 散列表都存储在数组中，可以有效的利用 CPU 缓存加快查询速度。 ② 序列化起来简单，链表包含指针，序列化起来没那么容易。（？） ■ 缺点： ① 删除数据的时候比较麻烦，需要特殊的标记已经删除的数据。 ② 开放寻址所有的数据存储到一个数组中，比起链表法来说，冲突的代价更高。 ③ 使用开放寻址的散列表，转载因子不能太大，这种方法比链表法更浪费内存空间。 ■ 适用条件： 当数据量比较小、装载因子小的时候，适合采用开放寻址法。 2、链表法■ 优势： ① 链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创键，并不需要提前申请好。 ② 链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适合装载因子小于1 的情况。接近1时就会有可能大量的散列冲突，导致大量的探测、再散列等。链表法只不过是链表变长了，查找效率有所下降，比起顺村查找还是快很多。 ■ 缺点： ① 链表的因为需要存储指针，所以对于比较小的对象存储，是比较消耗内的。可能让内存进行翻倍。 ② 因为链表的结点是散列的分布到内存的，不是连续的，对 CPU 不友好。 ■ 改进： 我们将链表法中的链表改造为其他高效动态的数据结构，比如跳表、红黑树。这样，即便出现的散列冲突，极端情况下，所有数据都散列到同一个桶内，最终退化成的散列表的查询时间也只不过是O(logn)。 ■ 适用条件： 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。 五、举例：工业级散列表 HashMap1、初始化大小 HashMap默认的初始化大小16，当然这个默认值可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始化大小，减少动态扩容的次数，这样大大提高HashMap的性能。 2、装载因子和动态扩容 最大转载因子是0.75，当 HashMap 中的元素个数超过0.75 * capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都是原来的两倍大小。 3、散列冲突解决方法 使用链表法来解决冲突的。负载因子和散列函数设计的再合理，也避免不了会出现拉链过长的情况，一旦拉链过长，则会影响 HashMap 的性能。 4、对链表法的优化 当链表长度太长（默认超过8）时，链表就转化成了红黑树，利用红黑树快速增删改查的特点，提高HashMap的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。 散列表（三）一、LRU 缓存淘汰算法1、淘汰数据 维护一个按照访问时间从大到小有序排序的链表结构。因为缓存大小有限，我们遍历整个链表，当缓存空间不足时，需要淘汰一个数据，直接将头部的结点删除。 2、缓存数据 当缓存某个数据的时候，先在链表中查找这个数据，如果没有找到，直接将数据添加到尾部，如果找到了，将它移动到尾部。再遍历链表的时候需要遍历整个链表，时间复杂度为O(n)。 3、主要操作 一下三种操作都涉及“查找”操作，时间复杂度为 O(n)，我们将链表和散列表两种数据结构组合到一起，将复杂度降为O(1)。 往缓存添加一个数据 从缓存删除一个数据 在缓存查找一个数据 4、散列表和(双向)链表结合 除了双向链表存储数据之外，我们还有一个 hnext 指针，一个链是在我们的双向链表中，另一个hnext是我们散列表的拉链。hnext指针将我们的链表串在散列表中。 ① 查找一个数据 散列表查找数据的时间复杂度为 O(1)，查找到之后，我们将其移动到双链表的为尾部。 ② 删除一个数据 我们通过散列表在O(1)的时间复杂度之内找到数据之后，然后通过前驱指针O(1)的时间复杂度，直接获取双向链表前驱结点，删除只需要O(1)的时间复杂度。 ③ 添加一个数据 添加数据先要查看缓存中有没有该数据，如果没有就添加到双链表的尾部，添加的时候判断缓存有没有满，如果满了，需要先删除链表头部的数据，然后将数据插入到链表的尾部。如果没有满，就直接插到链表的尾部。 二、Redis 有序集合 为什么 Redis 要用跳表来实现有序集合，而不是红黑树？ 1、Redis 中的有序集合支持的核心操作主要有下面这几个 插入一个数据； 删除一个数据； 查找一个数据； 按照区间查找数据（比如查找值在 [100, 356] 之间的数据）； 迭代输出有序序列。 2、跳表比红黑树的优势 1、查找操作比红黑树要快。 2、插入、删除和红黑树差不多，但是按照区间查找O(logn)就能完成。 2、跳表更容易代码实现，意味着可读性好，不容易出错。 3、跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。 3、红黑树的优势 红黑树直接拿来用就可以了，跳表必须自己实现。 三、LinkedHashMap LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。 代码实例：12345678910111213// 10 是初始大小，0.75 是装载因子，true 是表示按照访问时间排序HashMap&lt;Integer, Integer&gt; m = new LinkedHashMap&lt;&gt;(10, 0.75f, true);m.put(3, 11);m.put(1, 12);m.put(5, 23);m.put(2, 22);m.put(3, 26);m.get(5);for (Map.Entry e : m.entrySet()) &#123; System.out.println(e.getKey()); //打印顺序为 1235&#125; 实现原理与LRU 缓存淘汰策略一样的，按照此分析。 四、为什么散列表经常和链表使用原因一： 1、虽然散列表可以非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。 2、它无法按照某种顺序快速的遍历数据，如果希望按照顺序遍历散列表中的数据，那我们就将散列表中的数据拷贝到数组中，然后排序，再遍历。 原因二： 因为散列表是动态数据结构，不停的进行插入、删除。每当我们进行遍历数据的时候，先要进行排序，那效率就会很低。 五、思考1、如果把双向链表改成单链表，还能否正常工作呢？为什么呢？ 答: 可以，但是删除操作时间复杂度会降到 O（n）。 2、假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作： 根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息； 答：散列表实现，时间复杂度为 O（1）。 查找积分在某个区间的猎头 ID 列表； 答：跳表。 查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表。 答：需要排序，暂时无法实现。（？？？？？） 六、疑问 1、散列表和链表是怎么关联起来的？ 2、散列表怎么直接定位到结点的？答：散列表中存储少量的链表。 3、查找数据将其移动到尾部？答：需要维护一个指向尾部的指针。 4、插入的时候，内存已满，需要在链表头部插入数据，散列表对应的值是否也应该改变？]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax 全面解析]]></title>
    <url>%2F2018%2F11%2F15%2FAjax%20%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[小鹿带你全面了解 Ajax 。 Ajax 全面解析一、Ajax 概念介绍1、Ajax-XMLHttpRequest 对象的创建 IE5 和 IE6 不支持 new 一个 XMLHttpRequest 的，我们使用时需要进行判断。 123456var request;if(window.XMLHttpRequest)&#123; request = new XMLHttpRequest();//IE7+&#125;else&#123; request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE6.IE5&#125; 2、XMLHttpRequest 发送请求① open(method,url,async) method :发送请求的方法 （Post、Get） url : 请求地址（相对地址/绝对地址） async : 是否异步处理（同步或者异步） 实例： 3、XMLHttpRequest 取得相应 responseText: 获取字符串形式的响应数据 responseXML: 获取 XML 形式的响应数据 status 和 statusText : 以数字和文本形式返回 HTTP 状态码 getAllResponseHeader (): 获取所有的响应报头 getResponseHeader ():查询响应中的某个字段的值 监听服务器响应状态：readyState 属性 0：请求未初始化，open 还没有调用 1：服务器连接已建立，open 已经调用 2：请求已接收，也就是接收到头信息了 3：请求处理中，也就是接收到响应主体了 4：请求已完成，且响应已就绪，也就是响应完成了]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【排序】]]></title>
    <url>%2F2018%2F10%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[冒泡排序、插入排序、选择排序、归并排序、快速排序、桶排序、计数排序、基数排序！ 一、如何分析一个“排序算法”1、排序算法的执行效率 最好、最好、平均时间复杂度 分析三种复杂度，还要分析出最好、最坏时间复杂度对应的要排列的原始数据是什么样的。 时间复杂度的系数、常数、低阶 时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。数据规模可能很小，10、100、1000，我们就必须把系数、常数、低阶考虑进来。 比较次数和交换（或移动）次数 基于比较的排序算法的执行过程，会涉及到比较和交换。如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。 2、排序算法的内存消耗 算法的内存消耗可以通过空间复杂度来衡量。 原地排序算法 就是指特定空间复杂度是 O(1) 的排序算法。 稳定排序算法 如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。 例子： 稳定排序，电商系统按照金额的排序，相同金额按时间早晚排序（先排时间，后排金额 [相同的后操作紫自动调整]）。 二、插入排序、冒泡排序、选择排序 O(n²)1、冒泡排序■ 冒泡排序思路 每次冒泡对相邻的两个元素进行比较，看是否满足大小关系，不满足就进行互换，一次冒泡会让至少一个元素移动到它应该在的位置。有 n 个数据，需要重复 n 次。 ■ 冒泡排序优化 当某次冒泡过程已经没有数据交换时，说明已经达到完全有序，不用再执行后续的冒泡操作。 ■ 冒泡排序是原地排序算法吗？ 答：是 分析：冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。 ■ 冒泡排序是稳定的排序算法吗？ 答：是 分析：当有相邻的两个元素大小相等的时候，我们不做交换，所以冒泡排序是稳定的排序算法。 ■ 冒泡排序的时间复杂度是多少？ 最好的情况是数据已经排好序，我们只进行一次冒泡排序就可以了，最好时间复杂度为 O(n) 。最坏的情况是，要排序的数据刚好是倒序排列的，我们只进行 n 此冒泡操作，所以最坏的时间复杂度为 O(n²)。平均时间复杂度为 O(n²)。 ■ 代码实现 123456789101112131415161718// 冒泡排序，a 表示数组，n 表示数组大小public void bubbleSort(int[] a, int n) &#123; if (n &lt;= 1) return; for (int i = 0; i &lt; n; ++i) &#123; // 提前退出冒泡循环的标志位 boolean flag = false; for (int j = 0; j &lt; n - i - 1; ++j) &#123; if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true; // 表示有数据交换 &#125; &#125; if (!flag) break; // 没有数据交换，提前退出 &#125;&#125; 2、插入排序■ 插入排序思想 将数据分为两个区间，未排序和已排序区间。初始化已排序只有一个元素（默认第一个），从未排序选出元素找到合适位置有序的插入，直到结束位置。 ■ 插入排序是原地排序算法吗？ 答：是。 分析：插入排序的运算并不需要额外的存储空间，所以空间复杂度是 O（1），是一个原地排序算法。 ■ 插入排序是稳定的排序算法吗？ 答：是。 分析： 对于值相同的元素，我们会将后边出现的元素插入到前边出现的元素的后边，所以插入排序是稳定排序。 ■ 插入排序的时间复杂度是多少？ 最好的情况就是数据元素已经排好序，最好的时间复杂度为 O（1）。如果数组是倒序的，最坏的时间复杂度是 O（n²）。在数组中插入数据的平均时间复杂度为 O（n），对于插入排序来说我们每次就相当于数组插入一个新的数据，循环执行n次插入数据，所以平均时间复杂度为 O（n²）。 ■ 插入排序代码实现 12345678910111213141516171819// 插入排序，a 表示数组，n 表示数组大小（从小到大进行排序）public void insertionSort(int[] a, int n) &#123; //如果数组大小为 1 直接返回 if (n &lt;= 1) return; //否则进行插入排序 for (int i = 1; i &lt; n; ++i) &#123; int value = a[i]; int j = i - 1; // 查找插入的位置 for (; j &gt;= 0; --j) &#123; if (a[j] &gt; value) &#123; a[j+1] = a[j]; // 数据移动 &#125; else &#123; break; &#125; &#125; a[j+1] = value; // 插入数据 &#125;&#125; 3、选择排序■ 选择排序算法思想 将在未排序期间寻找到最小的数据，并将其放到已排好区间的元素的尾部。 ■ 选择排序是原地排序算法吗? 答： 原地排序算法。 分析： 数组中的两个元素需要相互交换，需要用一个变量来存储交换值，选择排序的空间复杂度为O（1），所以，是一种原地排序算法。 ■ 选择排序是稳定的排序算法吗？ 答 ：不是。 分析：选择排序每次都要找到剩余未排序元素的最小值，并和前边的元素交换位置，这样破坏了稳定性。所以说，选择排序是一种不稳定的排序算法。 ■ 选择排序的时间复杂度是多少？ 最好的时间复杂度为 O（1），最坏的情况就是 O(n²)。平均时间复杂度就是 O（n²） 4、希尔排序 插入排序有很大的优化思路，进而有了希尔排序。 5、思考：为什么插入排序比冒泡排序更受欢迎 移动次数：冒泡排序和插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。 代码实现：，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。 1234567891011121314//冒泡排序中数据的交换操作：if (a[j] &gt; a[j+1]) &#123; // 交换 int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = true;&#125;//插入排序中数据的移动操作：if (a[j] &gt; value) &#123; a[j+1] = a[j]; // 数据移动&#125; else &#123; break;&#125; 三、归并排序、快速排序 O(nlogn)1、归并排序■ 核心思想 假入排序一个数组，先把数组从中间分成前后两个部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就有序了。 ■ 实现过程 使用分治思想，分治思想用递归来实现，分析写出递归公式，找出终止条件，最后将递推公式翻译成递归代码。 ■ 递推公式 12345递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))终止条件：p &gt;= r 不用再继续分解 ■ 递归代码 123456789101112131415161718// 归并排序算法, A 是数组，n 表示数组大小merge_sort(A, n) &#123; merge_sort_c(A, 0, n-1)&#125;// 递归调用函数merge_sort_c(A, p, r) &#123; // 递归终止条件 if p &gt;= r then return // 取 p 到 r 之间的中间位置 q q = (p+r) / 2 // 分治递归 merge_sort_c(A, p, q) merge_sort_c(A, q+1, r) // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r] merge(A[p...r], A[p...q], A[q+1...r])&#125; ■ 合并函数（merge函数）+ 哨兵思想 仿照两个有序数组的合并。 12345678910111213141516171819202122232425merge(A[p...r], A[p...q], A[q+1...r]) &#123; var i := p，j := q+1，k := 0 // 初始化变量 i, j, k var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组 while i&lt;=q AND j&lt;=r do &#123; if A[i] &lt;= A[j] &#123; tmp[k++] = A[i++] // i++ 等于 i:=i+1 &#125; else &#123; tmp[k++] = A[j++] &#125; &#125; // 判断哪个子数组中有剩余的数据 var start := i，end := q if j&lt;=r then start := j, end:=r // 将剩余的数据拷贝到临时数组 tmp while start &lt;= end do &#123; tmp[k++] = A[start++] &#125; // 将 tmp 中的数组拷贝回 A[p...r] for i:=0 to r-p do &#123; A[p+i] = tmp[i] &#125;&#125; ■ 代码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.test.xiaolu;/** * 归并排序 * @author 小鹿 * */public class MergeSort &#123; public static void main(String[] args) &#123; MergeSort mSort = new MergeSort(); int[] a = new int[] &#123;4,3,7,2,9,1&#125;; mSort.mergeSort(a,0,a.length-1); for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i]); &#125; &#125; /** * 功能:递归分治数据 * @param a 要分治的数组 * @param p 数组起始位置 * @param r 数组终止位置 */ public void mergeSort(int[] a,int p,int r) &#123; //终止条件 if(p &gt;= r) return; //取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值 int q = p + (r - p)/2; //递归分治 mergeSort(a,p,q); mergeSort(a,q+1,r); //两个有序数组的合并 merge(a, p, q, r); &#125; /** * 功能: 合并 mergr * @param a 要合并的数组 * @param p 数组起始的下标 * @param q 第二个数组起始的下标 * @param r 数组结束的下标 */ public void merge(int[] a,int p,int q,int r) &#123; int i = p,j = q+1,k = 0; int[] temp = new int[r-p+1]; //两个有序数组合并 while(i &lt;= q &amp;&amp; j &lt;= r) &#123; if(a[i] &lt;= a[j]) &#123; temp[k++] = a[i++]; &#125;else &#123; temp[k++] = a[j++]; &#125; &#125; int s = i; int e = q; if(j &lt;= r) &#123; s = j; e = r; &#125; //剩余的数据添加到尾部 while(s &lt;= e) &#123; temp[k++] = a[s++]; &#125; //将 temp 数据搬移到原数组 for (int l = 0; l &lt;= r-p; l++) &#123; a[p+l] = temp[l]; &#125; &#125;&#125; ■ 性能分析 归并排序是否是稳定排序算法？ 答：是的。 分析：只看 merge 合并函数，如果有两个相同的元素，当然先放排在最前边的元素，两个相同元素的位置不变，所以说，归并排序是稳定排序。 归并排序是否是原地排序算法？ 1、不能用递归思想了，用完系统直接释放掉了。 2、merge 额外的空间 temp。在任意时刻，CPU 只有一个函数在使用，也就是说我们呢开辟一个 n 大小数组空间就可以了，空间复杂度为 O(n)。因此，归并排序不是原地排序算法。 归并排序的时间复杂度是多少？ 答：O(nlogn)。 分析： 1、 A 问题分为 B 问题和 C 问题，时间复杂度为 B 问题加上 C 问题再加上合并的时间。 2、假设对 n 个元素进行归并排序的时间复杂度为 T(n) 。分解两个子数组的时间为 2*T(n/2)。合并两个有序子数据的时间复杂度为 n(n)，我们就可以推导出时间复杂度的计算公式。 121T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。O(n) = 2T(n) = 2*T(n/2) + n； n&gt;1 1234567T(n) = 2*T(n/2) + n = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n ...... = 2^k * T(n/2^k) + k * n ...... 可以推导出 T(n) = 2^kT(n/2^k)+kn ，当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n ，我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。所以归并排序的时间复杂度为 O(nlogn) 。 稳定性 归并排序和原始数据的有序程度无关，所以时间复杂度与是非常稳定的。 2、快速排序■ 核心思想 有一组数据，数组中的下标是 p 到 r 。在 p 到 r 之间任意选择一个数据作为 pivot (区分点)。大于区分点的放到右边（q+1 到 r），小于区分点的放到左边（p 到 q-1），将 pivot 数据放中间。 ■ 递推公式 12345递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)终止条件：p &gt;= r ■ 代码实现 12345678910111213// 快速排序，A 是数组，n 表示数组的大小quick_sort(A, n) &#123; quick_sort_c(A, 0, n-1)&#125;// 快速排序递归函数，p,r 为下标quick_sort_c(A, p, r) &#123; if p &gt;= r then return // 获取分区点（一般情况，选择最后一个元素） q = partition(A, p, r) quick_sort_c(A, p, q-1) quick_sort_c(A, q+1, r)&#125; ■ partition() 分区函数 12345678910111213141516171819private static int partition(int[] a, int p, int r) &#123; int pivot = a[r]; int i = p; for(int j = p; j &lt; r; ++j) &#123; if (a[j] &lt; pivot) &#123; int tmp = a[i]; a[i] = a[j]; a[j] = tmp; ++i; &#125; &#125; int tmp = a[i]; a[i] = a[r]; a[r] = tmp; System.out.println("i=" + i); return i;&#125; 注意：要想实现原地排序，不能用两个数组的合并了，必须在数组内完成，所以有了下边的操作。 交换技巧 如果插入数据，数据搬移，非常耗时。上述的数据插入正是一种交换的技巧，在 O(1) 时间内进行插入小于pirot 的位置。 ■ 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.test.xiaolu;/** * 功能:快速排序 * @author 小鹿 * */public class QuickSort &#123; public static void main(String[] args) &#123; QuickSort quickSort = new QuickSort(); int[] a = new int[] &#123;4,3,7,2,9,1&#125;; quickSort.quickSort(a, 6); for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i]+" "); &#125; &#125; public void quickSort(int a[],int n) &#123; quickSortInternally(a,0,n-1); &#125; /** * 功能:快速排序递归函数 * @param a 数组 * @param i 起始位置 * @param j 终止位置 */ private void quickSortInternally(int[] a, int p, int r) &#123; //终止条件 if(p &gt;= r) return; //获取区分点 pivot int q = partition(a, p, r); //区分点两端开始递归 quickSortInternally(a,p,q-1); quickSortInternally(a,q+1,r); &#125; /** * 功能:获取区分点 * @param a 数组 * @param p 起始位置 * @param r 终止位置 * @return 返回区分点 */ public int partition(int[] a,int p,int r) &#123; //将最后一个元素作为区分点 int pivot = a[r]; int i = p; for (int j = p; j &lt; r; ++j) &#123; if(a[j] &lt; pivot) &#123; //确保 i 永远指向第一个大于 pivot 的数 if(i == j) &#123; i++; &#125;else &#123; int tmp = a[i]; a[i++] = a[j]; a[j] = tmp; &#125; &#125; &#125; int temp = a[i]; a[i] = a[r]; a[r] = temp; System.out.println("i=" + i); return i; &#125;&#125; ■ 性能分析 快排是否为稳定排序算法？ 答：不是。 分析：排序函数 partition 随机的位置，交换会导致相同元素位置会发生改变，所以快排是不稳定算法。 快排是否为原地排序算法？ 答：是的。 分析：在空间复杂度 O(1) 内进行对数据的排序，所以是原地排序算法。 快排的复杂度分析？ 最好时间复杂度：O(nlogn)。 分析：每次选择的 pivot 合适，正好将区间一分为二，但是不切合实际情况。 最坏时间复杂度： O(n2) 。 一个有序数据，每次分区点都是最后一个，需要进行 n 次分区才能完成快排，每次分区扫描 n/2 个元素，时间复杂度退化到 O(n2) 。 平均时间复杂度：O(nlogn)。 分析：快排的大部分情况的时间复杂度为 O(nlogn)，只有极端情况为 O(n²) , 有很多方法可以降低这种极端情况下的概率。 4、归并排序和快速排序的区别 1、归并排序数据的有序性是从下到上的，而快速排序的数据有序性是从上到下的。 2、归并排序是稳定的排序算法（和数据的有序性无关），但是不是原地排序算法，合并不能在原地执行，空间复杂度为O(n)。 3、快速排序解决了归并排序占用太多内存空间的问题，在原地就可以实现排序。 6、思考：如何用快排思想在 O(n) 内查找第 K 大元素？■ 实现思路 求某数据中第 K 大数据，先将 r[n-1] 作为区分点划分，如果 p+1 = k，则 a[p] 就是要找到的数据（数组下标从 0 开始的）。如果 k &lt; p+1 第 k 大数据在 [0，p] 之间，如果 k &gt; p+1 ,第 k 大数据在 [p+1,r] 之间。进而继续划分查找。 ■ 代码实现 ■ 复杂度分析 每次查找都是数据的一半，所以查找的时间复杂度就是（n/2+n/4+n/8+… = 2n-1）,O(n)。另一种方法是每次寻找数据中的最小值放到数据的首部，查找 n 次就可以了，时间复杂度为 K*n,当 k 小的时候可以，当 k 为 n/2 或者 n 的时候，时间复杂度退化成 O（n²）; 7、扩展提高现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？ 同时指向10个文件的第一条数据，进行比较选出最小时间戳的数据放入新文件，一次类推，有 n个数据需要比较 n 次，时间复杂度为 O(n) ，空间复杂度为 O(1) 。 四、桶排序、计数排序、基数排序1、桶排序（Bucket sort）■ 算法思想 对每个桶划定范围，将数据分别放到不同的桶中进行排序，然后依次取出每个桶中的数据，组成的序列就是有序的了。 ■ 时间复杂度分析 答：O(n)。 分析：假设有 n 个数据，分到 m 个桶中，每个桶中平均放 k=n/m 。每个桶中的数据以时间复杂度 O(k logk) 进行排序，m 个桶时间复杂度为 mk*logk ,因为 k = n/m ,所以时间复杂度为 O(n*log(n/m)) 。当桶的个数趋近于数据的个数的时候（m-&gt;n），桶排序的时间复杂度为 O(n)。 ■ 适用条件 1、桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。 2、各个桶内的数据必须是均匀分布的。在极端情况下，分布到同一个桶中，时间复杂度退化到 O(nlogn)。 ■ 实例分析 问题 有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？ 解决思路 步骤一： 扫描一遍文件，假设订单金额数据范围，最小 1 元，最高 10 万元。然后划定金额平均分到 100 个桶中，每个桶中 1 - 1000 ，以此类推。然后从 0 编号，到 99 号桶。 步骤二： ① 情况一：平均分配到桶中。 每个桶进行快速排序，100 个桶排好之后，依次按照编号进行取出数据。 ② 情况二：不平均分配每个桶。 每个桶中的数据各不相同，有的桶中的数据会大于内存，继续划分桶内数据多的，比如 1 - 1000 比较多，我们划分 10 个区间，然后进行快速排序。 2、计数排序（Counting sort）■ 算法思想 计数排序是桶排序的一种特殊情况，当要排序 n 个数据的时候，所处的范围并不大，最大值为 K ，将数据划分为 K 个桶，每个桶内的值都是相同的，省去了桶内排序的时间。 ■ 适用条件 ① 计数排序应用于数据范围不大的场景中，如果数据范围 k 要比排序的数据 n 大很多，就不适用了。 ② 计数排序只能给非负整数排序，可以再不改变相对大小的情况下，转化为非负整数。 ■ 算法过程 实例分析 有八个考生，分数分别再0-5之间，将这八个考生的成绩放入到数组A【8】中，它们分别是 2，5，3，0，2，3，0，3 。 步骤 ① 给定一组数据 ，先寻找数组中的最大值 max。（上述中是 5） ② 再新定义一个数组 C[max+1] ，将其初始化为 0。（计数数组，下标对应着分数 0-5 分） ③ 将遍历所有的数据根据下标（分数）统计的相同分数的学生个数放入到对应下标分数的数组 C 。 ④ 对数组 C 中存储的相同分数学生的个数顺序依次求和，重新放回数组 C 中。 ⑤ 从数组 A[8] 中，倒序依次取数据做判断，根据数组中存取的数据与数组 C 找下标相同的数据，C 中与该分数相同的数字下标存储的就是当前包括该分数在内的小于该分数的学生个数。 ⑥ 我们将新定义一个数组R，其实该个数就是该学生的排名，放在 R 数组中就需要 -1 （毕竟数组是从 0 开始的）。 ⑦ 依次倒序遍历上述的数组 A 中的数据，重复上述过程，直到将数据排好序，将排序结果复制到 A 数组中。 ■ 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。public void countingSort(int[] a, int n) &#123; // 判断数组是否有数据 if (n &lt;= 1) return; // 1、查找数组中数据的最大值，给定范围 int max = a[0]; for (int i = 1; i &lt; n; ++i) &#123; if (max &lt; a[i]) &#123; max = a[i]; &#125; &#125; // 2、申请一个计数数组 c，下标大小 [0,max] int[] c = new int[max + 1]; for (int i = 0; i &lt;= max; ++i) &#123; c[i] = 0; &#125; // 3、计算每个元素的个数，放入 c 中 for (int i = 0; i &lt; n; ++i) &#123; c[a[i]]++; &#125; // 4、依次累加 for (int i = 1; i &lt;= max; ++i) &#123; c[i] = c[i-1] + c[i]; &#125; // 5、6、临时数组 r，存储排序之后的结果 int[] r = new int[n]; for (int i = n - 1; i &gt;= 0; --i) &#123; int index = c[a[i]]-1; r[index] = a[i]; c[a[i]]--; &#125; // 7、将结果拷贝给 a 数组 for (int i = 0; i &lt; n; ++i) &#123; a[i] = r[i]; &#125;&#125; ■ 实际实例 在高考中怎么知道自己排名？假如有 50 万考生，最高分是 900 分，最低分是 0 分，我们就划分为 901 个桶。将 50 万的学生成绩分别放到这 901 个桶中。然后遍历桶中的数据依次放入一个数组中，那么就排好序了！ ■ 技巧扩展 1、如果是小数，精确到小数点后一位，先将所有数据乘以 10，转化成整数，再放到 9010 个桶中。 2、如果排序的数据有负数，数据范围为【-1000,1000】，需要先对每个数据加 1000，转化成非负数。 3、基数排序（Radix sort）■ 算法思路 借助稳定排序算法，先将低位的进行排序（或相同数据），然后以此类推。 ■ 适用条件 1、数据分割成 “位” 来比较，位之间有递进关系。 2、每一位的数据范围不能太大，否则无法做到时间复杂度为 O(n) 了。 ■ 时间复杂度 如果要排序的数据有 k 位，就要进行 k 次桶排序或者计数排序，总时间复杂度为 O(K*n)。当 K 不大的时候，基数排序的复杂度就接近于 O(n)。 ■ 举例分析 问题 对十万个手机号从小到大进行排序。 解决 先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。 ■ 扩展思考 给牛津的 20 万单词进行排序。单词长短不齐，我们补充 0 ，因为所有字母都大于 “0”,不会影响顺序，然后进行基数排序。 4、思考：如何根据年龄给 100 万用户排序？ 答：桶排序 分析： 假设年龄范围为 1 到 120 岁，分为 120 个桶并编号 0 - 119，将 100 万数据放到相对应的桶中，然后依次按照桶的编号取出数据，这样都得到了 100 万的数据，时间复杂度为 O(n)。]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美【递归】]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E9%80%92%E5%BD%92%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿整理的递归调用的知识架构体系。 目录[TOC] 一、递归满足的三个条件 用一下三个条件来判断是否可以用递归来解决。 一个问题可不可以分解为多个问题的解。 该问题是否和子问题的求解思路相同。 该问题是否有终止条件。 二、如何编写递归代码 将问题分解为子问题。 然后寻找递归终止条件。 写出递推公式。 最终转化成递归代码。 三、怎么理解递归 1、如果试图想清楚递归的每个步骤，会让我们陷入思维误区，从而导致我们出现理解障碍。 2、我们应该这样想：假设问题 A 可以分解为 B、C、D 三个子问题，我们可以假设 B、C、D已经解决了，在此基础上考虑问题 A。我们只需要思考问题 A 和 问题 B、C、D 的关系即可，从而屏蔽掉递归细节。 四、递归的特点优点： 递归是一种高效、简洁的编码技巧，只要满足递归的三个条件我们就可以用递归代码来解决。 缺点：1、 问题一：递归警惕堆栈溢出■ 具体问题 因为函数的调用是使用栈来保存临时变量的，每调用一个函数，我们就将临时的变量压入栈中，等函数执行完成之后，然后临时变量才出栈。因为我们的系统栈或者虚拟机栈空一般都不会很大，如果我们的递归规模很大，调用层次很深，递归过程中，函数的临时变量一直压入栈，导致堆栈溢出。 1Exception in thread "main" java.lang.StackOverflowError ◆ 如何避免堆栈溢出？ 我们采用在代码中限制递归深度来解决，比如超过递归深度 1000 我们就不在往下递归，直接返回错误。 不足点： 因为允许最大递归深度跟当前线程剩余的栈空间大小有关，事先计算栈的大小。如果实时计算，代码过于复杂，影响代码的可读性。只能说对于比较小的递归深度可以用这种方法。 2、问题二：递归警惕重复计算■ 具体问题 如果我们有个递归代码是 f(n) = f(n-1) + f(n-2)，当 n 分别为 4 和 5 的时候，我们都要计算两次 f(3) 值，导致了递归重复计算，从而影响效率。 ◆ 如何解决？ 我们可以借助散列表来保存已经求解过的值，当我们递归计算该值的时候，我们先在散列表查找是否已经记录过该值，如果求解过了，我们就从散列表中取值，不需要递归重复计算。 12345678910111213public int f(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n) if (hasSolvedList.containsKey(n)) &#123; return hasSovledList.get(n); &#125; int ret = f(n-1) + f(n-2); hasSovledList.put(n, ret); return ret;&#125; 3、问题三：递归的高空间复杂度 递归代码里有很多的函数带哦用，每次调用都要在栈中保存数据，因为在栈中保存数据都要额外的考虑这部分的开销，比如最简单的递归 f(n) = f(n-1)+1 ,空间辅助度并不是 O(1)，而是 O(n) 。 五、递归代码转换为非递归代码 递归有缺点也有优点，实际开发中，我们还是需要是否采用递归来实现。 ■ 递归： 递归是借助系统的栈和虚拟机的栈来实现的，所有的递归代码都可以用非递归代码来表示。 ■ 非递归： 非递归代码实现递归代码，只不过是用手动模拟入栈、出栈的过程，所以看上去并不是递归代码的样子。 不足： 非递归实现并没有解决递归的弊端，徒劳的增加了实现的复杂度。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法之美|【复杂度分析】]]></title>
    <url>%2F2018%2F09%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%E3%80%90%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你体验数据结构之美！ 数据结构与算法之美 要想真正的学习一门有多么难多么简单的技术也好，知识也好首先我们要有一个正确的学习方法。 最普通不过的就是从三问来入手，也就是一下三种。 为什么 是什么 怎么学 为什么要学习数据结构与算法? 想要通关大厂面试，千万别让数据结构和算法拖了后腿 很多大公司，比如 BAT、Google、Facebook，面试的时候都喜欢考算法、让人现场写代码。有些人虽然技术不错，但每次去面试都会“跪”在算法上，很是可惜。那你有没有想过，为什么这些大公司都喜欢考算法呢？校招的时候，参加面试的学生通常没有实际项目经验，公司只能考察他们的基础知识是否牢固。 业务开发工程师，你真的愿意做一辈子 CRUD boy 吗？ 如果你能弄明白这些底层原理，你就能更好地使用它们。即便出现问题，也很容易就能定位。因此，掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。 基础架构研发工程师，写出达到开源水平的框架才是你的目标！ 我觉得，高手之间的竞争其实就在细节。这些细节包括：你用的算法是不是够优化，数据存取的效率是不是够高，内存是不是够节省等等。这些累积起来，决定了一个框架是不是优秀。所以，如果你还不懂数据结构和算法，没听说过大 O 复杂度分析，不知道怎么分析代码的时间复杂度和空间复杂度，那肯定说不过去了，赶紧来补一补吧！ 对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！ 何为编程能力强？是代码的可读性好、健壮？还是扩展性好？我觉得没法列，也列不全。但是，在我看来，性能好坏起码是其中一个非常重要的评判标准。但是，如果你连代码的时间复杂度、空间复杂度都不知道怎么分析，怎么写出高性能的代码呢？ 有的人写代码的时候，从来都不考虑非功能性的需求，只是完成功能，凑合能用就好；做事情的时候，也从来没有长远规划，只把眼前事情做好就满足了。 我曾经面试过很多大龄候选人，简历能写十几页，经历的项目有几十个，但是细看下来，每个项目都是重复地堆砌业务逻辑而已，完全没有难度递进，看不出有能力提升。久而久之，十年的积累可能跟一年的积累没有任何区别。这样的人，怎么不会被行业淘汰呢？ 如果你在一家成熟的公司，或者 BAT 这样的大公司，面对的是千万级甚至亿级的用户，开发的是 TB、PB 级别数据的处理系统。性能几乎是开发过程中时刻都要考虑的问题。一个简单的 ArrayList、Linked List 的选择问题，就可能会产生成千上万倍的性能差别。这个时候，数据结构和算法的意义就完全凸显出来了。 其实，我觉得，数据结构和算法这个东西，如果你不去学，可能真的这辈子都用不到，也感受不到它的好。但是一旦掌握，你就会常常被它的强大威力所折服。 小结 我们的目的是建立时间复杂度、空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维， 如何抓住重点，系统高效地学习数据结构算法？ 什么是数据结构？什么是算法？ 从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。 学习的重点在什么地方？ 想要学习数据结构与算法，首先要掌握一个数据结构与算法中最重要的概念——复杂度分析。 这个概念究竟有多重要呢？可以这么说，它几乎占了数据结构和算法这门课的半壁江山，是数据结构和算法学习的精髓。 数据结构和算法学着 20 个知识点就够了 10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树； 10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。 学习技巧 我还给你分享了我总结的一些学习技巧，比如边学边练、多问、多思考，还有两个比较通用的学习方法，打怪升级法和沉淀法。掌握了这些学习技巧，可以让你学习过程中事半功倍。 03 | 由浅入深学数据结构和算法 由浅入深的计划 为了由浅入深地带你学习，分成四个递进的模块。 入门篇时间、空间复杂度分析是数据结构和算法中非常重要的知识点，贯穿整个专栏的学习过程。但同时也是比较难掌握的，所以我用了 2 节课来讲这部分内容，而且还举了大量的实例，让你一边学一边练，真正能掌握复杂度分析，为后面的学习铺路。 我希望通过这一模块，你能掌握时间、空间复杂度的概念，大 O 表示法的由来，各种复杂度分析技巧，以及最好、最坏、平均、均摊复杂度分析方法。之后，面对任何代码的复杂度分析，你都能游刃有余、毫不畏惧！ 基础篇这部分是专栏中篇幅最大的内容，也是我们学习的重点，共有 26 节内容，涵盖了最基础、最常用的数据结构和算法。针对每种数据结构和算法，我都会结合具体的软件开发实例，由浅入深进行讲解，并适时总结一些实用“宝典”，保证你印象深刻、学有所用。 比如递归这一节，我会讲到，为什么递归代码比较难写？如何避免堆栈溢出？如何避免递归冗余计算？如何将递归代码转化为非递归代码？ 高级篇这部分我会讲一些不是那么常用的数据结构和算法。虽然不常用，但是这些内容你也需要知道。设置这一部分的目的，是为了让你开拓视野，强化训练算法思维、逻辑思维。如果说学完基础部分可以考 80 分，那掌握这一部分就能让你成为尖子生！ 实战篇我们整个专栏都是围绕数据结构和算法在具体软件实践中的应用来讲的，所以最后我会通过实战部分串讲一下前面讲到的数据结构和算法。我会拿一些开源项目、框架或者系统设计问题，剖析它们背后的数据结构和算法，让你有一个更加直观的感受。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reach]]></title>
    <url>%2F2018%2F09%2F14%2FReact%2F</url>
    <content type="text"><![CDATA[小鹿带你一起学 React。 React 详细教程React 安装首先安装 Node.js在Node.js 使用 npm 包管理工具来安装React步骤一：安装全局的 React ，在哪里都可以创建 React 文件1npm install -g create-react-app 注意：如果是 max 系统 在命令前增加 sudo 全局。 步骤二：在你的文件夹中创建项目（脚手架）1create-react-app 项目名 步骤三：切换到该目录下，可以启动该项目1npm start Rect基础入门文件结构和 JSX 语法React的目录结构在 Package.json 配置文件中的一些依赖包。 &quot;react&quot;: &quot;^16.5.2&quot; 为 React 库 &quot;react-dom&quot;: &quot;^16.5.2&quot;将一些 JSX 语法渲染到 DOM中 &quot;react-scripts&quot;: &quot;1.1.5&quot; JSX 语法 React 使用 JSX 来替代常规的 JavaScript，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 优点： JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。 它是类型安全的，在编译过程中就能发现错误。 使用 JSX 编写模板更加简单快速。 使用 JSXJSX 看起来类似 HTML ，我们可以看下实例: 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;example&apos;)); 添加自定义属性需要使用 data- 前缀。 1234567&lt;div&gt; &lt;h2&gt;欢迎学习 React&lt;/h2&gt; &lt;p data-myattribute = &quot;somevalue&quot;&gt;这是一个很不错的 JavaScript 库!&lt;/p&gt;&lt;/div&gt;,document.getElementById(&apos;example&apos;)); React 组件的作用自定义组件名：HelloMessage 方法一：用函数来自定义创建组件 123456789101112131415function HelloMessage(props) &#123; return &lt;h1&gt;Hello World!&lt;/h1&gt;;&#125;//ES6语法函数定义//const HelloMessage = () =&gt; &#123;// return &lt;h1&gt;Hello World!&lt;/h1&gt;;//&#125; const element = &lt;HelloMessage /&gt;; ReactDOM.render( element, document.getElementById(&apos;example&apos;)); 方法二：使用 ES6 class 来定义一个组件: 创建一个模块 Person 123456789101112import React from &apos;react&apos;;import &apos;./Person.css&apos;;const person = ( ) =&gt; &#123; return ( &lt;div className=&quot;Person&quot;&gt; &lt;h1&gt;你好，我是,我已经拥有本书&lt;/h1&gt; &lt;/div&gt; )&#125;export default person;//暴露接口 其他文件调用 12345678910import Person from &apos;./Person/Person&apos;;//导入class App extends Component &#123; render() &#123; &lt;div&gt; &lt;Person /&gt; &lt;/div&gt; &#125;&#125;export default App; 调用自定义组件 123456import App from &apos;./App&apos;;ReactDOM.render( &lt;App /&gt;, document.getElementById(&apos;root&apos;)); 注意：原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。 组件 - 模块间通信在创建组件的 render（）函数中，调用模块函数的同时加入传值 12345678class App extends Component &#123; render() &#123; &lt;div&gt; &lt;Person name=&quot;张三&quot;/&gt; &lt;Person&gt;我是闭合标签，可以通过props.children获取&lt;/Person&gt; &lt;/div&gt; &#125;&#125; 12345678910111213import React from &apos;react&apos;;import &apos;./Person.css&apos;;const person = (props) =&gt; &#123; return ( &lt;div className=&quot;Person&quot;&gt; &lt;h1&gt;你好，我是&#123;props.name&#125;,我已经拥有本书&lt;/h1&gt; &lt;p&gt;&#123;props.children&#125;&lt;/p&gt; &lt;/div&gt; )&#125;export default person;//暴露接口 State 状态123456789101112131415161718192021222324252627282930class App extends Component &#123;state = &#123; persons:[ &#123;name:&quot;逯相强&quot;,count:1&#125;, &#123;name:&quot;Heimal&quot;,count:2&#125;, &#123;name:&quot;Aim&quot;,count:3&#125;, ], anything:&quot;张三&quot;, showPersons:false&#125;//定义一个函数switchNmmeHandle = (newName) =&gt;&#123; // console.log(&quot;你好&quot;); this.setState(&#123; persons:[ &#123;name:newName,count:1&#125;, &#123;name:&quot;Heimal&quot;,count:222&#125;, &#123;name:&quot;Aim&quot;,count:3&#125;, ] &#125;) &#125; render() &#123; &lt;button onClick=&#123;() =&gt; this.switchNmmeHandle(&quot;米修&quot;)&#125;&gt;更改&lt;/button&gt; &lt;div&gt; &lt;Person name=&#123;this.state.persons[0].name&#125; /&gt; &lt;/div&gt; &#125;&#125;export default App; state 与 props 的区别：state ：用于改变组件内容状态的值（动态） props：用于组件通信进行传值 属性传值1234567891011 class App extends Component &#123; render() &#123; &lt;div&gt; &lt;Person myClick=&#123;this.switchNmmeHandle.bind(this,&quot;米修missu&quot;)&#125; /&gt; &lt;/div&gt; &#125;&#125;export default App; 1234567891011const person = ( props) =&gt; &#123; return ( &lt;div className=&quot;Person&quot;&gt; &lt;h1 onClick=&#123;props.myClick&#125;&gt;你好，我是&#123;props.name&#125;,我已经拥有&#123;props.count&#125;本书&lt;/h1&gt; &lt;p&gt;&#123;props.children&#125;&lt;/p&gt; &lt;/div&gt; )&#125;export default person; 双向数据绑定123456789101112import React from &apos;react&apos;;import &apos;./Person.css&apos;;const person = ( props) =&gt; &#123; return ( &lt;div&gt; &lt;input type=&quot;test&quot; onChange=&#123;props.changed&#125; defaultValue=&#123;props.name&#125;&gt;&lt;/input&gt; &lt;/div&gt; )&#125;export default person; 12345678910111213141516171819202122 class App extends Component &#123; changedNameHandler = (event)=&gt;&#123; this.setState(&#123; persons:[ &#123;name:event.target.value,count:1&#125;, &#123;name:&quot;Heimal&quot;,count:222&#125;, &#123;name:&quot;Aim&quot;,count:3&#125;, ] &#125;)&#125; render() &#123; &lt;div&gt; &lt;Person changed=&#123;this.changedNameHandler&#125; name=&#123;this.state.persons[0].name&#125; count=&#123;this.state.persons[0].count&#125; /&gt; &lt;/div&gt; &#125;&#125;export default App; 组件样式的两种方式方式一： 在 CSS 文件中设置，然后倒入引用 Person.css: 12345678.Person&#123; width: 60%; margin: 16px auto; border: 1px solid #eee; box-shadow: 0 2px 3px #ccc; padding: 16px; text-align: center;&#125; Person.js引用 12345678import &apos;./Person.css&apos;;//用 className &lt;div className=&quot;Person&quot;&gt; &lt;h1 onClick=&#123;props.myClick&#125;&gt;你好，我是&#123;props.name&#125;,我已经拥有&#123;props.count&#125;本书&lt;/h1&gt; &lt;p&gt;&#123;props.children&#125;&lt;/p&gt; &lt;input type=&quot;test&quot; onChange=&#123;props.changed&#125; defaultValue=&#123;props.name&#125;&gt;&lt;/input&gt; &lt;/div&gt; 方式二：1234567891011121314151617class App extends Component &#123;state = &#123; persons:[ &#123;name:&quot;逯相强&quot;,count:1&#125;, &#123;name:&quot;Heimal&quot;,count:2&#125;, &#123;name:&quot;Aim&quot;,count:3&#125;, ], anything:&quot;张三&quot;, showPersons:false&#125;render( return( //引用样式 &lt;button style=&#123;style&#125; onClick=&#123;this.switchNmmeHandle.bind(this,&quot;missu&quot;)&#125;&gt;更改&lt;/button&gt; ))&#125; React的 if 分支 在React中的if判断使用的三元运算符 使用代码抽离，大大减少代码的冗余度。 12345678910111213141516171819202122232425262728class App extends Component &#123; render ( let person = null; if(this.state.showPersons)&#123; person = ( &lt;div&gt; &lt;Person changed=&#123;this.changedNameHandler&#125; name=&#123;this.state.persons[0].name&#125; count=&#123;this.state.persons[0].count&#125; /&gt; &lt;Person myClick=&#123;this.switchNmmeHandle.bind(this,&quot;米修missu&quot;)&#125; name=&#123;this.state.persons[1].name&#125; count=&#123;this.state.persons[1].count&#125; /&gt; &lt;Person name=&#123;this.state.persons[2].name&#125; count=&#123;this.state.persons[2].count&#125; &gt;你们好，欢迎购买书籍&lt;/Person&gt; &lt;/div&gt; ) return ( &lt;div className=&quot;App&quot;&gt; //调用 &#123;person&#125; &lt;/div&gt; ) &#125; React - 使用循环 使用ES6语法 1234567891011&lt;div&gt; &#123; this.state.persons.map((person,index) =&gt;&#123; return &lt;Person myClick=&#123;() =&gt; this.delectPersonHandler(index)&#125; key=&#123;person.id&#125; name=&#123;person.name&#125; count=&#123;person.count&#125;/&gt; &#125;) &#125; &lt;/div&gt; React 使用循环输出每个值都要有一个 key 与之对应，要映射到虚拟的 DOM 上，虚拟的DOM和真实的DOM通过key对应起来。 React 动态改变样式和添加类名1style.backgroundColor = &apos;red&apos; 12345678910111213141516// const classes = [&quot;red&quot;,&quot;bold&quot;].join(&quot; &quot;); const classes = []; if(this.state.persons.length &lt;= 2 )&#123; classes.push(&quot;red&quot;); &#125; if(this.state.persons.length &lt;= 1 )&#123; classes.push(&quot;bold&quot;); &#125; return ( &lt;h1&gt;Hello Word!&lt;/h1&gt; &lt;p className=&#123;classes.join(&quot; &quot;)&#125;&gt;Hello React&lt;/p&gt;//通过数组来动态改变值 &lt;/div&gt; ); 定义的css样式 1234567.red&#123; color: red;&#125;.bold&#123; font-weight: bold;&#125; React 的项目目录结构React元素渲染 元素是构成 React 应用的最小单位，它用于描述屏幕上输出的内容。 1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。 将元素渲染到 DOM 中首先我们在一个 HTML 页面中添加一个 id=”example” 的 : 1&lt;div id=&quot;example&quot;&gt;&lt;/div&gt; 要将React元素渲染到根DOM节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上： 12345const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;ReactDOM.render(element,document.getElementById(&apos;example&apos;)); 更新元素渲染React 元素都是不可变的。当元素被创建之后，你是无法改变其内容或属性的。 目前更新界面的唯一办法是创建一个新的元素，然后将它传入 ReactDOM.render() 方法： 实例： 12345678910111213function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;example&apos;) );&#125;setInterval(tick, 1000); 以上实例通过 setInterval() 方法，每秒钟调用一次 ReactDOM.render()。 我们可以将要展示的部分封装起来，以下实例用一个函数来表示： 语法： 123456789101112function Clock(props) &#123; return ( );&#125;function tick() &#123; ReactDOM.render( );&#125;setInterval(tick, 1000); 实例： 123456789101112131415function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById(&apos;example&apos;) );&#125;setInterval(tick, 1000); 除了函数外我们还可以创建一个 React.Component 的 ES6 类（需要使用 this.props 替换 props ） 语法： 12345678910111213class Clock extends React.Component &#123; render() &#123; return ( ); &#125;&#125;function tick() &#123; ReactDOM.render( );&#125;setInterval(tick, 1000); 实例： 1234567891011121314151617class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById(&apos;example&apos;) );&#125;setInterval(tick, 1000); 独立文件你的 React JSX 代码可以放在一个独立文件上，例如我们创建一个 helloworld_react.js 文件，代码如下： 1234&lt;body&gt;&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot; src=&quot;helloworld_react.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; JavaScript 表达式们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中。实例如下： 1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;&#123;1+1&#125;&lt;/h1&gt; &lt;/div&gt;,document.getElementById(&apos;example&apos;)); 在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false. 1234567ReactDOM.render( &lt;div&gt; &lt;h1&gt;&#123;i == 1 ? &apos;True!&apos; : &apos;False&apos;&#125;&lt;/h1&gt; &lt;/div&gt;,document.getElementById(&apos;example&apos;)); 样式 React 推荐使用内联样式。,我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px 。 12345678var myStyle = &#123; fontSize: 100, color: &apos;#FF0000&apos;&#125;;ReactDOM.render( &lt;h1 style = &#123;myStyle&#125;&gt;菜鸟教程&lt;/h1&gt;, document.getElementById(&apos;example&apos;)); 注释注释需要写在花括号中，实例如下： 1234567ReactDOM.render(&lt;div&gt;&lt;h1&gt;哈哈哈&lt;/h1&gt;&#123;/*注释...*/&#125;&lt;/div&gt;,document.getElementById(&apos;example&apos;)); 数组12345678var arr = [ &lt;h1&gt;react&lt;/h1&gt;, &lt;h2&gt;学的不仅是技术，更是梦想！&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById(&apos;example&apos;)); 参数传递函数定义的组件：props.name 12345678910function HelloMessage(props) &#123; return &lt;h1&gt;Hello &#123;props.name&#125;!&lt;/h1&gt;;&#125; const element = &lt;HelloMessage name=&quot;Runoob&quot;/&gt;; ReactDOM.render( element, document.getElementById(&apos;example&apos;)); ES6创建的组件：this.props.name 123456789101112131415class HelloMessage extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125; HelloMessage.defaultProps = &#123; name: &apos;Runoob&apos; &#125;; const element = &lt;HelloMessage/&gt;; ReactDOM.render( element, document.getElementById(&apos;example&apos;) ); 复合组件1234567891011121314151617181920212223function Name(props) &#123; return &lt;h1&gt;网站名称：&#123;props.name&#125;&lt;/h1&gt;;&#125;function Url(props) &#123; return &lt;h1&gt;网站地址：&#123;props.url&#125;&lt;/h1&gt;;&#125;function Nickname(props) &#123; return &lt;h1&gt;网站小名：&#123;props.nickname&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Name name=&quot;菜鸟教程&quot; /&gt; &lt;Url url=&quot;http://www.runoob.com&quot; /&gt; &lt;Nickname nickname=&quot;Runoob&quot; /&gt; &lt;/div&gt; );&#125; ReactDOM.render( &lt;App /&gt;, document.getElementById(&apos;example&apos;)); React State(状态) React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。 以下实例创建一个名称扩展为 React.Component 的 ES6 类，在 render() 方法中使用 this.state 来修改当前的时间。 12345678910111213141516171819class Clock extends React.Component &#123;//构造函数 constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;现在是 &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;example&apos;)); 将生命周期方法添加到类中 在具有许多组件的应用程序中，在销毁时释放组件所占用的资源非常重要。 ① 每当 Clock 组件第一次加载到 DOM 中的时候，我们都想生成定时器，这在 React 中被称为挂载。 ② 每当 Clock 生成的这个 DOM 被移除的时候，我们也会想要清除定时器，这在 React 中被称为卸载。 1234567891011121314151617181920212223class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; //生成定时器 componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; //卸载定时器 componentWillUnmount() &#123; clearInterval(this.timerID); &#125; //给stata赋值 tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125;&#125; 实例解析： ① componentDidMount()与 componentWillUnmount()方法被称作生命周期钩子。 ② 在组件输出到 DOM 后会执行 componentDidMount()钩子，我们就可以在这个钩子上设置一个定时器。 ③ this.timerID为计算器的 ID，我们可以在 componentWillUnmount()钩子中卸载计算器。 代码执行顺序： 当 &lt;Clock /&gt; 被传递给 ReactDOM.render() 时，React 调用 Clock 组件的构造函数。 由于 Clock 需要显示当前时间，所以使用包含当前时间的对象来初始化 this.state 。 我们稍后会更新此状态。 React 然后调用 Clock 组件的 render() 方法。这是 React 了解屏幕上应该显示什么内容，然后 React 更新 DOM 以匹配 Clock 的渲染输出。 当 Clock 的输出插入到 DOM 中时，React 调用 componentDidMount() 生命周期钩子。 在其中，Clock 组件要求浏览器设置一个定时器，每秒钟调用一次 tick()。 浏览器每秒钟调用 tick() 方法。 在其中，Clock 组件通过使用包含当前时间的对象调用 setState() 来调度UI更新。 通过调用 setState()，React 知道状态已经改变，并再次调用 render() 方法来确定屏幕上应当显示什么。 这一次，render() 方法中的 this.state.date 将不同，所以渲染输出将包含更新的时间，并相应地更新 DOM。 一旦 Clock 组件被从 DOM 中移除，React 会调用 componentWillUnmount() 这个钩子函数，定时器也就会被清除。 State 和 Props以下实例演示了如何在应用中组合使用 state 和 props 。我们可以在父组件中设置 state， 并通过在子组件上使用 props 将其传递到子组件上。在 render 函数中, 我们设置 name 和 site 来获取父组件传递过来的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041class WebSite extends React.Component &#123; constructor() &#123; super(); this.state = &#123; name: &quot;菜鸟教程&quot;, site: &quot;https://www.runoob.com&quot; &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;Name name=&#123;this.state.name&#125; /&gt; &lt;Link site=&#123;this.state.site&#125; /&gt; &lt;/div&gt; ); &#125;&#125; class Name extends React.Component &#123; render() &#123; return ( &lt;h1&gt;&#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125; class Link extends React.Component &#123; render() &#123; return ( &lt;a href=&#123;this.props.site&#125;&gt; &#123;this.props.site&#125; &lt;/a&gt; ); &#125;&#125; ReactDOM.render( &lt;WebSite /&gt;, document.getElementById(&apos;example&apos;));]]></content>
      <categories>
        <category>Reach</category>
      </categories>
      <tags>
        <tag>Reach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView详细解析]]></title>
    <url>%2F2018%2F09%2F14%2FWebView%20%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Android WebView详细解析。 Android WebView详细解析简介 WebView是一个基于webkit引擎、展现web页面的控件。 作用 WebView 控件功能强大，除了具有一般 View 的属性和设置外，还可以对url请求、页面加载、渲染、页面交互进行强大的处理。 显示和渲染 Web 页面 直接使用 html 文件（网络上或本地 assets 中）作布局 可和 JavaScript 交互调用 使用方法 Webview 自身的常见方法； Webview 的最常用的子类 （WebSettings 类、WebViewClient 类、WebChromeClient 类) Android 和 Js 的交互 Webview常用方法WebView的状态1234567//销毁Webview//在关闭了Activity时，如果Webview的音乐或视频，还在播放。就必须销毁Webview//但是注意：webview调用destory时,webview仍绑定在Activity上//这是由于自定义webview构建时传入了该Activity的context对象//因此需要先从父容器中移除 webview,然后再销毁webview:rootLayout.removeView(webView); webView.destroy(); 关于前进 / 后退网页123456789//是否可以后退Webview.canGoBack() //后退网页Webview.goBack()//是否可以前进 Webview.canGoForward()//前进网页Webview.goForward() 常见用法：Back键控制网页后退 问题：在不做任何处理前提下 ，浏览网页时点击系统的“Back”键,整个 Browser 会调用 finish()而结束自身 目标：点击返回后，是网页回退而不是推出浏览器 解决方案：在当前Activity中处理并消费掉该 Back 事件 1234567public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if ((keyCode == KEYCODE_BACK) &amp;&amp; mWebView.canGoBack()) &#123; mWebView.goBack(); return true; &#125; return super.onKeyDown(keyCode, event);&#125; 清除缓存数据常用类WebSettings 类 作用：对WebView进行配置和管理 步骤： 1、添加访问网络权限（AndroidManifest.xml） 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 2、生成一个WebView组件（有两种方式） 1234567891011//方式1：直接在在Activity中生成WebView webView = new WebView(this)//如果访问的页面中要与Javascript交互，则webview必须设置支持JavascriptwebSettings.setJavaScriptEnabled(true); //支持通过JS打开新窗口 webSettings.setJavaScriptCanOpenWindowsAutomatically(true);//方法2：在Activity的layout文件里添加webview控件：WebView webview = (WebView) findViewById(R.id.webView); 3、进行配置-利用WebSettings子类 12//声明WebSettings子类WebSettings webSettings = webView.getSettings(); WebViewClient 类 作用：处理各种通知 &amp; 请求事件 常用方法： 方法一：shouldOverrideUrlLoading() 作用：打开网页时不调用系统浏览器， 而是在本 WebView 中显示；在网页上的所有加载都经过这个方法,这个函数我们可以做很多操作。 123456789101112131415161718192021//步骤1. 定义Webview组件Webview webview = (WebView) findViewById(R.id.webView1);//步骤2. 选择加载方式 //方式1. 加载一个网页： webView.loadUrl(&quot;http://www.google.com/&quot;); //方式2：加载apk包中的html页面 webView.loadUrl(&quot;file:///android_asset/test.html&quot;); //方式3：加载手机本地的html页面 webView.loadUrl(&quot;content://com.android.htmlfileprovider/sdcard/test.html&quot;);//步骤3. 复写shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示 webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); return true; &#125; &#125;); 方法二：onPageStarted() 作用：开始载入页面调用的，我们可以设定一个 loading 的页面，告诉用户程序在等待网络响应。 123456webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; //设定加载开始的操作 &#125; &#125;); 方法三：onPageFinished() 作用：在页面加载结束时调用。我们可以关闭 loading 条，切换程序动作。 123456 webView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageFinished(WebView view, String url) &#123; //设定加载结束的操作 &#125;&#125;); WebChromeClient 类 辅助 WebView 处理 Javascript 的对话框,网站图标,网站标题等等。 常用方法： 方法一：onProgressChanged（） 作用：获得网页的加载进度并显示 12345678910webview.setWebChromeClient(new WebChromeClient()&#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; if (newProgress &lt; 100) &#123; String progress = newProgress + &quot;%&quot;; progress.setText(progress); &#125; else &#123; &#125; &#125;) 方法二：onReceivedTitle（） 作用：获取Web页中的标题 （每个网站都有自己的标题） 123456webview.setWebChromeClient(new WebChromeClient()&#123; @Override public void onReceivedTitle(WebView view, String title) &#123; titleview.setText(title)； &#125; 如何避免WebView内存泄露？① 不在 xml 中定义 Webview ，而是在需要的时候在 Activity 中创建，并且 Context 使用 getApplicationgContext() 1234LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); mWebView = new WebView(getApplicationContext()); mWebView.setLayoutParams(params); mLayout.addView(mWebView); ② 在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。 123456789101112@Override protected void onDestroy() &#123; if (mWebView != null) &#123; mWebView.loadDataWithBaseURL(null, &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null); mWebView.clearHistory(); ((ViewGroup) mWebView.getParent()).removeView(mWebView); mWebView.destroy(); mWebView = null; &#125; super.onDestroy(); &#125;]]></content>
      <categories>
        <category>APP混合开发</category>
      </categories>
      <tags>
        <tag>APP混合开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracel 高级数据库]]></title>
    <url>%2F2018%2F09%2F05%2FOracel%20%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[小鹿带你学习 Oracel 高级数据库（企业级）。 Oracel 高级数据库入门命令01|基本命令使用超级管理员登录 :1$ sys/密码 as sysdba 用户切换到超级管理员1$ conn sys/密码 as sysdba 新建用户并设置密码：1$ create user 用户名 identified by 口令[即密码]； 删除用户：1$ drop user 用户名; 锁定用户：1$ alter user 用户名 account lock; 解锁用户：1$ alter user 用户名 account unlock; 授予用户登录的权限：1grant create session to 用户名； 授予用户操作数据库的权限：1grant resource to 用户名； 登录被创建的用户：1connect 用户名/密码 02|查询操作查询表中的年龄并分组显示：12select Tname,to_char(sysdate,&apos;yyyy&apos;)- to_char(生日日期字段，&apos;yyyy&apos;)as agefrom teacher; 查询某一字段不为空的信息：123select *from 表名where 字段名 is null; 查询日期在一个范围之内：123select *from 表名where to_char(生日日期字段，&apos;yyyy&apos;) between &apos;年月日&apos; and &apos;年月日&apos; 授予用户创建表空间的权限1grant create tablespace to user10; 授予用户修改表空间的权限、1grant unlimited tablespace to user10; 修改表空间的名字1alter tablespace tbs10 rename to tbs20; 将表空间设置为脱机装状态1alter tablespaace tbs20 offline; 先将表表空间设置为联机再设置为只读状态12alter tablespaace tbs20 online;alter tablespace tbs20 read only; 删除表空间,并删除数据文件1drop tablespace tbs20 including contents; 表的创建和管理基本步骤（整个操作在超级管理员的环境下运行的） 所有用到的表名之前要加上用户名。 登录超级管理员系统 创建用户 授权用户 创建一个表空间 创建表并添加到已创建的表空间中 基本命令使用创建表空间12SQL&gt; create tablespace 表空间名 2 datafile &apos;C:\app\Administrator\admin\orcl\tbs02.dbf&apos; size 10m; 创建表并添加到已创建的表空间中12345SQL&gt; create table 用户名.表名( 2 BT_ID char(2) primary key, 3 BT_Name varchar2(20), 4 BT_Info VARCHAR2(50) 5 ) tablespace 表空间名; 将一个表从一个表空间添加到另一个表空间中1SQL&gt; alter table 用户名.表名 move tablespace 表空间名; 创建表并设置外键12345678910create table 用户名.表名(b_id char(10) primary key,b_name varchar2(40),author varchar2(20),bt_id char(2),p_id char(4),pubdate date,price number(5,2),constraint 外键新名字 foreign key(外键) references 用户名.参照的另一个表名(主键))tablespace 表空间名; 主键约束12Alter table 设置主键的表add constraint(约束) 主键字段别名 primary key(主键字段) 外键约束123Alter table 设置外键表名add constraint(约束) 外键别名 foreign key(外键) references 用户名.参照的另一个表名(主键)on delete cascade);//级联删除 非空约束12Alter table 表名modify 字段名 not null; 删除表中的字段12Alter table 表名drop column 字段名； 添加表中的字段12Alter table 表名 add 字段名 数据类型;]]></content>
      <categories>
        <category>Oracel</category>
      </categories>
      <tags>
        <tag>Oracel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 基本命令]]></title>
    <url>%2F2018%2F09%2F04%2FLinux%20%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[小鹿带你一览 Linux 的魅力！ Shell 命令简单命令who 命令 列出所有用户正在使用系统的用户，所使用的终端名和注册系统的时间。 who -b 最近用户登陆的时间 who-H,--heading 打印出各列的标题 who -m 仅显示与stdin(标准输入)相关的主机名和用户。 who -q,--count 显示所有注册用户名和注册用户数目。 echo 命令 将命令行输入的字符输出在屏幕上 echo -n 表示输出字符之后不换行 date 命令 在屏幕上显示或设置系统的日期和时间 cal 命令显示某一个月或者某一年的日历 1$ cal 10 //将列出公元 10 年的日历 clear 命令 清除屏幕上的信息 passwd 命令 更改自己的密码 1$ Changing password for user 用户名. 控制台效果 1234(current)UNIX password:▍(输入旧密码。输入密码正确，按Enter键)Enter new UNIX password:▍(输入新密码, 然后按Enter键)Retype new UNIX password:▍(重新输入一遍新密码, 认证，最后按Enter键)passwd:all authentication tokens updated successfully.(表示修改成功) ls 命令 ls 命令列出指定目录的内容 1$ ls /home/mengqc/dir pwd 命令 显示当前目录的路径 su 命令 可更改用户的身份。 1$ su //普通用户切换到超级用户（需要输入密码） 1# su 普通用户名 //超级用户切换到普通用户 文件常用命令cat 命令 创建文件；显示文件的内容；连接两个或多个文件。 一般格式： cat [选项][FILE] 1234$ cat &gt;文件名 //输入此命令之后，用户依次输入文件内容【Enter】之后【Ctrl+D】结束输入$ cat m1 //显示文件的内容$ cat m1 m2 //显示两个文件内容$ cat m1 m2 &lt; file //合并两个文件m1、m2合并后的文件名为 file more 命令 显示文件的内容，每次显示一屏 less 命令 分屏显示文件内容 head 命令 显示文件的前十行 tail 命令 在屏幕上显示指定文件FILE 的末尾 10 行 123$ tail mfile //显示文件的最后十行$ tail -n +20 mfile //显示文件内容从20行到文件末尾$ tail -c 10 mfile //显示文件mfile的最后十个字符 文件及其类型文件概念文件 文件通常存放到外存，可以作为一个独立的单位存放和实时操作（如打开、关闭、读、写） 文件的成分 索引节点：系统利用其中的信息对相应文件实时控制和管理（包括文件权限、） 数据：文件的实际内容 文件的命名 尽量反映文件的内容 可由 ASCLL 组成 文件名通配符① 星号（*） 与0个或多个任意的字符相匹配。 星号匹配的是当前目录下的所有文件，但以点（.）开头的隐含文件除外。 .*只与隐含文件匹配。 ② 问号（?） 问号只与单个任意的字符匹配。你可以使用多个问号。 ③ 方括号（[ ]） ​]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 进阶之链接数据库]]></title>
    <url>%2F2018%2F08%2F31%2F%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%20java%20%E4%B9%8B%E3%80%90%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[最常用到的 Java 之连接数据库，详细解析，保证你看了之候明明白白。 （超详细的） Java 进阶之连接数据库Java 连接之前我们需要准备好连接数据库的 jar 包，里边封装了我们需要的连接数据库的工具和类，都给我们封装好了，连接数据库就 so eary 了。 连接数据库步骤准备① 下载：在网上下载连接数据库的 jar 包，或者到我的公众号：一个不甘平凡的码农，回复：“ 数据库jar ” 就可以下载了。 ② 放到新建 libs 文件夹下：下载完之后我们将 jar 包放到我们创建的 java 项目的根目录下新建文件夹 libs 下。 ③ 加载 jar 包：虽然我们把连接数据库的 jar 包放到我们项目了，但是我们还没有加载 jar 包，也就是说代码中无法调用，我们要做的是加载 jar 包。 在项目中点击 jar 包鼠标右键，选择 Build Path → configure Build Path 出现如下页面： ④ 选择上边的第三个标签 Librarise，选择 Add External JARs… 选择需要加载的 jar，就会出现在左边栏中： ⑤ 然后选择第四个标签 Order and Export 在我们 jar 包前打钩然后保存就可以了。 写代码连接数据库新建一个j ava 类 DBOP.java。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*** 功能：连接数据库**/public class DBOP &#123; //加载驱动的变量 String driver="com.mysql.jdbc.Driver"; //url 包括数据库的 ip（这里用到的是本机就是localhost/127.0.0.1 ） 以及 3306端口，DBName 为你的数据库的名字 String url="jdbc:mysql://localhost:3306/DBName?useSSL=true"; //数据库的用户名 String user="root"; //数据库的密码 String password="root"; //功能：连接数据库并执行Sql语句之后关闭数据库 //参数：HashMap&lt;String,Object&gt;&gt;：map 类型变量，sql ：sql语句 public ArrayList&lt;HashMap&lt;String,Object&gt;&gt; query(String sql) throws ClassNotFoundException, SQLException&#123; //定义查询结果返回的数据在 ResultSet 集合 ResultSet resultSet=null; //定义 connection 对象 Connection connection=null; //定义执行 sql 语句的对象 Statement statement=null; //创建一个List对象，里边的类型为HashMap数据类型 ArrayList&lt;HashMap&lt;String,Object&gt;&gt;list=new ArrayList&lt;&gt;(); //加载驱动 Class.forName(driver); //接下来的连接数据库操作要在try...catch 语句中执行 try &#123; //开始尝试连接数据库（传入url（包含ip、端口、数据库名等信息），数据库用户名和密码），连接结果返回一个 Connection 对象 connection =(Connection) DriverManager.getConnection(url,user,password); //通过 connection 对象的 createStatement 方法创建一个能够执行 sql 语句的 Statement 对象 statement=(Statement) connection.createStatement(); //通过 statement 对象执行 sql 语句将执行结果返回一个 ResultSet 对象集合 resultSet=statement.executeQuery(sql); //通过 ResultSet 对象可获取到 ResultSetMetaData 对象集合(目的是可以获取到表中的字段名) ResultSetMetaData resultSetMetaData=(ResultSetMetaData) resultSet.getMetaData(); // 遍历我们的查询结果集合 resultSet，我们将查询到的每条结果封装成 map（表字段名:对应的值）放到 List 中去。 while (resultSet.next()) &#123; //如果查询结果的 resultSet 集合中还有数据就执行 while 循环 //创建一个 map 对象 HashMap&lt;String, Object&gt;map = new HashMap&lt;&gt;(); //通过for循环，将查询结果中的对应数据库表的字段名和查询值封装到map中 for(int i=0;i&lt;resultSetMetaData.getColumnCount();i++) &#123; //通过resultSetMetaData.getColumnName(i) 可获取到对应字段名 map.put(resultSetMetaData.getColumnName(i), resultSet.getObject(i)); &#125; //将每个 map 对象添加到 list 当中 list.add(map); &#125; &#125; catch (Exception e) &#123; // 连接数据库中途出错时就会执行 catch 语句块 e.printStackTrace(); &#125;finally &#123; //无论连接数据库出错还是成功，程序在最后总会执行 finally 语句（我们就在里边执行关闭数据库的操作） //关闭 resultSet 对象集合 if(resultSet!=null)&#123; resultSet.close(); &#125; //关闭 statement 执行 sql 语句的对象 if(statement!=null)&#123; statement.close(); &#125; //最后关闭数据库连接 if(connection!=null)&#123; connection.close(); &#125; &#125; //将结果集返回一个List对象，方便我们取出查询结果数据 return list; &#125;&#125; 尊重他人劳动成果，转载请说明出处：http://luxiangqiang.xn--6qq986b3xl/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java 进阶</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Next + github 搭建个人博客详细教程]]></title>
    <url>%2F2018%2F08%2F27%2FHexo%20%E4%B9%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E3%80%90%E7%BB%93%E6%9E%84%E7%AF%87%E3%80%91%2F</url>
    <content type="text"><![CDATA[每个程序员必不可少的就是博客网站了，一开始我们并不知道可以搭建属于自己的个人博客网站，通常会在CSDN、博客园等别人搭建的博客网站写博客，当你写久了以后会感觉很 low, 一些文章需要审核通过才能发布。索性我们还不如自己搭建一个个人博客，个人博客的设计美化和内容都按照自己喜欢的要求来，然后在阿里云买一个高大上的域名，岂不是很装逼？尽管你没有学过网页 web 开发，但是通过这篇小鹿详细教程可以亲自搭建起属于自己的个人博客。 Hexo + Next + github 搭建个人博客详细教程小鹿的博客网址：小鹿的博客 建站前的准备建站之前我们先要做好准备工作，将相关的工具准备好。 安装 Node.js Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 安装网址：https://nodejs.org/zh-cn/ 验证是否安装成功：打开cmd命令行(win+r 输入cmd回车)执行 ： 12node -vnpm -v 安装成功之后显示版本号： 安装 Git 通常使用 github 的对 git 并不陌生，Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 [1] Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 安装网址：https://www.git-scm.com/download/win 验证是否安装成功：打开cmd命令行(win+r 输入cmd回车)执行 ： 1git --version 安装成功之后显示版本号： 安装 Hexo Hexo 是一个快速、简洁且高效的博客框架。 了解更多关于 Hexo 请查看官方网站：Hexo 安装 hexo 框架 1$ npm install -g hexo-cli 这里安装的是hexo最新版本，如果想安装以前的的版本请运行命令$ npm install -g hexo 以上步骤不出问题的话就已经在本地机器上搭建起了 Hexo 环境。 下面介绍 Hexo 的具体使用方法。 初始化Hexo创建hexo工程1$ hexo init blog 创建一个文件夹blog（blog 为文件夹的名字，可改成自己想要的名字），使用 Hexo 命令初始化 blog 为 hexo 工程目录。 新建POST12$ cd blog$ hexo new “HelloWorld” 进入初始化后的blog文件夹，创建名为HelloWorld的文件，此时会在/blog/sources/_post/目录下生成HelloWorld.md文件。 生成静态文件1$ hexo generate 使用 Hexo 引擎将 Markdown 格式的文件解析成可以使用浏览器查看的 HTML 文件，HTML 文件存储在blog/public 目录下。 运行hexo服务器1$ hexo server 打开命令行提示的地址，一般是 http://localhost:4000/，既可以看到我们的Hexo网站。 此时 Helloworld 文章中没有任何内容。打开 /blog/sources/_post/ 目录，使用编辑器打开其中的 HelloWorld.md 并在其中添加 markdown 格式的内容保存，然后重新运行以下命令： 12$ hexo generate$ hexo server 命令的含义：hexo generate 生成静态文件， hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 如果重新改变端口号请详细查看官网文档，这里不多介绍。 注意：如果在 HelloWorld.md 文件中有中文，在网页进行浏览可能出现乱码，解决方式通过编辑器打开HelloWorld.md 文件把编码方式改成 utf-8 就可以了。 安装主题Hexo 提供了默认主题 landscape，主题的位置在 blog -&gt;themes 文件夹下。主题根据自己喜好可以在网上找到，通过 Git 进行相应的下载。下面小鹿贴出几个主题可以进行相应的下载，喜欢哪一个可以进行配置到自己的个人博客了。 主题一：hexo-theme-next（小鹿用的主题是这一个，后期是自己改进美化的） 主题二：Casper 主题三：daleanthony 主题四：hexo-theme-yilia 主题五：jacman 主题六：hexo-theme-apollo 小鹿给大家找了一个主题链接可以选择自己喜欢的主题：更多主题 配置主题打开 git-bash 切换到 blog -&gt; themes 目录下，如果在目录 blog -&gt;themes 右键选择启动 git-bash 就不用切换了。如果在桌面直接启动 git-bash ,可通过下边命令切换到 blog -&gt;themes目录下。 1$ cd /blog/themes 选好一个主题，复制主题的 github 地址，通过 git 命令进行下载。（例：https://github.com/iissnan/hexo-theme-next 为一个主题的 github 地址） 1git clone https://github.com/iissnan/hexo-theme-next 下载完之后我将文件夹改成 next 了（也可以不改，我为了名字简洁点）。 然后在修改 /blog/config.yml 文件，将其中的 theme 改成 next。（这个是改变主题的地方，如果你用的是其他的主题，将这个 next 改成你下载下来的主题的文件夹的名称） 重新运行以下命令，查看更换主题后的效果 ： 12$ hexo generate$ hexo server 申请 Github 免费静态内容空间注册 Github 账号我们去 Github 的官网进行账号注册 ，注册完成之后我们根据官方文档进行配置 ，然后我们使用自己的账户创建一个 Repository （仓库）。 点击网站右上角的 + 号，选择 New Repository( 注意：创建仓库的名字要你的注册的用户名一致。其他默认，确定创建)。 之后你的静态内容空间就已经创建好了，在浏览器输入你的 your username（用户名）.github.io 就可以访问了。 将 Hexo 上传 Github 上。步骤一：安装 deployer-git （安装部署工具，方便以后更新） 1$ npm install hexo-deployer-git --save 步骤二：在 /blog/_config.yml 中修改 deploy 属性(注意“：”之后有空格 ) 否则配置失败。 1234deploy: type: git repository: https://github.com/luxiangqiang/luxiangqiang.github.io.git branch: master 将上方的 Repository 换成你申请的 Git 仓库地址 使用 https 的方式部署每次提交到 Github 都要输入用户名和密码，如果嫌麻烦请使用 SSH 的方式，百度/谷歌自行搜索。 步骤三：初始化本地仓库。 1git init 步骤四：连接远程仓库 ( 如果是第一次使用 git，在使用 git 的时候会提示输入用户名和密码，用户名是自己的注册邮箱。 ) 1git remote add origin https://github.com/luxiangqiang/luxiangqiang.github.io.git 步骤五：发布 hexo 到 github page 12//等于一次性执行了，清空、刷新、部署三个命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 步骤六：推送到远程仓库（github） 1git push origin 这里建议创建一个新的分支 hexo，用于管理 hexo 文件。提交的的时候只提交 hexo 网站 html、css 等源文件。 创建并切换到新建分支： 1git checkout -b hexo 将分支推送到远程仓库： 1git push origin hexo 记得提交以后去 github 上把 hexo 分支设置默认，以后写文章等都要部署。 文章在 hexo 目录下的 \source\ _posts 文件夹中，是 md 格式，也就是 Markdown 格式。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零学习微信小程序（一）]]></title>
    <url>%2F2018%2F08%2F27%2F%E4%BB%8E%E9%9B%B6%E5%85%A5%E9%97%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%90%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[小鹿带你从零学习微信小程序。 从零学习微信小程序配置全局配置在 app.json 配置文件下的 pages 中添加页面名称和路径（刷新）： 页面配置在小程序的 app.js 中添加一下代码; 1234567891011121314151617181920212223242526"tabBar": &#123; "color":"black", "selectedColor":"blue", "borderStyle":"black", "position":"bottom", "list": [ &#123; "pagePath": "pages/index/index", "text": "电影推荐", "iconPath": "images/index.png", "selectedIconPath":"images/index_act.png" &#125;, &#123; "pagePath": "pages/mov/mov", "text": "优惠", "iconPath":"images/kou.png", "selectedIconPath": "images/kou_act.png" &#125; , &#123; "pagePath": "pages/about/about", "text": "我的", "iconPath":"images/about.png", "selectedIconPath": "images/about_act.png" &#125; ] &#125; ① list 中的对象表示小程序页面下方有几个导航（至少两个） pagePath：页面路径，必须在 pages 中先定义 text：tab 上按钮文字 iconPath：图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，不支持网络图片。当 postion 为 top 时，不显示 icon。 selectedIconPath：选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，不支持网络图片。 当 postion 为 top 时，不显示 icon。 ② tabBar 下的字段属性： color：tab 上的文字默认颜色 selectedColor： tab 上的文字选中时的颜色 borderStyle：tabbar上边框的颜色， 仅支持 black / white position： tabBar的位置，仅支持 bottom / top 逻辑层注册程序小程序的生命周期在小程序的 app.js 文件中配置: 12345678910111213141516//app.js//功能：注册小程序（小程序的生命周期）App(&#123; //监听小程序初始化 onLaunch:function(e)&#123; console.log(e+&quot;初始化成功&quot;) &#125;, //监听小程序显示 onShow:function()&#123; console.log(&quot;显示&quot;) &#125;, //监听小程序隐藏 onHide:function()&#123; console.log(&quot;隐藏&quot;) &#125;,&#125;) getApp(Object)全局的 getApp() 函数可以用来获取到小程序 App 实例。 在小程序的 app.js 文件中添加 name 变量： 1234567891011121314151617//app.js//功能：注册小程序（小程序的生命周期）App(&#123; //监听小程序初始化 onLaunch:function(e)&#123; console.log(e+&quot;初始化成功&quot;) &#125;, //监听小程序显示 onShow:function()&#123; console.log(&quot;显示&quot;) &#125;, //监听小程序隐藏 onHide:function()&#123; console.log(&quot;隐藏&quot;) &#125;, name:&quot;李文木&quot;&#125;) 在 index.js 文件中通过 var app = getApp(); 获取变量的值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//index.jsvar app = getApp();Page(&#123; name:&quot;&quot;, /** * 页面的初始数据 */ data: &#123; &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; this.setData(&#123; name:app.name &#125;) &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125;&#125;) 然后通过在 index.wxml 文件中显示出来： 1&lt;text&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; 注册页面初始数据在某一页面下的 about.js 文件中定义变量： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// pages/about/about.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; header:&quot;我是逯相强&quot;, array:[ &#123;name:&quot;爱奇艺&quot;&#125;, &#123;age:67&#125;, &#123;class:&quot;清华大学&quot;&#125; ] &#125;, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; &#125;, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () &#123; &#125;, /** * 页面上拉触底事件的处理函数 */ onReachBottom: function () &#123; &#125;, /** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; &#125;&#125;) 在页面中引用以上定义的变量和数组 123456789101112131415&lt;!--pages/about/about.wxml--&gt;//引用变量&lt;text&gt;&#123;&#123;header&#125;&#125;&lt;/text&gt;//引用数组（方法一）&lt;view&gt;&#123;&#123;array[0].name&#125;&#125;&lt;/view&gt;&lt;view&gt;&#123;&#123;array[1].age&#125;&#125;&lt;/view&gt;&lt;view&gt;&#123;&#123;array[2].class&#125;&#125;&lt;/view&gt;//引用数组（方法二）&lt;block wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt; &lt;view&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;item.age&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;item.class&#125;&#125;&lt;/view&gt;&lt;/block&gt; 页面的生命周期回调123456789101112131415161718192021222324252627282930313233343536373839/** * 生命周期函数--监听页面加载 */ onLoad: function (options) &#123; //页面初始化 console.log(&quot;页面初始化&quot;); &#125;, /** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; //页面渲染完成 console.log(&quot;页面渲染完成&quot;); &#125;, /** * 生命周期函数--监听页面显示 */ onShow: function () &#123; //页面显示 console.log(&quot;页面显示&quot;); &#125;, /** * 生命周期函数--监听页面隐藏 */ onHide: function () &#123; //页面隐藏 console.log(&quot;页面隐藏&quot;); &#125;, /** * 生命周期函数--监听页面卸载 */ onUnload: function () &#123; //页面关闭 console.log(&quot;页面关闭&quot;); &#125;, 下拉刷新在小程序的 app.json 中，添加下拉事件 1&quot;enablePullDownRefresh&quot;:true 在页面中的下拉刷新函数调用函数 123456onPullDownRefresh: function () &#123; console.log(&quot;下拉中...&quot;); this.setData(&#123; msg:&quot;改变了&quot; &#125;) &#125; 上拉触顶可设置页面底部的加载动画。 1234//上拉触顶 onReachBottom:function()&#123; console.log(&quot;上拉触顶...&quot;); &#125; 实现页面跳转（1）正常跳转 123wx.navigateTo(&#123; url: &apos;页面路径&apos; &#125;) （2）重定向跳转 123wx.redirectTo(&#123; url: &apos;页面路径&apos;, &#125;) 两者区别：有无返回箭头 视图层数据绑定简单绑定数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于： 在页面的 .js 文件中添加变量： 12345Page(&#123; data: &#123; data:&quot;我是一条数据&quot; &#125;&#125;) 在 wxml 页面中引用： 1&lt;view&gt; &#123;&#123; data &#125;&#125; &lt;/view&gt; 数组绑定在页面的 .js 文件中添加数组变量： 1234567891011Page(&#123; data: &#123; array:[ &#123; id: &quot;item_1&quot; &#125;, &#123; id: &quot;item_2&quot; &#125;, &#123; id: &quot;item_3&quot; &#125;, &#123; id: &quot;item_4&quot; &#125;, &#123; id: &quot;item_5&quot; &#125;, ] &#125;&#125;) 在 wxml 页面中引用：item 指 array 中的每一项 123&lt;block wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt; &lt;view class=&quot;item.id&quot;&gt;这条数据的id为&#123;&#123;item.id&#125;&#125;&lt;/view&gt;&lt;/block&gt; 注意： &lt;block/&gt; 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 逻辑判断（1）if判断 12345Page(&#123; data: &#123; bool:false &#125;&#125;) 在 wxml 页面中引用： 1&lt;view wx:if=&quot;&#123;&#123;bool&#125;&#125;&quot;&gt;这是一台电脑&lt;/view&gt; 结果不会显示到界面。 列表渲染修改默认变量名 wx:for默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item 1234567891011Page(&#123; data: &#123; array:[ &#123; id: &quot;item_1&quot; &#125;, &#123; id: &quot;item_2&quot; &#125;, &#123; id: &quot;item_3&quot; &#125;, &#123; id: &quot;item_4&quot; &#125;, &#123; id: &quot;item_5&quot; &#125;, ] &#125;&#125;) 在 wxml 页面中引用： 使用 wx:for-item 可以指定数组当前元素的变量名， 使用 wx:for-index 可以指定数组当前下标的变量名： 123&lt;block wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-item=&quot;for-item&quot; wx:for-index=&quot;for-index&quot;&gt; &lt;view class=&quot;item.id&quot;&gt;&#123;&#123;for-index&#125;&#125;这条数据的id为&#123;&#123;for-item.id&#125;&#125;&lt;/view&gt;&lt;/block&gt; wx:key如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 &lt;input/&gt; 中的输入内容，&lt;switch/&gt; 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。 如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 123&lt;block wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:key=&quot;this&quot; wx:for-item=&quot;number_item&quot; wx:for-index=&quot;number_index&quot;&gt; &lt;view class=&quot;item.id&quot;&gt;&#123;&#123;number_index&#125;&#125;这条数据的id为&#123;&#123;number_item.id&#125;&#125;&lt;/view&gt;&lt;/block&gt; 条件渲染（1）if 、elif、else 判断 12345 Page(&#123; data: &#123; length:7 &#125;&#125;) 在 wxml 页面中引用： 1234&lt;!--条件判断--&gt;&lt;view wx:if=&quot;&#123;&#123;length&lt;6&#125;&#125;&quot;&gt;这是小于六的数字&lt;/view&gt;&lt;view wx:elif=&quot;&#123;&#123;length&gt;9&#125;&#125;&quot;&gt;只是大于六的数字&lt;/view&gt;&lt;view wx:else=&quot;&#123;&#123;length&lt;6&#125;&#125;&quot;&gt;没有你要找的数据&lt;/view&gt; （2）block wx:if 因为 wx:if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 &lt;block/&gt; 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。 1234&lt;block wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt; &lt;view&gt; view1 &lt;/view&gt; &lt;view&gt; view2 &lt;/view&gt;&lt;/block&gt; 注意： &lt;block/&gt; 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 模板123456789 Page(&#123; data: &#123; items:&#123; name: &quot;逯相强&quot;, age: &quot;21&quot;, class: &quot;软件工程1602&quot; &#125; &#125;&#125;) 定义模板123456&lt;!--定义模板--&gt;&lt;template name=&quot;msg&quot;&gt;&lt;view&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/view&gt;&lt;view&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/view&gt;&lt;view&gt;班级：&#123;&#123;class&#125;&#125;&lt;/view&gt;&lt;/template&gt; 使用模板12&lt;!--使用模板--&gt;&lt;template is=&quot;msg&quot; data=&quot;&#123;&#123;...items&#125;&#125;&quot;/&gt; 事件定义点击事件： 1234567891011 Page(&#123; data: &#123; &#125;， //点击事件 change: function () &#123; this.setData(&#123; data:&quot;我是第二条数据&quot; &#125;) &#125;,&#125;) 使用点击事件 12&lt;!--点击事件--&gt;&lt;button bindtap=&quot;change&quot;&gt;点击&lt;/button&gt; 引用WXML 提供两种文件引用方式import和include。 importimport可以在该文件中使用目标文件定义的template，如： 在 item.wxml 中定义了一个叫item的template： 1234&lt;!-- item.wxml --&gt;&lt;template name=&quot;item&quot;&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;&lt;/template&gt; 在 index.wxml 中引用了 item.wxml，就可以使用item模板： 12&lt;import src=&quot;item.wxml&quot;/&gt;&lt;template is=&quot;item&quot; data=&quot;&#123;&#123;text: &apos;forbar&apos;&#125;&#125;&quot;/&gt; includeinclude 可以将目标文件除了 &lt;template/&gt; &lt;wxs/&gt; 外的整个代码引入，相当于是拷贝到 include 位置，如： 1234&lt;!-- index.wxml --&gt;&lt;include src=&quot;header.wxml&quot;/&gt;&lt;view&gt; body &lt;/view&gt;&lt;include src=&quot;footer.wxml&quot;/&gt; 12&lt;!-- header.wxml --&gt;&lt;view&gt; header &lt;/view&gt; 12&lt;!-- footer.wxml --&gt;&lt;view&gt; footer &lt;/view&gt;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 基础之快速入门]]></title>
    <url>%2F2018%2F08%2F23%2FPython%20%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[此篇文章适合于具有一定编程语言基础的开发者快速入门学习 Python。 一、Python 基础语法Python 标识符 1、以下划线开头的标识符是有特殊意义的。 ① 以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入； ② 以双下划线开头的 _ _foo 代表类的私有成员； ③ 以双下划线开头和结尾的 foo 代表 Python 里特殊方法专用的标识，如 _ _ init _ _() 代表类的构造函数。 行和缩进 学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 { } 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。 缩进的空白数量是可变的，但是·所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示： 1234if True: print "True"else: print "False" 以下代码将会执行错误 1234567if True: print "Answer" print "True"else: print "Answer" # 没有严格缩进，在执行时会报错 print "False 执行以上代码，会出现如下错误提醒： 1234 File "test.py", line 10 print "False" ^IndentationError: unindent does not match any outer indentation level ① IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。 ② 如果是 IndentationError: unexpected indent 错误, 则 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是 tab 和空格没对齐的问题“，所有 python 对格式要求非常严格。 ③ 建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用 。 Python注释1、 python 中单行注释采用 # 开头。 2、python 中多行注释使用三个单引号 (‘’’) 或三个双引号 (“””)。 1234567891011'''这是多行注释，使用单引号。这是多行注释，使用单引号。这是多行注释，使用单引号。'''"""这是多行注释，使用双引号。这是多行注释，使用双引号。这是多行注释，使用双引号。""" Python空行1、函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 2、空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 等待用户输入下面的程序执行后就会等待用户输入，按回车键后就会退出： 1raw_input("按下 enter 键退出，其他任意键显示...\n") Print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾 加上逗号 , 12345678910111213x=&quot;a&quot;y=&quot;b&quot;# 换行输出print xprint yprint &apos;---------&apos;# 不换行输出print x,print y,# 不换行输出print x,y 以上实例执行结果为： 1234ab---------a b a b 多个语句构成代码组① 缩进相同的一组语句构成一个代码块，我们称之代码组。 ② 像 if、while、def 和 class 这样的复合语句，首行以关键字开始，以冒号 ( : ) 结束，该行之后的一行或多行代码构成代码组。 如下实例： 123456if expression : suite elif expression : suite else : suite 二 、Python 变量类型1、Python 中的变量赋值不需要类型声明。 2、每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。 3、每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 例如： 1234567counter = 100 # 赋值整型变量miles = 1000.0 # 浮点型name = "John" # 字符串 print counterprint milesprint name 执行以上程序会输出如下结果： 1231001000.0John 标准数据类型Python 有五个标准的数据类型： Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） Python字符串1、字符串或串 (String) 是由数字、字母、下划线组成的一串字符。 2、python 的字串列表有 2 种取值顺序: 从左到右索引默认 0 开始的，最大范围是字符串长度少 1 从右到左索引默认 -1 开始的，最大范围是字符串开头 3、如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。 123&gt;&gt;&gt; s = 'abcdef'&gt;&gt;&gt; s[1:5]'bcde' 上面的结果包含了 s[1] 的值 b，而取到的最大范围不包括尾下标，就是 s[5] 的值 f。 Python列表1、List（列表） 是 Python 中使用最频繁的数据类型。 2、列表用 [ ] 标识，是 python 最通用的复合数据类型。 123456789list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]tinylist = [123, 'john'] print list # 输出完整列表print list[0] # 输出列表的第一个元素print list[1:3] # 输出第二个至第三个元素 print list[2:] # 输出从第三个开始至列表末尾的所有元素print tinylist * 2 # 输出列表两次print list + tinylist # 打印组合的列表 以上实例输出结果： 123456['runoob', 786, 2.23, 'john', 70.2]runoob[786, 2.23][2.23, 'john', 70.2][123, 'john', 123, 'john']['runoob', 786, 2.23, 'john', 70.2, 123, 'john'] Python 元组1、元组是另一个数据类型，类似于List（列表）。 2、元组用 “()” 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 实例： 123456789tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )tinytuple = (123, 'john') print tuple # 输出完整元组print tuple[0] # 输出元组的第一个元素print tuple[1:3] # 输出第二个至第三个的元素 print tuple[2:] # 输出从第三个开始至列表末尾的所有元素print tinytuple * 2 # 输出元组两次print tuple + tinytuple # 打印组合的元组 以上实例输出结果： 123456('runoob', 786, 2.23, 'john', 70.2)runoob(786, 2.23)(2.23, 'john', 70.2)(123, 'john', 123, 'john')('runoob', 786, 2.23, 'john', 70.2, 123, 'john') 以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的： 1234tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]tuple[2] = 1000 # 元组中是非法应用list[2] = 1000 # 列表中是合法应用 Python 字典1、字典(dictionary)是除列表以外 python 之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。 2、两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 3、字典用“{ }”标识。字典由索引 (key) 和它对应的值 （value） 组成。 实例： 1234567891011dict = &#123;&#125;dict['one'] = "This is one"dict[2] = "This is two" tinydict = &#123;'name': 'john','code':6734, 'dept': 'sales'&#125; print dict['one'] # 输出键为'one' 的值print dict[2] # 输出键为 2 的值print tinydict # 输出完整的字典print tinydict.keys() # 输出所有键print tinydict.values() # 输出所有值 输出结果为： 12345This is oneThis is two&#123;'dept': 'sales', 'code': 6734, 'name': 'john'&#125;['dept', 'code', 'name']['sales', 6734, 'john'] 三、Python 运算符Python逻辑运算符 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False Python成员运算符除了以上的一些运算符之外，Python 还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 实例： 1234567891011121314151617181920a = 10b = 20list = [1, 2, 3, 4, 5 ]; if ( a in list ): print "1 - 变量 a 在给定的列表中 list 中"else: print "1 - 变量 a 不在给定的列表中 list 中" if ( b not in list ): print "2 - 变量 b 不在给定的列表中 list 中"else: print "2 - 变量 b 在给定的列表中 list 中" # 修改变量 a 的值a = 2if ( a in list ): print "3 - 变量 a 在给定的列表中 list 中"else: print "3 - 变量 a 不在给定的列表中 list 中" 以上实例输出结果： 1231 - 变量 a 不在给定的列表中 list 中2 - 变量 b 不在给定的列表中 list 中3 - 变量 a 在给定的列表中 list 中 Python身份运算符身份运算符用于比较两个对象的存储单元 。 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 实例： 123456789101112131415161718192021222324a = 20b = 20 if ( a is b ): print "1 - a 和 b 有相同的标识"else: print "1 - a 和 b 没有相同的标识" if ( a is not b ): print "2 - a 和 b 没有相同的标识"else: print "2 - a 和 b 有相同的标识" # 修改变量 b 的值b = 30if ( a is b ): print "3 - a 和 b 有相同的标识"else: print "3 - a 和 b 没有相同的标识" if ( a is not b ): print "4 - a 和 b 没有相同的标识"else: print "4 - a 和 b 有相同的标识" 以上实例输出结果： 12341 - a 和 b 有相同的标识2 - a 和 b 有相同的标识3 - a 和 b 没有相同的标识4 - a 和 b 没有相同的标识 is 与 == 区别： is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 四、python 条件语句1、Python 编程中 if 语句用于控制程序的执行，基本形式为： 1234if 判断条件： 执行语句……else： 执行语句…… 2、当判断条件为多个值时，可以使用以下形式： 12345678if 判断条件1: 执行语句1……elif 判断条件2: 执行语句2……elif 判断条件3: 执行语句3……else: 执行语句4…… 3、由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。 五、Python 循环语句Python提供了for循环和while循环（在Python中没有do..while循环）: 循环类型 描述 while 循环 在给定的判断条件为 true 时执行循环体，否则退出循环体。 for 循环 重复执行语句 嵌套循环 你可以在while循环体中嵌套for循环 1、while 循环12while 判断条件： 执行语句…… 实例： 123456count = 0while (count &lt; 9): print 'The count is:', count count = count + 1 print "Good bye!" 以上代码执行输出结果: 12345678910The count is: 0The count is: 1The count is: 2The count is: 3The count is: 4The count is: 5The count is: 6The count is: 7The count is: 8Good bye! 循环使用 else 语句在 python 中，while … else 在循环条件为 false 时执行 else 语句块： 123456count = 0while count &lt; 5: print count, " is less than 5" count = count + 1else: print count, " is not less than 5" 以上实例输出结果为： 1234560 is less than 51 is less than 52 is less than 53 is less than 54 is less than 55 is not less than 5 2、for 循环语句Python for 循环可以遍历任何序列的项目，如一个列表或者一个字符串。 语法： 12for iterating_var in sequence: statements(s) 实例： 12345678for letter in 'Python': # 第一个实例 print '当前字母 :', letter fruits = ['banana', 'apple', 'mango']for fruit in fruits: # 第二个实例 print '当前水果 :', fruit print "Good bye!" 以上实例输出结果: 12345678910当前字母 : P当前字母 : y当前字母 : t当前字母 : h当前字母 : o当前字母 : n当前水果 : banana当前水果 : apple当前水果 : mangoGood bye! 通过序列索引迭代另外一种执行循环的遍历方式是通过索引，如下实例： 12345fruits = ['banana', 'apple', 'mango']for index in range(len(fruits)): print '当前水果 :', fruits[index] print "Good bye!" 以上实例输出结果： 1234当前水果 : banana当前水果 : apple当前水果 : mangoGood bye! 以上实例我们使用了内置函数 len() 和 range(),函数 len() 返回列表的长度，即元素的个数。 range 返回一个序列的数。 循环使用 else 语句在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样 实例： 12345678for num in range(10,20): # 迭代 10 到 20 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print '%d 等于 %d * %d' % (num,i,j) break # 跳出当前循环 else: # 循环的 else 部分 print num, '是一个质数' 以上实例输出结果： 1234567891010 等于 2 * 511 是一个质数12 等于 2 * 613 是一个质数14 等于 2 * 715 等于 3 * 516 等于 2 * 817 是一个质数18 等于 2 * 919 是一个质数 六、Python pass 语句1、Python pass 是空语句，是为了保持程序结构的完整性。 2、pass 不做任何事情，一般用做占位语句。 实例： 12345678# 输出 Python 的每个字母for letter in 'Python': if letter == 'h': pass print '这是 pass 块' print '当前字母 :', letterprint "Good bye!" 以上实例执行结果： 12345678当前字母 : P当前字母 : y当前字母 : t这是 pass 块当前字母 : h当前字母 : o当前字母 : nGood bye! 七、Python 列表(List)1、序列是 Python 中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是 1，依此类推。 2、创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示： 123list1 = ['physics', 'chemistry', 1997, 2000]list2 = [1, 2, 3, 4, 5 ]list3 = ["a", "b", "c", "d"] 与字符串的索引一样，列表索引从 0 开始。列表可以进行截取、组合等。 访问列表中的值使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示： 12345list1 = ['physics', 'chemistry', 1997, 2000]list2 = [1, 2, 3, 4, 5, 6, 7 ] print "list1[0]: ", list1[0]print "list2[1:5]: ", list2[1:5] 以上实例输出结果： 12list1[0]: physicslist2[1:5]: [2, 3, 4, 5] 更新列表你可以对列表的数据项进行修改或更新，你也可以使用 append() 方法来添加列表项，如下所示： 1234list = [] ## 空列表list.append('Google') ## 使用 append() 添加元素list.append('Runoob')print list 以上实例输出结果 ： 1['Google', 'Runoob'] 删除列表元素可以使用 del 语句来删除列表的元素，如下实例： 123456list1 = ['physics', 'chemistry', 1997, 2000] print list1del list1[2]print "After deleting value at index 2 : "print list1 以上实例输出结果： 123['physics', 'chemistry', 1997, 2000]After deleting value at index 2 :['physics', 'chemistry', 2000] Python 列表脚本操作符 Python 表达式 结果 描述 len([1, 2, 3]) 3 长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [‘Hi!’] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 3 in [1, 2, 3] True 元素是否存在于列表中 for x in [1, 2, 3]: print x, 1 2 3 迭代 八、Python 元组1、Python 的元组与列表类似，不同之处在于元组的元素不能修改。 2、如下实例： 123tup1 = ('physics', 'chemistry', 1997, 2000)tup2 = (1, 2, 3, 4, 5 )tup3 = "a", "b", "c", "d" 创建空元组 1tup1 = () 元组中只包含一个元素时，需要在元素后面添加逗号 1tup1 = (50,) 访问元组元组可以使用下标索引来访问元组中的值，如下实例: 12345tup1 = ('physics', 'chemistry', 1997, 2000)tup2 = (1, 2, 3, 4, 5, 6, 7 ) print "tup1[0]: ", tup1[0]print "tup2[1:5]: ", tup2[1:5] 以上实例输出结果 : 12tup1[0]: physicstup2[1:5]: (2, 3, 4, 5) 修改元组元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例: 123456789tup1 = (12, 34.56)tup2 = ('abc', 'xyz') # 以下修改元组元素操作是非法的。# tup1[0] = 100 # 创建一个新的元组tup3 = tup1 + tup2print tup3 以上实例输出结果： 1(12, 34.56, 'abc', 'xyz') 删除元组元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例: 123456tup = ('physics', 'chemistry', 1997, 2000) print tupdel tupprint "After deleting tup : "print tup 以上实例元组被删除后，输出变量会有异常信息，输出如下所示： 123456('physics', 'chemistry', 1997, 2000)After deleting tup :Traceback (most recent call last): File "test.py", line 9, in &lt;module&gt; print tupNameError: name 'tup' is not defined 元组运算符与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 Python 表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 (‘Hi!’,) * 4 (‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’) 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print x, 1 2 3 迭代 无关闭分隔符任意无符号的对象，以逗号隔开，默认为元组，如下实例： 123print 'abc', -4.24e93, 18+6.6j, 'xyz'x, y = 1, 2print "Value of x , y : ", x,y 以上实例运行结果： 12abc -4.24e+93 (18+6.6j) xyzValue of x , y : 1 2 九、Python 字典(Dictionary)1、字典是另一种可变容器模型，且可存储任意类型对象。 2、字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示： 1d = &#123;key1 : value1, key2 : value2 &#125; 键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。 12345&gt;&gt;&gt;dict = &#123;'a': 1, 'b': 2, 'b': '3'&#125;;&gt;&gt;&gt; dict['b']'3'&gt;&gt;&gt; dict&#123;'a': 1, 'b': '3'&#125; 值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。 一个简单的字典实例: 1dict = &#123;'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'&#125; 也可如此创建字典： 12dict1 = &#123; 'abc': 456 &#125;;dict2 = &#123; 'abc': 123, 98.6: 37 &#125;; 访问字典里的值把相应的键放入熟悉的方括弧，如下实例: 1234dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; print "dict['Name']: ", dict['Name'];print "dict['Age']: ", dict['Age']; 以上实例输出结果： 12dict[&apos;Name&apos;]: Zaradict[&apos;Age&apos;]: 7 修改字典向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例: 12345678dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; dict['Age'] = 8; # update existing entrydict['School'] = "DPS School"; # Add new entry print "dict['Age']: ", dict['Age'];print "dict['School']: ", dict['School']; 以上实例输出结果： 12dict[&apos;Age&apos;]: 8dict[&apos;School&apos;]: DPS School 删除字典元素1、能删单一的元素也能清空字典，清空只需一项操作。 2、显示删除一个字典用del命令，如下实例： 12345678dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125;; del dict['Name']; # 删除键是'Name'的条目dict.clear(); # 清空词典所有条目del dict ; # 删除词典 print "dict['Age']: ", dict['Age'];print "dict['School']: ", dict['School']; 但这会引发一个异常，因为用del后字典不再存在： 12345dict['Age']:Traceback (most recent call last): File "test.py", line 8, in &lt;module&gt; print "dict['Age']: ", dict['Age'];TypeError: 'type' object is unsubscriptable 字典键的特性字典值可以没有限制地取任何 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。 两个重要的点需要记住： 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例： 123dict = &#123;'Name': 'Zara', 'Age': 7, 'Name': 'Manni'&#125;; print "dict['Name']: ", dict['Name']; 以上实例输出结果： 1dict['Name']: Manni 2）键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行，如下实例： 123dict = &#123;['Name']: 'Zara', 'Age': 7&#125;; print "dict['Name']: ", dict['Name']; 以上实例输出结果： 1234Traceback (most recent call last): File "test.py", line 3, in &lt;module&gt; dict = &#123;['Name']: 'Zara', 'Age': 7&#125;;TypeError: list objects are unhashable 十、Python 函数1、函数能提高应用的模块性，和代码的重复利用率。你已经知道 Python 提供了许多内建函数，比如 print()。但你也可以自己创建函数，这被叫做用户自定义函数。 定义一个函数你可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的 return 相当于返回 None。 语法1234def functionname( parameters ): "函数_文档字符串" function_suite return [expression] 默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。 实例1234def printme( str ): "打印传入的字符串到标准显示设备上" print str return 函数调用这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 提示符执行。 如下实例调用了 printme（）函数： 123456789# 定义函数def printme( str ): "打印任何传入的字符串" print str; return; # 调用函数printme("我要调用用户自定义函数!");printme("再次调用同一函数"); 以上实例输出结果： 12我要调用用户自定义函数!再次调用同一函数 参数传递在 python 中，类型属于对象，变量是没有类型的： 123a=[1,2,3] a="Runoob" 以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。 可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身 la 没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如 fun（a），传递的只是 a 的值，没有影响 a 对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 python 传不可变对象实例123456def ChangeInt( a ): a = 10 b = 2ChangeInt(b)print b # 结果是 2 实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。 传可变对象实例1234567891011# 可写函数说明def changeme( mylist ): "修改传入的列表" mylist.append([1,2,3,4]); print "函数内取值: ", mylist return # 调用changeme函数mylist = [10,20,30];changeme( mylist );print "函数外取值: ", mylist 实例中传入函数的和在末尾添加新内容的对象用的是同一个引用，故输出结果如下： 12函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数以下是调用函数时可使用的正式参数类型： 必备参数 关键字参数 默认参数 不定长参数 必备参数必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 12345678#可写函数说明def printme( str ): "打印任何传入的字符串" print str; return; #调用printme函数printme(); 以上实例输出结果： 1234Traceback (most recent call last): File "test.py", line 11, in &lt;module&gt; printme();TypeError: printme() takes exactly 1 argument (0 given) 关键字参数1、关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 2、使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 以下实例在函数 printme() 调用时使用参数名： 12345678#可写函数说明def printme( str ): "打印任何传入的字符串" print str; return; #调用printme函数printme( str = "My string"); 以上实例输出结果： 1My string 下例能将关键字参数顺序不重要展示得更清楚： 123456789#可写函数说明def printinfo( name, age ): "打印任何传入的字符串" print "Name: ", name; print "Age ", age; return; #调用printinfo函数printinfo( age=50, name="miki" ); 以上实例输出结果： 12Name: mikiAge 50 缺省参数调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的 age，如果 age 没有被传入： 12345678910#可写函数说明def printinfo( name, age = 35 ): "打印任何传入的字符串" print "Name: ", name; print "Age ", age; return; #调用printinfo函数printinfo( age=50, name="miki" );printinfo( name="miki" ); 以上实例输出结果： 1234Name: mikiAge 50Name: mikiAge 35 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下： 1234def functionname([formal_args,] *var_args_tuple ): "函数_文档字符串" function_suite return [expression] 加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下： 123456789101112# 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print "输出: " print arg1 for var in vartuple: print var return; # 调用printinfo 函数printinfo( 10 );printinfo( 70, 60, 50 ); 以上实例输出结果： 123456输出:10输出:706050 匿名函数python 使用 lambda 来创建匿名函数。 lambda 只是一个表达式，函数体比 def 简单很多。 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 语法lambda 函数的语法只包含一个语句，如下： 1lambda [arg1 [,arg2,.....argn]]:expression 如下实例： 123456# 可写函数说明sum = lambda arg1, arg2: arg1 + arg2; # 调用sum函数print "相加后的值为 : ", sum( 10, 20 )print "相加后的值为 : ", sum( 20, 20 ) 以上实例输出结果： 12相加后的值为 : 30相加后的值为 : 40 return 语句return 语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的 return 语句返回 None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做： 123456789# 可写函数说明def sum( arg1, arg2 ): # 返回2个参数的和." total = arg1 + arg2 print "函数内 : ", total return total; # 调用sum函数total = sum( 10, 20 ); 以上实例输出结果： 1函数内 : 30 变量作用域一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。 变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下： 全局变量 局部变量 全局变量和局部变量1、定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 2、局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例： 1234567891011total = 0; # 这是一个全局变量# 可写函数说明def sum( arg1, arg2 ): #返回2个参数的和." total = arg1 + arg2; # total在这里是局部变量. print "函数内是局部变量 : ", total return total; #调用sum函数sum( 10, 20 );print "函数外是全局变量 : ", total 以上实例输出结果： 12函数内是局部变量 : 30函数外是全局变量 : 0 十一、Python 文件I/O读取键盘输入Python 提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下： raw_input input raw_input函数raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）： 12str = raw_input("请输入：")print "你输入的内容是: ", str 这将提示你输入任意字符串，然后在屏幕上显示相同的字符串。当我输入”Hello Python！”，它的输出如下： 12请输入：Hello Python！你输入的内容是: Hello Python！ input函数nput([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个 Python 表达式作为输入，并将运算结果返回。 12str = input("请输入：")print "你输入的内容是: ", str 这会产生如下的对应着输入的结果： 12请输入：[x*5 for x in range(2,10,2)]你输入的内容是: [10, 20, 30, 40] 打开和关闭文件Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作 open 函数你必须先用 Python 内置的 open() 函数打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。 语法： 1file object = open(file_name [, access_mode][, buffering]) 各个参数的细节如下： file_name：file_name 变量是一个包含了你要访问的文件名称的字符串值。 access_mode：access_mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读 (r)。 buffering :如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 不同模式打开文件的完全列表： 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 File对象的属性一个文件被打开后，你有一个 file 对象，你可以得到有关该文件的各种信息。 以下是和 file 对象相关的所有属性的列表： 属性 描述 file.closed 返回 true 如果文件已被关闭，否则返回 false。 file.mode 返回被打开文件的访问模式。 file.name 返回文件的名称。 file.softspace 如果用 print 输出后，必须跟一个空格符，则返回 false。否则返回 true。 如下实例： 123456# 打开一个文件fo = open("foo.txt", "w")print "文件名: ", fo.nameprint "是否已关闭 : ", fo.closedprint "访问模式 : ", fo.modeprint "末尾是否强制加空格 : ", fo.softspace 以上实例输出结果： 1234文件名: foo.txt是否已关闭 : False访问模式 : w末尾是否强制加空格 : 0 close()方法语法： 1fileObject.close() write()方法1、write() 方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python 字符串可以是二进制数据，而不是仅仅是文字。 2、write() 方法不会在字符串的结尾添加换行符(‘\n’)： 语法： 1fileObject.write(string) 在这里，被传递的参数是要写入到已打开文件的内容。 例子： 123456# 打开一个文件fo = open("foo.txt", "w")fo.write( "www.runoob.com!\nVery good site!\n") # 关闭打开的文件fo.close() 上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容: 123$ cat foo.txt www.runoob.com!Very good site! read()方法**方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python** 字符串可以是二进制数据，而不是仅仅是文字。 语法： 1fileObject.read([count]) 在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。 例子： 123456# 打开一个文件fo = open("foo.txt", "r+")str = fo.read(10)print "读取的字符串是 : ", str# 关闭打开的文件fo.close() 以上实例输出结果： 1读取的字符串是 : www.runoob 文件定位tell() 方法告诉你文件内的当前位置 ,seek（offset [,from]）方法改变当前文件的位置。Offset 变量表示要移动的字节数。From 变量指定开始移动字节的参考位置。 例子： 123456789101112131415# 打开一个文件fo = open("foo.txt", "r+")str = fo.read(10)print "读取的字符串是 : ", str # 查找当前位置position = fo.tell()print "当前文件位置 : ", position # 把指针再次重新定位到文件开头position = fo.seek(0, 0)str = fo.read(10)print "重新读取字符串 : ", str# 关闭打开的文件fo.close() 以上实例输出结果： 123读取的字符串是 : www.runoob当前文件位置 : 10重新读取字符串 : www.runoob Python 异常处理python 提供了两个非常重要的功能来处理 python 程序在运行中出现的异常和错误。你可以使用该功能来调试python 程序。 异常处理。 断言(Assertions)。 python标准异常 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告 异常处理1、捕捉异常可以使用 try/except 语句。 2、try/except 语句用来检测 try 语句块中的错误，从而让 except 语句捕获异常信息并处理。 3、如果你不想在异常发生时结束你的程序，只需在 try 里捕获它。 语法： 12345678try:&lt;语句&gt; #运行别的代码except &lt;名字&gt;：&lt;语句&gt; #如果在try部份引发了'name'异常except &lt;名字&gt;，&lt;数据&gt;:&lt;语句&gt; #如果引发了'name'异常，获得附加的数据else:&lt;语句&gt; #如果没有异常发生 try 的工作原理是，当开始一个 try 语句后，python 就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try 子句先执行，接下来会发生什么依赖于执行时是否出现异常。 如果当 try 后的语句执行时发生异常，python 就跳回到 try 并执行第一个匹配该异常的 except 子句，异常处理完毕，控制流就通过整个 try 语句（除非在处理异常时又引发新的异常）。 如果在 try 后的语句里发生了异常，却没有匹配的 except 子句，异常将被递交到上层的 try，或者到程序的最上层（这样将结束程序，并打印缺省的出错信息）。 如果在 try 子句执行时没有发生异常，python 将执行 else 语句后的语句（如果有 else 的话），然后控制流通过整个 try 语句。 实例1下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，且并未发生异常： 12345678try: fh = open("testfile", "w") fh.write("这是一个测试文件，用于测试异常!!")except IOError: print "Error: 没有找到文件或读取文件失败"else: print "内容写入文件成功" fh.close() 以上程序输出结果： 1234$ python test.py 内容写入文件成功$ cat testfile # 查看写入的内容这是一个测试文件，用于测试异常!! 实例2下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，但文件没有写入权限，发生了异常： 12345678try: fh = open("testfile", "w") fh.write("这是一个测试文件，用于测试异常!!")except IOError: print "Error: 没有找到文件或读取文件失败"else: print "内容写入文件成功" fh.close() 在执行代码前为了测试方便，我们可以先去掉 testfile 文件的写权限，命令如下： 1chmod -w testfile 再执行以上代码： 12$ python test.py Error: 没有找到文件或读取文件失败 使用 except 而不带任何异常类型你可以不带任何异常类型使用 except，如下实例： 12345678try: 正常的操作 ......................except: 发生异常，执行这块代码 ......................else: 如果没有异常执行这块代码 以上方式 try-except 语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。 使用 except 而带多种异常类型你也可以使用相同的 except 语句来处理多个异常信息，如下所示： 12345678try: 正常的操作 ......................except(Exception1[, Exception2[,...ExceptionN]]]): 发生以上多个异常中的一个，执行这块代码 ......................else: 如果没有异常执行这块代码 try-finally 语句try-finally 语句无论是否发生异常都将执行最后的代码。 12345try:&lt;语句&gt;finally:&lt;语句&gt; #退出try时总会执行raise 当在 try 块中抛出一个异常，立即执行 finally 块代码。 异常的参数1、一个异常可以带上参数，可作为输出的异常信息参数。 2、你可以通过 except 语句来捕获异常的参数，如下所示： 12345try: 正常的操作 ......................except ExceptionType, Argument: 你可以在这输出 Argument 的值...]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 进阶之最全面的命名规范]]></title>
    <url>%2F2018%2F08%2F22%2FAndroid%20%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[今天分享一下 Android 的命名规范，要养成一个良好的规范习惯对以后工作很重要！ Android 进阶之最全面的命名规范目录 1. 为什么规范 Android 代码命名？ 增强代码的可读性 增强代码的可维护性 正由于上述两个作用，从而使得 开发效率 &amp; 维护效率 得到大幅度的提高。 2. Android需要命名的代码（对象）有哪些？ 3. 具体命名规范下面，我将对 Android 代码对象中的命名规范进行详细讲解 注：由于 Android主要用Java实现，所以Android规范会涵盖部分Java规范 3.1 包 基础规则：小写、单词间连续无间隔、反域名法（分为4级，具体如下图） 第4级包名会随着功能的不同而不同。下面我列举出一些常见 &amp; 需要规范的4级功能包名 3.2 类 基础规则 类型 = 名词 / 名词短语； 形式 = 驼峰形式中的 大骆驼拼写法（UpperCamelCase） 即名称中的每个词的首字母都大写，如 AndroidStudio 在具体命名类时，会根据 该类的类型不同而附加额外的命名规则。具体如下图 3.3 变量 基础规则 类型 = 名词 / 名词短语； 形式 = 驼峰形式中的 小骆驼拼写法（LowerCamelCase） 即名称中的第1个词的首字母小写，后面每个词的首字母大写，如androidStudioTool 在具体命名变量时，会根据该变量的类型不同而 附加额外的命名规则。具体如下图 3.4 方法 基础规则 类型 = 动词 / 动词短语； 形式 = 驼峰形式中的 小骆驼拼写法（LowerCamelCase） 即名称中的第1个词的首字母小写，后面每个词的首字母大写，如androidStudioTool 在具体命名 方法名时，会根据 该方法名的作用不同而 附加额外的命名规则。具体如下图 3.5参数名 基础规则：驼峰形式中的 小骆驼拼写法（LowerCamelCase） 即名称中的第1个词的首字母小写，后面每个词的首字母大写，如androidStudioTool 附加命名规则：功能名，如userName 3.6 资源 Android的资源包括： 下面，我将对每种Android资源的命名规则进行详细讲解 3.6.1 布局文件资源 3.6.2 图片资源 3.6.3 参数值资源 3.6.4 动画资源 3.7 额外 至此，关于Android的代码命名规范讲解完毕 4. 附录：常见使用单词缩写表 使用单词缩写的原则：只使用约定俗成的单词缩写 严禁自由缩写单词 具体如下图]]></content>
      <categories>
        <category>Android 初级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 基础之服务的基本用法]]></title>
    <url>%2F2018%2F08%2F21%2FAndroid%20%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[服务是Android 四大组件之一，是非常重要的知识点，下面是 Android 服务的基本用法入门基础讲解。 Android 四大组件之一服务（service）定义一个服务1、新建服务new —&gt; Service — &gt; .java 文件（定义一个服务就必须在里边实现相应的操作） 123456789101112131415//服务创建的时候会调用@Override public void onCreate() &#123; super.onCreate(); &#125;//每次服务启动的时候调用(一旦启动服务，在其方法执行的工作) @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId); &#125;//会在服务销毁的时候调用 @Override public void onDestroy() &#123; super.onDestroy(); &#125; 以上是服务最常用到的三个方法。 2、使用服务之前，需要在 AndroidManifest.xml 中注册服务 123456&lt;!--服务注册--&gt;&lt;service android:name=".MyService" //服务的类名 android:enabled="true" //是否允许除当前程序之外的其他程序访问 android:exported="true"&gt; //是否启动这个服务&lt;/service&gt; 启动和停止服务启动服务12Intent startintent = new Intent(this,MyService.class);startService(startintent); 停止服务12Intent stopIntent = new Intent(this,MyService.class);stopService(stopIntent); 活动和服务进行通信 上面我们学习到了服务的启动和停止，我们也知道服务实在活动中启动的，但是活动怎么才能知道服务去干吗了呢？怎么样用活动去指挥服务去完成什么样的任务呢？ 实例1、在 MyService.java 类中创建一个管理下载的 DownloadBinder 类 123456789101112// 用Binder对象来对下载功能进行管理class DownloadBinder extends Binder &#123; public void startDownload()&#123; Log.d("MyService","开始下载..."); &#125; public void getProgress()&#123; Log.d("获取下载进度","获取到了下载进度"); return; &#125;&#125; 我们在布局中创建两个按钮分别（绑定服务）和（取消绑定服务）。 2、创建 ServiceConnection 的匿名类，里边重写了两个方法，分别会在活动与服务成功绑定以及活动与服务的连接断开的时候调用，绑定成功时就会调用相应的方法 123456789101112131415161718192021222324252627 private MyService.DownloadBinder downloadBinder;//活动连接服务的对象private ServiceConnection connection = new ServiceConnection() &#123; /** * 功能：绑定成功 * @param componentName * @param iBinder */ @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; downloadBinder = (MyService.DownloadBinder) iBinder; //开始下载 downloadBinder.startDownload(); //获取下载进度 downloadBinder.getProgress(); &#125; /** * 功能：服务和活动断开时调用 * @param componentName */ @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125;&#125;; 3、绑定服务 12345678Intent bindIntent = new Intent(this,MyService.class);/** * 功能：将 MainActivity与 MyService进行绑定 * 参数一：bindIntent 启动服务Intent对象 * 参数二：connection 活动和服务的连接 * 参数三：BIND_AUTO_CREATE 活动和服务绑定成功后自动创建服务（使MyServiced的onCreate执行） */bindService(bindIntent,connection,BIND_AUTO_CREATE);//绑定服务 4、解除服务 12unbindService(connection);break; 服务的生命周期1、项目的任何位置调用了 Context 的 startService() 方法，服务就会回调 onStartCommand（）方法启动服务。 2、如果这个服务之前没有创建过，onCreate（）方法就会比 onStartCommand（）先执行。服务启动一直保持运行状态，直到 stopService（）或 stopSelf（）方法被调用。 3、每调用一次 startService（）方法，onStartCommand（）方法就会执行一次。 4、调用 Context 的 bindService（）来获取一个服务的持久连接，之后回调 onBind 方法。 5、如果这个服务之前没有创建过，onCreate（）方法就会比 onBind（）方法先执行。]]></content>
      <categories>
        <category>Andoid</category>
      </categories>
      <tags>
        <tag>Android 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2F2018%2F08%2F16%2F%E5%85%B3%E4%BA%8E%E6%88%91%2F</url>
    <content type="text"><![CDATA[关于小鹿的一篇自我介绍！ 自我介绍编程能力Ai、Fw、Fl、Br、Ae、Pr、Id、Ps 等软件的安装与卸载，精通 CSS、JavaScript、PHP、ASP、C、C++、C#、Java、Ruby、Perl、Lisp、Python、Objective-C、ActionScript、Pascal 等单词的拼写，熟悉 Windows、Linux、OS X、Android、iOS、WP8 等系统的开关机。 项目经验本人学识渊博、经验丰富、代码风骚、效率恐怖、C/C++、JAVA、php无不精通、深山苦练20余年、一天只睡4个小时、电话通知出 BUG 后秒登 VPN，千里之外定位问题、瞬息之间修复上线。身体强壮、健步如飞、可连续编程 100 小时不休息、讨论技术方案5小时不喝水，上至带项目、出方案，下至盗账号、威胁 PM，什么都能干。 泡面矿泉水已备好，学校不支持编程已辍学、家人不支持编程已断绝关系、老婆不支持编程已离婚、小孩不支持编程已送孤儿院，备用电源百兆光纤永不断电断网，门口已埋地雷无人打扰。 联系我公众号： 微信：lxq17853556107 欢迎来搞事情！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 进阶之百度推送]]></title>
    <url>%2F2018%2F08%2F16%2FAndroid%20%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%99%BE%E5%BA%A6%E6%8E%A8%E9%80%81%2F</url>
    <content type="text"><![CDATA[小鹿带你学会百度推送！ Android 进阶之百度推送步骤第一步：首先在百度云注册账号 （） 第二步：注册好账号之后，创建应用。 第三步：点击创建新应用。 第四步：填写应用名称 第五步：点击创建好应用之后进行应用配置。 第六步：选择终端（这里我们选择 Android），将项目包名填写进去。 第七步：要记住 API KEY 项目中要用到。 第八步：下载百度推送 SDK（官网），添加到项目中。 第九步：开始新建 Android 项目为 BaiDu_Push_Demo。 第十步：在 build.gradle 中添加依赖。 12//加载jar包compile files('src/main/JniLibs/pushservice-6.1.1.21.jar') 第十一步：新建 PushServiceReceiver.java 类（类中都是关于百度推送的回调）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247package com.example.boybaby.baidu_pust_demo;/** * Created by apple on 2018/4/25. */import android.content.Context;import android.text.TextUtils;import android.util.Log;import android.widget.Toast;import org.json.JSONException;import org.json.JSONObject;import java.util.List;/* * Push消息处理receiver。请编写您需要的回调函数， 一般来说： onBind是必须的，用来处理startWork返回值； *onMessage用来接收透传消息； onSetTags、onDelTags、onListTags是tag相关操作的回调； *onNotificationClicked在通知被点击时回调； onUnbind是stopWork接口的返回值回调 * 返回值中的errorCode，解释如下： *0 - Success *10001 - Network Problem *10101 Integrate Check Error *30600 - Internal Server Error *30601 - Method Not Allowed *30602 - Request Params Not Valid *30603 - Authentication Failed *30604 - Quota Use Up Payment Required *30605 -Data Required Not Found *30606 - Request Time Expires Timeout *30607 - Channel Token Timeout *30608 - Bind Relation Not Found *30609 - Bind Number Too Many * 当您遇到以上返回错误时，如果解释不了您的问题，请用同一请求的返回值requestId和errorCode联系我们追查问题。 * */public class PushMessageReceiver extends com.baidu.android.pushservice.PushMessageReceiver &#123; /** * TAG to Log */ public static final String TAG = PushMessageReceiver.class .getSimpleName(); /** * 调用PushManager.startWork后，sdk将对push * server发起绑定请求，这个过程是异步的。绑定请求的结果通过onBind返回。 如果您需要用单播推送，需要把这里获取的channel * id和user id上传到应用server中，再调用server接口用channel id和user id给单个手机或者用户推送。 * * @param context BroadcastReceiver的执行Context * @param errorCode 绑定接口返回值，0 - 成功 * @param appid 应用id。errorCode非0时为null * @param userId 应用user id。errorCode非0时为null * @param channelId 应用channel id。errorCode非0时为null * @param requestId 向服务端发起的请求id。在追查问题时有用； * @return none */ @Override public void onBind(Context context, int errorCode, String appid, String userId, String channelId, String requestId) &#123; String responseString = "onBind errorCode=" + errorCode + " appid=" + appid + " userId=" + userId + " channelId=" + channelId + " requestId=" + requestId; Log.d(TAG, responseString); if (errorCode == 0) &#123; // 绑定成功 Log.d(TAG, "绑定成功"); &#125; &#125; /** * 接收透传消息的函数。 * * @param context 上下文 * @param message 推送的消息 * @param customContentString 自定义内容,为空或者json字符串 */ @Override public void onMessage(Context context, String message, String customContentString) &#123; String messageString = "透传消息 onMessage=\"" + message + "\" customContentString=" + customContentString; Log.d(TAG, messageString); // 自定义内容获取方式，mykey和myvalue对应透传消息推送时自定义内容中设置的键和值 if (!TextUtils.isEmpty(customContentString)) &#123; JSONObject customJson = null; try &#123; customJson = new JSONObject(customContentString); String myvalue = null; if (!customJson.isNull("mykey")) &#123; myvalue = customJson.getString("mykey"); &#125; &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; /** * 接收通知到达的函数。 * * @param context 上下文 * @param title 推送的通知的标题 * @param description 推送的通知的描述 * @param customContentString 自定义内容，为空或者json字符串 */ @Override public void onNotificationArrived(Context context, String title, String description, String customContentString) &#123; String notifyString = "通知到达 onNotificationArrived title=\"" + title + "\" description=\"" + description + "\" customContent=" + customContentString; Log.d(TAG, notifyString); //Toast.makeText(context,description,Toast.LENGTH_LONG).show(); //Intent intent=new Intent(context,Main2Activity.class); //context.startActivity(intent); // 自定义内容获取方式，mykey和myvalue对应通知推送时自定义内容中设置的键和值 if (!TextUtils.isEmpty(customContentString)) &#123; JSONObject customJson = null; try &#123; customJson = new JSONObject(customContentString); String myvalue = null; if (!customJson.isNull("mykey")) &#123; myvalue = customJson.getString("mykey"); &#125; &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; // Demo更新界面展示代码，应用请在这里加入自己的处理逻辑 // 你可以參考 onNotificationClicked中的提示从自定义内容获取具体值 &#125; /** * 接收通知点击的函数。 * * @param context 上下文 * @param title 推送的通知的标题 * @param description 推送的通知的描述 * @param customContentString 自定义内容，为空或者json字符串 */ @Override public void onNotificationClicked(Context context, String title, String description, String customContentString) &#123; String notifyString = "通知点击 onNotificationClicked title=\"" + title + "\" description=\"" + description + "\" customContent=" + customContentString; Log.d(TAG, notifyString); Toast.makeText(context,description,Toast.LENGTH_LONG).show(); // 自定义内容获取方式，mykey和myvalue对应通知推送时自定义内容中设置的键和值 if (!TextUtils.isEmpty(customContentString)) &#123; JSONObject customJson = null; try &#123; customJson = new JSONObject(customContentString); String myvalue = null; if (!customJson.isNull("mykey")) &#123; myvalue = customJson.getString("mykey"); &#125; &#125; catch (JSONException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; /** * setTags() 的回调函数。 * * @param context 上下文 * @param errorCode 错误码。0表示某些tag已经设置成功；非0表示所有tag的设置均失败。 * @param failTags 设置失败的tag * @param requestId 分配给对云推送的请求的id */ @Override public void onSetTags(Context context, int errorCode, List&lt;String&gt; sucessTags, List&lt;String&gt; failTags, String requestId) &#123; String responseString = "onSetTags errorCode=" + errorCode + " sucessTags=" + sucessTags + " failTags=" + failTags + " requestId=" + requestId; Log.d(TAG, responseString); &#125; /** * delTags() 的回调函数。 * * @param context 上下文 * @param errorCode 错误码。0表示某些tag已经删除成功；非0表示所有tag均删除失败。 * @param failTags 删除失败的tag * @param requestId 分配给对云推送的请求的id */ @Override public void onDelTags(Context context, int errorCode, List&lt;String&gt; sucessTags, List&lt;String&gt; failTags, String requestId) &#123; String responseString = "onDelTags errorCode=" + errorCode + " sucessTags=" + sucessTags + " failTags=" + failTags + " requestId=" + requestId; Log.d(TAG, responseString); &#125; /** * listTags() 的回调函数。 * * @param context 上下文 * @param errorCode 错误码。0表示列举tag成功；非0表示失败。 * @param tags 当前应用设置的所有tag。 * @param requestId 分配给对云推送的请求的id */ @Override public void onListTags(Context context, int errorCode, List&lt;String&gt; tags, String requestId) &#123; String responseString = "onListTags errorCode=" + errorCode + " tags=" + tags; Log.d(TAG, responseString); &#125; /** * PushManager.stopWork() 的回调函数。 * * @param context 上下文 * @param errorCode 错误码。0表示从云推送解绑定成功；非0表示失败。 * @param requestId 分配给对云推送的请求的id */ @Override public void onUnbind(Context context, int errorCode, String requestId) &#123; String responseString = "onUnbind errorCode=" + errorCode + " requestId = " + requestId; Log.d(TAG, responseString); if (errorCode == 0) &#123; // 解绑定成功 Log.d(TAG, "解绑成功"); &#125; &#125;&#125; 第十二步：在 AndroidManifest.xml 中配置权限和相关服务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.boybaby.baidu_pust_demo"&gt; &lt;!-- Push service 运行需要的权限 --&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt; &lt;uses-permission android:name="android.permission.WRITE_SETTINGS" /&gt; &lt;uses-permission android:name="android.permission.VIBRATE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;uses-permission android:name="android.permission.DISABLE_KEYGUARD" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;!-- 富媒体需要声明的权限 --&gt; &lt;uses-permission android:name="android.permission.ACCESS_DOWNLOAD_MANAGER" /&gt; &lt;uses-permission android:name="android.permission.DOWNLOAD_WITHOUT_NOTIFICATION" /&gt; &lt;uses-permission android:name="android.permission.EXPAND_STATUS_BAR" /&gt; &lt;!-- 适配Android N系统必需的ContentProvider写权限声明，写权限包含应用包名 --&gt; &lt;uses-permission android:name="baidu.push.permission.WRITE_PUSHINFOPROVIDER.com.example.boybaby.com.example.boybaby.baidu_pust_demo" /&gt; &lt;permission android:name="baidu.push.permission.WRITE_PUSHINFOPROVIDER.com.example.boybaby.com.example.boybaby.baidu_pust_demo" android:protectionLevel="signature"&gt; &lt;/permission&gt; &lt;!-- 权限结束 --&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- push service start --&gt; &lt;!-- 用于接收系统消息以保证PushService正常运行 --&gt; &lt;receiver android:name="com.baidu.android.pushservice.PushServiceReceiver" android:process=":bdservice_v1"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.BOOT_COMPLETED" /&gt; &lt;action android:name="android.net.conn.CONNECTIVITY_CHANGE" /&gt; &lt;action android:name="com.baidu.android.pushservice.action.notification.SHOW" /&gt; &lt;action android:name="com.baidu.android.pushservice.action.media.CLICK" /&gt; &lt;!-- 以下四项为可选的action声明，可大大提高service存活率和消息到达速度 --&gt; &lt;action android:name="android.intent.action.MEDIA_MOUNTED" /&gt; &lt;action android:name="android.intent.action.USER_PRESENT" /&gt; &lt;action android:name="android.intent.action.ACTION_POWER_CONNECTED" /&gt; &lt;action android:name="android.intent.action.ACTION_POWER_DISCONNECTED" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;!-- Push服务接收客户端发送的各种请求 --&gt; &lt;receiver android:name="com.baidu.android.pushservice.RegistrationReceiver" android:process=":bdservice_v1"&gt; &lt;intent-filter&gt; &lt;action android:name="com.baidu.android.pushservice.action.METHOD" /&gt; &lt;action android:name="com.baidu.android.pushservice.action.BIND_SYNC" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.PACKAGE_REMOVED" /&gt; &lt;data android:scheme="package" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;service android:name="com.baidu.android.pushservice.PushService" android:exported="true" android:process=":bdservice_v1"&gt; &lt;intent-filter&gt; &lt;action android:name="com.baidu.android.pushservice.action.PUSH_SERVICE" /&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;!-- 4.4版本新增的CommandService声明，提升小米和魅族手机上的实际推送到达率 --&gt; &lt;service android:name="com.baidu.android.pushservice.CommandService" android:exported="true" /&gt; &lt;!-- 适配Android N系统必需的ContentProvider声明，写权限包含应用包名 --&gt; &lt;provider android:name="com.baidu.android.pushservice.PushInfoProvider" android:authorities="com.example.boybaby.baidu_pust_demo.bdpush" android:exported="true" android:protectionLevel="signature" android:writePermission="baidu.push.permission.WRITE_PUSHINFOPROVIDER.com.example.boybaby.baidu_pust_demo.PushMessageReceiver" /&gt; &lt;!-- push应用定义消息receiver声明 --&gt; &lt;receiver android:name="com.example.boybaby.baidu_pust_demo.PushMessageReceiver"&gt; &lt;intent-filter&gt; &lt;!-- 接收push消息 --&gt; &lt;action android:name="com.baidu.android.pushservice.action.MESSAGE" /&gt; &lt;!-- 接收bind、setTags等method的返回结果 --&gt; &lt;action android:name="com.baidu.android.pushservice.action.RECEIVE" /&gt; &lt;!-- 接收通知点击事件，和通知自定义内容 --&gt; &lt;action android:name="com.baidu.android.pushservice.action.notification.CLICK" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;!-- push结束 --&gt; &lt;/application&gt;&lt;/manifest&gt; 注意：在配置文件中需要将包名换成自己项目的包名。 ① ② ③ 以上三个地方的包名需要改成自己的。 第十三步：在 MainAcitivity 中注册百度推送 API KEY。 12345678910111213141516171819package com.example.boybaby.baidu_pust_demo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import com.baidu.android.pushservice.PushConstants;import com.baidu.android.pushservice.PushManager;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //注册,第三个参数是要修改的API KEY的字符串 PushManager.startWork(getApplicationContext(), PushConstants.LOGIN_TYPE_API_KEY,"Cy1dU6vskzHqPmEmNu2aCZsR"); &#125;&#125; 第十四步：创建通知并发送。 第十五步：发送成功。 手机端收到通知：]]></content>
      <categories>
        <category>Android 初级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 进阶之 Spinner 下拉框]]></title>
    <url>%2F2018%2F08%2F16%2FAndroid%20%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%B8%8B%E6%8B%89%E6%A1%86%2F</url>
    <content type="text"><![CDATA[Android 中下拉框的使用是用 Spinner 来实现的，Sprinner 下拉框中的数据有两种添加方法。一种方法是使用 spinner.xml 布局文件的方式添加，另外一方式是用 Adapter 适配器的方法来实现的。之所以整理今天整理一下 Spinner 的两种方式的使用因为在实际的项目中都用到过，所以做了一个总结。 Android 进阶之 Spinner 下拉框Sprinner 的实现方式一：使用布局文件来传入数据。步骤： 第一步：新建 activity_sprinner.xml 布局文件 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="xml布局引用方式:" android:textSize="20dp"/&gt; &lt;Spinner android:id="@+id/spinner_xml" android:layout_width="120dp" android:layout_height="wrap_content"&gt; &lt;/Spinner&gt;&lt;/LinearLayout&gt; 第二步：在 values 文件夹下新建 spinner.xml 文件。 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;string-array name="spingArr"&gt; &lt;item&gt;中国&lt;/item&gt; &lt;item&gt;美国&lt;/item&gt; &lt;item&gt;俄国&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 第三步：新建 SpinnerActivity.java 类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class SpinnerActivity extends AppCompatActivity &#123; //声明控件 private Spinner spinner; private TextView textView; private ArrayAdapter arrayAdapter; private String spinnerStr; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.actvity_spinner); //关联控件 spinner = (Spinner) findViewById(R.id.spinner_xml); textView = (TextView) findViewById(R.id.tv_text); //使数据布局文件和Adapter适配器关联 relevanceSpinner(); //Spinner下拉框监听事件 spinner.setOnItemSelectedListener(new Spinner.OnItemSelectedListener() &#123; //选择下拉框数据监听 public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; spinnerStr = arrayAdapter.getItem(arg2).toString(); textView.setText(spinnerStr); &#125; //未选择下拉框监听 public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; spinnerStr = ""; &#125; &#125;); &#125; //使数据布局文件和Adapter适配器关联 public void relevanceSpinner()&#123; //R.array.spingArr 为 values 文件夹下 spinner.xml 中 string-array 的 name 值 arrayAdapter = ArrayAdapter.createFromResource(this, R.array.spingArr, android.R.layout.simple_spinner_item); //将 adapter2 添加到 spinner 中 spinner.setAdapter(arrayAdapter); &#125;&#125; 最终运行图示： Sprinner的实现方式二：在Activity中动态传入数据显示。步骤步骤一：新建 activity_main.xml布局文件。 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Activity引用方式:" android:textSize="20dp"/&gt; &lt;Spinner android:id="@+id/spinner_equment_name" android:layout_width="120dp" android:layout_height="wrap_content"&gt; &lt;/Spinner&gt; &lt;TextView android:id="@+id/tvText" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 步骤二：新建 MainActivity.java 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MainActivity extends AppCompatActivity &#123; //声明控件 private Spinner spinner; private ArrayAdapter arr_adapter = null; private List&lt;String&gt; list = new ArrayList&lt;String&gt;(); private TextView text; private String spinnerText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //关联控件 spinner = (Spinner) findViewById(R.id.spinner_equment_name); text = (TextView)findViewById(R.id.tvText); //list填充数据（如果是服务器接收的数据可动态填充） list.add("中国"); list.add("美国"); list.add("俄国"); //适配器 arr_adapter = new ArrayAdapter(this, android.R.layout.simple_spinner_item, list); //设置样式 arr_adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); //加载spinner适配器 spinner.setAdapter(arr_adapter); //Spinner 选择数据监听事件 spinner.setOnItemSelectedListener(new Spinner.OnItemSelectedListener() &#123; public void onItemSelected(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) &#123; spinnerText = arr_adapter.getItem(arg2).toString(); text.setText(spinnerText); &#125; public void onNothingSelected(AdapterView&lt;?&gt; arg0) &#123; spinnerText = ""; text.setText(spinnerText); &#125; &#125;); &#125;&#125; 运行显示图示： 还有一些关于Spinner的属性等到用到时在补充，以上就是这些，谢谢！]]></content>
      <categories>
        <category>Android 初级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 之一切皆对象]]></title>
    <url>%2F2018%2F08%2F16%2F%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%20java%20%E4%B9%8B%E3%80%90%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1%E3%80%91%2F</url>
    <content type="text"><![CDATA[Java语言是面向对象的编程语言，当我们用Java做实际开发时，我们必须将思想转化到面向对象的世界中。这是作为一个Java程序员的基本功，如果你兼备使用这种语言的一种能力，会使你学起来更加简单。我们在项目开发中，经常做到会new对象、会使用对象已经足够了。想知道java对象在程序内怎么存储怎么使用的吗？今天的内容深入剖析java对象。 Java 之一切皆对象一、用引用操纵对象什么是引用在java程序中，尽管我们一切都将看作为对象，但实际上操作对象的标识符实际上是对象的一个“引用（referen）”。 为了读者方便理解，我们可以将操纵对象的标识符想象成电视机的遥控器（引用），电视机为对象。只要握住遥控器，我们就可以保持与电视机的连接。当我们减小电视机的音量时，我们的实际操控是遥控器（引用），再由遥控器操纵电视机（对象）。以上形象的比喻就是我们在 java 中使用对象时，不是直接对对象进行操作，而是通过引用进而对对象的控制操作。 即使我们没有电视机，遥控器也可以独立的存在。也就是说，我们可以单独的拥有一个引用，并不一定需要一个对象去关联。下面举个小例子详细说明，我们可以创建一个 String 的引用。 String s; 这里所创建的只是引用，并不是对象。如果此时此刻对s进行输出使用，运行时就会返回一个错误。因为s实际上没有与任何的事物关联。因此，为了安全起见，我们通常在项目中创建一个引用通常做初始化处理：String = “abc”; 这里用到的是字符串带文本的初始化，通常还有另外一种更通用的方法。 对象的创建与存储我们一旦创建了引用就必须关联一个对象，通常用new关键字来实现。new关键字的意思是“给我一个新对象”，所以另一种初始化字符串的方式为： String s = new String(“abc”); 除此之外，java中还有很多数据类型，以上只是举个小例子。 对象存储到了什么地方？很多人对会在程序中很轻松的new出一个对象，但是对象到底存储到什么地方呢？特别是内存会发生什么变化呢？下边的讲解会对你有很大的帮助。 寄存器。这是这是最快的存储区，因为这是位于不同于其他的存储位置—处理器内部。但是寄存器的数量有限，所以寄存器根据需求进行分配。 栈堆。位于 RAM（随机访问存储器）中，通过栈堆指针从处理器那获取直接支持。如果栈堆指针向下移动，则重新分配新的内存。若指针向上移动，则释放内存空间。某些的java数据就存储到栈堆中，比如上面讲到的遥控器（引用）就存储到该区域，而对象并不存储到其中。 堆。一种通用的内存池，（位于 RAM ）中，用于存放 java 所有的对象。堆不同于栈堆的好处就是：编译器不知道存储到堆里的数据存活多长时间。因此，在堆里分配存储有很大的灵活性。当需要一个对象时，只需要new写一行代码，当执行到该代码时，会自动在堆里进行存储分配。堆的分配清理空间比栈堆的花费的时间要长。 常量存储。常量值通常直接存放到程序的内部，这样做是安全的，因为他们的值永远不会被改变。在嵌入式系统开发中，常量本身会和其他部分分隔开，在这种情况下，我们可以选择将其存放到 ROM（只读存储器）中。 ​ 5. 非RAM存储。如果数据完全存活于程序之外，那么它可以不受程序任何控制，在程序没有运行时也可以存在。两个基本的例子就是流对象和持久化对象。在流对象中，数据转化为字节流，通常被发送到另一个机器。在“持久化对象”中，对 象被存放于磁盘上，因此即使程序终止，他们仍可以保持原有的状态。这种存储方式的技巧在于：把对象转化成可以存放在其他媒体的事物，在需要时，再恢复成常规，基于RAM的对象]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 进阶之 OKHttp 与服务器通信]]></title>
    <url>%2F2018%2F08%2F12%2FAndroid%20%E8%BF%9B%E9%98%B6%E4%B9%8B%20Okhttp%20%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[人生中第一次写博客，也就是大学大二期间。我认为记录这些点点滴滴的经验和知识有两点必要。第一，是能够记录自己在学习IT之路的一些经验和知识的整理；第二，把自己所理解的知识点更能详细分享给喜欢编程的每一个人，希望读者看了这些能够有所帮助，虽然别人也写到同样的知识，但是我通过学习这个知识点再加上我的个人理解来记录下来，有些知识说的不到位请各位批评改正！ ​ 言归正传，下面来讲一下利用okhttp做服务器通信（socket通信），之前大多数开发者用的是流的通信方式，自从安卓提供okhttp框架之后，实现客户端与服务器的通信更方便快捷了，废话不多说，下面我进行一一讲解！TT 搭建OkHTTP框架之前注意： 1、在 build 中加入okhttp，Gson 的架包，修改 build.gradle（app）中加上： 1compile 'com.squareup.okhttp:okhttp:2.4.0' 2、在 AndroidManifest 中增加请求网络的权限（如不加，APP连不上网络）； 1&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 搭建步骤： 1、首先创建okhttp对象，设置为全局（以下操作都围绕该对象来做的） 1OkHttpClient okHttpClient = new OkHttpClient(); 2、对该对象进行封装（里边携带往服务器发送的相关参数（如果不是自己服务器参考该服务器开发文档）和URL（服务器提供的接口API）） 123456789101112131415161718192021222324252627Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; MediaType JSON = MediaType.parse("application/json; charset=utf-8"); List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();//将JSON数据以Map形式存储到list中去,以List数组形式存储着数据; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); //建立Map对象，向Map添加数据; map.put("StartTime", "2018-01-11 09:14"); map.put("EndTime", ""); map.put("Interval", "5"); map.put("Start", "0"); map.put("Limit", "1"); map.put("Order", "1"); list.add(map); JSONObject jsonObject = new JSONObject(map); //创建JSONObject对象; String string = jsonObject.toString(); //将jsonObject对象转换成字符串; RequestBody body = RequestBody.create(JSON, string);//将JSON数据打包成Body通过post上传; Request request = new Request.Builder() .url(Get_All_url) //该服务器的api（URL） .addHeader("userkey", "55656535336494b84c749b31453ea55") .post(body) .build(); executeRequest(request); &#125; &#125;); t1.start(); 做服务器连接是一个耗时的工作要在线程里完成，这里我将发往服务器的相关参数封装到 Map 里边然后将 Map 放到 List 中将 List 打包成 JSONobject 对象，然后将对象转化成字符串才能封装成传输数据的 body 才能上传服务器，body “相当于人的身体”，将其封装到 request 对象中，如果相关服务器有相关的 key 标识的话，可以通过 addHeader 键值对方式存到 request 头部，这样一个完整的数据包打包成功了，可以通 executeRequest(request)发送到服务器！ 补充：在以上封装数据的时候可能与别的博主写的不同，但是用这个List/map的格式封装感觉更易懂一些，下面就详细说一下。 我们通常看到别人的 okhttp 上传都是用到的 FormEncodingBuilder 可以简单理解为表单的形式，代码如下： 123456789FormEncodingBuilder builder = new FormEncodingBuilder ();builder.add("username","admin");builder.ass("password","123");Request request = new Request.Builder() .url(https://mp.csdn.net/) //该服务器的api（URL） .addHeader("userkey", "2312333321323") //头部标识（不需要可去掉） .post(builder.builde()) .build(); executeRequest(request); 我们都知道网络通信的格式大多数 Json 数据，我们要利用 map 和 List 的结合打包成 Json 数据，下面举个例子,比如我们要打包成这种形式的 Json 数据： 123456Map&lt;String, String&gt; map1 = new HashMap&lt;&gt;();//生成一个Map类型对象map1 Map&lt;String, String&gt; map2 = new HashMap&lt;&gt;();//生成一个Map类型对象map2map1.add("Name","T1");map1.add("Value","1");map2.add("Name","01H1");map2.add("Value","96.2")； 在 Json 数据中一个{}里的内容就称为一个对象，{“Name”:”T1”,”Value”,”1”} 称为一个对象，我们将这个对象数据以 Map 键值对类型存到 map1 中，同理将第二个 Json 对象存放到 map2 中去，map1、map2就可以封装成{“Name”:”T1”,”Value”,”1”}，{“Name”:”01H1”,”Value”,”96.2”} 的形式，我们可以清楚的看到两个{}对象最外层还包含着一个 [ ] 的括号，我们就可以将 [ ] 用 List 来表示，那 List 存放的数据类型是什么呢？不明思义，当然是{}两个 json 对象咯，{ } 两个对象用 map 封装的，所以 List 中存放着 Map 类型的数据，我们可以这样声明并添加： 123456789List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();//我们将封装好的map1和map2添加到list中去list.add(map1);list.add(map2);//我们将list装换成JsonArray数组形式JsonArray jsonarray = new JSONArray(list);//我们再把jsonarray形式转化成字符串就可以上传了String str = jsonarray.toString();RequestBody body = RequestBody.create(JSON, str); 经过以上的层层封装，我们终于把数据封装成想要的样子，简单总结一下， { } 的数据用 Map 键值对进行封装，而 [] Json 数组形式用 List 封装，最后那 List 转化成 JsonArray 数组形式就可以得到想要的数据了！ 注意：如果Json 数据只由 {} 对象形式封装成的，我们可以将 map 转化成 JsonObject 对象,然后将 JsonObject 妆化成字符串上传服务器！ 12JsonObject jsonobject = new JSONObject(map1);String str = new jsonobjct.toString(); 经过上边的讲解你是否可以封装任意 Json 数据了呢？ 3、第三步是来对服务器返回的数据做处理 该 OKHTTP 框架也提供了简单的服务器回调方法，下边我们来看一下 12345678910111213141516171819202122232425//服务器返回调用函数private void executeRequest(Request request) &#123; //3.将Request封装为Call Call call = new OkHttpClient().newCall(request); //4.执行call call.enqueue(new Callback() &#123; @Override//回调错误时 public void onFailure(Request request, IOException e) &#123; &#125; @Override//回调成功时 public void onResponse(Response response) throws IOException &#123; final String relsult = response.body().string();//接收服务器返回来的信息 try &#123; JSONArray jsonarray = new JSONArray(relsult);//将返回的信息转换成JSON形式 &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; 当服务器进行响应时，会自动的调用 executeRequest() 函数，回调函数中自带的两种相应方法分别为服务器响应失败和服务器响应成功，开发人员可以在其中做相应的解析和回调！]]></content>
      <categories>
        <category>Android 初级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 深入剖析四种启动模式]]></title>
    <url>%2F2018%2F08%2F08%2FAndroid%20%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在 Android 应用开发中，打造良好的用户体验是非常重要的。 Android 系统中的 Activity 可以说一件很赞的设计，它在内存管理上良好的设计，使得多任务管理在Android系统中运行游刃有余。下面小鹿带你全面解析 Android 的四大启动模式 Android 深入剖析四种启动模式一、四大启动模式 ​ 在实际项目中，根据特定的需求需要对每个活动指定恰当的启动模式。Android 页面的启动模式分为四种：standard、singleTop、singleTask和singleInstance，可以通过 AndroidManifest.xml 中通过给标签指定 android:launchMode 属性来选择启动模式。 1、standard​ standard 是活动默认的启动模式。在不进行设置的情况下，所有的活动都是自动使用这种启动模式。在这里讲启动模式之前，先说一下 Android 是利用返回栈来管理活动的。对于基础差的开发者还不理解 Android 活动（页面）是怎么进行管理的，就是用到刚刚上边说到的返回栈来管理活动的。 ​ 我们详细来看一下，根据我自己对任务的理解来详细说一下，Android 是使用任务（Task）来管理活动的，一个任务就是存放到栈里的活动（页面）的集合，这个栈也成为返回栈（Back Stack）,栈是一种先进后出的的数据结构，在默认的情况下，每当启动一个活动，它会在返回栈中入栈，并位于栈的顶端位置，每当用户按Back键或调用finish()方法去毁掉一个活动时，处于栈顶的活动就会出栈，这时，前一个入栈的活动就会处于栈顶位置。也就是说，用户可以看到的活动（页面）就是处于栈顶的活动！（为了更好的理解我的给大家大体画了个图） 我新建了一个项目，代码如下，我启动三次第一个页面进行测试： 123456789101112@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //控制台打印本页面的存标识 Log.d("FirstActivity",this.toString()); setContentView(R.layout.activity_first);&#125;//启动本页面public void Start_Intent(View v)&#123; Intent intent = new Intent(FirstActivity.this,FirstActivity.class); startActivity(intent);&#125; 控制台打印信息为： 从控制台打印信息可以看到，每点击一下按钮都会创建一个 FirstActivity 实例，这时，返回栈中也有三个实例，当我们按 Back 键退出时需要按三下才能退出程序！（如图）: 2、singleTop 当活动的启动模式指定为 singleTop，在启动活动如果发现返回栈栈顶已经是该活动时，就直接去使用它，不会创建新的活动实例。 代码如下： 12345678&lt;activity android:name=".FirstActivity" android:launchMode="singleTop"&gt;//启动模式singleTop &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 123456789101112131415public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //控制台打印本页面的存标识 Log.d("FirstActivity",this.toString()); setContentView(R.layout.activity_first); &#125; //启动本页面 public void Start_Intent(View v)&#123; Intent intent = new Intent(FirstActivity.this,SecondActivity.class); startActivity(intent); &#125;&#125; 1234567891011121314public class SecondActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Log.d("SecondActivity",this.toString()); &#125; //启动本页面 public void Start_Intent(View v)&#123; Intent intent = new Intent(SecondActivity.this,FirstActivity.class); startActivity(intent); &#125;&#125; 从打印信息可以看出，创建了两个 FirstActivity 实例，因为我们在 FirstActivity 跳转到 SecondActivity 时，位于栈顶的是 SecondActivity ,因此会再创建一个新的实例 FirstActivity .当用户按下 Back 三次才可以退出程序。下面看示意图： 3、singleTask​ 开发者使用 singleTask 可以解决上边 singleTop 模式重复创建栈顶活动的问题，为了避免活动不处于栈顶重复创建活动实例的情况，我们可以使用 singleTask 的模式。这个模式的特点是什么呢？当每次用户启动一个活动时，系统先检查返回栈的是否存在该活动，如果不存在就创建一个新的实例，如果存在该活动，位于该活动顶部的活动全部出栈，使该活动处于栈顶！代码改一下上方的 android：launchMode=”singleTask” 可以自己试一下！示意图如下： 4、singleInstance​ singleInstance模式比前边的三种模式要复杂一些，与前边的三个模式不同的是指定为 singleIntance 模式的活动会启动一个新的返回栈来管理这个活动，什么时候可以用到这个模式呢？当我们这个程序的活动允许其他程序调用时，要实现这个程序和其他程序共享这个活动的话，前边的三种模式都实现不了，因为每个程序都有自己的返回栈，同一个活动在不同的返回栈中入栈的时候会创建一个新的实例。而 singleIntance 模式可以解决这个问题，以为这个模式有一个独立的返回栈来管理这个活动，无论有多少程序来调用这个活动，都共用同一个返回栈。 ​ 举个例子：我们建立三个页面，分别为FirstActivity、SecondActivity、ThirdActivity 每个页面都要分别用 123Log.d(&quot;FirstActivity&quot;,&quot;getTaskId()&quot;);Log.d(&quot;SecondActivity&quot;,&quot;getTaskId()&quot;);Log.d(&quot;ThirdActivity&quot;,&quot;getTaskId()&quot;); 来查看创建返回栈的 id,我们将 singleIntance 模式指定为 SecondActivity 页面，我们实现三个页面的连续跳转，控制台打印出信息为：121、122、121。可以很明白的看出 SecondActivity 单独位于一个返回栈中。 ​ FirstActivity*页面跳转到 SecondActivity 页面，我来解释一下，因为 FirstActivity 和 ThirdActivity 位于同一个返回栈中，所以 ThirdActivity 位于栈顶出栈，FirstActivity 页面位于栈顶，所以 ThirdActivity 页面直接跳转到 FirstActivity 页面，再按 Back 键时，FirstActivity 和 ThirdActivity 的返回栈为空，就会显示另一个返回栈的活动，当另一个返回栈的活动出栈时，程序才会退出！ 示意图如下： 二、四大启动模式深入剖析 Activity 的启动模式也是一个难点，原因是形形色色的启动模式和标志位太容易混淆，但是 Activity 作为四大组件之首，它的确非常重要，为了满足项目的需求，必须使用 Activity 的启动模式。 1、Activity 的 LaunchMode1.1 启动模式​ 之所以 Activity 使用启动模式，因为 Activity 的创建是在任务栈中的，当我们启动同一个 Activity 时，系统就会创建多个 Activity 实例放入任务栈中，当我们按 back 键时，任务栈中的实例就会一一出栈。栈我想并不陌生，具有的特点：先进先出。如果我们不允许系统重复创建相同的 Activity ，我们就会用到 Activity 的启动模式进行设置。Activity 的启动模式分为四种 standard、singleTop、singleTask和 singleInstance,之前的那篇文章也有相关介绍，下面就简单提一下。 （1）standard 标准模式 :​ 这是系统默认的启动模式，每次启动一个 Activity 都会创建一个新的实例，不管这个实例是否存在。如果 A 启动了 B，B 的活动就会进入到 A 的任务栈中。 （2）singleTop 栈顶复用模式 :​ 在这种启动模式下，新的 Activity 已经位于栈顶，如果再次启动该 Activity ，此 Activity 不会被重新创建。同时系统的 onNewIntent 方法被回调，通过此方法的参数我们可以取出当前的请求信息。当然 Activity 的 onCreate、onStart 和 onResume 方法不会重新被调用。如果该 Activity 没有位于栈顶，该活动就会重新被创建。 （3）singleTask 栈内复用模式 :​ 这是一种单例模式，在这种模式下，只要栈中存在该实例，该实例不会被重新创建。比如：我们想要创建一个实例 A，系统就会先判断任务栈中是否存在和 A 同样的实例。如果实例存在任务栈中，系统就会把 A 调用到栈顶并调用它的 onNewIntent 方法，同时 A 以上的 Activity 实例都会被移除出栈直到 A 位于栈顶位置；如果实例不存在，系统就会创新创建一个新的实例 A 并将其压入栈顶。 （3）singleInstance 单实例模式 :​ 我通常把这种模式的 Activity 称为 singleTask 模式的加强版，除了具有 singleTask 模式具有的特点外，以 singleInstance 启动的 Activity 实例单独存在一个任务栈中，后续的请求不会创建新的实例。 1.2 任务栈什么是任务栈？各个 Activity 是怎么样分配到各个任务栈的？以下情况都是在 singleTask 模式情况下来说的。 从一个参数说起，TaskAffinity ，翻译为任务的相关性，这个参数标识了一个 Activity 所需要得任务栈的名字，默认情况下，Activity 所需要的任务栈的名字为应用的包名。任务栈分为前台任务栈和后台任务栈，后台任务栈中的 Activity 处于暂停状态，用户可以将后台任务栈切换到前台。 ——任务栈 1.3 设置启动模式的两种方式 第一种方式 : 通过 AndroidMenifest 配置文件设置启动模式 12345678910&lt;activity android:name=".MonitoringActivitys.MonitorActivity" android:label="@string/title_activity_monitor" android:theme="@style/AppTheme.NoActionBar" android:launchMode="singleTask"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 第二种方式 : 通过 Intent 中设置标志位来设置启动模式 123Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 区别： ① 第二种优先级要高于第一种 ② 第一种无法给 Activity 设定 FLAG_ACTIVITY_CLEAR_TOP 标识，第二种无法为 Activity 指定 singleInstance 模式。]]></content>
      <categories>
        <category>Android 高级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 深入剖析生命周期]]></title>
    <url>%2F2018%2F08%2F08%2FAndroid%20%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Activity 生命周期是研究Android开发最基础的知识点之一，熟练掌握生命周期的特性可以在实际开发中避免踩坑。比如，一些UI的初始化和回收操作、框架库的注册于反注册（摧毁）、线程的启动和停止等。 Android 的生命周期深入剖析一、正常情况下生命周期 onCreate : 表示页面（Activity）的创建。（生命周期第一个阶段）功能：完成初始化工作，如：加载页面布局资源、初始化数据。 onStart : 表示页面（Activity）正在被启动，即将开始。功能：页面为可见状态，但是无法与用户交互。 onResume : 表示页面（Activity）出现在前台。功能：与 onStart 相比，onStart 处于后台，OnResume 才显示到前台。 onPause : 表示页面（Activity）正在停止。功能：页面处于后台，正常情况下，onStop 紧接着执行。此时会做一些数据存储、停止动画不太耗时的工作。onPause 执行完新的页面（Activity）的 onResume 才会执行。 onStop : 表示页面（Activity）即将停止。功能：页面为不可见状态，做稍微轻量级的不太耗时的回收工作。 onDestroy : 表示页面（Activity）即将销毁。（生命周期最后一个阶段）功能：回收工作和资源的释放。 onRestart : 表示页面（Activity）重新启动。功能：页面从不可见状态转化为可见状态时会调用此方法。如：Home 键切换页面（打开新的 Activity），然后回到页面过程中。 问题：1、onStart 和 onResume、onPause和onStop从描述上来看差不多，对我们来说有什么实质上的不同？ 答：onStart 和 onStop 是从 Activity 是否可见这个角度来回调的，而 onResume 和 onPause 是从是否位于前台来回调的。 2、假设当前 Activity 为 A。如果用户打开一个新的 Activity B，那么 B 的 onResume 和 A 的 onPause 哪个先执行？ 答：根据 Android 的基本运行机制，不能再 onPause 中执行重量级的操作，因为必须 onPause 执行完成以后新 Activity 才能 onResume。onPause 和 onResume 都不能执行耗时的操作，尤其是 onPause，这就意味着我们应该在 onStop 中做操作。从而使新的 Activity 显示出来并切换到前台。 二、异常情况下生命周期1、情况一：资源相关的系统配置发生改变导致 Activity 被杀死并重新创建 比如当前Activity处于竖屏状态，如果突然旋转屏幕，由于系统配置发生改变，在默认情况下，Activity 就会被销毁并且重新创建。 （1）异常生命周期调用过程： ​ ① Activity 会被销毁，其中 onPause、onStop、onDestory均会被调用，同时由于 Activity 是在异常情况下终止的 ​ ② 系统会调用 onSavaInstanceState 来保存当前的 Activity 的状态。这个方法的调用时机是在 onStop 之前，它和 onPause 没有既定的时序关系，它既可能在 onPause 之前或者之后调用。这种情况只会出现在 Activity 被异常终止的条件下。 ​ ③ 当 Activity 被重新创建后，系统会调用 onRestoreInstanceState,并且把 Activity 销毁时的 onSaveInstanceState 方法所保存的 Bundle 对象作为参数同时传递给 onRestoreInstanceState 和 onCreate 方法。因此我们可以通过判断 onRestoreInstanceState 和 onCreate 方法是否被重建。 ​ ④ 如果被重建了，我们会取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceState 的调用在 onStart 之后。 （2）需要注意的两点： ★ 我们销毁 Activity 重新创建获取数据状态时，有两种方式，接收位置可以选择 onRestoreInstanceState（官方建议使用）或者 onCreate 两者的区别。 ​ ① onRestoreInstanceState 一旦被调用，其参数 Bundle saveInstanceState 一定是有值的，我们不用额外的判断是否为空。 ​ ② onCreate 正常启动的话，其参数 Bundle saveInstanceState 为 null,所以必须进行额外的判断。 ​ ③ 系统只有在 Activity 异常终止的时候才会调用 onSaveInstanceState 和 onRestoreInstanceState 来存储和恢复数据，其他情况不会出发这个过程。 2、情况二：资源内存不足导致低优先级的 Activity 被杀死（1）先描述一下 Activity 的优先级情况，Activity 的优先级从高到底，可分为一下三种： ​ ① 前台 Activity —— 正在和用户交互的 Activity ，优先级最高。 ​ ② 可见但非前台的 Activity —— 比如 Activity 中弹出了一个对话框，导致 Activity 可见但是位于后台和无法与用户直接交互。 ​ ③ 后台 Activity —— 已经被暂停的 Activity ，比如执行了 onStop ，优先级最低。 （2）资源内存不足时的过程分析： ​ ① 当系统资源不足时，系统会按照上述优先级去杀死目标的 Activity 所在的进程，并在后续通过 onSaveInstanceState 和 onRestoreInstanceState 来存储和恢复数据。如果一些后台的进程脱离了四大组件而独立运行，那么这个进程很快就被杀死。我们常常将后台工作放到 Service 中保持进程具有一定的优先级。 （3）问题：当系统发生改变时，我们不想让 Activity 发生改变，比如，当我们旋转屏幕时，不想重新创建新的 Activity ，我们会怎么操作？ ​ 如果我们没有在 configChanges 属性中指定选项的话，当系统配置发生改变的话 Activity 就会被重新创建。我们常用到的三个属性： ​ ① locale : 设备的本地位置发生了改变，一般指切换了系统语言。 ​ ② keyboardHidden : 键盘可访问性发生了改变，比如用户调用了键盘。 ​ ③ orientation ： 屏幕方向发生了改变，这个是最常用到的，比如旋转的手机屏幕，一般与 screenSize 属性值配合使用。 ​ 这样，Activity 不会被创建，onSaveInstanceState 和 onRestoreInstanceState 方法不会被调用，取而代之，系统调用了 onConfigurationChanged 方法，这个时候我们可以做一些特殊的处理了。]]></content>
      <categories>
        <category>Android 高级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 深入剖析消息机制]]></title>
    <url>%2F2018%2F07%2F31%2FAndroid%20%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android 的消息机制主要是指 Handler 的运行机制，对于大家来说Handler已经是轻车熟路了，可是真的掌握了Handler？本文主要通过几个问题围绕着Handler展开深入并拓展的了解。 小鹿带你全面深入了解 Android 消息机制。 Android 的消息机制深入剖析Android 的消息机制主要是指 Handlerr 的运行需要底层的 MessageQueue 和 Looper 的支撑。 （1）MessageQueue 的中文翻译是消息队列。以队列的形式对外提供插入和删除工作。虽然叫做消息队列，但是内部存储结构并不是真正的队列，而是以单链表的数据结构来存储消息列表。 （2）Looper 的中文翻译为循环，我们叫它消息循环。由于 MessageQueue 只是一个存储单元，不会去处理消息。而 Looper 确弥补了这个功能，Looper 会以无限无限循环的形式去查找是否有新的消息，有的话就去处理消息，否则就一直等待。 学习思维导图： 一、Android 消息机制概述 Android 消息机制主要是指 Handler 的运行机制以及 Handler 所附带的 MessageQueue 和 Looper的工作过程。Handler 的主要作用就是将一个任务切换到某个指定的线程中去执行。 1、概述（1）、思考：为什么 Android 要提供这个功能呢？答：因为 Android 规定访问 UI 线程只能在主线程中进行的，如果在子线程中访问 UI ，那么程序就会抛出异常。 （2）、源码：经过查看看源码的 checkThread（）方法对更新 UI 是否在主线程中更新，进行抛出异常信息提示开发者（相信在开发中都遇到过这个种情况）。 （3)、过程：由于以上限制，这就要求开发者必须在主线程中更新 UI，但是 Android 又建议不要在主线程中进行过于耗时的工作，否则会产生应用程序无响应 ANR。考虑到这种情况，当我们在服务器拉去一些信息并显示到 UI 上时，拉去工作我们将在子线程中进行，拉取完毕之后不能再子线程中直接更新 UI ，没有 Handler ，那我们的确没有办法将访问 UI 的工作切换到主线程去执行。因此，系统之所以给我们提供 Handler，主要原因是为了解决在子线程中无法访问 UI 的矛盾。 （4)、问题： ① 为什么不能再子线程中更新 UI？答 ： 因为 Android 的 UI 控件不是线性安全的。如果在多线程中并发的访问可能会导致 UI 控件处于不可预期的状态。 ② 为什么不对 UI 控件的访问加上锁机制呢？答 ：首先，加上锁机制会让访问 UI 变的复杂，其次锁机制会降低 UI 的访问效率，因为锁机制会阻塞某些线程的执行。 最简单最高效的就是采用单线程模型来处理 UI 操作，只需通过 Handlerr 切换一下 UI 访问的执行线程即可。 2、Handler 的工作原理 Handler 创建时就会采用当前的 Looper 来构建内部的消息循环系统，如果当前没有 Looper ,那么就会报错。 怎么解决上述问题？两个方法： ① 为当前线程创建 Looper 即可。② 在 Looper 的线程中创建 Handler 也可以。 工作原理：（1）Handler 创建过程： Handler 被创建之后，内部的 MessageQueue 和 Looper 就与 Handler 一起工作协同工作了， 然后通过 Handler 的 post 方法将一个 Runnable 投递给 Handler 内部的 Looper 去处理；也可以通过 Handler 的 send 方法发送一个消息，也是通过 Looper 去处理的，其实 Post 方法最终也是通过 send 方法来完成的.. （2）send 方法的工作过程：当 Handler 的 send 方法被调用时，它会调用 MessageQueue 的 enqueueMessage 方法将这个消息放到消息队列中，然后 Looper 发现新消息，就会处理这个消息，最终消息的 Runnable 或者 Handler 的 handlerMessage 方法就会被调用。 二、 Android 的消息机制分析1、消息队列的工作原理 消息队列在 Android 主要是指 MessageQueue ，MessageQueue 主要包括两个操作：插入和删除。消息队列的内部实现并不是队列，实际上通过一条单链表的数据结构来维护消息队列，单链表在插入删除上很有优势。 ① 插入（enqueueMessage）：往消息队列中插入一条消息。（源码实现就是单链表的插入） ② 删除（next）：从消息队列中取出一条消息并将其从消息队列中移除。（next 是一个无限循环的方法，消息队列没有信息就处于阻塞状态，有新消息到来就执行单链表的删除） 2、Lopper 的工作原理 Looper 在 Android 消息机制中扮演着消息循环的角色，作用：不停地从 MessageQueue 中查看是否有新的消息，如果有消息就会立刻处理，如果没有消息就会处于阻塞状态。 （1) Looper 的构造方法① 创建一个 MessageQueue 消息队列。 ② 将当前线程的对象保存起来。 （2）如何为一个线程创建 Looper（Handle 的工作需要 Looper，没有 Looper 就会报错） ① 通过 Looper.prepare() 方法为线程创建一个 Looper 。 ② 通过 Looper.loop() 方法来开启消息循环。 （3）创建线程的另一种方法① 主线程 Looper 的获取。 Looper 这个方法主要给线程也就是 ActivityThread 创建 Looper 使用的，本质也是通过 prepare 来实现的，由于主线程的 Looper 比较特殊，所以 Looper 提供了一个 getMainLopper 的方法获取主线程的 Looper。 ② Looper 的退出。** Looper 提供了两个方法：quit 方法和 quitSafely** 方法。 两者区别： quite 直接退出 Looper。 而 quitSafely 只是设定一个退出标记，先把消息队列中的消息处理完之后再退出（4）Looper.loop() 方法实现原理loop 是一个死循环，唯一能跳出循环的方法就是 MessageQueue 的 next 方法返回了 null。当 Looper 的 quit 方法被调用时，MessageQueue 的 quit 方法或者 quitSafely 方法就会通知消息队列退出，当消息队列被标记为退出状态时，next 就会返回一个 null。Looper 是必须退出的，否则 loop 会永远循环下去。loop 方法会调用 MessageQueue 的 next 方法获取消息，如果 MessageQueue 没有消息，next 就会处于阻塞状态，loop 方法也会处于阻塞状态。 3、详解 Handler 的工作原理 Handler 的主要工作就是发送和接收消息。消息的发送可以通过 post 一系列方法以及 send 的一系列方法来实现，post 的一系列方法最终都是通过 send 一系列方法来实现的。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HandlerActivity extends Activity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //开启线程 handler(); &#125; //主线程 Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 1: // 获取Message里面的复杂数据 Bundle date = new Bundle(); date = msg.getData(); String name = date.getString(&quot;name&quot;); int age = date.getInt(&quot;age&quot;); String sex = date.getString(&quot;sex&quot;); //这里是主线程，可进行对UI的更新 textView.setText(name) &#125; &#125; &#125;; //子线程 public void handler()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Message message = new Message(); message.what = 1; // Message对象保存的数据是Bundle类型的 Bundle data = new Bundle(); data.putString(&quot;name&quot;, &quot;李文志&quot;); data.putInt(&quot;age&quot;, 18); data.putString(&quot;sex&quot;, &quot;男&quot;); // 把数据保存到Message对象中 message.setData(data); // 使用Handler对象发送消息 handler.sendMessage(message); &#125; &#125;).start(); &#125;&#125; （1）发送消息通过对源码分析，Handler 发送消息的过程仅仅是向消息队列中插入一条信息，MessageQueue 的 next 方法就会返回这条信息给 Looper ,Looper 接收到消息之后就立即处理，由 Looper 交给 Handler 去处理消息，Handler 的 dispatchMessage 方法就会被调用，这时候 Handler 就进入了消息处理阶段。 （2）消息处理深入 dispatchMessage 的源代码进行分析，Handler 处理消息如下： ① 首先检查 Message 的 callback 是否为 null, 不为 null 就通过 handlerCallback 来处理消息。（Message的 callback 是一个 Runnable d 对象，实际上就是 post 方法所递的 Runnable 参数） ② 其次检查 mCallback 是否为 null，不为 null 就调用 mCallback 的 handlerMessage 方法来处理消息。Callback 是个接口。 ③ 我们通过 Callback 可以采用如下的方式来创建 Handle 对象。 1Handler handler = new Handler(callback); 这样创建的意义就是创建一个实例但是并不需要派生 Handler 的子类。 ③ 但是，在我们的日常开发中，经常派生一个 Handler 的子类并重写其 handleMessage 方法来处理具体的消息，如果不想创建派生子类，就可以通过 Callback 来实现。 4、主线程的消息循环 Android 的主线程就是 ActivityThread，主线程的入口方法为 main ，在 main 方法中系统会通过 Looper.prepareMainLooper() ；来创建主线程的 Looper 以及 MessageQueue ，并通过 Looper.loop() 来开启主线程的消息循环。 主线程的消息循环开始了以后，ActivityThread 还需要一个 Handler 来和消息队列进行交互，这个 Handler 就是 ActivityThread.H 。ActivityThread 通过 ApplicationThread 和 AMS 进行进程间通信，AMS 以进程间通信的方式完成 ActvityThread 的请求后会回调 ApplicationThread 中的 Binder 方法，然后 ApplicationThread 向 H 发送消息，H 收到消息会将 ApplicationThread 中的逻辑切换到 ActivityThread 中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。]]></content>
      <categories>
        <category>Android 高级进阶</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
</search>
